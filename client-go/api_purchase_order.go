/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PurchaseOrderAPIService PurchaseOrderAPI service
type PurchaseOrderAPIService service

type ApiCreateOrderRequest struct {
	ctx context.Context
	ApiService *PurchaseOrderAPIService
	version float32
	appKey *string
	cart *string
	deviceId *string
	accountId *int64
	description *string
	currencyType *string
	paymentMethodId *int64
	externalOrderId *string
	externalPaymentId *string
	remoteRefType *string
	externalDate *int64
	promoCode *string
}

// The application requesting the purchase
func (r ApiCreateOrderRequest) AppKey(appKey string) ApiCreateOrderRequest {
	r.appKey = &appKey
	return r
}

// &#x60;&#x60;&#x60;json [   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 234, \&quot;orderCustomType\&quot;: \&quot;OfferLocation\&quot;, \&quot;orderCustomId\&quot;: 123, \&quot;retailerLocationId\&quot;: 1234, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 235, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 10.50, \&quot;orderCustomType\&quot;: \&quot;ServiceFee\&quot; },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 25.10, \&quot;quantity\&quot;: 2, \&quot;orderCustomType\&quot;: \&quot;Hat\&quot;, \&quot;orderCustomId\&quot;: 123 } ] &#x60;&#x60;&#x60; 
func (r ApiCreateOrderRequest) Cart(cart string) ApiCreateOrderRequest {
	r.cart = &cart
	return r
}

// The device id (deviceId or accountId required)
func (r ApiCreateOrderRequest) DeviceId(deviceId string) ApiCreateOrderRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiCreateOrderRequest) AccountId(accountId int64) ApiCreateOrderRequest {
	r.accountId = &accountId
	return r
}

// A description of the purchase
func (r ApiCreateOrderRequest) Description(description string) ApiCreateOrderRequest {
	r.description = &description
	return r
}

// Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  
func (r ApiCreateOrderRequest) CurrencyType(currencyType string) ApiCreateOrderRequest {
	r.currencyType = &currencyType
	return r
}

// Use a specific payment method (CASH), if not provided use default
func (r ApiCreateOrderRequest) PaymentMethodId(paymentMethodId int64) ApiCreateOrderRequest {
	r.paymentMethodId = &paymentMethodId
	return r
}

// Store identifier from external system
func (r ApiCreateOrderRequest) ExternalOrderId(externalOrderId string) ApiCreateOrderRequest {
	r.externalOrderId = &externalOrderId
	return r
}

// Store identifier from external system
func (r ApiCreateOrderRequest) ExternalPaymentId(externalPaymentId string) ApiCreateOrderRequest {
	r.externalPaymentId = &externalPaymentId
	return r
}

// Remote Reference type
func (r ApiCreateOrderRequest) RemoteRefType(remoteRefType string) ApiCreateOrderRequest {
	r.remoteRefType = &remoteRefType
	return r
}

// External Date
func (r ApiCreateOrderRequest) ExternalDate(externalDate int64) ApiCreateOrderRequest {
	r.externalDate = &externalDate
	return r
}

// The Promo Code
func (r ApiCreateOrderRequest) PromoCode(promoCode string) ApiCreateOrderRequest {
	r.promoCode = &promoCode
	return r
}

func (r ApiCreateOrderRequest) Execute() (*OrderResponse, *http.Response, error) {
	return r.ApiService.CreateOrderExecute(r)
}

/*
CreateOrder Create Order

Creates a new purchase with some number of items associated with it. The purchase is added to the order that was created

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateOrderRequest
*/
func (a *PurchaseOrderAPIService) CreateOrder(ctx context.Context, version float32) ApiCreateOrderRequest {
	return ApiCreateOrderRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OrderResponse
func (a *PurchaseOrderAPIService) CreateOrderExecute(r ApiCreateOrderRequest) (*OrderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PurchaseOrderAPIService.CreateOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/order/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.cart == nil {
		return localVarReturnValue, nil, reportError("cart is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.currencyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyType", r.currencyType, "form", "")
	} else {
		var defaultValue string = "CASH"
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyType", defaultValue, "form", "")
		r.currencyType = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "cart", r.cart, "form", "")
	if r.paymentMethodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethodId", r.paymentMethodId, "form", "")
	}
	if r.externalOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalOrderId", r.externalOrderId, "form", "")
	}
	if r.externalPaymentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalPaymentId", r.externalPaymentId, "form", "")
	}
	if r.remoteRefType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "remoteRefType", r.remoteRefType, "form", "")
	}
	if r.externalDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalDate", r.externalDate, "form", "")
	}
	if r.promoCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "promoCode", r.promoCode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOrderRequest struct {
	ctx context.Context
	ApiService *PurchaseOrderAPIService
	version float32
	orderId *int64
	deviceId *string
	accountId *int64
}

// Order Id
func (r ApiDeleteOrderRequest) OrderId(orderId int64) ApiDeleteOrderRequest {
	r.orderId = &orderId
	return r
}

// The device id (deviceId or accountId required)
func (r ApiDeleteOrderRequest) DeviceId(deviceId string) ApiDeleteOrderRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiDeleteOrderRequest) AccountId(accountId int64) ApiDeleteOrderRequest {
	r.accountId = &accountId
	return r
}

func (r ApiDeleteOrderRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteOrderExecute(r)
}

/*
DeleteOrder Delete Order

Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteOrderRequest
*/
func (a *PurchaseOrderAPIService) DeleteOrder(ctx context.Context, version float32) ApiDeleteOrderRequest {
	return ApiDeleteOrderRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *PurchaseOrderAPIService) DeleteOrderExecute(r ApiDeleteOrderRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PurchaseOrderAPIService.DeleteOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/order/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderId == nil {
		return localVarReturnValue, nil, reportError("orderId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderRequest struct {
	ctx context.Context
	ApiService *PurchaseOrderAPIService
	version float32
	deviceId *string
	accountId *int64
	orderId *int64
	externalOrderId *string
}

// The device id (deviceId or accountId required)
func (r ApiGetOrderRequest) DeviceId(deviceId string) ApiGetOrderRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiGetOrderRequest) AccountId(accountId int64) ApiGetOrderRequest {
	r.accountId = &accountId
	return r
}

// The order id to get details of, either orderId or externalOrderId must be provided
func (r ApiGetOrderRequest) OrderId(orderId int64) ApiGetOrderRequest {
	r.orderId = &orderId
	return r
}

// The external order id to get details of, either orderId or externalOrderId must be provided
func (r ApiGetOrderRequest) ExternalOrderId(externalOrderId string) ApiGetOrderRequest {
	r.externalOrderId = &externalOrderId
	return r
}

func (r ApiGetOrderRequest) Execute() (*OrderResponse, *http.Response, error) {
	return r.ApiService.GetOrderExecute(r)
}

/*
GetOrder Get Order

Get an order record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetOrderRequest
*/
func (a *PurchaseOrderAPIService) GetOrder(ctx context.Context, version float32) ApiGetOrderRequest {
	return ApiGetOrderRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OrderResponse
func (a *PurchaseOrderAPIService) GetOrderExecute(r ApiGetOrderRequest) (*OrderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PurchaseOrderAPIService.GetOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/order/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.externalOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalOrderId", r.externalOrderId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPreviewOrderRequest struct {
	ctx context.Context
	ApiService *PurchaseOrderAPIService
	version float32
	appKey *string
	cart *string
	deviceId *string
	accountId *int64
	description *string
	currencyType *string
	paymentMethodId *int64
	externalOrderId *string
	externalPaymentId *string
	remoteRefType *string
	externalDate *int64
	promoCode *string
}

// The application requesting the purchase
func (r ApiPreviewOrderRequest) AppKey(appKey string) ApiPreviewOrderRequest {
	r.appKey = &appKey
	return r
}

// A JSON list of items to purchase
func (r ApiPreviewOrderRequest) Cart(cart string) ApiPreviewOrderRequest {
	r.cart = &cart
	return r
}

// The device id (deviceId or accountId required)
func (r ApiPreviewOrderRequest) DeviceId(deviceId string) ApiPreviewOrderRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiPreviewOrderRequest) AccountId(accountId int64) ApiPreviewOrderRequest {
	r.accountId = &accountId
	return r
}

// A description of the purchase
func (r ApiPreviewOrderRequest) Description(description string) ApiPreviewOrderRequest {
	r.description = &description
	return r
}

// Determines the method of purchasing offer. &#x60;&#x60;&#x60;json {   \&quot;VOID\&quot;: \&quot;used for when there is no payment involved (ie. for updating the status of a purchase order)\&quot;,   \&quot;CASH\&quot;: \&quot;use card on file\&quot;,   \&quot;POINTS\&quot;: \&quot;use account balance\&quot;,   \&quot;TICKETS\&quot;: \&quot;use tickets\&quot;,   \&quot;REFUND\&quot;: \&quot;not allowed for a create, requires a paymentTransactionId\&quot;,   \&quot;CREDIT\&quot;: \&quot;add to the account balance\&quot;,   \&quot;RELOAD\&quot;: \&quot;charge a credit card then add to the account balance\&quot; } &#x60;&#x60;&#x60; 
func (r ApiPreviewOrderRequest) CurrencyType(currencyType string) ApiPreviewOrderRequest {
	r.currencyType = &currencyType
	return r
}

// Use a specific payment method (CASH), if not provided use default
func (r ApiPreviewOrderRequest) PaymentMethodId(paymentMethodId int64) ApiPreviewOrderRequest {
	r.paymentMethodId = &paymentMethodId
	return r
}

// Store identifier from external system
func (r ApiPreviewOrderRequest) ExternalOrderId(externalOrderId string) ApiPreviewOrderRequest {
	r.externalOrderId = &externalOrderId
	return r
}

// Store identifier from external system
func (r ApiPreviewOrderRequest) ExternalPaymentId(externalPaymentId string) ApiPreviewOrderRequest {
	r.externalPaymentId = &externalPaymentId
	return r
}

// Remote Reference type
func (r ApiPreviewOrderRequest) RemoteRefType(remoteRefType string) ApiPreviewOrderRequest {
	r.remoteRefType = &remoteRefType
	return r
}

// External Date
func (r ApiPreviewOrderRequest) ExternalDate(externalDate int64) ApiPreviewOrderRequest {
	r.externalDate = &externalDate
	return r
}

// The Promo Code
func (r ApiPreviewOrderRequest) PromoCode(promoCode string) ApiPreviewOrderRequest {
	r.promoCode = &promoCode
	return r
}

func (r ApiPreviewOrderRequest) Execute() (*OrderResponse, *http.Response, error) {
	return r.ApiService.PreviewOrderExecute(r)
}

/*
PreviewOrder Preview Order

Previews a purchase to see the total cost before making it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiPreviewOrderRequest
*/
func (a *PurchaseOrderAPIService) PreviewOrder(ctx context.Context, version float32) ApiPreviewOrderRequest {
	return ApiPreviewOrderRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OrderResponse
func (a *PurchaseOrderAPIService) PreviewOrderExecute(r ApiPreviewOrderRequest) (*OrderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PurchaseOrderAPIService.PreviewOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/order/preview"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.cart == nil {
		return localVarReturnValue, nil, reportError("cart is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.currencyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyType", r.currencyType, "form", "")
	} else {
		var defaultValue string = "CASH"
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyType", defaultValue, "form", "")
		r.currencyType = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "cart", r.cart, "form", "")
	if r.paymentMethodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethodId", r.paymentMethodId, "form", "")
	}
	if r.externalOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalOrderId", r.externalOrderId, "form", "")
	}
	if r.externalPaymentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalPaymentId", r.externalPaymentId, "form", "")
	}
	if r.remoteRefType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "remoteRefType", r.remoteRefType, "form", "")
	}
	if r.externalDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalDate", r.externalDate, "form", "")
	}
	if r.promoCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "promoCode", r.promoCode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchOrdersRequest struct {
	ctx context.Context
	ApiService *PurchaseOrderAPIService
	version float32
	appKey *string
	deviceId *string
	accountId *int64
	start *int32
	limit *int32
	descending *bool
	activeOnly *bool
	ignoreCustomerFilter *bool
	orderItemTypes *string
	orderItemIds *string
	orderCustomTypes *string
	orderCustomIds *string
	sortField *string
	offerTypes *string
	specialOfferTypes *string
	categoryIds *string
	filterIds *string
	offerAudienceIds *string
	transactionAudienceIds *string
	offerIds *string
	offerLocationIds *string
	retailerIds *string
	retailerLocationIds *string
	statuses *string
	keyword *string
	redeemableStartDate *int64
	redeemableEndDate *int64
	startedSince *int64
	startedBefore *int64
	endedSince *int64
	endedBefore *int64
}

// The application requesting the purchase
func (r ApiSearchOrdersRequest) AppKey(appKey string) ApiSearchOrdersRequest {
	r.appKey = &appKey
	return r
}

// The device id (deviceId or accountId required)
func (r ApiSearchOrdersRequest) DeviceId(deviceId string) ApiSearchOrdersRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiSearchOrdersRequest) AccountId(accountId int64) ApiSearchOrdersRequest {
	r.accountId = &accountId
	return r
}

// The start index for pagination
func (r ApiSearchOrdersRequest) Start(start int32) ApiSearchOrdersRequest {
	r.start = &start
	return r
}

// The limit for pagination
func (r ApiSearchOrdersRequest) Limit(limit int32) ApiSearchOrdersRequest {
	r.limit = &limit
	return r
}

// Determines whether to return the resulting list in descending or ascending order
func (r ApiSearchOrdersRequest) Descending(descending bool) ApiSearchOrdersRequest {
	r.descending = &descending
	return r
}

// Only return active orders
func (r ApiSearchOrdersRequest) ActiveOnly(activeOnly bool) ApiSearchOrdersRequest {
	r.activeOnly = &activeOnly
	return r
}

// Determines whether to ignore the customer filter (requires an Admin/Exec account)
func (r ApiSearchOrdersRequest) IgnoreCustomerFilter(ignoreCustomerFilter bool) ApiSearchOrdersRequest {
	r.ignoreCustomerFilter = &ignoreCustomerFilter
	return r
}

// Filter results by orderItemTypes
func (r ApiSearchOrdersRequest) OrderItemTypes(orderItemTypes string) ApiSearchOrdersRequest {
	r.orderItemTypes = &orderItemTypes
	return r
}

// Filter results by orderItemIds
func (r ApiSearchOrdersRequest) OrderItemIds(orderItemIds string) ApiSearchOrdersRequest {
	r.orderItemIds = &orderItemIds
	return r
}

// Filter results by orderCustomTypes
func (r ApiSearchOrdersRequest) OrderCustomTypes(orderCustomTypes string) ApiSearchOrdersRequest {
	r.orderCustomTypes = &orderCustomTypes
	return r
}

// Filter results by orderCustomIds
func (r ApiSearchOrdersRequest) OrderCustomIds(orderCustomIds string) ApiSearchOrdersRequest {
	r.orderCustomIds = &orderCustomIds
	return r
}

// Determines what to sort the results by
func (r ApiSearchOrdersRequest) SortField(sortField string) ApiSearchOrdersRequest {
	r.sortField = &sortField
	return r
}

// Filter results by offer type
func (r ApiSearchOrdersRequest) OfferTypes(offerTypes string) ApiSearchOrdersRequest {
	r.offerTypes = &offerTypes
	return r
}

// Filter results by special offer type
func (r ApiSearchOrdersRequest) SpecialOfferTypes(specialOfferTypes string) ApiSearchOrdersRequest {
	r.specialOfferTypes = &specialOfferTypes
	return r
}

// Filter results by category Ids
func (r ApiSearchOrdersRequest) CategoryIds(categoryIds string) ApiSearchOrdersRequest {
	r.categoryIds = &categoryIds
	return r
}

// Filter results by filter Ids
func (r ApiSearchOrdersRequest) FilterIds(filterIds string) ApiSearchOrdersRequest {
	r.filterIds = &filterIds
	return r
}

// Filter results by offer audience Ids
func (r ApiSearchOrdersRequest) OfferAudienceIds(offerAudienceIds string) ApiSearchOrdersRequest {
	r.offerAudienceIds = &offerAudienceIds
	return r
}

// Filter results by transaction audience Ids
func (r ApiSearchOrdersRequest) TransactionAudienceIds(transactionAudienceIds string) ApiSearchOrdersRequest {
	r.transactionAudienceIds = &transactionAudienceIds
	return r
}

// Filter results by offer Ids
func (r ApiSearchOrdersRequest) OfferIds(offerIds string) ApiSearchOrdersRequest {
	r.offerIds = &offerIds
	return r
}

// Filter results by offer location Ids
func (r ApiSearchOrdersRequest) OfferLocationIds(offerLocationIds string) ApiSearchOrdersRequest {
	r.offerLocationIds = &offerLocationIds
	return r
}

// Filter results by retailer Ids
func (r ApiSearchOrdersRequest) RetailerIds(retailerIds string) ApiSearchOrdersRequest {
	r.retailerIds = &retailerIds
	return r
}

// Filter results by retailer location Ids
func (r ApiSearchOrdersRequest) RetailerLocationIds(retailerLocationIds string) ApiSearchOrdersRequest {
	r.retailerLocationIds = &retailerLocationIds
	return r
}

// Filter results by offer transaction status (0: non-redeemable, 1: redeemable, 2: redeemed, 3: user deleted, 4: unclaimed/rewarded, 5: membership active, 6: membership cancelled)
func (r ApiSearchOrdersRequest) Statuses(statuses string) ApiSearchOrdersRequest {
	r.statuses = &statuses
	return r
}

// The keyword to search for
func (r ApiSearchOrdersRequest) Keyword(keyword string) ApiSearchOrdersRequest {
	r.keyword = &keyword
	return r
}

// Filter results by the offer redeemable date
func (r ApiSearchOrdersRequest) RedeemableStartDate(redeemableStartDate int64) ApiSearchOrdersRequest {
	r.redeemableStartDate = &redeemableStartDate
	return r
}

// Filter results by the offer redeemable date
func (r ApiSearchOrdersRequest) RedeemableEndDate(redeemableEndDate int64) ApiSearchOrdersRequest {
	r.redeemableEndDate = &redeemableEndDate
	return r
}

// Filter results by the offer start date
func (r ApiSearchOrdersRequest) StartedSince(startedSince int64) ApiSearchOrdersRequest {
	r.startedSince = &startedSince
	return r
}

// Filter results by the offer start date
func (r ApiSearchOrdersRequest) StartedBefore(startedBefore int64) ApiSearchOrdersRequest {
	r.startedBefore = &startedBefore
	return r
}

// Filter results by the offer end date
func (r ApiSearchOrdersRequest) EndedSince(endedSince int64) ApiSearchOrdersRequest {
	r.endedSince = &endedSince
	return r
}

// Filter results by the offer end date
func (r ApiSearchOrdersRequest) EndedBefore(endedBefore int64) ApiSearchOrdersRequest {
	r.endedBefore = &endedBefore
	return r
}

func (r ApiSearchOrdersRequest) Execute() ([]OrderResponse, *http.Response, error) {
	return r.ApiService.SearchOrdersExecute(r)
}

/*
SearchOrders Search Orders

Search on active orders by customer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchOrdersRequest
*/
func (a *PurchaseOrderAPIService) SearchOrders(ctx context.Context, version float32) ApiSearchOrdersRequest {
	return ApiSearchOrdersRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []OrderResponse
func (a *PurchaseOrderAPIService) SearchOrdersExecute(r ApiSearchOrdersRequest) ([]OrderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PurchaseOrderAPIService.SearchOrders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/order/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", defaultValue, "form", "")
		r.descending = &defaultValue
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", defaultValue, "form", "")
		r.activeOnly = &defaultValue
	}
	if r.ignoreCustomerFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignoreCustomerFilter", r.ignoreCustomerFilter, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignoreCustomerFilter", defaultValue, "form", "")
		r.ignoreCustomerFilter = &defaultValue
	}
	if r.orderItemTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderItemTypes", r.orderItemTypes, "form", "")
	}
	if r.orderItemIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderItemIds", r.orderItemIds, "form", "")
	}
	if r.orderCustomTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderCustomTypes", r.orderCustomTypes, "form", "")
	}
	if r.orderCustomIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderCustomIds", r.orderCustomIds, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	} else {
		var defaultValue string = "ID"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", defaultValue, "form", "")
		r.sortField = &defaultValue
	}
	if r.offerTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerTypes", r.offerTypes, "form", "")
	}
	if r.specialOfferTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "specialOfferTypes", r.specialOfferTypes, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.filterIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterIds", r.filterIds, "form", "")
	}
	if r.offerAudienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerAudienceIds", r.offerAudienceIds, "form", "")
	}
	if r.transactionAudienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionAudienceIds", r.transactionAudienceIds, "form", "")
	}
	if r.offerIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerIds", r.offerIds, "form", "")
	}
	if r.offerLocationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationIds", r.offerLocationIds, "form", "")
	}
	if r.retailerIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerIds", r.retailerIds, "form", "")
	}
	if r.retailerLocationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationIds", r.retailerLocationIds, "form", "")
	}
	if r.statuses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", r.statuses, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.redeemableStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemableStartDate", r.redeemableStartDate, "form", "")
	}
	if r.redeemableEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemableEndDate", r.redeemableEndDate, "form", "")
	}
	if r.startedSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedSince", r.startedSince, "form", "")
	}
	if r.startedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedBefore", r.startedBefore, "form", "")
	}
	if r.endedSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endedSince", r.endedSince, "form", "")
	}
	if r.endedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endedBefore", r.endedBefore, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOrderRequest struct {
	ctx context.Context
	ApiService *PurchaseOrderAPIService
	version float32
	orderId *int64
	appKey *string
	cart *string
	deviceId *string
	accountId *int64
	paymentTransactionId *int64
	description *string
	currencyType *string
	paymentMethodId *int64
	externalPaymentId *string
	externalDate *int64
}

// The order to add the purchase to, leave null for new order.
func (r ApiUpdateOrderRequest) OrderId(orderId int64) ApiUpdateOrderRequest {
	r.orderId = &orderId
	return r
}

// The application requesting the purchase
func (r ApiUpdateOrderRequest) AppKey(appKey string) ApiUpdateOrderRequest {
	r.appKey = &appKey
	return r
}

// &#x60;&#x60;&#x60;json [   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 234, \&quot;orderCustomType\&quot;: \&quot;OfferLocation\&quot;, \&quot;orderCustomId\&quot;: 123, \&quot;retailerLocationId\&quot;: 1234, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 235, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 10.50, \&quot;orderCustomType\&quot;: \&quot;ServiceFee\&quot; },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 25.10, \&quot;quantity\&quot;: 2, \&quot;orderCustomType\&quot;: \&quot;Hat\&quot;, \&quot;orderCustomId\&quot;: 123 } ] &#x60;&#x60;&#x60; 
func (r ApiUpdateOrderRequest) Cart(cart string) ApiUpdateOrderRequest {
	r.cart = &cart
	return r
}

// The device id (deviceId or accountId required)
func (r ApiUpdateOrderRequest) DeviceId(deviceId string) ApiUpdateOrderRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiUpdateOrderRequest) AccountId(accountId int64) ApiUpdateOrderRequest {
	r.accountId = &accountId
	return r
}

// The payment transaction to apply the refund to
func (r ApiUpdateOrderRequest) PaymentTransactionId(paymentTransactionId int64) ApiUpdateOrderRequest {
	r.paymentTransactionId = &paymentTransactionId
	return r
}

// A description of the purchase
func (r ApiUpdateOrderRequest) Description(description string) ApiUpdateOrderRequest {
	r.description = &description
	return r
}

// Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  
func (r ApiUpdateOrderRequest) CurrencyType(currencyType string) ApiUpdateOrderRequest {
	r.currencyType = &currencyType
	return r
}

// Use a specific payment method (CASH), if not provided use default
func (r ApiUpdateOrderRequest) PaymentMethodId(paymentMethodId int64) ApiUpdateOrderRequest {
	r.paymentMethodId = &paymentMethodId
	return r
}

// Store identifier from external system
func (r ApiUpdateOrderRequest) ExternalPaymentId(externalPaymentId string) ApiUpdateOrderRequest {
	r.externalPaymentId = &externalPaymentId
	return r
}

// External Date
func (r ApiUpdateOrderRequest) ExternalDate(externalDate int64) ApiUpdateOrderRequest {
	r.externalDate = &externalDate
	return r
}

func (r ApiUpdateOrderRequest) Execute() (*OrderResponse, *http.Response, error) {
	return r.ApiService.UpdateOrderExecute(r)
}

/*
UpdateOrder Update Order

Updates new purchase with some number of items associated with it. The orderId provided is used to retrieve the record and the payment is added to it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateOrderRequest
*/
func (a *PurchaseOrderAPIService) UpdateOrder(ctx context.Context, version float32) ApiUpdateOrderRequest {
	return ApiUpdateOrderRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OrderResponse
func (a *PurchaseOrderAPIService) UpdateOrderExecute(r ApiUpdateOrderRequest) (*OrderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PurchaseOrderAPIService.UpdateOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/order/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderId == nil {
		return localVarReturnValue, nil, reportError("orderId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.cart == nil {
		return localVarReturnValue, nil, reportError("cart is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	if r.paymentTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentTransactionId", r.paymentTransactionId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.currencyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyType", r.currencyType, "form", "")
	} else {
		var defaultValue string = "CASH"
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyType", defaultValue, "form", "")
		r.currencyType = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "cart", r.cart, "form", "")
	if r.paymentMethodId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethodId", r.paymentMethodId, "form", "")
	}
	if r.externalPaymentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalPaymentId", r.externalPaymentId, "form", "")
	}
	if r.externalDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalDate", r.externalDate, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
