/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// AlbumAPIService AlbumAPI service
type AlbumAPIService service

type ApiAddAlbumCollectionRequest struct {
	ctx context.Context
	ApiService *AlbumAPIService
	version float32
	title *string
	coverAssetNullable *bool
	includeCoverInAssetList *bool
	publicRead *bool
	publicWrite *bool
	publicDelete *bool
	publicAdd *bool
	anonymous *bool
	deviceId *string
	accountId *int64
	assetsToAdd *string
	media *os.File
	mediaURL *string
	assetId *int64
	attachedMedia *os.File
	attachedMediaURL *string
	startDate *int64
	endDate *int64
	tags *string
	description *string
	albumType *string
	albumTypeId *int64
	subType *string
	latitude *float64
	longitude *float64
	locationDescription *string
	visibility *string
	gameType *string
	appKey *string
	cellPhone *string
	streetAddress *string
	streetAddress2 *string
	city *string
	state *string
	postalCode *string
	fullAddress *string
	metaData *string
	categoryIds *string
	categoryFilterIds *string
	audienceIds *string
	includeAllAppUsersAsMembers *bool
	includeAudiencesAsMembers *bool
	audienceOperator *string
	approvalStatus *string
	linkedObjectType *string
	linkedObjectId *int64
}

// the title of the album
func (r ApiAddAlbumCollectionRequest) Title(title string) ApiAddAlbumCollectionRequest {
	r.title = &title
	return r
}

// determines whether the cover image of the album can be empty, else will use the user&#39;s profile picture as the cover image
func (r ApiAddAlbumCollectionRequest) CoverAssetNullable(coverAssetNullable bool) ApiAddAlbumCollectionRequest {
	r.coverAssetNullable = &coverAssetNullable
	return r
}

// determines whether the cover image should be added to the album asset list
func (r ApiAddAlbumCollectionRequest) IncludeCoverInAssetList(includeCoverInAssetList bool) ApiAddAlbumCollectionRequest {
	r.includeCoverInAssetList = &includeCoverInAssetList
	return r
}

// determines whether the album&#39;s participants has read permissions
func (r ApiAddAlbumCollectionRequest) PublicRead(publicRead bool) ApiAddAlbumCollectionRequest {
	r.publicRead = &publicRead
	return r
}

// determines whether the album&#39;s participants has write permissions
func (r ApiAddAlbumCollectionRequest) PublicWrite(publicWrite bool) ApiAddAlbumCollectionRequest {
	r.publicWrite = &publicWrite
	return r
}

// determines whether the album&#39;s participants has delete permissions
func (r ApiAddAlbumCollectionRequest) PublicDelete(publicDelete bool) ApiAddAlbumCollectionRequest {
	r.publicDelete = &publicDelete
	return r
}

// determines whether the album&#39;s participants has add permissions
func (r ApiAddAlbumCollectionRequest) PublicAdd(publicAdd bool) ApiAddAlbumCollectionRequest {
	r.publicAdd = &publicAdd
	return r
}

// determines whether the album is posted anonymously
func (r ApiAddAlbumCollectionRequest) Anonymous(anonymous bool) ApiAddAlbumCollectionRequest {
	r.anonymous = &anonymous
	return r
}

// a unique ID given by the device (deviceId or accountId required)
func (r ApiAddAlbumCollectionRequest) DeviceId(deviceId string) ApiAddAlbumCollectionRequest {
	r.deviceId = &deviceId
	return r
}

// the account ID of the user (deviceId or accountId required)
func (r ApiAddAlbumCollectionRequest) AccountId(accountId int64) ApiAddAlbumCollectionRequest {
	r.accountId = &accountId
	return r
}

// Comma separated list of asset IDs to add to the album&#39;s asset list (use \&quot;assetId\&quot; for setting the cover of the album)
func (r ApiAddAlbumCollectionRequest) AssetsToAdd(assetsToAdd string) ApiAddAlbumCollectionRequest {
	r.assetsToAdd = &assetsToAdd
	return r
}

// a MultipartFile containing the cover image of the album (this will only be used if \&quot;assetId\&quot; is empty)
func (r ApiAddAlbumCollectionRequest) Media(media *os.File) ApiAddAlbumCollectionRequest {
	r.media = media
	return r
}

// this can be used if the \&quot;media\&quot; is a link (this will only be used if \&quot;assetId\&quot; and media are empty)
func (r ApiAddAlbumCollectionRequest) MediaURL(mediaURL string) ApiAddAlbumCollectionRequest {
	r.mediaURL = &mediaURL
	return r
}

// The asset ID to set the album cover image
func (r ApiAddAlbumCollectionRequest) AssetId(assetId int64) ApiAddAlbumCollectionRequest {
	r.assetId = &assetId
	return r
}

// a MultipartFile containing an asset that the \&quot;media\&quot; file references. Example to upload a video: the \&quot;media\&quot; file should contain a screen capture of the video, and the \&quot;attachedMedia\&quot; should be the actual video.
func (r ApiAddAlbumCollectionRequest) AttachedMedia(attachedMedia *os.File) ApiAddAlbumCollectionRequest {
	r.attachedMedia = attachedMedia
	return r
}

// this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc)
func (r ApiAddAlbumCollectionRequest) AttachedMediaURL(attachedMediaURL string) ApiAddAlbumCollectionRequest {
	r.attachedMediaURL = &attachedMediaURL
	return r
}

// the start date
func (r ApiAddAlbumCollectionRequest) StartDate(startDate int64) ApiAddAlbumCollectionRequest {
	r.startDate = &startDate
	return r
}

// the end date
func (r ApiAddAlbumCollectionRequest) EndDate(endDate int64) ApiAddAlbumCollectionRequest {
	r.endDate = &endDate
	return r
}

// the tags
func (r ApiAddAlbumCollectionRequest) Tags(tags string) ApiAddAlbumCollectionRequest {
	r.tags = &tags
	return r
}

// the description of the album
func (r ApiAddAlbumCollectionRequest) Description(description string) ApiAddAlbumCollectionRequest {
	r.description = &description
	return r
}

// a custom field used for aggregation and searching
func (r ApiAddAlbumCollectionRequest) AlbumType(albumType string) ApiAddAlbumCollectionRequest {
	r.albumType = &albumType
	return r
}

// a custom indexed number used for aggregation and searching
func (r ApiAddAlbumCollectionRequest) AlbumTypeId(albumTypeId int64) ApiAddAlbumCollectionRequest {
	r.albumTypeId = &albumTypeId
	return r
}

// a custom string field used for aggregation and searching
func (r ApiAddAlbumCollectionRequest) SubType(subType string) ApiAddAlbumCollectionRequest {
	r.subType = &subType
	return r
}

// latitude used to update the album&#39;s location
func (r ApiAddAlbumCollectionRequest) Latitude(latitude float64) ApiAddAlbumCollectionRequest {
	r.latitude = &latitude
	return r
}

// longitude used to update the album&#39;s location
func (r ApiAddAlbumCollectionRequest) Longitude(longitude float64) ApiAddAlbumCollectionRequest {
	r.longitude = &longitude
	return r
}

// the location description
func (r ApiAddAlbumCollectionRequest) LocationDescription(locationDescription string) ApiAddAlbumCollectionRequest {
	r.locationDescription = &locationDescription
	return r
}

// the determines the album&#39;s participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
func (r ApiAddAlbumCollectionRequest) Visibility(visibility string) ApiAddAlbumCollectionRequest {
	r.visibility = &visibility
	return r
}

// @deprecated, use the appKey
func (r ApiAddAlbumCollectionRequest) GameType(gameType string) ApiAddAlbumCollectionRequest {
	r.gameType = &gameType
	return r
}

// the application key
func (r ApiAddAlbumCollectionRequest) AppKey(appKey string) ApiAddAlbumCollectionRequest {
	r.appKey = &appKey
	return r
}

// the cell phone number
func (r ApiAddAlbumCollectionRequest) CellPhone(cellPhone string) ApiAddAlbumCollectionRequest {
	r.cellPhone = &cellPhone
	return r
}

// The street address of the location
func (r ApiAddAlbumCollectionRequest) StreetAddress(streetAddress string) ApiAddAlbumCollectionRequest {
	r.streetAddress = &streetAddress
	return r
}

// Additional address information (such as a suite number, floor number, building name, or PO Box)
func (r ApiAddAlbumCollectionRequest) StreetAddress2(streetAddress2 string) ApiAddAlbumCollectionRequest {
	r.streetAddress2 = &streetAddress2
	return r
}

// The city of the location
func (r ApiAddAlbumCollectionRequest) City(city string) ApiAddAlbumCollectionRequest {
	r.city = &city
	return r
}

// The state of of the location
func (r ApiAddAlbumCollectionRequest) State(state string) ApiAddAlbumCollectionRequest {
	r.state = &state
	return r
}

// The postal code of the location
func (r ApiAddAlbumCollectionRequest) PostalCode(postalCode string) ApiAddAlbumCollectionRequest {
	r.postalCode = &postalCode
	return r
}

// The full address of the location which should include the street address, city, state, and postal code
func (r ApiAddAlbumCollectionRequest) FullAddress(fullAddress string) ApiAddAlbumCollectionRequest {
	r.fullAddress = &fullAddress
	return r
}

// External custom client defined data
func (r ApiAddAlbumCollectionRequest) MetaData(metaData string) ApiAddAlbumCollectionRequest {
	r.metaData = &metaData
	return r
}

// comma separated category ids string associated with the Album
func (r ApiAddAlbumCollectionRequest) CategoryIds(categoryIds string) ApiAddAlbumCollectionRequest {
	r.categoryIds = &categoryIds
	return r
}

// comma separated filter ids string associated with the Album
func (r ApiAddAlbumCollectionRequest) CategoryFilterIds(categoryFilterIds string) ApiAddAlbumCollectionRequest {
	r.categoryFilterIds = &categoryFilterIds
	return r
}

// comma separated audience ids string associated with the album
func (r ApiAddAlbumCollectionRequest) AudienceIds(audienceIds string) ApiAddAlbumCollectionRequest {
	r.audienceIds = &audienceIds
	return r
}

// determines whether to include all app users as members (only admins of the app can do this)
func (r ApiAddAlbumCollectionRequest) IncludeAllAppUsersAsMembers(includeAllAppUsersAsMembers bool) ApiAddAlbumCollectionRequest {
	r.includeAllAppUsersAsMembers = &includeAllAppUsersAsMembers
	return r
}

// determines whether to include all users of the audiences as members (only admins of the app can do this)
func (r ApiAddAlbumCollectionRequest) IncludeAudiencesAsMembers(includeAudiencesAsMembers bool) ApiAddAlbumCollectionRequest {
	r.includeAudiencesAsMembers = &includeAudiencesAsMembers
	return r
}

// determines whether to use ands or ors when using the audience list to add users
func (r ApiAddAlbumCollectionRequest) AudienceOperator(audienceOperator string) ApiAddAlbumCollectionRequest {
	r.audienceOperator = &audienceOperator
	return r
}

// The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
func (r ApiAddAlbumCollectionRequest) ApprovalStatus(approvalStatus string) ApiAddAlbumCollectionRequest {
	r.approvalStatus = &approvalStatus
	return r
}

// sets a linked object so that it can be returned as part of the album response
func (r ApiAddAlbumCollectionRequest) LinkedObjectType(linkedObjectType string) ApiAddAlbumCollectionRequest {
	r.linkedObjectType = &linkedObjectType
	return r
}

// sets a linked object id so that it can be returned as part of the album response
func (r ApiAddAlbumCollectionRequest) LinkedObjectId(linkedObjectId int64) ApiAddAlbumCollectionRequest {
	r.linkedObjectId = &linkedObjectId
	return r
}

func (r ApiAddAlbumCollectionRequest) Execute() (*SearchResponse, *http.Response, error) {
	return r.ApiService.AddAlbumCollectionExecute(r)
}

/*
AddAlbumCollection Create Album

Create an Album.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAddAlbumCollectionRequest
*/
func (a *AlbumAPIService) AddAlbumCollection(ctx context.Context, version float32) ApiAddAlbumCollectionRequest {
	return ApiAddAlbumCollectionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SearchResponse
func (a *AlbumAPIService) AddAlbumCollectionExecute(r ApiAddAlbumCollectionRequest) (*SearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumAPIService.AddAlbumCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/album/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if r.coverAssetNullable == nil {
		return localVarReturnValue, nil, reportError("coverAssetNullable is required and must be specified")
	}
	if r.includeCoverInAssetList == nil {
		return localVarReturnValue, nil, reportError("includeCoverInAssetList is required and must be specified")
	}
	if r.publicRead == nil {
		return localVarReturnValue, nil, reportError("publicRead is required and must be specified")
	}
	if r.publicWrite == nil {
		return localVarReturnValue, nil, reportError("publicWrite is required and must be specified")
	}
	if r.publicDelete == nil {
		return localVarReturnValue, nil, reportError("publicDelete is required and must be specified")
	}
	if r.publicAdd == nil {
		return localVarReturnValue, nil, reportError("publicAdd is required and must be specified")
	}
	if r.anonymous == nil {
		return localVarReturnValue, nil, reportError("anonymous is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	if r.assetsToAdd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetsToAdd", r.assetsToAdd, "form", "")
	}
	if r.media != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "media", r.media, "form", "")
	}
	if r.mediaURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaURL", r.mediaURL, "form", "")
	}
	if r.assetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "form", "")
	}
	if r.attachedMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedMedia", r.attachedMedia, "form", "")
	}
	if r.attachedMediaURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedMediaURL", r.attachedMediaURL, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "coverAssetNullable", r.coverAssetNullable, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "includeCoverInAssetList", r.includeCoverInAssetList, "form", "")
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.albumType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumType", r.albumType, "form", "")
	}
	if r.albumTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumTypeId", r.albumTypeId, "form", "")
	}
	if r.subType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subType", r.subType, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "publicRead", r.publicRead, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "publicWrite", r.publicWrite, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "publicDelete", r.publicDelete, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "publicAdd", r.publicAdd, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.locationDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locationDescription", r.locationDescription, "form", "")
	}
	if r.visibility != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibility", r.visibility, "form", "")
	}
	if r.gameType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameType", r.gameType, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.cellPhone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cellPhone", r.cellPhone, "form", "")
	}
	if r.streetAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streetAddress", r.streetAddress, "form", "")
	}
	if r.streetAddress2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streetAddress2", r.streetAddress2, "form", "")
	}
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	if r.postalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postalCode", r.postalCode, "form", "")
	}
	if r.fullAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fullAddress", r.fullAddress, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "anonymous", r.anonymous, "form", "")
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.categoryFilterIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryFilterIds", r.categoryFilterIds, "form", "")
	}
	if r.audienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIds", r.audienceIds, "form", "")
	}
	if r.includeAllAppUsersAsMembers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAllAppUsersAsMembers", r.includeAllAppUsersAsMembers, "form", "")
	}
	if r.includeAudiencesAsMembers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAudiencesAsMembers", r.includeAudiencesAsMembers, "form", "")
	}
	if r.audienceOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceOperator", r.audienceOperator, "form", "")
	}
	if r.approvalStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalStatus", r.approvalStatus, "form", "")
	}
	if r.linkedObjectType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkedObjectType", r.linkedObjectType, "form", "")
	}
	if r.linkedObjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkedObjectId", r.linkedObjectId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddAlbumUsersRequest struct {
	ctx context.Context
	ApiService *AlbumAPIService
	version float32
	albumId *int64
	includeFriendGroup *bool
	deviceId *string
	accountId *int64
	read *bool
	write *bool
	delete *bool
	add *bool
	connections *string
	connectionGroups *string
}

// the album ID
func (r ApiAddAlbumUsersRequest) AlbumId(albumId int64) ApiAddAlbumUsersRequest {
	r.albumId = &albumId
	return r
}

// determines whether to include all friends as participants
func (r ApiAddAlbumUsersRequest) IncludeFriendGroup(includeFriendGroup bool) ApiAddAlbumUsersRequest {
	r.includeFriendGroup = &includeFriendGroup
	return r
}

// a unique ID given by the device (deviceId or accountId required)
func (r ApiAddAlbumUsersRequest) DeviceId(deviceId string) ApiAddAlbumUsersRequest {
	r.deviceId = &deviceId
	return r
}

// the account ID of the user (deviceId or accountId required)
func (r ApiAddAlbumUsersRequest) AccountId(accountId int64) ApiAddAlbumUsersRequest {
	r.accountId = &accountId
	return r
}

// determines whether the users being added have read permissions
func (r ApiAddAlbumUsersRequest) Read(read bool) ApiAddAlbumUsersRequest {
	r.read = &read
	return r
}

// determines whether the users being added have write permissions
func (r ApiAddAlbumUsersRequest) Write(write bool) ApiAddAlbumUsersRequest {
	r.write = &write
	return r
}

// determines whether the users being added have delete permissions
func (r ApiAddAlbumUsersRequest) Delete(delete bool) ApiAddAlbumUsersRequest {
	r.delete = &delete
	return r
}

// determines whether the users being added have add permissions
func (r ApiAddAlbumUsersRequest) Add(add bool) ApiAddAlbumUsersRequest {
	r.add = &add
	return r
}

// comma separated list of connection IDs
func (r ApiAddAlbumUsersRequest) Connections(connections string) ApiAddAlbumUsersRequest {
	r.connections = &connections
	return r
}

// comma separated list of connection group IDs
func (r ApiAddAlbumUsersRequest) ConnectionGroups(connectionGroups string) ApiAddAlbumUsersRequest {
	r.connectionGroups = &connectionGroups
	return r
}

func (r ApiAddAlbumUsersRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.AddAlbumUsersExecute(r)
}

/*
AddAlbumUsers Add Album Users

Add users to an album as participants.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAddAlbumUsersRequest
*/
func (a *AlbumAPIService) AddAlbumUsers(ctx context.Context, version float32) ApiAddAlbumUsersRequest {
	return ApiAddAlbumUsersRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AlbumAPIService) AddAlbumUsersExecute(r ApiAddAlbumUsersRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumAPIService.AddAlbumUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/album/user/add"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.albumId == nil {
		return localVarReturnValue, nil, reportError("albumId is required and must be specified")
	}
	if r.includeFriendGroup == nil {
		return localVarReturnValue, nil, reportError("includeFriendGroup is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "albumId", r.albumId, "form", "")
	if r.read != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "read", r.read, "form", "")
	}
	if r.write != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "write", r.write, "form", "")
	}
	if r.delete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delete", r.delete, "form", "")
	}
	if r.add != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "add", r.add, "form", "")
	}
	if r.connections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connections", r.connections, "form", "")
	}
	if r.connectionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionGroups", r.connectionGroups, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "includeFriendGroup", r.includeFriendGroup, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApproveAlbumRequest struct {
	ctx context.Context
	ApiService *AlbumAPIService
	version float32
	albumId *int64
	deviceId *string
	accountId *int64
	approvalStatus *string
	verified *bool
}

// The ID of the album
func (r ApiApproveAlbumRequest) AlbumId(albumId int64) ApiApproveAlbumRequest {
	r.albumId = &albumId
	return r
}

// A unique ID given by the device (deviceId or accountId required)
func (r ApiApproveAlbumRequest) DeviceId(deviceId string) ApiApproveAlbumRequest {
	r.deviceId = &deviceId
	return r
}

// The account ID of the user (deviceId or accountId required)
func (r ApiApproveAlbumRequest) AccountId(accountId int64) ApiApproveAlbumRequest {
	r.accountId = &accountId
	return r
}

// The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
func (r ApiApproveAlbumRequest) ApprovalStatus(approvalStatus string) ApiApproveAlbumRequest {
	r.approvalStatus = &approvalStatus
	return r
}

// Sets whether the album should be marked as \&quot;verified\&quot;
func (r ApiApproveAlbumRequest) Verified(verified bool) ApiApproveAlbumRequest {
	r.verified = &verified
	return r
}

func (r ApiApproveAlbumRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.ApproveAlbumExecute(r)
}

/*
ApproveAlbum Approve Album

Sets the approval status of an Album.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiApproveAlbumRequest
*/
func (a *AlbumAPIService) ApproveAlbum(ctx context.Context, version float32) ApiApproveAlbumRequest {
	return ApiApproveAlbumRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AlbumAPIService) ApproveAlbumExecute(r ApiApproveAlbumRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumAPIService.ApproveAlbum")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/album/approve"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.albumId == nil {
		return localVarReturnValue, nil, reportError("albumId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "albumId", r.albumId, "form", "")
	if r.approvalStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalStatus", r.approvalStatus, "form", "")
	}
	if r.verified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verified", r.verified, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAlbumCollectionRequest struct {
	ctx context.Context
	ApiService *AlbumAPIService
	version float32
	returnNulls *bool
	albumId *int64
	deviceId *string
	accountId *int64
	likePreviewSize *int32
	assetPreviewSize *int32
	notePreviewSize *int32
	connectionPreviewSize *int32
	audiencePreviewSize *int32
}

// This parameter is deprecated.
func (r ApiGetAlbumCollectionRequest) ReturnNulls(returnNulls bool) ApiGetAlbumCollectionRequest {
	r.returnNulls = &returnNulls
	return r
}

// the album to look up
func (r ApiGetAlbumCollectionRequest) AlbumId(albumId int64) ApiGetAlbumCollectionRequest {
	r.albumId = &albumId
	return r
}

// a unique ID given by the device (deviceId or accountId required)
func (r ApiGetAlbumCollectionRequest) DeviceId(deviceId string) ApiGetAlbumCollectionRequest {
	r.deviceId = &deviceId
	return r
}

// the account ID of the user (deviceId or accountId required)
func (r ApiGetAlbumCollectionRequest) AccountId(accountId int64) ApiGetAlbumCollectionRequest {
	r.accountId = &accountId
	return r
}

// returns the last X likes. To search on and paginate the remaining likes - please use the \&quot;/like/search\&quot;Â endpoint.
func (r ApiGetAlbumCollectionRequest) LikePreviewSize(likePreviewSize int32) ApiGetAlbumCollectionRequest {
	r.likePreviewSize = &likePreviewSize
	return r
}

// returns the first X assets. To search on and paginate the remaining assets - please use the \&quot;/assets/search\&quot;Â endpoint.
func (r ApiGetAlbumCollectionRequest) AssetPreviewSize(assetPreviewSize int32) ApiGetAlbumCollectionRequest {
	r.assetPreviewSize = &assetPreviewSize
	return r
}

// returns the last X notes. To search on and paginate the remaining notes - please use the \&quot;/note/search\&quot; endpoint.
func (r ApiGetAlbumCollectionRequest) NotePreviewSize(notePreviewSize int32) ApiGetAlbumCollectionRequest {
	r.notePreviewSize = &notePreviewSize
	return r
}

// returns the first X users/connections. To search on and paginate the remaining connections - please use the \&quot;/permissions/search\&quot; endpoint.
func (r ApiGetAlbumCollectionRequest) ConnectionPreviewSize(connectionPreviewSize int32) ApiGetAlbumCollectionRequest {
	r.connectionPreviewSize = &connectionPreviewSize
	return r
}

// returns the first X audiences. To search on and paginate the remaining audiences - please use the \&quot;/audience/search\&quot; endpoint.
func (r ApiGetAlbumCollectionRequest) AudiencePreviewSize(audiencePreviewSize int32) ApiGetAlbumCollectionRequest {
	r.audiencePreviewSize = &audiencePreviewSize
	return r
}

func (r ApiGetAlbumCollectionRequest) Execute() (*AlbumFullResponse, *http.Response, error) {
	return r.ApiService.GetAlbumCollectionExecute(r)
}

/*
GetAlbumCollection  Get Album

Get an Album.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetAlbumCollectionRequest
*/
func (a *AlbumAPIService) GetAlbumCollection(ctx context.Context, version float32) ApiGetAlbumCollectionRequest {
	return ApiGetAlbumCollectionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return AlbumFullResponse
func (a *AlbumAPIService) GetAlbumCollectionExecute(r ApiGetAlbumCollectionRequest) (*AlbumFullResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlbumFullResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumAPIService.GetAlbumCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/album/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.returnNulls == nil {
		return localVarReturnValue, nil, reportError("returnNulls is required and must be specified")
	}
	if r.albumId == nil {
		return localVarReturnValue, nil, reportError("albumId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "returnNulls", r.returnNulls, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "albumId", r.albumId, "form", "")
	if r.likePreviewSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "likePreviewSize", r.likePreviewSize, "form", "")
	}
	if r.assetPreviewSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetPreviewSize", r.assetPreviewSize, "form", "")
	}
	if r.notePreviewSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notePreviewSize", r.notePreviewSize, "form", "")
	}
	if r.connectionPreviewSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionPreviewSize", r.connectionPreviewSize, "form", "")
	}
	if r.audiencePreviewSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audiencePreviewSize", r.audiencePreviewSize, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLeaveAlbumRequest struct {
	ctx context.Context
	ApiService *AlbumAPIService
	version float32
	albumId *int64
	deviceId *string
	accountId *int64
}

// the album ID
func (r ApiLeaveAlbumRequest) AlbumId(albumId int64) ApiLeaveAlbumRequest {
	r.albumId = &albumId
	return r
}

// a unique ID given by the device (deviceId or accountId required)
func (r ApiLeaveAlbumRequest) DeviceId(deviceId string) ApiLeaveAlbumRequest {
	r.deviceId = &deviceId
	return r
}

// the account ID of the user (deviceId or accountId required)
func (r ApiLeaveAlbumRequest) AccountId(accountId int64) ApiLeaveAlbumRequest {
	r.accountId = &accountId
	return r
}

func (r ApiLeaveAlbumRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.LeaveAlbumExecute(r)
}

/*
LeaveAlbum Leave Album

 Allows a user to leave an album (they are no longer considered a participant). The album creator cannot leave their own albums.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiLeaveAlbumRequest
*/
func (a *AlbumAPIService) LeaveAlbum(ctx context.Context, version float32) ApiLeaveAlbumRequest {
	return ApiLeaveAlbumRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AlbumAPIService) LeaveAlbumExecute(r ApiLeaveAlbumRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumAPIService.LeaveAlbum")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/album/user/leave"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.albumId == nil {
		return localVarReturnValue, nil, reportError("albumId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "albumId", r.albumId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveAlbumRequest struct {
	ctx context.Context
	ApiService *AlbumAPIService
	version float32
	albumId *int64
	deviceId *string
	accountId *int64
}

// the album ID to delete
func (r ApiRemoveAlbumRequest) AlbumId(albumId int64) ApiRemoveAlbumRequest {
	r.albumId = &albumId
	return r
}

// a unique ID given by the device (deviceId or accountId required)
func (r ApiRemoveAlbumRequest) DeviceId(deviceId string) ApiRemoveAlbumRequest {
	r.deviceId = &deviceId
	return r
}

// the account ID of the user (deviceId or accountId required)
func (r ApiRemoveAlbumRequest) AccountId(accountId int64) ApiRemoveAlbumRequest {
	r.accountId = &accountId
	return r
}

func (r ApiRemoveAlbumRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.RemoveAlbumExecute(r)
}

/*
RemoveAlbum Delete Album

Deletes an Album

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiRemoveAlbumRequest
*/
func (a *AlbumAPIService) RemoveAlbum(ctx context.Context, version float32) ApiRemoveAlbumRequest {
	return ApiRemoveAlbumRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AlbumAPIService) RemoveAlbumExecute(r ApiRemoveAlbumRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumAPIService.RemoveAlbum")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/album/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.albumId == nil {
		return localVarReturnValue, nil, reportError("albumId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "albumId", r.albumId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveAlbumUsersRequest struct {
	ctx context.Context
	ApiService *AlbumAPIService
	version float32
	albumId *int64
	removeFriendGroup *bool
	deviceId *string
	accountId *int64
	connections *string
	connectionGroups *string
}

// the album ID
func (r ApiRemoveAlbumUsersRequest) AlbumId(albumId int64) ApiRemoveAlbumUsersRequest {
	r.albumId = &albumId
	return r
}

// remove friend group
func (r ApiRemoveAlbumUsersRequest) RemoveFriendGroup(removeFriendGroup bool) ApiRemoveAlbumUsersRequest {
	r.removeFriendGroup = &removeFriendGroup
	return r
}

// a unique ID given by the device (deviceId or accountId required)
func (r ApiRemoveAlbumUsersRequest) DeviceId(deviceId string) ApiRemoveAlbumUsersRequest {
	r.deviceId = &deviceId
	return r
}

// the account ID of the user (deviceId or accountId required)
func (r ApiRemoveAlbumUsersRequest) AccountId(accountId int64) ApiRemoveAlbumUsersRequest {
	r.accountId = &accountId
	return r
}

// comma separated list of connection IDs
func (r ApiRemoveAlbumUsersRequest) Connections(connections string) ApiRemoveAlbumUsersRequest {
	r.connections = &connections
	return r
}

// comma separated list of connection group IDs
func (r ApiRemoveAlbumUsersRequest) ConnectionGroups(connectionGroups string) ApiRemoveAlbumUsersRequest {
	r.connectionGroups = &connectionGroups
	return r
}

func (r ApiRemoveAlbumUsersRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.RemoveAlbumUsersExecute(r)
}

/*
RemoveAlbumUsers Remove Album Users

Remove participants of an album.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiRemoveAlbumUsersRequest
*/
func (a *AlbumAPIService) RemoveAlbumUsers(ctx context.Context, version float32) ApiRemoveAlbumUsersRequest {
	return ApiRemoveAlbumUsersRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AlbumAPIService) RemoveAlbumUsersExecute(r ApiRemoveAlbumUsersRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumAPIService.RemoveAlbumUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/album/user/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.albumId == nil {
		return localVarReturnValue, nil, reportError("albumId is required and must be specified")
	}
	if r.removeFriendGroup == nil {
		return localVarReturnValue, nil, reportError("removeFriendGroup is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "albumId", r.albumId, "form", "")
	if r.connections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connections", r.connections, "form", "")
	}
	if r.connectionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionGroups", r.connectionGroups, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "removeFriendGroup", r.removeFriendGroup, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchAlbumsRequest struct {
	ctx context.Context
	ApiService *AlbumAPIService
	version float32
	filter *string
	albumTypeId *int64
	subType *string
	includeInactive *bool
	sortField *string
	descending *bool
	start *int32
	limit *int32
	range_ *float64
	includeLiked *bool
	includeFavorited *bool
	includePermissions *bool
	likePreviewSize *int32
	assetPreviewSize *int32
	notePreviewSize *int32
	connectionPreviewSize *int32
	audiencePreviewSize *int32
	deviceId *string
	accountId *int64
	connectionAccountId *int64
	ownerId *int64
	albumIds *string
	excludeAlbumIds *string
	mediaId *int64
	keyword *string
	albumType *string
	limitPerAlbumType *int32
	dateCreated *int64
	updatedSince *int64
	updatedBefore *int64
	createdSince *int64
	createdBefore *int64
	startedSince *int64
	startedBefore *int64
	endedSince *int64
	endedBefore *int64
	latitude *float64
	longitude *float64
	appKey *string
	categoryIds *string
	categoryFilterIds *string
	audienceIds *string
	excludeAudienceIds *string
	includeCompletable *bool
	includeRating *bool
	searchMode *string
	stackSearch *bool
	stackWindowSize *int32
	minStackPerPage *int32
	stackPaginationIdentifier *string
	stackDetails *bool
	flagCountMinimum *int64
	removeFlaggedContent *bool
	verifiedFilter *bool
	linkedObjectType *string
	linkedObjectId *int64
	orderAudienceId *int64
	ignoreDefaultAppFilter *bool
	searchExpression *string
	generateAlbums *bool
}

// a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user&#39;s followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. 
func (r ApiSearchAlbumsRequest) Filter(filter string) ApiSearchAlbumsRequest {
	r.filter = &filter
	return r
}

// id of custom albumType
func (r ApiSearchAlbumsRequest) AlbumTypeId(albumTypeId int64) ApiSearchAlbumsRequest {
	r.albumTypeId = &albumTypeId
	return r
}

// filter albums with this album sub type
func (r ApiSearchAlbumsRequest) SubType(subType string) ApiSearchAlbumsRequest {
	r.subType = &subType
	return r
}

// determines whether to return inactive albums
func (r ApiSearchAlbumsRequest) IncludeInactive(includeInactive bool) ApiSearchAlbumsRequest {
	r.includeInactive = &includeInactive
	return r
}

// the field to sort by. See AlbumApiMap
func (r ApiSearchAlbumsRequest) SortField(sortField string) ApiSearchAlbumsRequest {
	r.sortField = &sortField
	return r
}

// determines whether the sorted list is in descending or ascending order
func (r ApiSearchAlbumsRequest) Descending(descending bool) ApiSearchAlbumsRequest {
	r.descending = &descending
	return r
}

// the start index for pagination
func (r ApiSearchAlbumsRequest) Start(start int32) ApiSearchAlbumsRequest {
	r.start = &start
	return r
}

// the limit for pagination (There is a hard limit of 100)
func (r ApiSearchAlbumsRequest) Limit(limit int32) ApiSearchAlbumsRequest {
	r.limit = &limit
	return r
}

// the maximum range the album can be from the center (used when sortField&#x3D;ALBUM_DISTANCE)
func (r ApiSearchAlbumsRequest) Range_(range_ float64) ApiSearchAlbumsRequest {
	r.range_ = &range_
	return r
}

// returns whether or not the current logged in user has liked the album
func (r ApiSearchAlbumsRequest) IncludeLiked(includeLiked bool) ApiSearchAlbumsRequest {
	r.includeLiked = &includeLiked
	return r
}

// returns whether or not the current logged in user has favorited the album
func (r ApiSearchAlbumsRequest) IncludeFavorited(includeFavorited bool) ApiSearchAlbumsRequest {
	r.includeFavorited = &includeFavorited
	return r
}

// returns permission details on whether they have read/write/delete permissions etc (client app probably doesn&#39;t need this)
func (r ApiSearchAlbumsRequest) IncludePermissions(includePermissions bool) ApiSearchAlbumsRequest {
	r.includePermissions = &includePermissions
	return r
}

// returns the last X likes
func (r ApiSearchAlbumsRequest) LikePreviewSize(likePreviewSize int32) ApiSearchAlbumsRequest {
	r.likePreviewSize = &likePreviewSize
	return r
}

// returns the first X assets
func (r ApiSearchAlbumsRequest) AssetPreviewSize(assetPreviewSize int32) ApiSearchAlbumsRequest {
	r.assetPreviewSize = &assetPreviewSize
	return r
}

// returns the last X notes
func (r ApiSearchAlbumsRequest) NotePreviewSize(notePreviewSize int32) ApiSearchAlbumsRequest {
	r.notePreviewSize = &notePreviewSize
	return r
}

// returns the first X users/connections
func (r ApiSearchAlbumsRequest) ConnectionPreviewSize(connectionPreviewSize int32) ApiSearchAlbumsRequest {
	r.connectionPreviewSize = &connectionPreviewSize
	return r
}

// returns the first X audiences. To search on and paginate the remaining audiences, please use the \&quot;/audience/search\&quot; endpoint.
func (r ApiSearchAlbumsRequest) AudiencePreviewSize(audiencePreviewSize int32) ApiSearchAlbumsRequest {
	r.audiencePreviewSize = &audiencePreviewSize
	return r
}

// a unique ID given by the device (deviceId or accountId required)
func (r ApiSearchAlbumsRequest) DeviceId(deviceId string) ApiSearchAlbumsRequest {
	r.deviceId = &deviceId
	return r
}

// the account ID of the user (deviceId or accountId required)
func (r ApiSearchAlbumsRequest) AccountId(accountId int64) ApiSearchAlbumsRequest {
	r.accountId = &accountId
	return r
}

// the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited.
func (r ApiSearchAlbumsRequest) ConnectionAccountId(connectionAccountId int64) ApiSearchAlbumsRequest {
	r.connectionAccountId = &connectionAccountId
	return r
}

// search on albums that have been created by this account (that the user has permissions to)
func (r ApiSearchAlbumsRequest) OwnerId(ownerId int64) ApiSearchAlbumsRequest {
	r.ownerId = &ownerId
	return r
}

// search on album within a comma separated list of album IDs (this does not work with sortField&#x3D;ALBUM_DISTANCE, or when stackSearch&#x3D;true)
func (r ApiSearchAlbumsRequest) AlbumIds(albumIds string) ApiSearchAlbumsRequest {
	r.albumIds = &albumIds
	return r
}

// Only for CLOUDINDEX mode, exclude albums with ids matching this list
func (r ApiSearchAlbumsRequest) ExcludeAlbumIds(excludeAlbumIds string) ApiSearchAlbumsRequest {
	r.excludeAlbumIds = &excludeAlbumIds
	return r
}

// search on albums that are in a particular media offering
func (r ApiSearchAlbumsRequest) MediaId(mediaId int64) ApiSearchAlbumsRequest {
	r.mediaId = &mediaId
	return r
}

// keyword search string
func (r ApiSearchAlbumsRequest) Keyword(keyword string) ApiSearchAlbumsRequest {
	r.keyword = &keyword
	return r
}

// filter albums with this album type
func (r ApiSearchAlbumsRequest) AlbumType(albumType string) ApiSearchAlbumsRequest {
	r.albumType = &albumType
	return r
}

// When using multiple album types this sets a per-album-type limit (used with cloud index mode)
func (r ApiSearchAlbumsRequest) LimitPerAlbumType(limitPerAlbumType int32) ApiSearchAlbumsRequest {
	r.limitPerAlbumType = &limitPerAlbumType
	return r
}

// return items that have been created before this date (time-stamp in milliseconds)
func (r ApiSearchAlbumsRequest) DateCreated(dateCreated int64) ApiSearchAlbumsRequest {
	r.dateCreated = &dateCreated
	return r
}

// return items that have been updated since this date (time-stamp in milliseconds)
func (r ApiSearchAlbumsRequest) UpdatedSince(updatedSince int64) ApiSearchAlbumsRequest {
	r.updatedSince = &updatedSince
	return r
}

// return items that have been updated before this date (time-stamp in milliseconds)
func (r ApiSearchAlbumsRequest) UpdatedBefore(updatedBefore int64) ApiSearchAlbumsRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// return items that have been created since this date (time-stamp in milliseconds)
func (r ApiSearchAlbumsRequest) CreatedSince(createdSince int64) ApiSearchAlbumsRequest {
	r.createdSince = &createdSince
	return r
}

// return items that have been created before this date (time-stamp in milliseconds)
func (r ApiSearchAlbumsRequest) CreatedBefore(createdBefore int64) ApiSearchAlbumsRequest {
	r.createdBefore = &createdBefore
	return r
}

// return items that have been started since this date (time-stamp in milliseconds)
func (r ApiSearchAlbumsRequest) StartedSince(startedSince int64) ApiSearchAlbumsRequest {
	r.startedSince = &startedSince
	return r
}

// return items that have been started before this date (time-stamp in milliseconds)
func (r ApiSearchAlbumsRequest) StartedBefore(startedBefore int64) ApiSearchAlbumsRequest {
	r.startedBefore = &startedBefore
	return r
}

// return items that have been ended since this date (time-stamp in milliseconds)
func (r ApiSearchAlbumsRequest) EndedSince(endedSince int64) ApiSearchAlbumsRequest {
	r.endedSince = &endedSince
	return r
}

// return items that have been ended before this date (time-stamp in milliseconds)
func (r ApiSearchAlbumsRequest) EndedBefore(endedBefore int64) ApiSearchAlbumsRequest {
	r.endedBefore = &endedBefore
	return r
}

// the latitude of where the search is centered on (used when sortField&#x3D;ALBUM_DISTANCE)
func (r ApiSearchAlbumsRequest) Latitude(latitude float64) ApiSearchAlbumsRequest {
	r.latitude = &latitude
	return r
}

// the longitude of where the search is centered on (used when sortField&#x3D;ALBUM_DISTANCE)
func (r ApiSearchAlbumsRequest) Longitude(longitude float64) ApiSearchAlbumsRequest {
	r.longitude = &longitude
	return r
}

// the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to.
func (r ApiSearchAlbumsRequest) AppKey(appKey string) ApiSearchAlbumsRequest {
	r.appKey = &appKey
	return r
}

// return results with categories matching this list
func (r ApiSearchAlbumsRequest) CategoryIds(categoryIds string) ApiSearchAlbumsRequest {
	r.categoryIds = &categoryIds
	return r
}

// return results with filters matching this list
func (r ApiSearchAlbumsRequest) CategoryFilterIds(categoryFilterIds string) ApiSearchAlbumsRequest {
	r.categoryFilterIds = &categoryFilterIds
	return r
}

// return results with audiences matching this list
func (r ApiSearchAlbumsRequest) AudienceIds(audienceIds string) ApiSearchAlbumsRequest {
	r.audienceIds = &audienceIds
	return r
}

// exclude audiences with ids matching this list
func (r ApiSearchAlbumsRequest) ExcludeAudienceIds(excludeAudienceIds string) ApiSearchAlbumsRequest {
	r.excludeAudienceIds = &excludeAudienceIds
	return r
}

// returns the user&#39;s completable object for the album if it exists
func (r ApiSearchAlbumsRequest) IncludeCompletable(includeCompletable bool) ApiSearchAlbumsRequest {
	r.includeCompletable = &includeCompletable
	return r
}

// returns the user&#39;s rating for the album if it exists
func (r ApiSearchAlbumsRequest) IncludeRating(includeRating bool) ApiSearchAlbumsRequest {
	r.includeRating = &includeRating
	return r
}

// The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default.
func (r ApiSearchAlbumsRequest) SearchMode(searchMode string) ApiSearchAlbumsRequest {
	r.searchMode = &searchMode
	return r
}

// groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize
func (r ApiSearchAlbumsRequest) StackSearch(stackSearch bool) ApiSearchAlbumsRequest {
	r.stackSearch = &stackSearch
	return r
}

// size of each window for each stack
func (r ApiSearchAlbumsRequest) StackWindowSize(stackWindowSize int32) ApiSearchAlbumsRequest {
	r.stackWindowSize = &stackWindowSize
	return r
}

// The minimum number of stacks returned in a response. For example,  first call, minStackPerPage &#x3D; 20, the API will return at least 20 results
func (r ApiSearchAlbumsRequest) MinStackPerPage(minStackPerPage int32) ApiSearchAlbumsRequest {
	r.minStackPerPage = &minStackPerPage
	return r
}

// this is used to tell the system where it left off on the previous previous page, since we can&#39;t use start/limit for stackSearch
func (r ApiSearchAlbumsRequest) StackPaginationIdentifier(stackPaginationIdentifier string) ApiSearchAlbumsRequest {
	r.stackPaginationIdentifier = &stackPaginationIdentifier
	return r
}

// set this to true when making the call to view the albums in the stack
func (r ApiSearchAlbumsRequest) StackDetails(stackDetails bool) ApiSearchAlbumsRequest {
	r.stackDetails = &stackDetails
	return r
}

// Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)
func (r ApiSearchAlbumsRequest) FlagCountMinimum(flagCountMinimum int64) ApiSearchAlbumsRequest {
	r.flagCountMinimum = &flagCountMinimum
	return r
}

// return items that have flagCount &gt;&#x3D; flagThreshold (controls removal of flagged content)
func (r ApiSearchAlbumsRequest) RemoveFlaggedContent(removeFlaggedContent bool) ApiSearchAlbumsRequest {
	r.removeFlaggedContent = &removeFlaggedContent
	return r
}

// setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both)
func (r ApiSearchAlbumsRequest) VerifiedFilter(verifiedFilter bool) ApiSearchAlbumsRequest {
	r.verifiedFilter = &verifiedFilter
	return r
}

// filter results by the linkedObjectType
func (r ApiSearchAlbumsRequest) LinkedObjectType(linkedObjectType string) ApiSearchAlbumsRequest {
	r.linkedObjectType = &linkedObjectType
	return r
}

// filter results by the linkedObjectId
func (r ApiSearchAlbumsRequest) LinkedObjectId(linkedObjectId int64) ApiSearchAlbumsRequest {
	r.linkedObjectId = &linkedObjectId
	return r
}

// determines whether to use the order assigned via the /album/order/_* api (which is tied to an audience)
func (r ApiSearchAlbumsRequest) OrderAudienceId(orderAudienceId int64) ApiSearchAlbumsRequest {
	r.orderAudienceId = &orderAudienceId
	return r
}

// if true, ignore the application&#39;s default app filter when searching
func (r ApiSearchAlbumsRequest) IgnoreDefaultAppFilter(ignoreDefaultAppFilter bool) ApiSearchAlbumsRequest {
	r.ignoreDefaultAppFilter = &ignoreDefaultAppFilter
	return r
}

// Advanced search expression to be used by the server
func (r ApiSearchAlbumsRequest) SearchExpression(searchExpression string) ApiSearchAlbumsRequest {
	r.searchExpression = &searchExpression
	return r
}

// If true and results are empty, attempt to generate albums via templates
func (r ApiSearchAlbumsRequest) GenerateAlbums(generateAlbums bool) ApiSearchAlbumsRequest {
	r.generateAlbums = &generateAlbums
	return r
}

func (r ApiSearchAlbumsRequest) Execute() ([]AlbumFullResponse, *http.Response, error) {
	return r.ApiService.SearchAlbumsExecute(r)
}

/*
SearchAlbums Search Albums

Searches on Albums.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchAlbumsRequest
*/
func (a *AlbumAPIService) SearchAlbums(ctx context.Context, version float32) ApiSearchAlbumsRequest {
	return ApiSearchAlbumsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []AlbumFullResponse
func (a *AlbumAPIService) SearchAlbumsExecute(r ApiSearchAlbumsRequest) ([]AlbumFullResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AlbumFullResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumAPIService.SearchAlbums")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/album/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filter == nil {
		return localVarReturnValue, nil, reportError("filter is required and must be specified")
	}
	if r.albumTypeId == nil {
		return localVarReturnValue, nil, reportError("albumTypeId is required and must be specified")
	}
	if r.subType == nil {
		return localVarReturnValue, nil, reportError("subType is required and must be specified")
	}
	if r.includeInactive == nil {
		return localVarReturnValue, nil, reportError("includeInactive is required and must be specified")
	}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}
	if r.descending == nil {
		return localVarReturnValue, nil, reportError("descending is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.range_ == nil {
		return localVarReturnValue, nil, reportError("range_ is required and must be specified")
	}
	if r.includeLiked == nil {
		return localVarReturnValue, nil, reportError("includeLiked is required and must be specified")
	}
	if r.includeFavorited == nil {
		return localVarReturnValue, nil, reportError("includeFavorited is required and must be specified")
	}
	if r.includePermissions == nil {
		return localVarReturnValue, nil, reportError("includePermissions is required and must be specified")
	}
	if r.likePreviewSize == nil {
		return localVarReturnValue, nil, reportError("likePreviewSize is required and must be specified")
	}
	if r.assetPreviewSize == nil {
		return localVarReturnValue, nil, reportError("assetPreviewSize is required and must be specified")
	}
	if r.notePreviewSize == nil {
		return localVarReturnValue, nil, reportError("notePreviewSize is required and must be specified")
	}
	if r.connectionPreviewSize == nil {
		return localVarReturnValue, nil, reportError("connectionPreviewSize is required and must be specified")
	}
	if r.audiencePreviewSize == nil {
		return localVarReturnValue, nil, reportError("audiencePreviewSize is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.connectionAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountId", r.connectionAccountId, "form", "")
	}
	if r.ownerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ownerId", r.ownerId, "form", "")
	}
	if r.albumIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumIds", r.albumIds, "form", "")
	}
	if r.excludeAlbumIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeAlbumIds", r.excludeAlbumIds, "form", "")
	}
	if r.mediaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaId", r.mediaId, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	if r.albumType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumType", r.albumType, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "albumTypeId", r.albumTypeId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "subType", r.subType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	if r.limitPerAlbumType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limitPerAlbumType", r.limitPerAlbumType, "form", "")
	}
	if r.dateCreated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dateCreated", r.dateCreated, "form", "")
	}
	if r.updatedSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedSince", r.updatedSince, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.createdSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdSince", r.createdSince, "form", "")
	}
	if r.createdBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBefore", r.createdBefore, "form", "")
	}
	if r.startedSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedSince", r.startedSince, "form", "")
	}
	if r.startedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedBefore", r.startedBefore, "form", "")
	}
	if r.endedSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endedSince", r.endedSince, "form", "")
	}
	if r.endedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endedBefore", r.endedBefore, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "range", r.range_, "form", "")
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.categoryFilterIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryFilterIds", r.categoryFilterIds, "form", "")
	}
	if r.audienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIds", r.audienceIds, "form", "")
	}
	if r.excludeAudienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeAudienceIds", r.excludeAudienceIds, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "includeLiked", r.includeLiked, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "includeFavorited", r.includeFavorited, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "includePermissions", r.includePermissions, "form", "")
	if r.includeCompletable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCompletable", r.includeCompletable, "form", "")
	}
	if r.includeRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRating", r.includeRating, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "likePreviewSize", r.likePreviewSize, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "assetPreviewSize", r.assetPreviewSize, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "notePreviewSize", r.notePreviewSize, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "connectionPreviewSize", r.connectionPreviewSize, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "audiencePreviewSize", r.audiencePreviewSize, "form", "")
	if r.searchMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchMode", r.searchMode, "form", "")
	}
	if r.stackSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stackSearch", r.stackSearch, "form", "")
	}
	if r.stackWindowSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stackWindowSize", r.stackWindowSize, "form", "")
	}
	if r.minStackPerPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minStackPerPage", r.minStackPerPage, "form", "")
	}
	if r.stackPaginationIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stackPaginationIdentifier", r.stackPaginationIdentifier, "form", "")
	}
	if r.stackDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stackDetails", r.stackDetails, "form", "")
	}
	if r.flagCountMinimum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flagCountMinimum", r.flagCountMinimum, "form", "")
	}
	if r.removeFlaggedContent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "removeFlaggedContent", r.removeFlaggedContent, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "removeFlaggedContent", defaultValue, "form", "")
		r.removeFlaggedContent = &defaultValue
	}
	if r.verifiedFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verifiedFilter", r.verifiedFilter, "form", "")
	}
	if r.linkedObjectType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkedObjectType", r.linkedObjectType, "form", "")
	}
	if r.linkedObjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkedObjectId", r.linkedObjectId, "form", "")
	}
	if r.orderAudienceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderAudienceId", r.orderAudienceId, "form", "")
	}
	if r.ignoreDefaultAppFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignoreDefaultAppFilter", r.ignoreDefaultAppFilter, "form", "")
	}
	if r.searchExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchExpression", r.searchExpression, "form", "")
	}
	if r.generateAlbums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "generateAlbums", r.generateAlbums, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAlbumCollectionRequest struct {
	ctx context.Context
	ApiService *AlbumAPIService
	version float32
	albumId *int64
	deviceId *string
	accountId *int64
	assetsToAdd *string
	assetsToRemove *string
	assetId *int64
	media *os.File
	mediaURL *string
	active *bool
	title *string
	startDate *int64
	endDate *int64
	tags *string
	description *string
	albumType *string
	albumTypeId *int64
	subType *string
	publicRead *bool
	publicWrite *bool
	publicDelete *bool
	publicAdd *bool
	latitude *float64
	longitude *float64
	locationDescription *string
	visibility *string
	cellPhone *string
	streetAddress *string
	streetAddress2 *string
	city *string
	state *string
	postalCode *string
	fullAddress *string
	anonymous *bool
	metaData *string
	categoryIds *string
	categoryFilterIds *string
	audienceIds *string
	audienceIdsToAdd *string
	audienceIdsToRemove *string
	includeAllAppUsersAsMembers *bool
	includeAudiencesAsMembers *bool
	audienceOperator *string
	linkedObjectType *string
	linkedObjectId *int64
	indexNow *bool
}

// the ID of the album to update
func (r ApiUpdateAlbumCollectionRequest) AlbumId(albumId int64) ApiUpdateAlbumCollectionRequest {
	r.albumId = &albumId
	return r
}

// a unique ID given by the device (deviceId or accountId required)
func (r ApiUpdateAlbumCollectionRequest) DeviceId(deviceId string) ApiUpdateAlbumCollectionRequest {
	r.deviceId = &deviceId
	return r
}

// the account ID of the user (deviceId or accountId required)
func (r ApiUpdateAlbumCollectionRequest) AccountId(accountId int64) ApiUpdateAlbumCollectionRequest {
	r.accountId = &accountId
	return r
}

// Comma separated list of asset IDs to add to the album&#39;s asset list (use \&quot;assetId\&quot; for setting the cover of the album)
func (r ApiUpdateAlbumCollectionRequest) AssetsToAdd(assetsToAdd string) ApiUpdateAlbumCollectionRequest {
	r.assetsToAdd = &assetsToAdd
	return r
}

// Comma separated list of asset IDs to remove from the album&#39;s asset list
func (r ApiUpdateAlbumCollectionRequest) AssetsToRemove(assetsToRemove string) ApiUpdateAlbumCollectionRequest {
	r.assetsToRemove = &assetsToRemove
	return r
}

// the cover asset ID
func (r ApiUpdateAlbumCollectionRequest) AssetId(assetId int64) ApiUpdateAlbumCollectionRequest {
	r.assetId = &assetId
	return r
}

// a MultipartFile containing the cover image of the album (this will only be used if \&quot;assetId\&quot; is empty)
func (r ApiUpdateAlbumCollectionRequest) Media(media *os.File) ApiUpdateAlbumCollectionRequest {
	r.media = media
	return r
}

// this can be used if the \&quot;media\&quot; is a link (this will only be used if \&quot;assetId\&quot; and media are empty)
func (r ApiUpdateAlbumCollectionRequest) MediaURL(mediaURL string) ApiUpdateAlbumCollectionRequest {
	r.mediaURL = &mediaURL
	return r
}

// determines whether the album is active or inactive
func (r ApiUpdateAlbumCollectionRequest) Active(active bool) ApiUpdateAlbumCollectionRequest {
	r.active = &active
	return r
}

// the title of the album
func (r ApiUpdateAlbumCollectionRequest) Title(title string) ApiUpdateAlbumCollectionRequest {
	r.title = &title
	return r
}

// the start date
func (r ApiUpdateAlbumCollectionRequest) StartDate(startDate int64) ApiUpdateAlbumCollectionRequest {
	r.startDate = &startDate
	return r
}

// the end date
func (r ApiUpdateAlbumCollectionRequest) EndDate(endDate int64) ApiUpdateAlbumCollectionRequest {
	r.endDate = &endDate
	return r
}

// the tags
func (r ApiUpdateAlbumCollectionRequest) Tags(tags string) ApiUpdateAlbumCollectionRequest {
	r.tags = &tags
	return r
}

// the description of the album
func (r ApiUpdateAlbumCollectionRequest) Description(description string) ApiUpdateAlbumCollectionRequest {
	r.description = &description
	return r
}

// a custom field used for aggregation and searching
func (r ApiUpdateAlbumCollectionRequest) AlbumType(albumType string) ApiUpdateAlbumCollectionRequest {
	r.albumType = &albumType
	return r
}

// a custom indexed number used for aggregation and searching
func (r ApiUpdateAlbumCollectionRequest) AlbumTypeId(albumTypeId int64) ApiUpdateAlbumCollectionRequest {
	r.albumTypeId = &albumTypeId
	return r
}

// a custom string field used for aggregation and searching
func (r ApiUpdateAlbumCollectionRequest) SubType(subType string) ApiUpdateAlbumCollectionRequest {
	r.subType = &subType
	return r
}

// determines whether the album&#39;s participants have read permissions
func (r ApiUpdateAlbumCollectionRequest) PublicRead(publicRead bool) ApiUpdateAlbumCollectionRequest {
	r.publicRead = &publicRead
	return r
}

// determines whether the album&#39;s participants have write permissions
func (r ApiUpdateAlbumCollectionRequest) PublicWrite(publicWrite bool) ApiUpdateAlbumCollectionRequest {
	r.publicWrite = &publicWrite
	return r
}

// determines whether the album&#39;s participants have delete permissions
func (r ApiUpdateAlbumCollectionRequest) PublicDelete(publicDelete bool) ApiUpdateAlbumCollectionRequest {
	r.publicDelete = &publicDelete
	return r
}

// determines whether the album&#39;s participants have add permissions
func (r ApiUpdateAlbumCollectionRequest) PublicAdd(publicAdd bool) ApiUpdateAlbumCollectionRequest {
	r.publicAdd = &publicAdd
	return r
}

// latitude used to update the album&#39;s location
func (r ApiUpdateAlbumCollectionRequest) Latitude(latitude float64) ApiUpdateAlbumCollectionRequest {
	r.latitude = &latitude
	return r
}

// longitude used to update the album&#39;s location
func (r ApiUpdateAlbumCollectionRequest) Longitude(longitude float64) ApiUpdateAlbumCollectionRequest {
	r.longitude = &longitude
	return r
}

// the location description
func (r ApiUpdateAlbumCollectionRequest) LocationDescription(locationDescription string) ApiUpdateAlbumCollectionRequest {
	r.locationDescription = &locationDescription
	return r
}

// the determines the album&#39;s participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
func (r ApiUpdateAlbumCollectionRequest) Visibility(visibility string) ApiUpdateAlbumCollectionRequest {
	r.visibility = &visibility
	return r
}

// the cell phone number
func (r ApiUpdateAlbumCollectionRequest) CellPhone(cellPhone string) ApiUpdateAlbumCollectionRequest {
	r.cellPhone = &cellPhone
	return r
}

// The street address of the location
func (r ApiUpdateAlbumCollectionRequest) StreetAddress(streetAddress string) ApiUpdateAlbumCollectionRequest {
	r.streetAddress = &streetAddress
	return r
}

// Additional address information (such as a suite number, floor number, building name, or PO Box)
func (r ApiUpdateAlbumCollectionRequest) StreetAddress2(streetAddress2 string) ApiUpdateAlbumCollectionRequest {
	r.streetAddress2 = &streetAddress2
	return r
}

// The city of the location
func (r ApiUpdateAlbumCollectionRequest) City(city string) ApiUpdateAlbumCollectionRequest {
	r.city = &city
	return r
}

// The state of of the location
func (r ApiUpdateAlbumCollectionRequest) State(state string) ApiUpdateAlbumCollectionRequest {
	r.state = &state
	return r
}

// The postal code of the location
func (r ApiUpdateAlbumCollectionRequest) PostalCode(postalCode string) ApiUpdateAlbumCollectionRequest {
	r.postalCode = &postalCode
	return r
}

// The full address of the location which should include the street address, city, state, and postal code
func (r ApiUpdateAlbumCollectionRequest) FullAddress(fullAddress string) ApiUpdateAlbumCollectionRequest {
	r.fullAddress = &fullAddress
	return r
}

// determines whether the album is posted anonymously
func (r ApiUpdateAlbumCollectionRequest) Anonymous(anonymous bool) ApiUpdateAlbumCollectionRequest {
	r.anonymous = &anonymous
	return r
}

// External custom client defined data
func (r ApiUpdateAlbumCollectionRequest) MetaData(metaData string) ApiUpdateAlbumCollectionRequest {
	r.metaData = &metaData
	return r
}

// comma separated category ids string associated with the Album
func (r ApiUpdateAlbumCollectionRequest) CategoryIds(categoryIds string) ApiUpdateAlbumCollectionRequest {
	r.categoryIds = &categoryIds
	return r
}

// comma separated filter ids string associated with the Album
func (r ApiUpdateAlbumCollectionRequest) CategoryFilterIds(categoryFilterIds string) ApiUpdateAlbumCollectionRequest {
	r.categoryFilterIds = &categoryFilterIds
	return r
}

// comma separated audience ids string associated with the album
func (r ApiUpdateAlbumCollectionRequest) AudienceIds(audienceIds string) ApiUpdateAlbumCollectionRequest {
	r.audienceIds = &audienceIds
	return r
}

// comma separated audience ids to add to the album
func (r ApiUpdateAlbumCollectionRequest) AudienceIdsToAdd(audienceIdsToAdd string) ApiUpdateAlbumCollectionRequest {
	r.audienceIdsToAdd = &audienceIdsToAdd
	return r
}

// comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd)
func (r ApiUpdateAlbumCollectionRequest) AudienceIdsToRemove(audienceIdsToRemove string) ApiUpdateAlbumCollectionRequest {
	r.audienceIdsToRemove = &audienceIdsToRemove
	return r
}

// determines whether to include all app users as members (only admins of the app can do this)
func (r ApiUpdateAlbumCollectionRequest) IncludeAllAppUsersAsMembers(includeAllAppUsersAsMembers bool) ApiUpdateAlbumCollectionRequest {
	r.includeAllAppUsersAsMembers = &includeAllAppUsersAsMembers
	return r
}

// determines whether to include all users of the audiences as members (only admins of the app can do this)
func (r ApiUpdateAlbumCollectionRequest) IncludeAudiencesAsMembers(includeAudiencesAsMembers bool) ApiUpdateAlbumCollectionRequest {
	r.includeAudiencesAsMembers = &includeAudiencesAsMembers
	return r
}

// determines whether to use ands or ors when using the audience list to add users
func (r ApiUpdateAlbumCollectionRequest) AudienceOperator(audienceOperator string) ApiUpdateAlbumCollectionRequest {
	r.audienceOperator = &audienceOperator
	return r
}

// sets a linked object so that it can be returned as part of the album response
func (r ApiUpdateAlbumCollectionRequest) LinkedObjectType(linkedObjectType string) ApiUpdateAlbumCollectionRequest {
	r.linkedObjectType = &linkedObjectType
	return r
}

// sets a linked object id so that it can be returned as part of the album response
func (r ApiUpdateAlbumCollectionRequest) LinkedObjectId(linkedObjectId int64) ApiUpdateAlbumCollectionRequest {
	r.linkedObjectId = &linkedObjectId
	return r
}

// determines whether the album should be indexed immediately
func (r ApiUpdateAlbumCollectionRequest) IndexNow(indexNow bool) ApiUpdateAlbumCollectionRequest {
	r.indexNow = &indexNow
	return r
}

func (r ApiUpdateAlbumCollectionRequest) Execute() (*AlbumResponse, *http.Response, error) {
	return r.ApiService.UpdateAlbumCollectionExecute(r)
}

/*
UpdateAlbumCollection Update Album

Update an Album.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateAlbumCollectionRequest
*/
func (a *AlbumAPIService) UpdateAlbumCollection(ctx context.Context, version float32) ApiUpdateAlbumCollectionRequest {
	return ApiUpdateAlbumCollectionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return AlbumResponse
func (a *AlbumAPIService) UpdateAlbumCollectionExecute(r ApiUpdateAlbumCollectionRequest) (*AlbumResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlbumResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumAPIService.UpdateAlbumCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/album/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.albumId == nil {
		return localVarReturnValue, nil, reportError("albumId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "albumId", r.albumId, "form", "")
	if r.assetsToAdd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetsToAdd", r.assetsToAdd, "form", "")
	}
	if r.assetsToRemove != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetsToRemove", r.assetsToRemove, "form", "")
	}
	if r.assetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "form", "")
	}
	if r.media != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "media", r.media, "form", "")
	}
	if r.mediaURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaURL", r.mediaURL, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.albumType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumType", r.albumType, "form", "")
	}
	if r.albumTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumTypeId", r.albumTypeId, "form", "")
	}
	if r.subType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subType", r.subType, "form", "")
	}
	if r.publicRead != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publicRead", r.publicRead, "form", "")
	}
	if r.publicWrite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publicWrite", r.publicWrite, "form", "")
	}
	if r.publicDelete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publicDelete", r.publicDelete, "form", "")
	}
	if r.publicAdd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publicAdd", r.publicAdd, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.locationDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locationDescription", r.locationDescription, "form", "")
	}
	if r.visibility != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibility", r.visibility, "form", "")
	}
	if r.cellPhone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cellPhone", r.cellPhone, "form", "")
	}
	if r.streetAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streetAddress", r.streetAddress, "form", "")
	}
	if r.streetAddress2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streetAddress2", r.streetAddress2, "form", "")
	}
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	if r.postalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postalCode", r.postalCode, "form", "")
	}
	if r.fullAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fullAddress", r.fullAddress, "form", "")
	}
	if r.anonymous != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "anonymous", r.anonymous, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.categoryFilterIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryFilterIds", r.categoryFilterIds, "form", "")
	}
	if r.audienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIds", r.audienceIds, "form", "")
	}
	if r.audienceIdsToAdd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIdsToAdd", r.audienceIdsToAdd, "form", "")
	}
	if r.audienceIdsToRemove != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIdsToRemove", r.audienceIdsToRemove, "form", "")
	}
	if r.includeAllAppUsersAsMembers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAllAppUsersAsMembers", r.includeAllAppUsersAsMembers, "form", "")
	}
	if r.includeAudiencesAsMembers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAudiencesAsMembers", r.includeAudiencesAsMembers, "form", "")
	}
	if r.audienceOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceOperator", r.audienceOperator, "form", "")
	}
	if r.linkedObjectType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkedObjectType", r.linkedObjectType, "form", "")
	}
	if r.linkedObjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linkedObjectId", r.linkedObjectId, "form", "")
	}
	if r.indexNow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "indexNow", r.indexNow, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
