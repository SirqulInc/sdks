/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ConnectionAPIService ConnectionAPI service
type ConnectionAPIService service

type ApiAddConnectionToGroupRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	returnNulls *bool
	groupId *int64
	deviceId *string
	accountId *int64
	connectionId *int64
	connectionAccountId *int64
	pendingId *int64
	latitude *float64
	longitude *float64
}

// whether to return nulls or not
func (r ApiAddConnectionToGroupRequest) ReturnNulls(returnNulls bool) ApiAddConnectionToGroupRequest {
	r.returnNulls = &returnNulls
	return r
}

// the group id
func (r ApiAddConnectionToGroupRequest) GroupId(groupId int64) ApiAddConnectionToGroupRequest {
	r.groupId = &groupId
	return r
}

// the device id (deviceId or accountId required)
func (r ApiAddConnectionToGroupRequest) DeviceId(deviceId string) ApiAddConnectionToGroupRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiAddConnectionToGroupRequest) AccountId(accountId int64) ApiAddConnectionToGroupRequest {
	r.accountId = &accountId
	return r
}

// the connection id
func (r ApiAddConnectionToGroupRequest) ConnectionId(connectionId int64) ApiAddConnectionToGroupRequest {
	r.connectionId = &connectionId
	return r
}

// the connection account id
func (r ApiAddConnectionToGroupRequest) ConnectionAccountId(connectionAccountId int64) ApiAddConnectionToGroupRequest {
	r.connectionAccountId = &connectionAccountId
	return r
}

// the pending id
func (r ApiAddConnectionToGroupRequest) PendingId(pendingId int64) ApiAddConnectionToGroupRequest {
	r.pendingId = &pendingId
	return r
}

// the current latitude of the user
func (r ApiAddConnectionToGroupRequest) Latitude(latitude float64) ApiAddConnectionToGroupRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiAddConnectionToGroupRequest) Longitude(longitude float64) ApiAddConnectionToGroupRequest {
	r.longitude = &longitude
	return r
}

func (r ApiAddConnectionToGroupRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.AddConnectionToGroupExecute(r)
}

/*
AddConnectionToGroup Add Connection

Adds a connection to a group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddConnectionToGroupRequest
*/
func (a *ConnectionAPIService) AddConnectionToGroup(ctx context.Context) ApiAddConnectionToGroupRequest {
	return ApiAddConnectionToGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ConnectionAPIService) AddConnectionToGroupExecute(r ApiAddConnectionToGroupRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.AddConnectionToGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/connection/group/addConnection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.returnNulls == nil {
		return localVarReturnValue, nil, reportError("returnNulls is required and must be specified")
	}
	if r.groupId == nil {
		return localVarReturnValue, nil, reportError("groupId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "returnNulls", r.returnNulls, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "form", "")
	}
	if r.connectionAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountId", r.connectionAccountId, "form", "")
	}
	if r.pendingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pendingId", r.pendingId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", r.groupId, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddConnectionsToGroupRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	connectionGroupId *int64
	deviceId *string
	accountId *int64
	connectionIds *string
	connectionAccountIds *string
	latitude *float64
	longitude *float64
}

// the connection group ID
func (r ApiAddConnectionsToGroupRequest) ConnectionGroupId(connectionGroupId int64) ApiAddConnectionsToGroupRequest {
	r.connectionGroupId = &connectionGroupId
	return r
}

// the device id (deviceId or accountId required)
func (r ApiAddConnectionsToGroupRequest) DeviceId(deviceId string) ApiAddConnectionsToGroupRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiAddConnectionsToGroupRequest) AccountId(accountId int64) ApiAddConnectionsToGroupRequest {
	r.accountId = &accountId
	return r
}

// comma separated list of connection ids
func (r ApiAddConnectionsToGroupRequest) ConnectionIds(connectionIds string) ApiAddConnectionsToGroupRequest {
	r.connectionIds = &connectionIds
	return r
}

// comma separated list of connection account ids
func (r ApiAddConnectionsToGroupRequest) ConnectionAccountIds(connectionAccountIds string) ApiAddConnectionsToGroupRequest {
	r.connectionAccountIds = &connectionAccountIds
	return r
}

// the current latitude of the user
func (r ApiAddConnectionsToGroupRequest) Latitude(latitude float64) ApiAddConnectionsToGroupRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiAddConnectionsToGroupRequest) Longitude(longitude float64) ApiAddConnectionsToGroupRequest {
	r.longitude = &longitude
	return r
}

func (r ApiAddConnectionsToGroupRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.AddConnectionsToGroupExecute(r)
}

/*
AddConnectionsToGroup Add Connections

Adds a list of connections to a group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddConnectionsToGroupRequest
*/
func (a *ConnectionAPIService) AddConnectionsToGroup(ctx context.Context) ApiAddConnectionsToGroupRequest {
	return ApiAddConnectionsToGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ConnectionAPIService) AddConnectionsToGroupExecute(r ApiAddConnectionsToGroupRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.AddConnectionsToGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connection/group/addConnections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.connectionGroupId == nil {
		return localVarReturnValue, nil, reportError("connectionGroupId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.connectionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionIds", r.connectionIds, "form", "")
	}
	if r.connectionAccountIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountIds", r.connectionAccountIds, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "connectionGroupId", r.connectionGroupId, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddSubGroupsRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	returnNulls *bool
	groupId *int64
	subGroupIds *string
	deviceId *string
	accountId *int64
	latitude *float64
	longitude *float64
}

// whether to return nulls or not
func (r ApiAddSubGroupsRequest) ReturnNulls(returnNulls bool) ApiAddSubGroupsRequest {
	r.returnNulls = &returnNulls
	return r
}

// the parent group id
func (r ApiAddSubGroupsRequest) GroupId(groupId int64) ApiAddSubGroupsRequest {
	r.groupId = &groupId
	return r
}

// comma separated list of group IDs to add to the parent group
func (r ApiAddSubGroupsRequest) SubGroupIds(subGroupIds string) ApiAddSubGroupsRequest {
	r.subGroupIds = &subGroupIds
	return r
}

// the device id (deviceId or accountId required)
func (r ApiAddSubGroupsRequest) DeviceId(deviceId string) ApiAddSubGroupsRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiAddSubGroupsRequest) AccountId(accountId int64) ApiAddSubGroupsRequest {
	r.accountId = &accountId
	return r
}

// the current latitude of the user
func (r ApiAddSubGroupsRequest) Latitude(latitude float64) ApiAddSubGroupsRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiAddSubGroupsRequest) Longitude(longitude float64) ApiAddSubGroupsRequest {
	r.longitude = &longitude
	return r
}

func (r ApiAddSubGroupsRequest) Execute() (*ConnectionGroupResponse, *http.Response, error) {
	return r.ApiService.AddSubGroupsExecute(r)
}

/*
AddSubGroups Add Connection Groups

Add sub groups to a group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddSubGroupsRequest
*/
func (a *ConnectionAPIService) AddSubGroups(ctx context.Context) ApiAddSubGroupsRequest {
	return ApiAddSubGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConnectionGroupResponse
func (a *ConnectionAPIService) AddSubGroupsExecute(r ApiAddSubGroupsRequest) (*ConnectionGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.AddSubGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/connection/group/addSubGroup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.returnNulls == nil {
		return localVarReturnValue, nil, reportError("returnNulls is required and must be specified")
	}
	if r.groupId == nil {
		return localVarReturnValue, nil, reportError("groupId is required and must be specified")
	}
	if r.subGroupIds == nil {
		return localVarReturnValue, nil, reportError("subGroupIds is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "returnNulls", r.returnNulls, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", r.groupId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "subGroupIds", r.subGroupIds, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrUpdateConnectionRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	deviceId *string
	accountId *int64
	connectionId *int64
	connectionAccountId *int64
	pendingId *int64
	groupId *int64
	gameType *string
	appKey *string
	isTrusted *bool
	ignoreFriendRequest *bool
	isContact *bool
	isBlocked *bool
	isFollowing *bool
	connectionResponse *bool
}

// the device id (deviceId or accountId required)
func (r ApiCreateOrUpdateConnectionRequest) DeviceId(deviceId string) ApiCreateOrUpdateConnectionRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiCreateOrUpdateConnectionRequest) AccountId(accountId int64) ApiCreateOrUpdateConnectionRequest {
	r.accountId = &accountId
	return r
}

// the connection id for editing
func (r ApiCreateOrUpdateConnectionRequest) ConnectionId(connectionId int64) ApiCreateOrUpdateConnectionRequest {
	r.connectionId = &connectionId
	return r
}

// the connection account id (i.e. the account id of another user)
func (r ApiCreateOrUpdateConnectionRequest) ConnectionAccountId(connectionAccountId int64) ApiCreateOrUpdateConnectionRequest {
	r.connectionAccountId = &connectionAccountId
	return r
}

// the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps)
func (r ApiCreateOrUpdateConnectionRequest) PendingId(pendingId int64) ApiCreateOrUpdateConnectionRequest {
	r.pendingId = &pendingId
	return r
}

// optional group id if the user wants to add this person into a group
func (r ApiCreateOrUpdateConnectionRequest) GroupId(groupId int64) ApiCreateOrUpdateConnectionRequest {
	r.groupId = &groupId
	return r
}

// This parameter is deprecated.
func (r ApiCreateOrUpdateConnectionRequest) GameType(gameType string) ApiCreateOrUpdateConnectionRequest {
	r.gameType = &gameType
	return r
}

// the application key
func (r ApiCreateOrUpdateConnectionRequest) AppKey(appKey string) ApiCreateOrUpdateConnectionRequest {
	r.appKey = &appKey
	return r
}

// determines whether the user is trusting this account
func (r ApiCreateOrUpdateConnectionRequest) IsTrusted(isTrusted bool) ApiCreateOrUpdateConnectionRequest {
	r.isTrusted = &isTrusted
	return r
}

// determines whether the user has set to ignore the user&#39;s friend request
func (r ApiCreateOrUpdateConnectionRequest) IgnoreFriendRequest(ignoreFriendRequest bool) ApiCreateOrUpdateConnectionRequest {
	r.ignoreFriendRequest = &ignoreFriendRequest
	return r
}

// determines whether the user is a contact of this account
func (r ApiCreateOrUpdateConnectionRequest) IsContact(isContact bool) ApiCreateOrUpdateConnectionRequest {
	r.isContact = &isContact
	return r
}

// determines whether the user is blocking this account
func (r ApiCreateOrUpdateConnectionRequest) IsBlocked(isBlocked bool) ApiCreateOrUpdateConnectionRequest {
	r.isBlocked = &isBlocked
	return r
}

// determines whether the user is following this account
func (r ApiCreateOrUpdateConnectionRequest) IsFollowing(isFollowing bool) ApiCreateOrUpdateConnectionRequest {
	r.isFollowing = &isFollowing
	return r
}

// whether to return the connection response or not
func (r ApiCreateOrUpdateConnectionRequest) ConnectionResponse(connectionResponse bool) ApiCreateOrUpdateConnectionRequest {
	r.connectionResponse = &connectionResponse
	return r
}

func (r ApiCreateOrUpdateConnectionRequest) Execute() (*ConnectionResponse, *http.Response, error) {
	return r.ApiService.CreateOrUpdateConnectionExecute(r)
}

/*
CreateOrUpdateConnection Create or Update Connection

Creates or updates the connection of the user and another account. Allows a user to follow, block, mark as trusted, and/or add someone to a group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrUpdateConnectionRequest
*/
func (a *ConnectionAPIService) CreateOrUpdateConnection(ctx context.Context) ApiCreateOrUpdateConnectionRequest {
	return ApiCreateOrUpdateConnectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConnectionResponse
func (a *ConnectionAPIService) CreateOrUpdateConnectionExecute(r ApiCreateOrUpdateConnectionRequest) (*ConnectionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.CreateOrUpdateConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/connection/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "form", "")
	}
	if r.connectionAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountId", r.connectionAccountId, "form", "")
	}
	if r.pendingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pendingId", r.pendingId, "form", "")
	}
	if r.groupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", r.groupId, "form", "")
	}
	if r.gameType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameType", r.gameType, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.isTrusted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isTrusted", r.isTrusted, "form", "")
	}
	if r.ignoreFriendRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignoreFriendRequest", r.ignoreFriendRequest, "form", "")
	}
	if r.isContact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isContact", r.isContact, "form", "")
	}
	if r.isBlocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isBlocked", r.isBlocked, "form", "")
	}
	if r.isFollowing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isFollowing", r.isFollowing, "form", "")
	}
	if r.connectionResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionResponse", r.connectionResponse, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrUpdateGroupRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	returnNulls *bool
	deviceId *string
	accountId *int64
	name *string
	groupId *int64
	assetId *int64
	connections *string
	description *string
	canViewProfileInfo *bool
	canViewGameInfo *bool
	canViewFriendInfo *bool
	active *bool
	latitude *float64
	longitude *float64
}

// whether to return nulls or not
func (r ApiCreateOrUpdateGroupRequest) ReturnNulls(returnNulls bool) ApiCreateOrUpdateGroupRequest {
	r.returnNulls = &returnNulls
	return r
}

// the device id (deviceId or accountId required)
func (r ApiCreateOrUpdateGroupRequest) DeviceId(deviceId string) ApiCreateOrUpdateGroupRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiCreateOrUpdateGroupRequest) AccountId(accountId int64) ApiCreateOrUpdateGroupRequest {
	r.accountId = &accountId
	return r
}

// the name of the group
func (r ApiCreateOrUpdateGroupRequest) Name(name string) ApiCreateOrUpdateGroupRequest {
	r.name = &name
	return r
}

// the group id to update a group (don&#39;t pass anything in if you want to create a new group)
func (r ApiCreateOrUpdateGroupRequest) GroupId(groupId int64) ApiCreateOrUpdateGroupRequest {
	r.groupId = &groupId
	return r
}

// the asset to attach to the group
func (r ApiCreateOrUpdateGroupRequest) AssetId(assetId int64) ApiCreateOrUpdateGroupRequest {
	r.assetId = &assetId
	return r
}

// comma separated list of connection IDs
func (r ApiCreateOrUpdateGroupRequest) Connections(connections string) ApiCreateOrUpdateGroupRequest {
	r.connections = &connections
	return r
}

// the description of the group
func (r ApiCreateOrUpdateGroupRequest) Description(description string) ApiCreateOrUpdateGroupRequest {
	r.description = &description
	return r
}

// determines whether the connections in the group can see the user&#39;s profile info
func (r ApiCreateOrUpdateGroupRequest) CanViewProfileInfo(canViewProfileInfo bool) ApiCreateOrUpdateGroupRequest {
	r.canViewProfileInfo = &canViewProfileInfo
	return r
}

// determines whether the connections in the group can see the user&#39;s game info
func (r ApiCreateOrUpdateGroupRequest) CanViewGameInfo(canViewGameInfo bool) ApiCreateOrUpdateGroupRequest {
	r.canViewGameInfo = &canViewGameInfo
	return r
}

// determines whether the connections in the group can see the user&#39;s friends/connections
func (r ApiCreateOrUpdateGroupRequest) CanViewFriendInfo(canViewFriendInfo bool) ApiCreateOrUpdateGroupRequest {
	r.canViewFriendInfo = &canViewFriendInfo
	return r
}

// Sets whether the connection group is active or inactive
func (r ApiCreateOrUpdateGroupRequest) Active(active bool) ApiCreateOrUpdateGroupRequest {
	r.active = &active
	return r
}

// the latitude of the group
func (r ApiCreateOrUpdateGroupRequest) Latitude(latitude float64) ApiCreateOrUpdateGroupRequest {
	r.latitude = &latitude
	return r
}

// the longitude of the group
func (r ApiCreateOrUpdateGroupRequest) Longitude(longitude float64) ApiCreateOrUpdateGroupRequest {
	r.longitude = &longitude
	return r
}

func (r ApiCreateOrUpdateGroupRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.CreateOrUpdateGroupExecute(r)
}

/*
CreateOrUpdateGroup Create or Update Connection Group

Creates a new private group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrUpdateGroupRequest
*/
func (a *ConnectionAPIService) CreateOrUpdateGroup(ctx context.Context) ApiCreateOrUpdateGroupRequest {
	return ApiCreateOrUpdateGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ConnectionAPIService) CreateOrUpdateGroupExecute(r ApiCreateOrUpdateGroupRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.CreateOrUpdateGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/connection/group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.returnNulls == nil {
		return localVarReturnValue, nil, reportError("returnNulls is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "returnNulls", r.returnNulls, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.groupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", r.groupId, "form", "")
	}
	if r.assetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "form", "")
	}
	if r.connections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connections", r.connections, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.canViewProfileInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "canViewProfileInfo", r.canViewProfileInfo, "form", "")
	}
	if r.canViewGameInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "canViewGameInfo", r.canViewGameInfo, "form", "")
	}
	if r.canViewFriendInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "canViewFriendInfo", r.canViewFriendInfo, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFollowAcceptRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	accountId *int64
	connectionAccountId *int64
	appKey *string
}

// the account id of the user
func (r ApiFollowAcceptRequest) AccountId(accountId int64) ApiFollowAcceptRequest {
	r.accountId = &accountId
	return r
}

// the account ID of the user who initiated the follow
func (r ApiFollowAcceptRequest) ConnectionAccountId(connectionAccountId int64) ApiFollowAcceptRequest {
	r.connectionAccountId = &connectionAccountId
	return r
}

// the application key for sending notifications
func (r ApiFollowAcceptRequest) AppKey(appKey string) ApiFollowAcceptRequest {
	r.appKey = &appKey
	return r
}

func (r ApiFollowAcceptRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.FollowAcceptExecute(r)
}

/*
FollowAccept Accept Follow Request

Accept someone's follow request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFollowAcceptRequest
*/
func (a *ConnectionAPIService) FollowAccept(ctx context.Context) ApiFollowAcceptRequest {
	return ApiFollowAcceptRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ConnectionAPIService) FollowAcceptExecute(r ApiFollowAcceptRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.FollowAccept")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/follow/accept"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.connectionAccountId == nil {
		return localVarReturnValue, nil, reportError("connectionAccountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountId", r.connectionAccountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFollowRejectRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	accountId *int64
	connectionAccountId *int64
	appKey *string
}

// the account id of the user
func (r ApiFollowRejectRequest) AccountId(accountId int64) ApiFollowRejectRequest {
	r.accountId = &accountId
	return r
}

// the account ID of the user who initiated the follow
func (r ApiFollowRejectRequest) ConnectionAccountId(connectionAccountId int64) ApiFollowRejectRequest {
	r.connectionAccountId = &connectionAccountId
	return r
}

// the application key for sending notifications
func (r ApiFollowRejectRequest) AppKey(appKey string) ApiFollowRejectRequest {
	r.appKey = &appKey
	return r
}

func (r ApiFollowRejectRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.FollowRejectExecute(r)
}

/*
FollowReject Reject Follow Request

Reject someone's follow request or remove them as a follower.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFollowRejectRequest
*/
func (a *ConnectionAPIService) FollowReject(ctx context.Context) ApiFollowRejectRequest {
	return ApiFollowRejectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ConnectionAPIService) FollowRejectExecute(r ApiFollowRejectRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.FollowReject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/follow/reject"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.connectionAccountId == nil {
		return localVarReturnValue, nil, reportError("connectionAccountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountId", r.connectionAccountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFollowRemoveRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	accountId *int64
	connectionAccountId *int64
	appKey *string
}

// the account id of the user
func (r ApiFollowRemoveRequest) AccountId(accountId int64) ApiFollowRemoveRequest {
	r.accountId = &accountId
	return r
}

// the account ID of the user who you want to unfollow
func (r ApiFollowRemoveRequest) ConnectionAccountId(connectionAccountId int64) ApiFollowRemoveRequest {
	r.connectionAccountId = &connectionAccountId
	return r
}

// the application key for sending notifications
func (r ApiFollowRemoveRequest) AppKey(appKey string) ApiFollowRemoveRequest {
	r.appKey = &appKey
	return r
}

func (r ApiFollowRemoveRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.FollowRemoveExecute(r)
}

/*
FollowRemove Remove Follower / Unfollow

Unfollow someone you are following or remove them as a follower.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFollowRemoveRequest
*/
func (a *ConnectionAPIService) FollowRemove(ctx context.Context) ApiFollowRemoveRequest {
	return ApiFollowRemoveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ConnectionAPIService) FollowRemoveExecute(r ApiFollowRemoveRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.FollowRemove")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/follow/remove"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.connectionAccountId == nil {
		return localVarReturnValue, nil, reportError("connectionAccountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountId", r.connectionAccountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFollowRequestRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	accountId *int64
	connectionAccountId *int64
	appKey *string
	approvalNeeded *bool
}

// the account id of the user
func (r ApiFollowRequestRequest) AccountId(accountId int64) ApiFollowRequestRequest {
	r.accountId = &accountId
	return r
}

// the account ID of the user who you want to follow
func (r ApiFollowRequestRequest) ConnectionAccountId(connectionAccountId int64) ApiFollowRequestRequest {
	r.connectionAccountId = &connectionAccountId
	return r
}

// the application key for sending notifications
func (r ApiFollowRequestRequest) AppKey(appKey string) ApiFollowRequestRequest {
	r.appKey = &appKey
	return r
}

// determines if the other user needs to confirm the follow request
func (r ApiFollowRequestRequest) ApprovalNeeded(approvalNeeded bool) ApiFollowRequestRequest {
	r.approvalNeeded = &approvalNeeded
	return r
}

func (r ApiFollowRequestRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.FollowRequestExecute(r)
}

/*
FollowRequest Send Follow Request

Send a request to follow someone.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFollowRequestRequest
*/
func (a *ConnectionAPIService) FollowRequest(ctx context.Context) ApiFollowRequestRequest {
	return ApiFollowRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ConnectionAPIService) FollowRequestExecute(r ApiFollowRequestRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.FollowRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/follow/request"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.connectionAccountId == nil {
		return localVarReturnValue, nil, reportError("connectionAccountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountId", r.connectionAccountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.approvalNeeded != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalNeeded", r.approvalNeeded, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalNeeded", defaultValue, "form", "")
		r.approvalNeeded = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFriendAcceptRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	friendAccountId *int64
	notifyFriend *bool
	deviceId *string
	accountId *int64
	gameType *string
	appKey *string
	notificationMessage *string
}

// the friend&#39;s account id
func (r ApiFriendAcceptRequest) FriendAccountId(friendAccountId int64) ApiFriendAcceptRequest {
	r.friendAccountId = &friendAccountId
	return r
}

// determines whether to send a notification to the afflicting party
func (r ApiFriendAcceptRequest) NotifyFriend(notifyFriend bool) ApiFriendAcceptRequest {
	r.notifyFriend = &notifyFriend
	return r
}

// the device id (deviceId or accountId required)
func (r ApiFriendAcceptRequest) DeviceId(deviceId string) ApiFriendAcceptRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiFriendAcceptRequest) AccountId(accountId int64) ApiFriendAcceptRequest {
	r.accountId = &accountId
	return r
}

// This parameter is deprecated.
func (r ApiFriendAcceptRequest) GameType(gameType string) ApiFriendAcceptRequest {
	r.gameType = &gameType
	return r
}

// the application key
func (r ApiFriendAcceptRequest) AppKey(appKey string) ApiFriendAcceptRequest {
	r.appKey = &appKey
	return r
}

// optional message to send in a notification
func (r ApiFriendAcceptRequest) NotificationMessage(notificationMessage string) ApiFriendAcceptRequest {
	r.notificationMessage = &notificationMessage
	return r
}

func (r ApiFriendAcceptRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.FriendAcceptExecute(r)
}

/*
FriendAccept Accept Friend

Accept a friend request and optionally sends a notification.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFriendAcceptRequest
*/
func (a *ConnectionAPIService) FriendAccept(ctx context.Context) ApiFriendAcceptRequest {
	return ApiFriendAcceptRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ConnectionAPIService) FriendAcceptExecute(r ApiFriendAcceptRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.FriendAccept")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/friend/accept"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.friendAccountId == nil {
		return localVarReturnValue, nil, reportError("friendAccountId is required and must be specified")
	}
	if r.notifyFriend == nil {
		return localVarReturnValue, nil, reportError("notifyFriend is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "friendAccountId", r.friendAccountId, "form", "")
	if r.gameType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameType", r.gameType, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "notifyFriend", r.notifyFriend, "form", "")
	if r.notificationMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notificationMessage", r.notificationMessage, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFriendRejectRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	friendAccountId *int64
	deviceId *string
	accountId *int64
	gameType *string
	appKey *string
	notifyFriend *bool
	notificationMessage *string
}

// the friend&#39;s account id
func (r ApiFriendRejectRequest) FriendAccountId(friendAccountId int64) ApiFriendRejectRequest {
	r.friendAccountId = &friendAccountId
	return r
}

// the device id (deviceId or accountId required)
func (r ApiFriendRejectRequest) DeviceId(deviceId string) ApiFriendRejectRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiFriendRejectRequest) AccountId(accountId int64) ApiFriendRejectRequest {
	r.accountId = &accountId
	return r
}

// This parameter is deprecated.
func (r ApiFriendRejectRequest) GameType(gameType string) ApiFriendRejectRequest {
	r.gameType = &gameType
	return r
}

// the application key
func (r ApiFriendRejectRequest) AppKey(appKey string) ApiFriendRejectRequest {
	r.appKey = &appKey
	return r
}

// determines whether to send a notification to the afflicting party
func (r ApiFriendRejectRequest) NotifyFriend(notifyFriend bool) ApiFriendRejectRequest {
	r.notifyFriend = &notifyFriend
	return r
}

// optional message to send in a notification
func (r ApiFriendRejectRequest) NotificationMessage(notificationMessage string) ApiFriendRejectRequest {
	r.notificationMessage = &notificationMessage
	return r
}

func (r ApiFriendRejectRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.FriendRejectExecute(r)
}

/*
FriendReject Decline Friend

Request a friend request and optionally sends a notification.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFriendRejectRequest
*/
func (a *ConnectionAPIService) FriendReject(ctx context.Context) ApiFriendRejectRequest {
	return ApiFriendRejectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ConnectionAPIService) FriendRejectExecute(r ApiFriendRejectRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.FriendReject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/friend/reject"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.friendAccountId == nil {
		return localVarReturnValue, nil, reportError("friendAccountId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "friendAccountId", r.friendAccountId, "form", "")
	if r.gameType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameType", r.gameType, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.notifyFriend != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notifyFriend", r.notifyFriend, "form", "")
	}
	if r.notificationMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notificationMessage", r.notificationMessage, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFriendRemoveRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	friendAccountId *int64
	deviceId *string
	accountId *int64
	notifyFriend *bool
	removeFromGroups *bool
}

// the account ID of the friend to remove
func (r ApiFriendRemoveRequest) FriendAccountId(friendAccountId int64) ApiFriendRemoveRequest {
	r.friendAccountId = &friendAccountId
	return r
}

// the device id (deviceId or accountId required)
func (r ApiFriendRemoveRequest) DeviceId(deviceId string) ApiFriendRemoveRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiFriendRemoveRequest) AccountId(accountId int64) ApiFriendRemoveRequest {
	r.accountId = &accountId
	return r
}

// optionally notifies the connection that they have been removed as a friend
func (r ApiFriendRemoveRequest) NotifyFriend(notifyFriend bool) ApiFriendRemoveRequest {
	r.notifyFriend = &notifyFriend
	return r
}

// optionally removes the connection from the user&#39;s groups
func (r ApiFriendRemoveRequest) RemoveFromGroups(removeFromGroups bool) ApiFriendRemoveRequest {
	r.removeFromGroups = &removeFromGroups
	return r
}

func (r ApiFriendRemoveRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.FriendRemoveExecute(r)
}

/*
FriendRemove Delete Friend

Removes a friend from the user's friends list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFriendRemoveRequest
*/
func (a *ConnectionAPIService) FriendRemove(ctx context.Context) ApiFriendRemoveRequest {
	return ApiFriendRemoveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ConnectionAPIService) FriendRemoveExecute(r ApiFriendRemoveRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.FriendRemove")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/friend/remove"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.friendAccountId == nil {
		return localVarReturnValue, nil, reportError("friendAccountId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "friendAccountId", r.friendAccountId, "form", "")
	if r.notifyFriend != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notifyFriend", r.notifyFriend, "form", "")
	}
	if r.removeFromGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "removeFromGroups", r.removeFromGroups, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFriendRequestRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	friendAccountId *int64
	deviceId *string
	accountId *int64
	gameType *string
	appKey *string
	notificationMessage *string
}

// the friend&#39;s account id
func (r ApiFriendRequestRequest) FriendAccountId(friendAccountId int64) ApiFriendRequestRequest {
	r.friendAccountId = &friendAccountId
	return r
}

// the device id (deviceId or accountId required)
func (r ApiFriendRequestRequest) DeviceId(deviceId string) ApiFriendRequestRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiFriendRequestRequest) AccountId(accountId int64) ApiFriendRequestRequest {
	r.accountId = &accountId
	return r
}

// This parameter is deprecated.
func (r ApiFriendRequestRequest) GameType(gameType string) ApiFriendRequestRequest {
	r.gameType = &gameType
	return r
}

// the application key
func (r ApiFriendRequestRequest) AppKey(appKey string) ApiFriendRequestRequest {
	r.appKey = &appKey
	return r
}

// optional message to send in a notification
func (r ApiFriendRequestRequest) NotificationMessage(notificationMessage string) ApiFriendRequestRequest {
	r.notificationMessage = &notificationMessage
	return r
}

func (r ApiFriendRequestRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.FriendRequestExecute(r)
}

/*
FriendRequest Request Friend

Sends a friend request notification to another user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFriendRequestRequest
*/
func (a *ConnectionAPIService) FriendRequest(ctx context.Context) ApiFriendRequestRequest {
	return ApiFriendRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ConnectionAPIService) FriendRequestExecute(r ApiFriendRequestRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.FriendRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/friend/request"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.friendAccountId == nil {
		return localVarReturnValue, nil, reportError("friendAccountId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "friendAccountId", r.friendAccountId, "form", "")
	if r.gameType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameType", r.gameType, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.notificationMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notificationMessage", r.notificationMessage, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConnectionSentFriendRequestsRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	deviceId *string
	accountId *int64
}

// the ID of the device
func (r ApiGetConnectionSentFriendRequestsRequest) DeviceId(deviceId string) ApiGetConnectionSentFriendRequestsRequest {
	r.deviceId = &deviceId
	return r
}

// the id of the account
func (r ApiGetConnectionSentFriendRequestsRequest) AccountId(accountId int64) ApiGetConnectionSentFriendRequestsRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetConnectionSentFriendRequestsRequest) Execute() (*ConnectionListResponse, *http.Response, error) {
	return r.ApiService.GetConnectionSentFriendRequestsExecute(r)
}

/*
GetConnectionSentFriendRequests Get Sent Friend Requests

Gets the connection sent friend requests.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConnectionSentFriendRequestsRequest
*/
func (a *ConnectionAPIService) GetConnectionSentFriendRequests(ctx context.Context) ApiGetConnectionSentFriendRequestsRequest {
	return ApiGetConnectionSentFriendRequestsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConnectionListResponse
func (a *ConnectionAPIService) GetConnectionSentFriendRequestsExecute(r ApiGetConnectionSentFriendRequestsRequest) (*ConnectionListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.GetConnectionSentFriendRequests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/connection/getRequested"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConnectionsRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	returnNulls *bool
	filter *string
	sortField *string
	descending *bool
	start *int32
	limit *int32
	deviceId *string
	accountId *int64
	connectionAccountId *int64
	q *string
	keyword *string
	i *int32
	l *int32
	latitude *float64
	longitude *float64
}

// whether to return nulls or not
func (r ApiGetConnectionsRequest) ReturnNulls(returnNulls bool) ApiGetConnectionsRequest {
	r.returnNulls = &returnNulls
	return r
}

// a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)
func (r ApiGetConnectionsRequest) Filter(filter string) ApiGetConnectionsRequest {
	r.filter = &filter
	return r
}

// sorts the response list by ConnectionApiMap
func (r ApiGetConnectionsRequest) SortField(sortField string) ApiGetConnectionsRequest {
	r.sortField = &sortField
	return r
}

// sorts the response list by descending order if true
func (r ApiGetConnectionsRequest) Descending(descending bool) ApiGetConnectionsRequest {
	r.descending = &descending
	return r
}

// start index of the pagination
func (r ApiGetConnectionsRequest) Start(start int32) ApiGetConnectionsRequest {
	r.start = &start
	return r
}

// limit of the pagination
func (r ApiGetConnectionsRequest) Limit(limit int32) ApiGetConnectionsRequest {
	r.limit = &limit
	return r
}

// the device id (deviceId or accountId required)
func (r ApiGetConnectionsRequest) DeviceId(deviceId string) ApiGetConnectionsRequest {
	r.deviceId = &deviceId
	return r
}

// the account id (deviceId or accountId required)
func (r ApiGetConnectionsRequest) AccountId(accountId int64) ApiGetConnectionsRequest {
	r.accountId = &accountId
	return r
}

// optional parameter to search on other account&#39;s connections
func (r ApiGetConnectionsRequest) ConnectionAccountId(connectionAccountId int64) ApiGetConnectionsRequest {
	r.connectionAccountId = &connectionAccountId
	return r
}

// This parameter is deprecated.
func (r ApiGetConnectionsRequest) Q(q string) ApiGetConnectionsRequest {
	r.q = &q
	return r
}

// an optional keyword to search on, this parameter is ignored if empty
func (r ApiGetConnectionsRequest) Keyword(keyword string) ApiGetConnectionsRequest {
	r.keyword = &keyword
	return r
}

// This parameter is deprecated.
func (r ApiGetConnectionsRequest) I(i int32) ApiGetConnectionsRequest {
	r.i = &i
	return r
}

// This parameter is deprecated.
func (r ApiGetConnectionsRequest) L(l int32) ApiGetConnectionsRequest {
	r.l = &l
	return r
}

// the current latitude of the user
func (r ApiGetConnectionsRequest) Latitude(latitude float64) ApiGetConnectionsRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiGetConnectionsRequest) Longitude(longitude float64) ApiGetConnectionsRequest {
	r.longitude = &longitude
	return r
}

func (r ApiGetConnectionsRequest) Execute() (*ConnectionListResponse, *http.Response, error) {
	return r.ApiService.GetConnectionsExecute(r)
}

/*
GetConnections Search Connections

Gets the connections.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConnectionsRequest
*/
func (a *ConnectionAPIService) GetConnections(ctx context.Context) ApiGetConnectionsRequest {
	return ApiGetConnectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConnectionListResponse
func (a *ConnectionAPIService) GetConnectionsExecute(r ApiGetConnectionsRequest) (*ConnectionListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.GetConnections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/connection/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.returnNulls == nil {
		return localVarReturnValue, nil, reportError("returnNulls is required and must be specified")
	}
	if r.filter == nil {
		return localVarReturnValue, nil, reportError("filter is required and must be specified")
	}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}
	if r.descending == nil {
		return localVarReturnValue, nil, reportError("descending is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "returnNulls", r.returnNulls, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.connectionAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountId", r.connectionAccountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	if r.i != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_i", r.i, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	if r.l != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_l", r.l, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupDetailsRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	combineConnections *bool
	deviceId *string
	accountId *int64
	groupId *int64
	latitude *float64
	longitude *float64
}

// whether to combine connections or not
func (r ApiGetGroupDetailsRequest) CombineConnections(combineConnections bool) ApiGetGroupDetailsRequest {
	r.combineConnections = &combineConnections
	return r
}

// the device id (deviceId or accountId required)
func (r ApiGetGroupDetailsRequest) DeviceId(deviceId string) ApiGetGroupDetailsRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiGetGroupDetailsRequest) AccountId(accountId int64) ApiGetGroupDetailsRequest {
	r.accountId = &accountId
	return r
}

// the group id
func (r ApiGetGroupDetailsRequest) GroupId(groupId int64) ApiGetGroupDetailsRequest {
	r.groupId = &groupId
	return r
}

// the current latitude of the user
func (r ApiGetGroupDetailsRequest) Latitude(latitude float64) ApiGetGroupDetailsRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiGetGroupDetailsRequest) Longitude(longitude float64) ApiGetGroupDetailsRequest {
	r.longitude = &longitude
	return r
}

func (r ApiGetGroupDetailsRequest) Execute() (*ConnectionGroupResponse, *http.Response, error) {
	return r.ApiService.GetGroupDetailsExecute(r)
}

/*
GetGroupDetails Get Connection Group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGroupDetailsRequest
*/
func (a *ConnectionAPIService) GetGroupDetails(ctx context.Context) ApiGetGroupDetailsRequest {
	return ApiGetGroupDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConnectionGroupResponse
func (a *ConnectionAPIService) GetGroupDetailsExecute(r ApiGetGroupDetailsRequest) (*ConnectionGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.GetGroupDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/connection/group/details/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.combineConnections == nil {
		return localVarReturnValue, nil, reportError("combineConnections is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.groupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", r.groupId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "combineConnections", r.combineConnections, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupSearchRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	sortField *string
	descending *bool
	activeOnly *bool
	start *int32
	limit *int32
	deviceId *string
	accountId *int64
	latitude *float64
	longitude *float64
	keyword *string
}

// the field to sort by
func (r ApiGroupSearchRequest) SortField(sortField string) ApiGroupSearchRequest {
	r.sortField = &sortField
	return r
}

// whether to return results in descending or ascending order
func (r ApiGroupSearchRequest) Descending(descending bool) ApiGroupSearchRequest {
	r.descending = &descending
	return r
}

// to search on active only or not
func (r ApiGroupSearchRequest) ActiveOnly(activeOnly bool) ApiGroupSearchRequest {
	r.activeOnly = &activeOnly
	return r
}

// The start of the pagination
func (r ApiGroupSearchRequest) Start(start int32) ApiGroupSearchRequest {
	r.start = &start
	return r
}

// the limit of the pagination
func (r ApiGroupSearchRequest) Limit(limit int32) ApiGroupSearchRequest {
	r.limit = &limit
	return r
}

// the device id (deviceId or accountId required)
func (r ApiGroupSearchRequest) DeviceId(deviceId string) ApiGroupSearchRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiGroupSearchRequest) AccountId(accountId int64) ApiGroupSearchRequest {
	r.accountId = &accountId
	return r
}

// the current latitude of the user
func (r ApiGroupSearchRequest) Latitude(latitude float64) ApiGroupSearchRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiGroupSearchRequest) Longitude(longitude float64) ApiGroupSearchRequest {
	r.longitude = &longitude
	return r
}

// keyword search string
func (r ApiGroupSearchRequest) Keyword(keyword string) ApiGroupSearchRequest {
	r.keyword = &keyword
	return r
}

func (r ApiGroupSearchRequest) Execute() ([]ConnectionInfoResponse, *http.Response, error) {
	return r.ApiService.GroupSearchExecute(r)
}

/*
GroupSearch Search Connection Groups

Gets a user's private groups and default groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGroupSearchRequest
*/
func (a *ConnectionAPIService) GroupSearch(ctx context.Context) ApiGroupSearchRequest {
	return ApiGroupSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ConnectionInfoResponse
func (a *ConnectionAPIService) GroupSearchExecute(r ApiGroupSearchRequest) ([]ConnectionInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ConnectionInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.GroupSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connection/group/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}
	if r.descending == nil {
		return localVarReturnValue, nil, reportError("descending is required and must be specified")
	}
	if r.activeOnly == nil {
		return localVarReturnValue, nil, reportError("activeOnly is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveConnectionFromGroupRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	returnNulls *bool
	groupId *int64
	deviceId *string
	accountId *int64
	connectionId *int64
	connectionAccountId *int64
	pendingId *int64
	latitude *float64
	longitude *float64
}

// whether to return nulls or not
func (r ApiRemoveConnectionFromGroupRequest) ReturnNulls(returnNulls bool) ApiRemoveConnectionFromGroupRequest {
	r.returnNulls = &returnNulls
	return r
}

// the group id
func (r ApiRemoveConnectionFromGroupRequest) GroupId(groupId int64) ApiRemoveConnectionFromGroupRequest {
	r.groupId = &groupId
	return r
}

// the device id (deviceId or accountId required)
func (r ApiRemoveConnectionFromGroupRequest) DeviceId(deviceId string) ApiRemoveConnectionFromGroupRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiRemoveConnectionFromGroupRequest) AccountId(accountId int64) ApiRemoveConnectionFromGroupRequest {
	r.accountId = &accountId
	return r
}

// the connection id
func (r ApiRemoveConnectionFromGroupRequest) ConnectionId(connectionId int64) ApiRemoveConnectionFromGroupRequest {
	r.connectionId = &connectionId
	return r
}

// the connection account id
func (r ApiRemoveConnectionFromGroupRequest) ConnectionAccountId(connectionAccountId int64) ApiRemoveConnectionFromGroupRequest {
	r.connectionAccountId = &connectionAccountId
	return r
}

// the pending id
func (r ApiRemoveConnectionFromGroupRequest) PendingId(pendingId int64) ApiRemoveConnectionFromGroupRequest {
	r.pendingId = &pendingId
	return r
}

// the current latitude of the user
func (r ApiRemoveConnectionFromGroupRequest) Latitude(latitude float64) ApiRemoveConnectionFromGroupRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiRemoveConnectionFromGroupRequest) Longitude(longitude float64) ApiRemoveConnectionFromGroupRequest {
	r.longitude = &longitude
	return r
}

func (r ApiRemoveConnectionFromGroupRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.RemoveConnectionFromGroupExecute(r)
}

/*
RemoveConnectionFromGroup Delete Connection

Removes the connection from group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoveConnectionFromGroupRequest
*/
func (a *ConnectionAPIService) RemoveConnectionFromGroup(ctx context.Context) ApiRemoveConnectionFromGroupRequest {
	return ApiRemoveConnectionFromGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ConnectionAPIService) RemoveConnectionFromGroupExecute(r ApiRemoveConnectionFromGroupRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.RemoveConnectionFromGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/connection/group/removeConnection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.returnNulls == nil {
		return localVarReturnValue, nil, reportError("returnNulls is required and must be specified")
	}
	if r.groupId == nil {
		return localVarReturnValue, nil, reportError("groupId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "returnNulls", r.returnNulls, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "form", "")
	}
	if r.connectionAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountId", r.connectionAccountId, "form", "")
	}
	if r.pendingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pendingId", r.pendingId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", r.groupId, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveConnectionsFromGroupRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	connectionGroupId *int64
	deviceId *string
	accountId *int64
	connectionIds *string
	connectionAccountIds *string
	latitude *float64
	longitude *float64
}

// connection group id
func (r ApiRemoveConnectionsFromGroupRequest) ConnectionGroupId(connectionGroupId int64) ApiRemoveConnectionsFromGroupRequest {
	r.connectionGroupId = &connectionGroupId
	return r
}

// the device id (deviceId or accountId required)
func (r ApiRemoveConnectionsFromGroupRequest) DeviceId(deviceId string) ApiRemoveConnectionsFromGroupRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiRemoveConnectionsFromGroupRequest) AccountId(accountId int64) ApiRemoveConnectionsFromGroupRequest {
	r.accountId = &accountId
	return r
}

// comma separated list of connection ids
func (r ApiRemoveConnectionsFromGroupRequest) ConnectionIds(connectionIds string) ApiRemoveConnectionsFromGroupRequest {
	r.connectionIds = &connectionIds
	return r
}

// comma separated list of connection account ids
func (r ApiRemoveConnectionsFromGroupRequest) ConnectionAccountIds(connectionAccountIds string) ApiRemoveConnectionsFromGroupRequest {
	r.connectionAccountIds = &connectionAccountIds
	return r
}

// the current latitude of the user
func (r ApiRemoveConnectionsFromGroupRequest) Latitude(latitude float64) ApiRemoveConnectionsFromGroupRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiRemoveConnectionsFromGroupRequest) Longitude(longitude float64) ApiRemoveConnectionsFromGroupRequest {
	r.longitude = &longitude
	return r
}

func (r ApiRemoveConnectionsFromGroupRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.RemoveConnectionsFromGroupExecute(r)
}

/*
RemoveConnectionsFromGroup Remove Connections

Remove a list of connections from a group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoveConnectionsFromGroupRequest
*/
func (a *ConnectionAPIService) RemoveConnectionsFromGroup(ctx context.Context) ApiRemoveConnectionsFromGroupRequest {
	return ApiRemoveConnectionsFromGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ConnectionAPIService) RemoveConnectionsFromGroupExecute(r ApiRemoveConnectionsFromGroupRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.RemoveConnectionsFromGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connection/group/removeConnections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.connectionGroupId == nil {
		return localVarReturnValue, nil, reportError("connectionGroupId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.connectionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionIds", r.connectionIds, "form", "")
	}
	if r.connectionAccountIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountIds", r.connectionAccountIds, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "connectionGroupId", r.connectionGroupId, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveGroupRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	returnNulls *bool
	groupId *int64
	deviceId *string
	accountId *int64
	latitude *float64
	longitude *float64
}

// whether to return nulls or not
func (r ApiRemoveGroupRequest) ReturnNulls(returnNulls bool) ApiRemoveGroupRequest {
	r.returnNulls = &returnNulls
	return r
}

// the group id
func (r ApiRemoveGroupRequest) GroupId(groupId int64) ApiRemoveGroupRequest {
	r.groupId = &groupId
	return r
}

// the device id (deviceId or accountId required)
func (r ApiRemoveGroupRequest) DeviceId(deviceId string) ApiRemoveGroupRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiRemoveGroupRequest) AccountId(accountId int64) ApiRemoveGroupRequest {
	r.accountId = &accountId
	return r
}

// the current latitude of the user
func (r ApiRemoveGroupRequest) Latitude(latitude float64) ApiRemoveGroupRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiRemoveGroupRequest) Longitude(longitude float64) ApiRemoveGroupRequest {
	r.longitude = &longitude
	return r
}

func (r ApiRemoveGroupRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.RemoveGroupExecute(r)
}

/*
RemoveGroup Delete Connection Group

Remove a user's group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoveGroupRequest
*/
func (a *ConnectionAPIService) RemoveGroup(ctx context.Context) ApiRemoveGroupRequest {
	return ApiRemoveGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ConnectionAPIService) RemoveGroupExecute(r ApiRemoveGroupRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.RemoveGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/connection/group/remove"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.returnNulls == nil {
		return localVarReturnValue, nil, reportError("returnNulls is required and must be specified")
	}
	if r.groupId == nil {
		return localVarReturnValue, nil, reportError("groupId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "returnNulls", r.returnNulls, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", r.groupId, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveSubGroupsRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	returnNulls *bool
	groupId *int64
	subGroupIds *string
	deviceId *string
	accountId *int64
	latitude *float64
	longitude *float64
}

// whether to return nulls or not
func (r ApiRemoveSubGroupsRequest) ReturnNulls(returnNulls bool) ApiRemoveSubGroupsRequest {
	r.returnNulls = &returnNulls
	return r
}

// the parent group id
func (r ApiRemoveSubGroupsRequest) GroupId(groupId int64) ApiRemoveSubGroupsRequest {
	r.groupId = &groupId
	return r
}

// comma separated list of group IDs to remove from the parent group
func (r ApiRemoveSubGroupsRequest) SubGroupIds(subGroupIds string) ApiRemoveSubGroupsRequest {
	r.subGroupIds = &subGroupIds
	return r
}

// the device id (deviceId or accountId required)
func (r ApiRemoveSubGroupsRequest) DeviceId(deviceId string) ApiRemoveSubGroupsRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiRemoveSubGroupsRequest) AccountId(accountId int64) ApiRemoveSubGroupsRequest {
	r.accountId = &accountId
	return r
}

// the current latitude of the user
func (r ApiRemoveSubGroupsRequest) Latitude(latitude float64) ApiRemoveSubGroupsRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiRemoveSubGroupsRequest) Longitude(longitude float64) ApiRemoveSubGroupsRequest {
	r.longitude = &longitude
	return r
}

func (r ApiRemoveSubGroupsRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.RemoveSubGroupsExecute(r)
}

/*
RemoveSubGroups Remove Connection Groups

Remove sub groups from a group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoveSubGroupsRequest
*/
func (a *ConnectionAPIService) RemoveSubGroups(ctx context.Context) ApiRemoveSubGroupsRequest {
	return ApiRemoveSubGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ConnectionAPIService) RemoveSubGroupsExecute(r ApiRemoveSubGroupsRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.RemoveSubGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/connection/group/removeSubGroup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.returnNulls == nil {
		return localVarReturnValue, nil, reportError("returnNulls is required and must be specified")
	}
	if r.groupId == nil {
		return localVarReturnValue, nil, reportError("groupId is required and must be specified")
	}
	if r.subGroupIds == nil {
		return localVarReturnValue, nil, reportError("subGroupIds is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "returnNulls", r.returnNulls, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", r.groupId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "subGroupIds", r.subGroupIds, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchConnectionsRequest struct {
	ctx context.Context
	ApiService *ConnectionAPIService
	returnNulls *bool
	start *int32
	limit *int32
	deviceId *string
	accountId *int64
	q *string
	keyword *string
	latitude *float64
	longitude *float64
	gameType *string
	appKey *string
	i *int32
	l *int32
	sortField *string
	hasLocation *bool
}

// return all json attributes if true. defualt is true.
func (r ApiSearchConnectionsRequest) ReturnNulls(returnNulls bool) ApiSearchConnectionsRequest {
	r.returnNulls = &returnNulls
	return r
}

// start index of the pagination
func (r ApiSearchConnectionsRequest) Start(start int32) ApiSearchConnectionsRequest {
	r.start = &start
	return r
}

// limit of the pagination
func (r ApiSearchConnectionsRequest) Limit(limit int32) ApiSearchConnectionsRequest {
	r.limit = &limit
	return r
}

// the device id (deviceId or accountId required)
func (r ApiSearchConnectionsRequest) DeviceId(deviceId string) ApiSearchConnectionsRequest {
	r.deviceId = &deviceId
	return r
}

// the account id (deviceId or accountId required)
func (r ApiSearchConnectionsRequest) AccountId(accountId int64) ApiSearchConnectionsRequest {
	r.accountId = &accountId
	return r
}

// This parameter is deprecated.
func (r ApiSearchConnectionsRequest) Q(q string) ApiSearchConnectionsRequest {
	r.q = &q
	return r
}

// keyword to search on, optional and this parameter is ignored if empt
func (r ApiSearchConnectionsRequest) Keyword(keyword string) ApiSearchConnectionsRequest {
	r.keyword = &keyword
	return r
}

// the current latitude of the user
func (r ApiSearchConnectionsRequest) Latitude(latitude float64) ApiSearchConnectionsRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiSearchConnectionsRequest) Longitude(longitude float64) ApiSearchConnectionsRequest {
	r.longitude = &longitude
	return r
}

// This parameter is deprecated.
func (r ApiSearchConnectionsRequest) GameType(gameType string) ApiSearchConnectionsRequest {
	r.gameType = &gameType
	return r
}

// the public application key, if provided only looks for users of that application
func (r ApiSearchConnectionsRequest) AppKey(appKey string) ApiSearchConnectionsRequest {
	r.appKey = &appKey
	return r
}

// This parameter is deprecated.
func (r ApiSearchConnectionsRequest) I(i int32) ApiSearchConnectionsRequest {
	r.i = &i
	return r
}

// This parameter is deprecated.
func (r ApiSearchConnectionsRequest) L(l int32) ApiSearchConnectionsRequest {
	r.l = &l
	return r
}

// the field to sort on
func (r ApiSearchConnectionsRequest) SortField(sortField string) ApiSearchConnectionsRequest {
	r.sortField = &sortField
	return r
}

// whether the search has location or not
func (r ApiSearchConnectionsRequest) HasLocation(hasLocation bool) ApiSearchConnectionsRequest {
	r.hasLocation = &hasLocation
	return r
}

func (r ApiSearchConnectionsRequest) Execute() (*ConnectionListResponse, *http.Response, error) {
	return r.ApiService.SearchConnectionsExecute(r)
}

/*
SearchConnections Search Possible Connections

Search for accounts that the user may not have a connection with.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchConnectionsRequest
*/
func (a *ConnectionAPIService) SearchConnections(ctx context.Context) ApiSearchConnectionsRequest {
	return ApiSearchConnectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConnectionListResponse
func (a *ConnectionAPIService) SearchConnectionsExecute(r ApiSearchConnectionsRequest) (*ConnectionListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionAPIService.SearchConnections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connection/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.returnNulls == nil {
		return localVarReturnValue, nil, reportError("returnNulls is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "returnNulls", r.returnNulls, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.gameType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameType", r.gameType, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.i != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_i", r.i, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	if r.l != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_l", r.l, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.hasLocation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasLocation", r.hasLocation, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
