/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// EventAPIService EventAPI service
type EventAPIService service

type ApiAttendEventRequest struct {
	ctx context.Context
	ApiService *EventAPIService
	deviceId *string
	accountId *int64
	appKey *string
	listingId *int64
	retailerLocationId *int64
	offerLocationId *int64
	transactionId *int64
	status *int32
	latitude *float64
	longitude *float64
}

// The device id (deviceId or accountId required)
func (r ApiAttendEventRequest) DeviceId(deviceId string) ApiAttendEventRequest {
	r.deviceId = &deviceId
	return r
}

// The account id (deviceId or accountId required)
func (r ApiAttendEventRequest) AccountId(accountId int64) ApiAttendEventRequest {
	r.accountId = &accountId
	return r
}

// The application of where to send notifications about the attend action
func (r ApiAttendEventRequest) AppKey(appKey string) ApiAttendEventRequest {
	r.appKey = &appKey
	return r
}

// The scheduled broadcast or marketing experience id
func (r ApiAttendEventRequest) ListingId(listingId int64) ApiAttendEventRequest {
	r.listingId = &listingId
	return r
}

// The retailer location where the event is being held
func (r ApiAttendEventRequest) RetailerLocationId(retailerLocationId int64) ApiAttendEventRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// The actual event being held
func (r ApiAttendEventRequest) OfferLocationId(offerLocationId int64) ApiAttendEventRequest {
	r.offerLocationId = &offerLocationId
	return r
}

// The wallet item to update the status of, if provided then ignore the listingId, retailerLocationId, and the offerLocationId
func (r ApiAttendEventRequest) TransactionId(transactionId int64) ApiAttendEventRequest {
	r.transactionId = &transactionId
	return r
}

// Sets whether the user is: undecided (0), attending (1), attending and checked in (2), or not attending (3)
func (r ApiAttendEventRequest) Status(status int32) ApiAttendEventRequest {
	r.status = &status
	return r
}

// The location of the status update
func (r ApiAttendEventRequest) Latitude(latitude float64) ApiAttendEventRequest {
	r.latitude = &latitude
	return r
}

// The location of the status update
func (r ApiAttendEventRequest) Longitude(longitude float64) ApiAttendEventRequest {
	r.longitude = &longitude
	return r
}

func (r ApiAttendEventRequest) Execute() (*OfferResponse, *http.Response, error) {
	return r.ApiService.AttendEventExecute(r)
}

/*
AttendEvent Attend Event

 Specify whether the user is attending an event at a particular location. This can also be used as a "check-in" action.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAttendEventRequest
*/
func (a *EventAPIService) AttendEvent(ctx context.Context) ApiAttendEventRequest {
	return ApiAttendEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OfferResponse
func (a *EventAPIService) AttendEventExecute(r ApiAttendEventRequest) (*OfferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OfferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventAPIService.AttendEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event/attend"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.listingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listingId", r.listingId, "form", "")
	}
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	if r.offerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationId", r.offerLocationId, "form", "")
	}
	if r.transactionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionId", r.transactionId, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateEventRequest struct {
	ctx context.Context
	ApiService *EventAPIService
	accountId *int64
	title *string
	retailerLocationIds *string
	subTitle *string
	details *string
	categoryIds *string
	filterIds *string
	active *bool
	imageAssetId *int64
	redeemableStart *int64
	redeemableEnd *int64
	metaData *string
}

// The logged in user.
func (r ApiCreateEventRequest) AccountId(accountId int64) ApiCreateEventRequest {
	r.accountId = &accountId
	return r
}

// The event title
func (r ApiCreateEventRequest) Title(title string) ApiCreateEventRequest {
	r.title = &title
	return r
}

// The retailer location to have the event at
func (r ApiCreateEventRequest) RetailerLocationIds(retailerLocationIds string) ApiCreateEventRequest {
	r.retailerLocationIds = &retailerLocationIds
	return r
}

// The event sub title
func (r ApiCreateEventRequest) SubTitle(subTitle string) ApiCreateEventRequest {
	r.subTitle = &subTitle
	return r
}

// The event details
func (r ApiCreateEventRequest) Details(details string) ApiCreateEventRequest {
	r.details = &details
	return r
}

// The categories the associate the event with
func (r ApiCreateEventRequest) CategoryIds(categoryIds string) ApiCreateEventRequest {
	r.categoryIds = &categoryIds
	return r
}

// The filters the associate the event with
func (r ApiCreateEventRequest) FilterIds(filterIds string) ApiCreateEventRequest {
	r.filterIds = &filterIds
	return r
}

// Is this event active
func (r ApiCreateEventRequest) Active(active bool) ApiCreateEventRequest {
	r.active = &active
	return r
}

// The image to show for the event
func (r ApiCreateEventRequest) ImageAssetId(imageAssetId int64) ApiCreateEventRequest {
	r.imageAssetId = &imageAssetId
	return r
}

// The event start date/time
func (r ApiCreateEventRequest) RedeemableStart(redeemableStart int64) ApiCreateEventRequest {
	r.redeemableStart = &redeemableStart
	return r
}

// The event end date/time
func (r ApiCreateEventRequest) RedeemableEnd(redeemableEnd int64) ApiCreateEventRequest {
	r.redeemableEnd = &redeemableEnd
	return r
}

// external custom client defined data
func (r ApiCreateEventRequest) MetaData(metaData string) ApiCreateEventRequest {
	r.metaData = &metaData
	return r
}

func (r ApiCreateEventRequest) Execute() (*OfferResponse, *http.Response, error) {
	return r.ApiService.CreateEventExecute(r)
}

/*
CreateEvent Create Event

Create a private event to share with associates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateEventRequest
*/
func (a *EventAPIService) CreateEvent(ctx context.Context) ApiCreateEventRequest {
	return ApiCreateEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OfferResponse
func (a *EventAPIService) CreateEventExecute(r ApiCreateEventRequest) (*OfferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OfferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventAPIService.CreateEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.retailerLocationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationIds", r.retailerLocationIds, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	if r.subTitle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subTitle", r.subTitle, "form", "")
	}
	if r.details != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "details", r.details, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.filterIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterIds", r.filterIds, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.imageAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId", r.imageAssetId, "form", "")
	}
	if r.redeemableStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemableStart", r.redeemableStart, "form", "")
	}
	if r.redeemableEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemableEnd", r.redeemableEnd, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteEventRequest struct {
	ctx context.Context
	ApiService *EventAPIService
	accountId *int64
	eventId *int64
}

// the id of the logged in user
func (r ApiDeleteEventRequest) AccountId(accountId int64) ApiDeleteEventRequest {
	r.accountId = &accountId
	return r
}

// the id of the event to update
func (r ApiDeleteEventRequest) EventId(eventId int64) ApiDeleteEventRequest {
	r.eventId = &eventId
	return r
}

func (r ApiDeleteEventRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteEventExecute(r)
}

/*
DeleteEvent Delete Event

Delete an event that the user has permissions to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteEventRequest
*/
func (a *EventAPIService) DeleteEvent(ctx context.Context) ApiDeleteEventRequest {
	return ApiDeleteEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *EventAPIService) DeleteEventExecute(r ApiDeleteEventRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventAPIService.DeleteEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.eventId == nil {
		return localVarReturnValue, nil, reportError("eventId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "eventId", r.eventId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventRequest struct {
	ctx context.Context
	ApiService *EventAPIService
	accountId *int64
	eventId *int64
}

// the id of the logged in user
func (r ApiGetEventRequest) AccountId(accountId int64) ApiGetEventRequest {
	r.accountId = &accountId
	return r
}

// The id of the event to return
func (r ApiGetEventRequest) EventId(eventId int64) ApiGetEventRequest {
	r.eventId = &eventId
	return r
}

func (r ApiGetEventRequest) Execute() (*OfferResponse, *http.Response, error) {
	return r.ApiService.GetEventExecute(r)
}

/*
GetEvent Get Event

Get an event.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEventRequest
*/
func (a *EventAPIService) GetEvent(ctx context.Context) ApiGetEventRequest {
	return ApiGetEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OfferResponse
func (a *EventAPIService) GetEventExecute(r ApiGetEventRequest) (*OfferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OfferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventAPIService.GetEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.eventId == nil {
		return localVarReturnValue, nil, reportError("eventId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "eventId", r.eventId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchEventTransactionsRequest struct {
	ctx context.Context
	ApiService *EventAPIService
	deviceId *string
	accountId *int64
	appKey *string
	keyword *string
	retailerId *int64
	retailerLocationId *int64
	excludeRetailerLocationId *int64
	listingId *int64
	offerId *int64
	offerLocationId *int64
	customerAccountIds *string
	affiliatedCategoryIds *string
	startDate *int64
	endDate *int64
	statuses *string
	sortField *string
	descending *bool
	start *int32
	limit *int32
}

// The device id (deviceId or accountId required)
func (r ApiSearchEventTransactionsRequest) DeviceId(deviceId string) ApiSearchEventTransactionsRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiSearchEventTransactionsRequest) AccountId(accountId int64) ApiSearchEventTransactionsRequest {
	r.accountId = &accountId
	return r
}

// The application key
func (r ApiSearchEventTransactionsRequest) AppKey(appKey string) ApiSearchEventTransactionsRequest {
	r.appKey = &appKey
	return r
}

// The keyword to search for
func (r ApiSearchEventTransactionsRequest) Keyword(keyword string) ApiSearchEventTransactionsRequest {
	r.keyword = &keyword
	return r
}

// Filter results for this retailer
func (r ApiSearchEventTransactionsRequest) RetailerId(retailerId int64) ApiSearchEventTransactionsRequest {
	r.retailerId = &retailerId
	return r
}

// Filter results for this retailer location
func (r ApiSearchEventTransactionsRequest) RetailerLocationId(retailerLocationId int64) ApiSearchEventTransactionsRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// Exclude results from this retailer location
func (r ApiSearchEventTransactionsRequest) ExcludeRetailerLocationId(excludeRetailerLocationId int64) ApiSearchEventTransactionsRequest {
	r.excludeRetailerLocationId = &excludeRetailerLocationId
	return r
}

// Filter results for this event listing
func (r ApiSearchEventTransactionsRequest) ListingId(listingId int64) ApiSearchEventTransactionsRequest {
	r.listingId = &listingId
	return r
}

// Filter results for this offer
func (r ApiSearchEventTransactionsRequest) OfferId(offerId int64) ApiSearchEventTransactionsRequest {
	r.offerId = &offerId
	return r
}

// Filter results for this offer location
func (r ApiSearchEventTransactionsRequest) OfferLocationId(offerLocationId int64) ApiSearchEventTransactionsRequest {
	r.offerLocationId = &offerLocationId
	return r
}

// Filter results by accounts
func (r ApiSearchEventTransactionsRequest) CustomerAccountIds(customerAccountIds string) ApiSearchEventTransactionsRequest {
	r.customerAccountIds = &customerAccountIds
	return r
}

// Comma separated list of category ids to determine whether the attendee is affiliated with the category
func (r ApiSearchEventTransactionsRequest) AffiliatedCategoryIds(affiliatedCategoryIds string) ApiSearchEventTransactionsRequest {
	r.affiliatedCategoryIds = &affiliatedCategoryIds
	return r
}

// Filter on attendance starting on or after this date (milliseconds since epoch)
func (r ApiSearchEventTransactionsRequest) StartDate(startDate int64) ApiSearchEventTransactionsRequest {
	r.startDate = &startDate
	return r
}

// Filter on attendance starting on or before this date (milliseconds since epoch)
func (r ApiSearchEventTransactionsRequest) EndDate(endDate int64) ApiSearchEventTransactionsRequest {
	r.endDate = &endDate
	return r
}

// Comma separated list of transaction statuses to filter on
func (r ApiSearchEventTransactionsRequest) Statuses(statuses string) ApiSearchEventTransactionsRequest {
	r.statuses = &statuses
	return r
}

// Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}
func (r ApiSearchEventTransactionsRequest) SortField(sortField string) ApiSearchEventTransactionsRequest {
	r.sortField = &sortField
	return r
}

// Determines whether the results are in descending order
func (r ApiSearchEventTransactionsRequest) Descending(descending bool) ApiSearchEventTransactionsRequest {
	r.descending = &descending
	return r
}

// The start index for pagination
func (r ApiSearchEventTransactionsRequest) Start(start int32) ApiSearchEventTransactionsRequest {
	r.start = &start
	return r
}

// The limit for pagination
func (r ApiSearchEventTransactionsRequest) Limit(limit int32) ApiSearchEventTransactionsRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchEventTransactionsRequest) Execute() ([]EventAttendanceResponse, *http.Response, error) {
	return r.ApiService.SearchEventTransactionsExecute(r)
}

/*
SearchEventTransactions Search Event Attendance

Searches on event type transactions. This can be used to see who is attending an event.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchEventTransactionsRequest
*/
func (a *EventAPIService) SearchEventTransactions(ctx context.Context) ApiSearchEventTransactionsRequest {
	return ApiSearchEventTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []EventAttendanceResponse
func (a *EventAPIService) SearchEventTransactionsExecute(r ApiSearchEventTransactionsRequest) ([]EventAttendanceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []EventAttendanceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventAPIService.SearchEventTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event/attendance/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.retailerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerId", r.retailerId, "form", "")
	}
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	if r.excludeRetailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeRetailerLocationId", r.excludeRetailerLocationId, "form", "")
	}
	if r.listingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listingId", r.listingId, "form", "")
	}
	if r.offerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	}
	if r.offerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationId", r.offerLocationId, "form", "")
	}
	if r.customerAccountIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customerAccountIds", r.customerAccountIds, "form", "")
	}
	if r.affiliatedCategoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "affiliatedCategoryIds", r.affiliatedCategoryIds, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.statuses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", r.statuses, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchEventsRequest struct {
	ctx context.Context
	ApiService *EventAPIService
	accountId *int64
	keyword *string
	activeOnly *bool
	categoryIds *string
	filterIds *string
	offerAudienceIds *string
	transactionAudienceIds *string
	sortField *string
	descending *bool
	startDate *int64
	endDate *int64
	start *int32
	limit *int32
}

// The logged in user.
func (r ApiSearchEventsRequest) AccountId(accountId int64) ApiSearchEventsRequest {
	r.accountId = &accountId
	return r
}

// The keyword used to search
func (r ApiSearchEventsRequest) Keyword(keyword string) ApiSearchEventsRequest {
	r.keyword = &keyword
	return r
}

// Return only active results
func (r ApiSearchEventsRequest) ActiveOnly(activeOnly bool) ApiSearchEventsRequest {
	r.activeOnly = &activeOnly
	return r
}

// the IDs of the categories that this event is associated with
func (r ApiSearchEventsRequest) CategoryIds(categoryIds string) ApiSearchEventsRequest {
	r.categoryIds = &categoryIds
	return r
}

// the IDs of the filters that this event is associated with
func (r ApiSearchEventsRequest) FilterIds(filterIds string) ApiSearchEventsRequest {
	r.filterIds = &filterIds
	return r
}

// Offer audience ids to filter on
func (r ApiSearchEventsRequest) OfferAudienceIds(offerAudienceIds string) ApiSearchEventsRequest {
	r.offerAudienceIds = &offerAudienceIds
	return r
}

// Transaction audience ids to filter on
func (r ApiSearchEventsRequest) TransactionAudienceIds(transactionAudienceIds string) ApiSearchEventsRequest {
	r.transactionAudienceIds = &transactionAudienceIds
	return r
}

// The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY
func (r ApiSearchEventsRequest) SortField(sortField string) ApiSearchEventsRequest {
	r.sortField = &sortField
	return r
}

// The order to return the search results
func (r ApiSearchEventsRequest) Descending(descending bool) ApiSearchEventsRequest {
	r.descending = &descending
	return r
}

// Filter the events to return only those that start on or after the date
func (r ApiSearchEventsRequest) StartDate(startDate int64) ApiSearchEventsRequest {
	r.startDate = &startDate
	return r
}

// Filter the events to return only those that start on or before the date
func (r ApiSearchEventsRequest) EndDate(endDate int64) ApiSearchEventsRequest {
	r.endDate = &endDate
	return r
}

// The record to begin the return set on
func (r ApiSearchEventsRequest) Start(start int32) ApiSearchEventsRequest {
	r.start = &start
	return r
}

// The number of records to return
func (r ApiSearchEventsRequest) Limit(limit int32) ApiSearchEventsRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchEventsRequest) Execute() ([]OfferShortResponse, *http.Response, error) {
	return r.ApiService.SearchEventsExecute(r)
}

/*
SearchEvents Search Events

Searches on events that the account has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchEventsRequest
*/
func (a *EventAPIService) SearchEvents(ctx context.Context) ApiSearchEventsRequest {
	return ApiSearchEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []OfferShortResponse
func (a *EventAPIService) SearchEventsExecute(r ApiSearchEventsRequest) ([]OfferShortResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OfferShortResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventAPIService.SearchEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.filterIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterIds", r.filterIds, "form", "")
	}
	if r.offerAudienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerAudienceIds", r.offerAudienceIds, "form", "")
	}
	if r.transactionAudienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionAudienceIds", r.transactionAudienceIds, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateEventRequest struct {
	ctx context.Context
	ApiService *EventAPIService
	accountId *int64
	eventId *int64
	retailerLocationIds *string
	title *string
	subTitle *string
	details *string
	categoryIds *string
	filterIds *string
	active *bool
	imageAssetId *int64
	redeemableStart *int64
	redeemableEnd *int64
}

// The logged in user.
func (r ApiUpdateEventRequest) AccountId(accountId int64) ApiUpdateEventRequest {
	r.accountId = &accountId
	return r
}

// The id of the event to update
func (r ApiUpdateEventRequest) EventId(eventId int64) ApiUpdateEventRequest {
	r.eventId = &eventId
	return r
}

// The retailer location to have the event at
func (r ApiUpdateEventRequest) RetailerLocationIds(retailerLocationIds string) ApiUpdateEventRequest {
	r.retailerLocationIds = &retailerLocationIds
	return r
}

// The event title
func (r ApiUpdateEventRequest) Title(title string) ApiUpdateEventRequest {
	r.title = &title
	return r
}

// The event sub title
func (r ApiUpdateEventRequest) SubTitle(subTitle string) ApiUpdateEventRequest {
	r.subTitle = &subTitle
	return r
}

// The event details
func (r ApiUpdateEventRequest) Details(details string) ApiUpdateEventRequest {
	r.details = &details
	return r
}

// The categories the associate the event with
func (r ApiUpdateEventRequest) CategoryIds(categoryIds string) ApiUpdateEventRequest {
	r.categoryIds = &categoryIds
	return r
}

// The filters the associate the event with
func (r ApiUpdateEventRequest) FilterIds(filterIds string) ApiUpdateEventRequest {
	r.filterIds = &filterIds
	return r
}

// Is this event active
func (r ApiUpdateEventRequest) Active(active bool) ApiUpdateEventRequest {
	r.active = &active
	return r
}

// The image to show for the event
func (r ApiUpdateEventRequest) ImageAssetId(imageAssetId int64) ApiUpdateEventRequest {
	r.imageAssetId = &imageAssetId
	return r
}

// The event start date/time
func (r ApiUpdateEventRequest) RedeemableStart(redeemableStart int64) ApiUpdateEventRequest {
	r.redeemableStart = &redeemableStart
	return r
}

// The event end date/time
func (r ApiUpdateEventRequest) RedeemableEnd(redeemableEnd int64) ApiUpdateEventRequest {
	r.redeemableEnd = &redeemableEnd
	return r
}

func (r ApiUpdateEventRequest) Execute() (*OfferResponse, *http.Response, error) {
	return r.ApiService.UpdateEventExecute(r)
}

/*
UpdateEvent Update Event

Update a private event to share with associates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateEventRequest
*/
func (a *EventAPIService) UpdateEvent(ctx context.Context) ApiUpdateEventRequest {
	return ApiUpdateEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OfferResponse
func (a *EventAPIService) UpdateEventExecute(r ApiUpdateEventRequest) (*OfferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OfferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventAPIService.UpdateEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/event/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.eventId == nil {
		return localVarReturnValue, nil, reportError("eventId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "eventId", r.eventId, "form", "")
	if r.retailerLocationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationIds", r.retailerLocationIds, "form", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.subTitle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subTitle", r.subTitle, "form", "")
	}
	if r.details != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "details", r.details, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.filterIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterIds", r.filterIds, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.imageAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId", r.imageAssetId, "form", "")
	}
	if r.redeemableStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemableStart", r.redeemableStart, "form", "")
	}
	if r.redeemableEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemableEnd", r.redeemableEnd, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
