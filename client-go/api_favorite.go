/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// FavoriteAPIService FavoriteAPI service
type FavoriteAPIService service

type ApiAddFavoriteRequest struct {
	ctx context.Context
	ApiService *FavoriteAPIService
	favoritableId *int64
	favoritableType *string
	deviceId *string
	accountId *int64
	latitude *float64
	longitude *float64
}

// The ID of the object to favorite {offerId, offerLocationId, retailerLocationId, categoryId}
func (r ApiAddFavoriteRequest) FavoritableId(favoritableId int64) ApiAddFavoriteRequest {
	r.favoritableId = &favoritableId
	return r
}

// The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY, ALBUM}
func (r ApiAddFavoriteRequest) FavoritableType(favoritableType string) ApiAddFavoriteRequest {
	r.favoritableType = &favoritableType
	return r
}

// The unique ID given by the device (deviceId or accountId required)
func (r ApiAddFavoriteRequest) DeviceId(deviceId string) ApiAddFavoriteRequest {
	r.deviceId = &deviceId
	return r
}

// The account ID of the user (deviceId or accountId required)
func (r ApiAddFavoriteRequest) AccountId(accountId int64) ApiAddFavoriteRequest {
	r.accountId = &accountId
	return r
}

// The current latitude of the user
func (r ApiAddFavoriteRequest) Latitude(latitude float64) ApiAddFavoriteRequest {
	r.latitude = &latitude
	return r
}

// The current longitude of the user
func (r ApiAddFavoriteRequest) Longitude(longitude float64) ApiAddFavoriteRequest {
	r.longitude = &longitude
	return r
}

func (r ApiAddFavoriteRequest) Execute() (*WrappedResponse, *http.Response, error) {
	return r.ApiService.AddFavoriteExecute(r)
}

/*
AddFavorite Create Favorite

Adds an offer, offer location, retailer location, or category to your favorites.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddFavoriteRequest
*/
func (a *FavoriteAPIService) AddFavorite(ctx context.Context) ApiAddFavoriteRequest {
	return ApiAddFavoriteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WrappedResponse
func (a *FavoriteAPIService) AddFavoriteExecute(r ApiAddFavoriteRequest) (*WrappedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WrappedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FavoriteAPIService.AddFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/favorite/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.favoritableId == nil {
		return localVarReturnValue, nil, reportError("favoritableId is required and must be specified")
	}
	if r.favoritableType == nil {
		return localVarReturnValue, nil, reportError("favoritableType is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "favoritableId", r.favoritableId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "favoritableType", r.favoritableType, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFavoriteRequest struct {
	ctx context.Context
	ApiService *FavoriteAPIService
	deviceId *string
	accountId *int64
	favoriteId *int64
	favoritableId *int64
	favoritableType *string
}

// The unique ID given by the device (deviceId or accountId required)
func (r ApiDeleteFavoriteRequest) DeviceId(deviceId string) ApiDeleteFavoriteRequest {
	r.deviceId = &deviceId
	return r
}

// The account ID of the user (deviceId or accountId required)
func (r ApiDeleteFavoriteRequest) AccountId(accountId int64) ApiDeleteFavoriteRequest {
	r.accountId = &accountId
	return r
}

// The ID of the favorite reference record (only optional if favoritableId &amp; favoritableType is pass in instead)
func (r ApiDeleteFavoriteRequest) FavoriteId(favoriteId int64) ApiDeleteFavoriteRequest {
	r.favoriteId = &favoriteId
	return r
}

// The ID of the object to un-favorite {offerId, offerLocationId, retailerLocationId, categoryId} (this is required if favoriteId is NOT passed in)
func (r ApiDeleteFavoriteRequest) FavoritableId(favoritableId int64) ApiDeleteFavoriteRequest {
	r.favoritableId = &favoritableId
	return r
}

// The type of the object to un-favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY} (this is required if favoriteId is NOT passed in)
func (r ApiDeleteFavoriteRequest) FavoritableType(favoritableType string) ApiDeleteFavoriteRequest {
	r.favoritableType = &favoritableType
	return r
}

func (r ApiDeleteFavoriteRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteFavoriteExecute(r)
}

/*
DeleteFavorite Delete Favorite

Removes a favorited item from the user's favorites list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteFavoriteRequest
*/
func (a *FavoriteAPIService) DeleteFavorite(ctx context.Context) ApiDeleteFavoriteRequest {
	return ApiDeleteFavoriteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *FavoriteAPIService) DeleteFavoriteExecute(r ApiDeleteFavoriteRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FavoriteAPIService.DeleteFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/favorite/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.favoriteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "favoriteId", r.favoriteId, "form", "")
	}
	if r.favoritableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "favoritableId", r.favoritableId, "form", "")
	}
	if r.favoritableType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "favoritableType", r.favoritableType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFavoriteRequest struct {
	ctx context.Context
	ApiService *FavoriteAPIService
	favoriteId *int64
	deviceId *string
	accountId *int64
	latitude *float64
	longitude *float64
}

// The ID of the favorite reference record
func (r ApiGetFavoriteRequest) FavoriteId(favoriteId int64) ApiGetFavoriteRequest {
	r.favoriteId = &favoriteId
	return r
}

// The unique ID given by the device (deviceId or accountId required)
func (r ApiGetFavoriteRequest) DeviceId(deviceId string) ApiGetFavoriteRequest {
	r.deviceId = &deviceId
	return r
}

// The account ID of the user (deviceId or accountId required)
func (r ApiGetFavoriteRequest) AccountId(accountId int64) ApiGetFavoriteRequest {
	r.accountId = &accountId
	return r
}

// The current latitude of the user
func (r ApiGetFavoriteRequest) Latitude(latitude float64) ApiGetFavoriteRequest {
	r.latitude = &latitude
	return r
}

// The current longitude of the user
func (r ApiGetFavoriteRequest) Longitude(longitude float64) ApiGetFavoriteRequest {
	r.longitude = &longitude
	return r
}

func (r ApiGetFavoriteRequest) Execute() (*WrappedResponse, *http.Response, error) {
	return r.ApiService.GetFavoriteExecute(r)
}

/*
GetFavorite Get Favorite

Retrieves a single favorited item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFavoriteRequest
*/
func (a *FavoriteAPIService) GetFavorite(ctx context.Context) ApiGetFavoriteRequest {
	return ApiGetFavoriteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WrappedResponse
func (a *FavoriteAPIService) GetFavoriteExecute(r ApiGetFavoriteRequest) (*WrappedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WrappedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FavoriteAPIService.GetFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/favorite/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.favoriteId == nil {
		return localVarReturnValue, nil, reportError("favoriteId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "favoriteId", r.favoriteId, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchFavoritesRequest struct {
	ctx context.Context
	ApiService *FavoriteAPIService
	favoritableType *string
	sortField *string
	descending *bool
	start *int32
	limit *int32
	activeOnly *bool
	returnFullResponse *bool
	deviceId *string
	accountId *int64
	connectionAccountId *int64
	secondaryType *string
	keyword *string
	latitude *float64
	longitude *float64
}

// The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY}
func (r ApiSearchFavoritesRequest) FavoritableType(favoritableType string) ApiSearchFavoritesRequest {
	r.favoritableType = &favoritableType
	return r
}

// Determines what to sort the results by {CREATED, UPDATED, DISPLAY}
func (r ApiSearchFavoritesRequest) SortField(sortField string) ApiSearchFavoritesRequest {
	r.sortField = &sortField
	return r
}

// Determines whether the results are in descending order
func (r ApiSearchFavoritesRequest) Descending(descending bool) ApiSearchFavoritesRequest {
	r.descending = &descending
	return r
}

// The start index for pagination
func (r ApiSearchFavoritesRequest) Start(start int32) ApiSearchFavoritesRequest {
	r.start = &start
	return r
}

// The limit for pagination (there is a hard limit of 1000)
func (r ApiSearchFavoritesRequest) Limit(limit int32) ApiSearchFavoritesRequest {
	r.limit = &limit
	return r
}

// Determines whether to only return active favorites
func (r ApiSearchFavoritesRequest) ActiveOnly(activeOnly bool) ApiSearchFavoritesRequest {
	r.activeOnly = &activeOnly
	return r
}

// Determines whether to return a detailed version of the response list
func (r ApiSearchFavoritesRequest) ReturnFullResponse(returnFullResponse bool) ApiSearchFavoritesRequest {
	r.returnFullResponse = &returnFullResponse
	return r
}

// The unique ID given by the device (deviceId or accountId required)
func (r ApiSearchFavoritesRequest) DeviceId(deviceId string) ApiSearchFavoritesRequest {
	r.deviceId = &deviceId
	return r
}

// The account ID of the user (deviceId or accountId required)
func (r ApiSearchFavoritesRequest) AccountId(accountId int64) ApiSearchFavoritesRequest {
	r.accountId = &accountId
	return r
}

// The ID of an account the user would like to view favorites for
func (r ApiSearchFavoritesRequest) ConnectionAccountId(connectionAccountId int64) ApiSearchFavoritesRequest {
	r.connectionAccountId = &connectionAccountId
	return r
}

// 
func (r ApiSearchFavoritesRequest) SecondaryType(secondaryType string) ApiSearchFavoritesRequest {
	r.secondaryType = &secondaryType
	return r
}

// The keyword to search for
func (r ApiSearchFavoritesRequest) Keyword(keyword string) ApiSearchFavoritesRequest {
	r.keyword = &keyword
	return r
}

// The current latitude of the user
func (r ApiSearchFavoritesRequest) Latitude(latitude float64) ApiSearchFavoritesRequest {
	r.latitude = &latitude
	return r
}

// The current longitude of the user
func (r ApiSearchFavoritesRequest) Longitude(longitude float64) ApiSearchFavoritesRequest {
	r.longitude = &longitude
	return r
}

func (r ApiSearchFavoritesRequest) Execute() (*SearchResponse, *http.Response, error) {
	return r.ApiService.SearchFavoritesExecute(r)
}

/*
SearchFavorites Search Favorites

Searches on the user's favorites.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchFavoritesRequest
*/
func (a *FavoriteAPIService) SearchFavorites(ctx context.Context) ApiSearchFavoritesRequest {
	return ApiSearchFavoritesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchResponse
func (a *FavoriteAPIService) SearchFavoritesExecute(r ApiSearchFavoritesRequest) (*SearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FavoriteAPIService.SearchFavorites")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/favorite/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.favoritableType == nil {
		return localVarReturnValue, nil, reportError("favoritableType is required and must be specified")
	}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}
	if r.descending == nil {
		return localVarReturnValue, nil, reportError("descending is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.activeOnly == nil {
		return localVarReturnValue, nil, reportError("activeOnly is required and must be specified")
	}
	if r.returnFullResponse == nil {
		return localVarReturnValue, nil, reportError("returnFullResponse is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.connectionAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountId", r.connectionAccountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "favoritableType", r.favoritableType, "form", "")
	if r.secondaryType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secondaryType", r.secondaryType, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "returnFullResponse", r.returnFullResponse, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWhoHasFavoritedRequest struct {
	ctx context.Context
	ApiService *FavoriteAPIService
	favoritableId *int64
	favoritableType *string
	start *int32
	limit *int32
	deviceId *string
	accountId *int64
	latitude *float64
	longitude *float64
	keyword *string
}

// The ID of the favoritableType to search on
func (r ApiWhoHasFavoritedRequest) FavoritableId(favoritableId int64) ApiWhoHasFavoritedRequest {
	r.favoritableId = &favoritableId
	return r
}

// The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY}
func (r ApiWhoHasFavoritedRequest) FavoritableType(favoritableType string) ApiWhoHasFavoritedRequest {
	r.favoritableType = &favoritableType
	return r
}

// The start index for pagination
func (r ApiWhoHasFavoritedRequest) Start(start int32) ApiWhoHasFavoritedRequest {
	r.start = &start
	return r
}

// The limit for pagination
func (r ApiWhoHasFavoritedRequest) Limit(limit int32) ApiWhoHasFavoritedRequest {
	r.limit = &limit
	return r
}

// The unique ID given by the device (deviceId or accountId required)
func (r ApiWhoHasFavoritedRequest) DeviceId(deviceId string) ApiWhoHasFavoritedRequest {
	r.deviceId = &deviceId
	return r
}

// The account ID of the user (deviceId or accountId required)
func (r ApiWhoHasFavoritedRequest) AccountId(accountId int64) ApiWhoHasFavoritedRequest {
	r.accountId = &accountId
	return r
}

// The current latitude of the user
func (r ApiWhoHasFavoritedRequest) Latitude(latitude float64) ApiWhoHasFavoritedRequest {
	r.latitude = &latitude
	return r
}

// The current longitude of the user
func (r ApiWhoHasFavoritedRequest) Longitude(longitude float64) ApiWhoHasFavoritedRequest {
	r.longitude = &longitude
	return r
}

// The keyword to limit that account list
func (r ApiWhoHasFavoritedRequest) Keyword(keyword string) ApiWhoHasFavoritedRequest {
	r.keyword = &keyword
	return r
}

func (r ApiWhoHasFavoritedRequest) Execute() ([]AccountResponse, *http.Response, error) {
	return r.ApiService.WhoHasFavoritedExecute(r)
}

/*
WhoHasFavorited Who has Favorited

Searches for everyone that has favorited an item

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWhoHasFavoritedRequest
*/
func (a *FavoriteAPIService) WhoHasFavorited(ctx context.Context) ApiWhoHasFavoritedRequest {
	return ApiWhoHasFavoritedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AccountResponse
func (a *FavoriteAPIService) WhoHasFavoritedExecute(r ApiWhoHasFavoritedRequest) ([]AccountResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AccountResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FavoriteAPIService.WhoHasFavorited")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/favorite/whois"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.favoritableId == nil {
		return localVarReturnValue, nil, reportError("favoritableId is required and must be specified")
	}
	if r.favoritableType == nil {
		return localVarReturnValue, nil, reportError("favoritableType is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "favoritableId", r.favoritableId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "favoritableType", r.favoritableType, "form", "")
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
