/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// GameLevelAPIService GameLevelAPI service
type GameLevelAPIService service

type ApiCreateGameLevelRequest struct {
	ctx context.Context
	ApiService *GameLevelAPIService
	accountId *int64
	name *string
	gameData *string
	gameDataSuffix *string
	appKey *string
	description *string
	difficulty *string
	appVersion *string
	assetImageId *int64
	assetIconId *int64
	visibility *string
	friendGroup *bool
	connectionIds *string
	connectionGroupIds *string
	balance *float64
	active *bool
	allocateTickets *bool
	ticketCount *int64
	ticketType *string
	points *int64
	tutorialTitle *string
	tutorialMessage *string
	tutorialAlignment *string
	tutorialImageAssetId *int64
	offerId *int64
	metaData *string
}

// The logged in user.
func (r ApiCreateGameLevelRequest) AccountId(accountId int64) ApiCreateGameLevelRequest {
	r.accountId = &accountId
	return r
}

// The name of the level.
func (r ApiCreateGameLevelRequest) Name(name string) ApiCreateGameLevelRequest {
	r.name = &name
	return r
}

// The game level data: xml, json, or other text based format.
func (r ApiCreateGameLevelRequest) GameData(gameData string) ApiCreateGameLevelRequest {
	r.gameData = &gameData
	return r
}

// The game level data format type.
func (r ApiCreateGameLevelRequest) GameDataSuffix(gameDataSuffix string) ApiCreateGameLevelRequest {
	r.gameDataSuffix = &gameDataSuffix
	return r
}

// The game application key to save the level for.
func (r ApiCreateGameLevelRequest) AppKey(appKey string) ApiCreateGameLevelRequest {
	r.appKey = &appKey
	return r
}

// The description of the level.
func (r ApiCreateGameLevelRequest) Description(description string) ApiCreateGameLevelRequest {
	r.description = &description
	return r
}

// The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD.
func (r ApiCreateGameLevelRequest) Difficulty(difficulty string) ApiCreateGameLevelRequest {
	r.difficulty = &difficulty
	return r
}

// The version number of the application required to correctly load/play the level.
func (r ApiCreateGameLevelRequest) AppVersion(appVersion string) ApiCreateGameLevelRequest {
	r.appVersion = &appVersion
	return r
}

// The asset Id of the level image.
func (r ApiCreateGameLevelRequest) AssetImageId(assetImageId int64) ApiCreateGameLevelRequest {
	r.assetImageId = &assetImageId
	return r
}

// The asset Id of the level icon.
func (r ApiCreateGameLevelRequest) AssetIconId(assetIconId int64) ApiCreateGameLevelRequest {
	r.assetIconId = &assetIconId
	return r
}

// Is the level visible to others, possible values are: PUBLIC, PRIVATE.
func (r ApiCreateGameLevelRequest) Visibility(visibility string) ApiCreateGameLevelRequest {
	r.visibility = &visibility
	return r
}

// Make the level be readable by all friends.
func (r ApiCreateGameLevelRequest) FriendGroup(friendGroup bool) ApiCreateGameLevelRequest {
	r.friendGroup = &friendGroup
	return r
}

// Make the level be readable by connections in this list.
func (r ApiCreateGameLevelRequest) ConnectionIds(connectionIds string) ApiCreateGameLevelRequest {
	r.connectionIds = &connectionIds
	return r
}

// Make the level be readable by connection groups in this list.
func (r ApiCreateGameLevelRequest) ConnectionGroupIds(connectionGroupIds string) ApiCreateGameLevelRequest {
	r.connectionGroupIds = &connectionGroupIds
	return r
}

// Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.
func (r ApiCreateGameLevelRequest) Balance(balance float64) ApiCreateGameLevelRequest {
	r.balance = &balance
	return r
}

// If true set the game level as active. Default is false.
func (r ApiCreateGameLevelRequest) Active(active bool) ApiCreateGameLevelRequest {
	r.active = &active
	return r
}

// If true then scoring will give tickets. Default is false.
func (r ApiCreateGameLevelRequest) AllocateTickets(allocateTickets bool) ApiCreateGameLevelRequest {
	r.allocateTickets = &allocateTickets
	return r
}

// The number of tickets to reward
func (r ApiCreateGameLevelRequest) TicketCount(ticketCount int64) ApiCreateGameLevelRequest {
	r.ticketCount = &ticketCount
	return r
}

// The type of ticket to reward, null means default type
func (r ApiCreateGameLevelRequest) TicketType(ticketType string) ApiCreateGameLevelRequest {
	r.ticketType = &ticketType
	return r
}

// The number of points to award for completing a level
func (r ApiCreateGameLevelRequest) Points(points int64) ApiCreateGameLevelRequest {
	r.points = &points
	return r
}

// Title of the tutorial.
func (r ApiCreateGameLevelRequest) TutorialTitle(tutorialTitle string) ApiCreateGameLevelRequest {
	r.tutorialTitle = &tutorialTitle
	return r
}

// Message of the tutotrial.
func (r ApiCreateGameLevelRequest) TutorialMessage(tutorialMessage string) ApiCreateGameLevelRequest {
	r.tutorialMessage = &tutorialMessage
	return r
}

// Alignment of the tutorial image. Default to NONE. Possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY
func (r ApiCreateGameLevelRequest) TutorialAlignment(tutorialAlignment string) ApiCreateGameLevelRequest {
	r.tutorialAlignment = &tutorialAlignment
	return r
}

// Asset id of the tutorial image.
func (r ApiCreateGameLevelRequest) TutorialImageAssetId(tutorialImageAssetId int64) ApiCreateGameLevelRequest {
	r.tutorialImageAssetId = &tutorialImageAssetId
	return r
}

// id of the offer
func (r ApiCreateGameLevelRequest) OfferId(offerId int64) ApiCreateGameLevelRequest {
	r.offerId = &offerId
	return r
}

// external custom client defined data
func (r ApiCreateGameLevelRequest) MetaData(metaData string) ApiCreateGameLevelRequest {
	r.metaData = &metaData
	return r
}

func (r ApiCreateGameLevelRequest) Execute() (*GameLevelResponse, *http.Response, error) {
	return r.ApiService.CreateGameLevelExecute(r)
}

/*
CreateGameLevel Create Game Level

Create a game level. Currently does NOT support game objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGameLevelRequest
*/
func (a *GameLevelAPIService) CreateGameLevel(ctx context.Context) ApiCreateGameLevelRequest {
	return ApiCreateGameLevelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GameLevelResponse
func (a *GameLevelAPIService) CreateGameLevelExecute(r ApiCreateGameLevelRequest) (*GameLevelResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GameLevelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameLevelAPIService.CreateGameLevel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/level/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.gameData == nil {
		return localVarReturnValue, nil, reportError("gameData is required and must be specified")
	}
	if r.gameDataSuffix == nil {
		return localVarReturnValue, nil, reportError("gameDataSuffix is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.difficulty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "difficulty", r.difficulty, "form", "")
	}
	if r.appVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appVersion", r.appVersion, "form", "")
	}
	if r.assetImageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetImageId", r.assetImageId, "form", "")
	}
	if r.assetIconId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetIconId", r.assetIconId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "gameData", r.gameData, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "gameDataSuffix", r.gameDataSuffix, "form", "")
	if r.visibility != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibility", r.visibility, "form", "")
	}
	if r.friendGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friendGroup", r.friendGroup, "form", "")
	}
	if r.connectionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionIds", r.connectionIds, "form", "")
	}
	if r.connectionGroupIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionGroupIds", r.connectionGroupIds, "form", "")
	}
	if r.balance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balance", r.balance, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.allocateTickets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allocateTickets", r.allocateTickets, "form", "")
	}
	if r.ticketCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketCount", r.ticketCount, "form", "")
	}
	if r.ticketType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketType", r.ticketType, "form", "")
	}
	if r.points != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "points", r.points, "form", "")
	}
	if r.tutorialTitle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tutorialTitle", r.tutorialTitle, "form", "")
	}
	if r.tutorialMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tutorialMessage", r.tutorialMessage, "form", "")
	}
	if r.tutorialAlignment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tutorialAlignment", r.tutorialAlignment, "form", "")
	}
	if r.tutorialImageAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tutorialImageAssetId", r.tutorialImageAssetId, "form", "")
	}
	if r.offerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteGameLevelRequest struct {
	ctx context.Context
	ApiService *GameLevelAPIService
	accountId *int64
	levelId *int64
}

// The logged in user.
func (r ApiDeleteGameLevelRequest) AccountId(accountId int64) ApiDeleteGameLevelRequest {
	r.accountId = &accountId
	return r
}

// The id of the level to return.
func (r ApiDeleteGameLevelRequest) LevelId(levelId int64) ApiDeleteGameLevelRequest {
	r.levelId = &levelId
	return r
}

func (r ApiDeleteGameLevelRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteGameLevelExecute(r)
}

/*
DeleteGameLevel Delete Game Level

Delete a game level. The level and account must be valid and have the appropirate permissions to view the content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteGameLevelRequest
*/
func (a *GameLevelAPIService) DeleteGameLevel(ctx context.Context) ApiDeleteGameLevelRequest {
	return ApiDeleteGameLevelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *GameLevelAPIService) DeleteGameLevelExecute(r ApiDeleteGameLevelRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameLevelAPIService.DeleteGameLevel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/level/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.levelId == nil {
		return localVarReturnValue, nil, reportError("levelId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "levelId", r.levelId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGameLevelRequest struct {
	ctx context.Context
	ApiService *GameLevelAPIService
	accountId *int64
	levelId *int64
	includeGameData *bool
}

// The logged in user.
func (r ApiGetGameLevelRequest) AccountId(accountId int64) ApiGetGameLevelRequest {
	r.accountId = &accountId
	return r
}

// The id of the level to return.
func (r ApiGetGameLevelRequest) LevelId(levelId int64) ApiGetGameLevelRequest {
	r.levelId = &levelId
	return r
}

// If true include the game level data, otherwise don&#39;t. default is false.
func (r ApiGetGameLevelRequest) IncludeGameData(includeGameData bool) ApiGetGameLevelRequest {
	r.includeGameData = &includeGameData
	return r
}

func (r ApiGetGameLevelRequest) Execute() (*GameLevelResponse, *http.Response, error) {
	return r.ApiService.GetGameLevelExecute(r)
}

/*
GetGameLevel Get Game Level

Get a game level. The level and account must be valid and have the appropirate permissions to view the content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGameLevelRequest
*/
func (a *GameLevelAPIService) GetGameLevel(ctx context.Context) ApiGetGameLevelRequest {
	return ApiGetGameLevelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GameLevelResponse
func (a *GameLevelAPIService) GetGameLevelExecute(r ApiGetGameLevelRequest) (*GameLevelResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GameLevelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameLevelAPIService.GetGameLevel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/level/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.levelId == nil {
		return localVarReturnValue, nil, reportError("levelId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "levelId", r.levelId, "form", "")
	if r.includeGameData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGameData", r.includeGameData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGameLevelsByApplicationRequest struct {
	ctx context.Context
	ApiService *GameLevelAPIService
	accountId *int64
	appKey *string
	keyword *string
	sortField *string
	descending *bool
	start *int32
	limit *int32
	appVersion *string
	includeGameData *bool
	filters *string
}

// The logged in user.
func (r ApiGetGameLevelsByApplicationRequest) AccountId(accountId int64) ApiGetGameLevelsByApplicationRequest {
	r.accountId = &accountId
	return r
}

// the application key
func (r ApiGetGameLevelsByApplicationRequest) AppKey(appKey string) ApiGetGameLevelsByApplicationRequest {
	r.appKey = &appKey
	return r
}

// Match the keyword to the owner name or level name.
func (r ApiGetGameLevelsByApplicationRequest) Keyword(keyword string) ApiGetGameLevelsByApplicationRequest {
	r.keyword = &keyword
	return r
}

// what field to sort on
func (r ApiGetGameLevelsByApplicationRequest) SortField(sortField string) ApiGetGameLevelsByApplicationRequest {
	r.sortField = &sortField
	return r
}

// whether to return levels in ascending or descending order
func (r ApiGetGameLevelsByApplicationRequest) Descending(descending bool) ApiGetGameLevelsByApplicationRequest {
	r.descending = &descending
	return r
}

// Start the result set at some index.
func (r ApiGetGameLevelsByApplicationRequest) Start(start int32) ApiGetGameLevelsByApplicationRequest {
	r.start = &start
	return r
}

// Limit the result to some number.
func (r ApiGetGameLevelsByApplicationRequest) Limit(limit int32) ApiGetGameLevelsByApplicationRequest {
	r.limit = &limit
	return r
}

// The maximum version of the level to return.
func (r ApiGetGameLevelsByApplicationRequest) AppVersion(appVersion string) ApiGetGameLevelsByApplicationRequest {
	r.appVersion = &appVersion
	return r
}

// If true include the game level data, otherwise don&#39;t. default is false.
func (r ApiGetGameLevelsByApplicationRequest) IncludeGameData(includeGameData bool) ApiGetGameLevelsByApplicationRequest {
	r.includeGameData = &includeGameData
	return r
}

// 
func (r ApiGetGameLevelsByApplicationRequest) Filters(filters string) ApiGetGameLevelsByApplicationRequest {
	r.filters = &filters
	return r
}

func (r ApiGetGameLevelsByApplicationRequest) Execute() (*GameLevelListResponse, *http.Response, error) {
	return r.ApiService.GetGameLevelsByApplicationExecute(r)
}

/*
GetGameLevelsByApplication Search Game Levels

Get a list of levels for an application, just those the account has permissions to view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGameLevelsByApplicationRequest
*/
func (a *GameLevelAPIService) GetGameLevelsByApplication(ctx context.Context) ApiGetGameLevelsByApplicationRequest {
	return ApiGetGameLevelsByApplicationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GameLevelListResponse
func (a *GameLevelAPIService) GetGameLevelsByApplicationExecute(r ApiGetGameLevelsByApplicationRequest) (*GameLevelListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GameLevelListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameLevelAPIService.GetGameLevelsByApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/level/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.appVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appVersion", r.appVersion, "form", "")
	}
	if r.includeGameData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGameData", r.includeGameData, "form", "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters", r.filters, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGameLevelsByBillableEntityRequest struct {
	ctx context.Context
	ApiService *GameLevelAPIService
	accountId *int64
	appKey *string
	keyword *string
	sortField *string
	descending *bool
	activeOnly *bool
	start *int64
	limit *int64
}

// The account id of the user
func (r ApiGetGameLevelsByBillableEntityRequest) AccountId(accountId int64) ApiGetGameLevelsByBillableEntityRequest {
	r.accountId = &accountId
	return r
}

// the application key
func (r ApiGetGameLevelsByBillableEntityRequest) AppKey(appKey string) ApiGetGameLevelsByBillableEntityRequest {
	r.appKey = &appKey
	return r
}

// The keyword used to search
func (r ApiGetGameLevelsByBillableEntityRequest) Keyword(keyword string) ApiGetGameLevelsByBillableEntityRequest {
	r.keyword = &keyword
	return r
}

// The column to sort the search on
func (r ApiGetGameLevelsByBillableEntityRequest) SortField(sortField string) ApiGetGameLevelsByBillableEntityRequest {
	r.sortField = &sortField
	return r
}

// The order to return the search results
func (r ApiGetGameLevelsByBillableEntityRequest) Descending(descending bool) ApiGetGameLevelsByBillableEntityRequest {
	r.descending = &descending
	return r
}

// Return only active results
func (r ApiGetGameLevelsByBillableEntityRequest) ActiveOnly(activeOnly bool) ApiGetGameLevelsByBillableEntityRequest {
	r.activeOnly = &activeOnly
	return r
}

// The record to begin the return set on
func (r ApiGetGameLevelsByBillableEntityRequest) Start(start int64) ApiGetGameLevelsByBillableEntityRequest {
	r.start = &start
	return r
}

// The number of records to return
func (r ApiGetGameLevelsByBillableEntityRequest) Limit(limit int64) ApiGetGameLevelsByBillableEntityRequest {
	r.limit = &limit
	return r
}

func (r ApiGetGameLevelsByBillableEntityRequest) Execute() (*GameLevelResponse, *http.Response, error) {
	return r.ApiService.GetGameLevelsByBillableEntityExecute(r)
}

/*
GetGameLevelsByBillableEntity Search Game Level by Billable Entity

Searches on game levels that the logged in user has access to. A user would have access if the creator of the game level is managed under the same BillableEntity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGameLevelsByBillableEntityRequest
*/
func (a *GameLevelAPIService) GetGameLevelsByBillableEntity(ctx context.Context) ApiGetGameLevelsByBillableEntityRequest {
	return ApiGetGameLevelsByBillableEntityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GameLevelResponse
func (a *GameLevelAPIService) GetGameLevelsByBillableEntityExecute(r ApiGetGameLevelsByBillableEntityRequest) (*GameLevelResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GameLevelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameLevelAPIService.GetGameLevelsByBillableEntity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/level/searchByBillableEntity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQuestionsInLevelRequest struct {
	ctx context.Context
	ApiService *GameLevelAPIService
	levelId *int64
	accountId *int64
}

// the id of the level to get questions from
func (r ApiGetQuestionsInLevelRequest) LevelId(levelId int64) ApiGetQuestionsInLevelRequest {
	r.levelId = &levelId
	return r
}

// the id of the logged in user
func (r ApiGetQuestionsInLevelRequest) AccountId(accountId int64) ApiGetQuestionsInLevelRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetQuestionsInLevelRequest) Execute() (*QuestionResponse, *http.Response, error) {
	return r.ApiService.GetQuestionsInLevelExecute(r)
}

/*
GetQuestionsInLevel Get Level Questions

Get questions within a level.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetQuestionsInLevelRequest
*/
func (a *GameLevelAPIService) GetQuestionsInLevel(ctx context.Context) ApiGetQuestionsInLevelRequest {
	return ApiGetQuestionsInLevelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuestionResponse
func (a *GameLevelAPIService) GetQuestionsInLevelExecute(r ApiGetQuestionsInLevelRequest) (*QuestionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuestionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameLevelAPIService.GetQuestionsInLevel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/level/questions/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.levelId == nil {
		return localVarReturnValue, nil, reportError("levelId is required and must be specified")
	}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "levelId", r.levelId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWordsInLevelRequest struct {
	ctx context.Context
	ApiService *GameLevelAPIService
	levelId *int64
	accountId *int64
}

// the id of the level to get words for
func (r ApiGetWordsInLevelRequest) LevelId(levelId int64) ApiGetWordsInLevelRequest {
	r.levelId = &levelId
	return r
}

// the id of the logged in user
func (r ApiGetWordsInLevelRequest) AccountId(accountId int64) ApiGetWordsInLevelRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetWordsInLevelRequest) Execute() (*WordzWordResponse, *http.Response, error) {
	return r.ApiService.GetWordsInLevelExecute(r)
}

/*
GetWordsInLevel Get Level Words

Get words within a level.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetWordsInLevelRequest
*/
func (a *GameLevelAPIService) GetWordsInLevel(ctx context.Context) ApiGetWordsInLevelRequest {
	return ApiGetWordsInLevelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WordzWordResponse
func (a *GameLevelAPIService) GetWordsInLevelExecute(r ApiGetWordsInLevelRequest) (*WordzWordResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WordzWordResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameLevelAPIService.GetWordsInLevel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/level/words/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.levelId == nil {
		return localVarReturnValue, nil, reportError("levelId is required and must be specified")
	}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "levelId", r.levelId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGameLevelRequest struct {
	ctx context.Context
	ApiService *GameLevelAPIService
	accountId *int64
	levelId *int64
	appKey *string
	name *string
	description *string
	difficulty *string
	appVersion *string
	assetImageId *int64
	assetIconId *int64
	gameData *string
	gameDataSuffix *string
	visibility *string
	friendGroup *bool
	connectionIds *string
	connectionGroupIds *string
	balance *float64
	active *bool
	allocateTickets *bool
	ticketCount *int64
	ticketType *string
	points *int64
	tutorialTitle *string
	tutorialMessage *string
	tutorialAlignment *string
	tutorialImageAssetId *int64
	offerId *int64
	metaData *string
}

// The logged in user.
func (r ApiUpdateGameLevelRequest) AccountId(accountId int64) ApiUpdateGameLevelRequest {
	r.accountId = &accountId
	return r
}

// If update then include the level Id.
func (r ApiUpdateGameLevelRequest) LevelId(levelId int64) ApiUpdateGameLevelRequest {
	r.levelId = &levelId
	return r
}

// The game application key to save the level for.
func (r ApiUpdateGameLevelRequest) AppKey(appKey string) ApiUpdateGameLevelRequest {
	r.appKey = &appKey
	return r
}

// The name of the level.
func (r ApiUpdateGameLevelRequest) Name(name string) ApiUpdateGameLevelRequest {
	r.name = &name
	return r
}

// The description of the level.
func (r ApiUpdateGameLevelRequest) Description(description string) ApiUpdateGameLevelRequest {
	r.description = &description
	return r
}

// The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD.
func (r ApiUpdateGameLevelRequest) Difficulty(difficulty string) ApiUpdateGameLevelRequest {
	r.difficulty = &difficulty
	return r
}

// The version number of the applicatuion required to correctly load/play the level.
func (r ApiUpdateGameLevelRequest) AppVersion(appVersion string) ApiUpdateGameLevelRequest {
	r.appVersion = &appVersion
	return r
}

// The asset Id of the level image.
func (r ApiUpdateGameLevelRequest) AssetImageId(assetImageId int64) ApiUpdateGameLevelRequest {
	r.assetImageId = &assetImageId
	return r
}

// The asset Id of the level icon.
func (r ApiUpdateGameLevelRequest) AssetIconId(assetIconId int64) ApiUpdateGameLevelRequest {
	r.assetIconId = &assetIconId
	return r
}

// The game level data: xml, json, or other texted based format.
func (r ApiUpdateGameLevelRequest) GameData(gameData string) ApiUpdateGameLevelRequest {
	r.gameData = &gameData
	return r
}

// The game level data format type.
func (r ApiUpdateGameLevelRequest) GameDataSuffix(gameDataSuffix string) ApiUpdateGameLevelRequest {
	r.gameDataSuffix = &gameDataSuffix
	return r
}

// Is the level visible to others, possible values are: PUBLIC, PRIVATE.
func (r ApiUpdateGameLevelRequest) Visibility(visibility string) ApiUpdateGameLevelRequest {
	r.visibility = &visibility
	return r
}

// Make the level be readable by all friends.
func (r ApiUpdateGameLevelRequest) FriendGroup(friendGroup bool) ApiUpdateGameLevelRequest {
	r.friendGroup = &friendGroup
	return r
}

// Make the level be readable by connections in this list.
func (r ApiUpdateGameLevelRequest) ConnectionIds(connectionIds string) ApiUpdateGameLevelRequest {
	r.connectionIds = &connectionIds
	return r
}

// Make the level be readable by connection groups in this list.
func (r ApiUpdateGameLevelRequest) ConnectionGroupIds(connectionGroupIds string) ApiUpdateGameLevelRequest {
	r.connectionGroupIds = &connectionGroupIds
	return r
}

// Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.
func (r ApiUpdateGameLevelRequest) Balance(balance float64) ApiUpdateGameLevelRequest {
	r.balance = &balance
	return r
}

// If true set the game level as active.
func (r ApiUpdateGameLevelRequest) Active(active bool) ApiUpdateGameLevelRequest {
	r.active = &active
	return r
}

// If true then scoring will give tickets.
func (r ApiUpdateGameLevelRequest) AllocateTickets(allocateTickets bool) ApiUpdateGameLevelRequest {
	r.allocateTickets = &allocateTickets
	return r
}

// The number of tickets to reward
func (r ApiUpdateGameLevelRequest) TicketCount(ticketCount int64) ApiUpdateGameLevelRequest {
	r.ticketCount = &ticketCount
	return r
}

// The type of ticket to reward, null means default type
func (r ApiUpdateGameLevelRequest) TicketType(ticketType string) ApiUpdateGameLevelRequest {
	r.ticketType = &ticketType
	return r
}

// The number of points to award for completing a level
func (r ApiUpdateGameLevelRequest) Points(points int64) ApiUpdateGameLevelRequest {
	r.points = &points
	return r
}

// Title of the tutorial.
func (r ApiUpdateGameLevelRequest) TutorialTitle(tutorialTitle string) ApiUpdateGameLevelRequest {
	r.tutorialTitle = &tutorialTitle
	return r
}

// Message of the tutorial.
func (r ApiUpdateGameLevelRequest) TutorialMessage(tutorialMessage string) ApiUpdateGameLevelRequest {
	r.tutorialMessage = &tutorialMessage
	return r
}

// Alignment of the tutorial image, possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY
func (r ApiUpdateGameLevelRequest) TutorialAlignment(tutorialAlignment string) ApiUpdateGameLevelRequest {
	r.tutorialAlignment = &tutorialAlignment
	return r
}

// Asset id of the tutorial image.
func (r ApiUpdateGameLevelRequest) TutorialImageAssetId(tutorialImageAssetId int64) ApiUpdateGameLevelRequest {
	r.tutorialImageAssetId = &tutorialImageAssetId
	return r
}

// 
func (r ApiUpdateGameLevelRequest) OfferId(offerId int64) ApiUpdateGameLevelRequest {
	r.offerId = &offerId
	return r
}

// external custom client defined data
func (r ApiUpdateGameLevelRequest) MetaData(metaData string) ApiUpdateGameLevelRequest {
	r.metaData = &metaData
	return r
}

func (r ApiUpdateGameLevelRequest) Execute() (*GameLevelResponse, *http.Response, error) {
	return r.ApiService.UpdateGameLevelExecute(r)
}

/*
UpdateGameLevel Update Game Level

Update a game level. Currently does NOT support game objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateGameLevelRequest
*/
func (a *GameLevelAPIService) UpdateGameLevel(ctx context.Context) ApiUpdateGameLevelRequest {
	return ApiUpdateGameLevelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GameLevelResponse
func (a *GameLevelAPIService) UpdateGameLevelExecute(r ApiUpdateGameLevelRequest) (*GameLevelResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GameLevelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameLevelAPIService.UpdateGameLevel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/level/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.levelId == nil {
		return localVarReturnValue, nil, reportError("levelId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "levelId", r.levelId, "form", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.difficulty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "difficulty", r.difficulty, "form", "")
	}
	if r.appVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appVersion", r.appVersion, "form", "")
	}
	if r.assetImageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetImageId", r.assetImageId, "form", "")
	}
	if r.assetIconId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetIconId", r.assetIconId, "form", "")
	}
	if r.gameData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameData", r.gameData, "form", "")
	}
	if r.gameDataSuffix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameDataSuffix", r.gameDataSuffix, "form", "")
	}
	if r.visibility != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibility", r.visibility, "form", "")
	}
	if r.friendGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "friendGroup", r.friendGroup, "form", "")
	}
	if r.connectionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionIds", r.connectionIds, "form", "")
	}
	if r.connectionGroupIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionGroupIds", r.connectionGroupIds, "form", "")
	}
	if r.balance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balance", r.balance, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.allocateTickets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allocateTickets", r.allocateTickets, "form", "")
	}
	if r.ticketCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketCount", r.ticketCount, "form", "")
	}
	if r.ticketType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketType", r.ticketType, "form", "")
	}
	if r.points != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "points", r.points, "form", "")
	}
	if r.tutorialTitle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tutorialTitle", r.tutorialTitle, "form", "")
	}
	if r.tutorialMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tutorialMessage", r.tutorialMessage, "form", "")
	}
	if r.tutorialAlignment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tutorialAlignment", r.tutorialAlignment, "form", "")
	}
	if r.tutorialImageAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tutorialImageAssetId", r.tutorialImageAssetId, "form", "")
	}
	if r.offerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateQuestionsInLevelRequest struct {
	ctx context.Context
	ApiService *GameLevelAPIService
	levelId *int64
	accountId *int64
	questionIds *string
}

// the id of the level to update questions on
func (r ApiUpdateQuestionsInLevelRequest) LevelId(levelId int64) ApiUpdateQuestionsInLevelRequest {
	r.levelId = &levelId
	return r
}

// the id of the logged in user
func (r ApiUpdateQuestionsInLevelRequest) AccountId(accountId int64) ApiUpdateQuestionsInLevelRequest {
	r.accountId = &accountId
	return r
}

// the IDs of the questions to update
func (r ApiUpdateQuestionsInLevelRequest) QuestionIds(questionIds string) ApiUpdateQuestionsInLevelRequest {
	r.questionIds = &questionIds
	return r
}

func (r ApiUpdateQuestionsInLevelRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.UpdateQuestionsInLevelExecute(r)
}

/*
UpdateQuestionsInLevel Update Level Questions

Updates a level with question game objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateQuestionsInLevelRequest
*/
func (a *GameLevelAPIService) UpdateQuestionsInLevel(ctx context.Context) ApiUpdateQuestionsInLevelRequest {
	return ApiUpdateQuestionsInLevelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *GameLevelAPIService) UpdateQuestionsInLevelExecute(r ApiUpdateQuestionsInLevelRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameLevelAPIService.UpdateQuestionsInLevel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/level/questions/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.levelId == nil {
		return localVarReturnValue, nil, reportError("levelId is required and must be specified")
	}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.questionIds == nil {
		return localVarReturnValue, nil, reportError("questionIds is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "levelId", r.levelId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "questionIds", r.questionIds, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWordsInLevelRequest struct {
	ctx context.Context
	ApiService *GameLevelAPIService
	levelId *int64
	accountId *int64
	wordIds *string
}

// the id of the level to update words for
func (r ApiUpdateWordsInLevelRequest) LevelId(levelId int64) ApiUpdateWordsInLevelRequest {
	r.levelId = &levelId
	return r
}

// the id of the logged in user
func (r ApiUpdateWordsInLevelRequest) AccountId(accountId int64) ApiUpdateWordsInLevelRequest {
	r.accountId = &accountId
	return r
}

// the ids of the words to update for the level
func (r ApiUpdateWordsInLevelRequest) WordIds(wordIds string) ApiUpdateWordsInLevelRequest {
	r.wordIds = &wordIds
	return r
}

func (r ApiUpdateWordsInLevelRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.UpdateWordsInLevelExecute(r)
}

/*
UpdateWordsInLevel Update Level Words

Updates a level with word game objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateWordsInLevelRequest
*/
func (a *GameLevelAPIService) UpdateWordsInLevel(ctx context.Context) ApiUpdateWordsInLevelRequest {
	return ApiUpdateWordsInLevelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *GameLevelAPIService) UpdateWordsInLevelExecute(r ApiUpdateWordsInLevelRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameLevelAPIService.UpdateWordsInLevel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/level/words/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.levelId == nil {
		return localVarReturnValue, nil, reportError("levelId is required and must be specified")
	}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.wordIds == nil {
		return localVarReturnValue, nil, reportError("wordIds is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "levelId", r.levelId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "wordIds", r.wordIds, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
