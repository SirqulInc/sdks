/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// MissionAPIService MissionAPI service
type MissionAPIService service

type ApiCreateMissionRequest struct {
	ctx context.Context
	ApiService *MissionAPIService
	version float32
	accountId *int64
	title *string
	description *string
	subType *string
	startDate *int64
	endDate *int64
	active *bool
	gameLevelIds *string
	creativeIds *string
	audienceIds *string
	missionTask *string
	formatType *string
	offerId *int64
	balance *float64
	advancedReporting *bool
	allocateTickets *bool
	ticketCount *int64
	ticketType *string
	points *int64
	metaData *string
	applicationIds *string
	devices *string
	deviceIds *string
	deviceVersions *string
	locations *string
	radius *string
}

// The logged in user.
func (r ApiCreateMissionRequest) AccountId(accountId int64) ApiCreateMissionRequest {
	r.accountId = &accountId
	return r
}

// The title of the mission
func (r ApiCreateMissionRequest) Title(title string) ApiCreateMissionRequest {
	r.title = &title
	return r
}

// The description of the mission
func (r ApiCreateMissionRequest) Description(description string) ApiCreateMissionRequest {
	r.description = &description
	return r
}

// Custom string client apps can use for searching/filtering missions
func (r ApiCreateMissionRequest) SubType(subType string) ApiCreateMissionRequest {
	r.subType = &subType
	return r
}

// The date/time to start the mission, send 0 to unset
func (r ApiCreateMissionRequest) StartDate(startDate int64) ApiCreateMissionRequest {
	r.startDate = &startDate
	return r
}

// The date/time to end the mission, send 0 to unset
func (r ApiCreateMissionRequest) EndDate(endDate int64) ApiCreateMissionRequest {
	r.endDate = &endDate
	return r
}

// Activate/deactivate the mission
func (r ApiCreateMissionRequest) Active(active bool) ApiCreateMissionRequest {
	r.active = &active
	return r
}

// the game level ids to include in the mission, comma separated
func (r ApiCreateMissionRequest) GameLevelIds(gameLevelIds string) ApiCreateMissionRequest {
	r.gameLevelIds = &gameLevelIds
	return r
}

// creatives to associate with the mission
func (r ApiCreateMissionRequest) CreativeIds(creativeIds string) ApiCreateMissionRequest {
	r.creativeIds = &creativeIds
	return r
}

// audiences to associate with the mission
func (r ApiCreateMissionRequest) AudienceIds(audienceIds string) ApiCreateMissionRequest {
	r.audienceIds = &audienceIds
	return r
}

// This parameter is deprecated.
func (r ApiCreateMissionRequest) MissionTask(missionTask string) ApiCreateMissionRequest {
	r.missionTask = &missionTask
	return r
}

// The string identifier for a mission format (this is not the missionFormatId)
func (r ApiCreateMissionRequest) FormatType(formatType string) ApiCreateMissionRequest {
	r.formatType = &formatType
	return r
}

// The offerId to give as a reward
func (r ApiCreateMissionRequest) OfferId(offerId int64) ApiCreateMissionRequest {
	r.offerId = &offerId
	return r
}

// Set the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited.
func (r ApiCreateMissionRequest) Balance(balance float64) ApiCreateMissionRequest {
	r.balance = &balance
	return r
}

// Flag to mark the mission as eligible for advanced reporting
func (r ApiCreateMissionRequest) AdvancedReporting(advancedReporting bool) ApiCreateMissionRequest {
	r.advancedReporting = &advancedReporting
	return r
}

// Flag to indicate owner should receive tickets for completed missions
func (r ApiCreateMissionRequest) AllocateTickets(allocateTickets bool) ApiCreateMissionRequest {
	r.allocateTickets = &allocateTickets
	return r
}

// The number of tickets to reward
func (r ApiCreateMissionRequest) TicketCount(ticketCount int64) ApiCreateMissionRequest {
	r.ticketCount = &ticketCount
	return r
}

// The type of ticket to reward, null means default type
func (r ApiCreateMissionRequest) TicketType(ticketType string) ApiCreateMissionRequest {
	r.ticketType = &ticketType
	return r
}

// The number of points to award for completing a mission
func (r ApiCreateMissionRequest) Points(points int64) ApiCreateMissionRequest {
	r.points = &points
	return r
}

// external custom client defined data
func (r ApiCreateMissionRequest) MetaData(metaData string) ApiCreateMissionRequest {
	r.metaData = &metaData
	return r
}

// Comma separated list of application ids
func (r ApiCreateMissionRequest) ApplicationIds(applicationIds string) ApiCreateMissionRequest {
	r.applicationIds = &applicationIds
	return r
}

// Deprecated parameter for device names
func (r ApiCreateMissionRequest) Devices(devices string) ApiCreateMissionRequest {
	r.devices = &devices
	return r
}

// Comma separated list of device ids
func (r ApiCreateMissionRequest) DeviceIds(deviceIds string) ApiCreateMissionRequest {
	r.deviceIds = &deviceIds
	return r
}

// Comma separated list of device version ranges
func (r ApiCreateMissionRequest) DeviceVersions(deviceVersions string) ApiCreateMissionRequest {
	r.deviceVersions = &deviceVersions
	return r
}

// List of lat/long pairs for mission locations
func (r ApiCreateMissionRequest) Locations(locations string) ApiCreateMissionRequest {
	r.locations = &locations
	return r
}

// Comma separated list of radii for locations
func (r ApiCreateMissionRequest) Radius(radius string) ApiCreateMissionRequest {
	r.radius = &radius
	return r
}

func (r ApiCreateMissionRequest) Execute() (*MissionResponse, *http.Response, error) {
	return r.ApiService.CreateMissionExecute(r)
}

/*
CreateMission Create Mission

Create a user defined mission.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateMissionRequest
*/
func (a *MissionAPIService) CreateMission(ctx context.Context, version float32) ApiCreateMissionRequest {
	return ApiCreateMissionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return MissionResponse
func (a *MissionAPIService) CreateMissionExecute(r ApiCreateMissionRequest) (*MissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MissionAPIService.CreateMission")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/mission/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.subType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subType", r.subType, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.gameLevelIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameLevelIds", r.gameLevelIds, "form", "")
	}
	if r.creativeIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creativeIds", r.creativeIds, "form", "")
	}
	if r.audienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIds", r.audienceIds, "form", "")
	}
	if r.missionTask != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionTask", r.missionTask, "form", "")
	}
	if r.formatType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "formatType", r.formatType, "form", "")
	}
	if r.offerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	}
	if r.balance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balance", r.balance, "form", "")
	}
	if r.advancedReporting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "advancedReporting", r.advancedReporting, "form", "")
	}
	if r.allocateTickets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allocateTickets", r.allocateTickets, "form", "")
	}
	if r.ticketCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketCount", r.ticketCount, "form", "")
	}
	if r.ticketType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketType", r.ticketType, "form", "")
	}
	if r.points != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "points", r.points, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.applicationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "applicationIds", r.applicationIds, "form", "")
	}
	if r.devices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "devices", r.devices, "form", "")
	}
	if r.deviceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceIds", r.deviceIds, "form", "")
	}
	if r.deviceVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceVersions", r.deviceVersions, "form", "")
	}
	if r.locations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locations", r.locations, "form", "")
	}
	if r.radius != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "radius", r.radius, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMissionRequest struct {
	ctx context.Context
	ApiService *MissionAPIService
	version float32
	accountId *int64
	missionId *int64
}

// the id of the logged in user
func (r ApiDeleteMissionRequest) AccountId(accountId int64) ApiDeleteMissionRequest {
	r.accountId = &accountId
	return r
}

// the id of the mission to delete
func (r ApiDeleteMissionRequest) MissionId(missionId int64) ApiDeleteMissionRequest {
	r.missionId = &missionId
	return r
}

func (r ApiDeleteMissionRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteMissionExecute(r)
}

/*
DeleteMission Delete Mission

Delete a mission.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteMissionRequest
*/
func (a *MissionAPIService) DeleteMission(ctx context.Context, version float32) ApiDeleteMissionRequest {
	return ApiDeleteMissionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *MissionAPIService) DeleteMissionExecute(r ApiDeleteMissionRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MissionAPIService.DeleteMission")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/mission/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.missionId == nil {
		return localVarReturnValue, nil, reportError("missionId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindMissionsRequest struct {
	ctx context.Context
	ApiService *MissionAPIService
	version float32
	appKey *string
	suffix *string
	type_ *string
	accountId *int64
	appVersion *string
	latitude *float64
	longitude *float64
	device *string
	deviceIdentifier *int64
	deviceVersion *string
	start *int32
	limit *int32
	includeGameData *bool
	includeAudiences *bool
	allocatesTickets *bool
	randomize *bool
	targetedAdsOnly *bool
	missionIds *string
	audienceOperator *string
}

// The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic.
func (r ApiFindMissionsRequest) AppKey(appKey string) ApiFindMissionsRequest {
	r.appKey = &appKey
	return r
}

// The type of mission to get, possible values are: click_banner, click_leaderboard, click_skyscraper, click_full, click_video, or click_zip
func (r ApiFindMissionsRequest) Suffix(suffix string) ApiFindMissionsRequest {
	r.suffix = &suffix
	return r
}

// The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix.
func (r ApiFindMissionsRequest) Type_(type_ string) ApiFindMissionsRequest {
	r.type_ = &type_
	return r
}

// The logged in user.
func (r ApiFindMissionsRequest) AccountId(accountId int64) ApiFindMissionsRequest {
	r.accountId = &accountId
	return r
}

// The version of the application, will not return levels newer than the appVersion.
func (r ApiFindMissionsRequest) AppVersion(appVersion string) ApiFindMissionsRequest {
	r.appVersion = &appVersion
	return r
}

// The current location of the requesting device
func (r ApiFindMissionsRequest) Latitude(latitude float64) ApiFindMissionsRequest {
	r.latitude = &latitude
	return r
}

// The current location of the requesting device
func (r ApiFindMissionsRequest) Longitude(longitude float64) ApiFindMissionsRequest {
	r.longitude = &longitude
	return r
}

// Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list.
func (r ApiFindMissionsRequest) Device(device string) ApiFindMissionsRequest {
	r.device = &device
	return r
}

// The device ID of the requesting device, use /audience/devices for list
func (r ApiFindMissionsRequest) DeviceIdentifier(deviceIdentifier int64) ApiFindMissionsRequest {
	r.deviceIdentifier = &deviceIdentifier
	return r
}

// The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string.
func (r ApiFindMissionsRequest) DeviceVersion(deviceVersion string) ApiFindMissionsRequest {
	r.deviceVersion = &deviceVersion
	return r
}

// The index into the record set to start with.
func (r ApiFindMissionsRequest) Start(start int32) ApiFindMissionsRequest {
	r.start = &start
	return r
}

// The total number of record to return.
func (r ApiFindMissionsRequest) Limit(limit int32) ApiFindMissionsRequest {
	r.limit = &limit
	return r
}

// Include the game level data with the mission.
func (r ApiFindMissionsRequest) IncludeGameData(includeGameData bool) ApiFindMissionsRequest {
	r.includeGameData = &includeGameData
	return r
}

// If true then return the audience data in the response. Default is false.
func (r ApiFindMissionsRequest) IncludeAudiences(includeAudiences bool) ApiFindMissionsRequest {
	r.includeAudiences = &includeAudiences
	return r
}

// If true/false only return missions whose game levels allocate (or don&#39;t allocate) tickets. Do not provide a value to return both.
func (r ApiFindMissionsRequest) AllocatesTickets(allocatesTickets bool) ApiFindMissionsRequest {
	r.allocatesTickets = &allocatesTickets
	return r
}

// return a random set of results, default is true. If false returns in natural order.
func (r ApiFindMissionsRequest) Randomize(randomize bool) ApiFindMissionsRequest {
	r.randomize = &randomize
	return r
}

// return only ads targeted to the specific app, no global ads.
func (r ApiFindMissionsRequest) TargetedAdsOnly(targetedAdsOnly bool) ApiFindMissionsRequest {
	r.targetedAdsOnly = &targetedAdsOnly
	return r
}

// return only ads from the specified campaigns.
func (r ApiFindMissionsRequest) MissionIds(missionIds string) ApiFindMissionsRequest {
	r.missionIds = &missionIds
	return r
}

// will return the items that have at least 1 or all of their audiences exist in the logged in userâ€™s audiences, depending if the value is OR or AND
func (r ApiFindMissionsRequest) AudienceOperator(audienceOperator string) ApiFindMissionsRequest {
	r.audienceOperator = &audienceOperator
	return r
}

func (r ApiFindMissionsRequest) Execute() (*MissionResponse, *http.Response, error) {
	return r.ApiService.FindMissionsExecute(r)
}

/*
FindMissions Find Missions

Get a set of ad filtered by the parameters provided.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiFindMissionsRequest
*/
func (a *MissionAPIService) FindMissions(ctx context.Context, version float32) ApiFindMissionsRequest {
	return ApiFindMissionsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return MissionResponse
func (a *MissionAPIService) FindMissionsExecute(r ApiFindMissionsRequest) (*MissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MissionAPIService.FindMissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/mission/find"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.suffix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suffix", r.suffix, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appVersion", r.appVersion, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.device != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device", r.device, "form", "")
	}
	if r.deviceIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceIdentifier", r.deviceIdentifier, "form", "")
	}
	if r.deviceVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceVersion", r.deviceVersion, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.includeGameData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGameData", r.includeGameData, "form", "")
	}
	if r.includeAudiences != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAudiences", r.includeAudiences, "form", "")
	}
	if r.allocatesTickets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allocatesTickets", r.allocatesTickets, "form", "")
	}
	if r.randomize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "randomize", r.randomize, "form", "")
	}
	if r.targetedAdsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "targetedAdsOnly", r.targetedAdsOnly, "form", "")
	}
	if r.missionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionIds", r.missionIds, "form", "")
	}
	if r.audienceOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceOperator", r.audienceOperator, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMissionRequest struct {
	ctx context.Context
	ApiService *MissionAPIService
	version float32
	accountId *int64
	missionId *int64
	returnCreative *bool
}

// The logged in user.
func (r ApiGetMissionRequest) AccountId(accountId int64) ApiGetMissionRequest {
	r.accountId = &accountId
	return r
}

// The id of the mission to return.
func (r ApiGetMissionRequest) MissionId(missionId int64) ApiGetMissionRequest {
	r.missionId = &missionId
	return r
}

// Return creatives associated with the mission when true
func (r ApiGetMissionRequest) ReturnCreative(returnCreative bool) ApiGetMissionRequest {
	r.returnCreative = &returnCreative
	return r
}

func (r ApiGetMissionRequest) Execute() (*MissionResponse, *http.Response, error) {
	return r.ApiService.GetMissionExecute(r)
}

/*
GetMission Get Mission

Get a mission.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetMissionRequest
*/
func (a *MissionAPIService) GetMission(ctx context.Context, version float32) ApiGetMissionRequest {
	return ApiGetMissionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return MissionResponse
func (a *MissionAPIService) GetMissionExecute(r ApiGetMissionRequest) (*MissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MissionAPIService.GetMission")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/mission/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.missionId == nil {
		return localVarReturnValue, nil, reportError("missionId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	if r.returnCreative != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnCreative", r.returnCreative, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiImportMissionRequest struct {
	ctx context.Context
	ApiService *MissionAPIService
	version float32
	accountId *int64
	latitude *float64
	longitude *float64
	appKey *string
	keyword *string
	start *int32
	limit *int32
	adSize *string
}

// The logged in user.
func (r ApiImportMissionRequest) AccountId(accountId int64) ApiImportMissionRequest {
	r.accountId = &accountId
	return r
}

// The current location of the requesting device
func (r ApiImportMissionRequest) Latitude(latitude float64) ApiImportMissionRequest {
	r.latitude = &latitude
	return r
}

// The current location of the requesting device
func (r ApiImportMissionRequest) Longitude(longitude float64) ApiImportMissionRequest {
	r.longitude = &longitude
	return r
}

// the application key
func (r ApiImportMissionRequest) AppKey(appKey string) ApiImportMissionRequest {
	r.appKey = &appKey
	return r
}

// the keyword of the mission
func (r ApiImportMissionRequest) Keyword(keyword string) ApiImportMissionRequest {
	r.keyword = &keyword
	return r
}

// The starting index in the result set to return. Default is 0.
func (r ApiImportMissionRequest) Start(start int32) ApiImportMissionRequest {
	r.start = &start
	return r
}

// The total number of records to return. Default is 20.
func (r ApiImportMissionRequest) Limit(limit int32) ApiImportMissionRequest {
	r.limit = &limit
	return r
}

// the size of the ad
func (r ApiImportMissionRequest) AdSize(adSize string) ApiImportMissionRequest {
	r.adSize = &adSize
	return r
}

func (r ApiImportMissionRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.ImportMissionExecute(r)
}

/*
ImportMission Import Mission

Create a mission using a source item such as an offer location.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiImportMissionRequest
*/
func (a *MissionAPIService) ImportMission(ctx context.Context, version float32) ApiImportMissionRequest {
	return ApiImportMissionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *MissionAPIService) ImportMissionExecute(r ApiImportMissionRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MissionAPIService.ImportMission")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/mission/import"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.latitude == nil {
		return localVarReturnValue, nil, reportError("latitude is required and must be specified")
	}
	if r.longitude == nil {
		return localVarReturnValue, nil, reportError("longitude is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	if r.adSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adSize", r.adSize, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchMissionFormatsRequest struct {
	ctx context.Context
	ApiService *MissionAPIService
	version float32
	start *int32
	limit *int32
	activeOnly *bool
}

// The starting index in the result set to return. Default is 0.
func (r ApiSearchMissionFormatsRequest) Start(start int32) ApiSearchMissionFormatsRequest {
	r.start = &start
	return r
}

// The total number of records to return. Default is 20.
func (r ApiSearchMissionFormatsRequest) Limit(limit int32) ApiSearchMissionFormatsRequest {
	r.limit = &limit
	return r
}

// Determines whether to return only active results. Default is false.
func (r ApiSearchMissionFormatsRequest) ActiveOnly(activeOnly bool) ApiSearchMissionFormatsRequest {
	r.activeOnly = &activeOnly
	return r
}

func (r ApiSearchMissionFormatsRequest) Execute() ([]MissionFormatResponse, *http.Response, error) {
	return r.ApiService.SearchMissionFormatsExecute(r)
}

/*
SearchMissionFormats Search Mission Formats

Searches on pre-defined mission formats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchMissionFormatsRequest
*/
func (a *MissionAPIService) SearchMissionFormats(ctx context.Context, version float32) ApiSearchMissionFormatsRequest {
	return ApiSearchMissionFormatsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []MissionFormatResponse
func (a *MissionAPIService) SearchMissionFormatsExecute(r ApiSearchMissionFormatsRequest) ([]MissionFormatResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MissionFormatResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MissionAPIService.SearchMissionFormats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/mission/format/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.activeOnly == nil {
		return localVarReturnValue, nil, reportError("activeOnly is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchMissionsRequest struct {
	ctx context.Context
	ApiService *MissionAPIService
	version float32
	accountId *int64
	keyword *string
	subType *string
	start *int32
	limit *int32
	includeGameData *bool
	includeAudiences *bool
	includeInactive *bool
	suffix *string
	sortField *string
	descending *bool
}

// The logged in user.
func (r ApiSearchMissionsRequest) AccountId(accountId int64) ApiSearchMissionsRequest {
	r.accountId = &accountId
	return r
}

// Filter by keyword
func (r ApiSearchMissionsRequest) Keyword(keyword string) ApiSearchMissionsRequest {
	r.keyword = &keyword
	return r
}

// Custom string client apps can use for searching/filtering missions
func (r ApiSearchMissionsRequest) SubType(subType string) ApiSearchMissionsRequest {
	r.subType = &subType
	return r
}

// The index into the record set to start with. Default is 0.
func (r ApiSearchMissionsRequest) Start(start int32) ApiSearchMissionsRequest {
	r.start = &start
	return r
}

// The total number of record to return. Default is 20, maximum is 100.
func (r ApiSearchMissionsRequest) Limit(limit int32) ApiSearchMissionsRequest {
	r.limit = &limit
	return r
}

// If true then return the game level data in the response. Default is false.
func (r ApiSearchMissionsRequest) IncludeGameData(includeGameData bool) ApiSearchMissionsRequest {
	r.includeGameData = &includeGameData
	return r
}

// If true then return the audience data in the response. Default is false.
func (r ApiSearchMissionsRequest) IncludeAudiences(includeAudiences bool) ApiSearchMissionsRequest {
	r.includeAudiences = &includeAudiences
	return r
}

// If true then include inactive missions. Default is false.
func (r ApiSearchMissionsRequest) IncludeInactive(includeInactive bool) ApiSearchMissionsRequest {
	r.includeInactive = &includeInactive
	return r
}

// A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml
func (r ApiSearchMissionsRequest) Suffix(suffix string) ApiSearchMissionsRequest {
	r.suffix = &suffix
	return r
}

// The field to sort the search on (for example TITLE)
func (r ApiSearchMissionsRequest) SortField(sortField string) ApiSearchMissionsRequest {
	r.sortField = &sortField
	return r
}

// Whether to sort in descending order (default true)
func (r ApiSearchMissionsRequest) Descending(descending bool) ApiSearchMissionsRequest {
	r.descending = &descending
	return r
}

func (r ApiSearchMissionsRequest) Execute() ([]MissionResponse, *http.Response, error) {
	return r.ApiService.SearchMissionsExecute(r)
}

/*
SearchMissions Search Missions

Get the list missions available to the account.  

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchMissionsRequest
*/
func (a *MissionAPIService) SearchMissions(ctx context.Context, version float32) ApiSearchMissionsRequest {
	return ApiSearchMissionsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []MissionResponse
func (a *MissionAPIService) SearchMissionsExecute(r ApiSearchMissionsRequest) ([]MissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MissionAPIService.SearchMissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/mission/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.subType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subType", r.subType, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.includeGameData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGameData", r.includeGameData, "form", "")
	}
	if r.includeAudiences != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAudiences", r.includeAudiences, "form", "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "form", "")
	}
	if r.suffix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suffix", r.suffix, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchMissionsByBillableEntityRequest struct {
	ctx context.Context
	ApiService *MissionAPIService
	version float32
	accountId *int64
	keyword *string
	start *int32
	limit *int32
	includeGameData *bool
	includeAudiences *bool
	includeInactive *bool
	suffix *string
	sortField *string
	descending *bool
}

// The logged in user.
func (r ApiSearchMissionsByBillableEntityRequest) AccountId(accountId int64) ApiSearchMissionsByBillableEntityRequest {
	r.accountId = &accountId
	return r
}

// Filter by keyword
func (r ApiSearchMissionsByBillableEntityRequest) Keyword(keyword string) ApiSearchMissionsByBillableEntityRequest {
	r.keyword = &keyword
	return r
}

// The index into the record set to start with. Default is 0.
func (r ApiSearchMissionsByBillableEntityRequest) Start(start int32) ApiSearchMissionsByBillableEntityRequest {
	r.start = &start
	return r
}

// The total number of record to return. Default id 20.
func (r ApiSearchMissionsByBillableEntityRequest) Limit(limit int32) ApiSearchMissionsByBillableEntityRequest {
	r.limit = &limit
	return r
}

// If true then return the game level data in the response. Default is false.
func (r ApiSearchMissionsByBillableEntityRequest) IncludeGameData(includeGameData bool) ApiSearchMissionsByBillableEntityRequest {
	r.includeGameData = &includeGameData
	return r
}

// If true then return the audience data in the response. Default is false.
func (r ApiSearchMissionsByBillableEntityRequest) IncludeAudiences(includeAudiences bool) ApiSearchMissionsByBillableEntityRequest {
	r.includeAudiences = &includeAudiences
	return r
}

// If true then include inactive missions. Default is false.
func (r ApiSearchMissionsByBillableEntityRequest) IncludeInactive(includeInactive bool) ApiSearchMissionsByBillableEntityRequest {
	r.includeInactive = &includeInactive
	return r
}

// A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml
func (r ApiSearchMissionsByBillableEntityRequest) Suffix(suffix string) ApiSearchMissionsByBillableEntityRequest {
	r.suffix = &suffix
	return r
}

// The field to sort the search on (for example TITLE)
func (r ApiSearchMissionsByBillableEntityRequest) SortField(sortField string) ApiSearchMissionsByBillableEntityRequest {
	r.sortField = &sortField
	return r
}

// Whether to sort in descending order (default true)
func (r ApiSearchMissionsByBillableEntityRequest) Descending(descending bool) ApiSearchMissionsByBillableEntityRequest {
	r.descending = &descending
	return r
}

func (r ApiSearchMissionsByBillableEntityRequest) Execute() ([]MissionResponse, *http.Response, error) {
	return r.ApiService.SearchMissionsByBillableEntityExecute(r)
}

/*
SearchMissionsByBillableEntity Search Missions by Billable Entity

Use the accountId to determine the associated BillableEntity.  From there get a list of all accounts associated as managers.  Get the list missions owned by all associated managers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchMissionsByBillableEntityRequest
*/
func (a *MissionAPIService) SearchMissionsByBillableEntity(ctx context.Context, version float32) ApiSearchMissionsByBillableEntityRequest {
	return ApiSearchMissionsByBillableEntityRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []MissionResponse
func (a *MissionAPIService) SearchMissionsByBillableEntityExecute(r ApiSearchMissionsByBillableEntityRequest) ([]MissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MissionAPIService.SearchMissionsByBillableEntity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/mission/searchByBillableEntity"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.includeGameData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGameData", r.includeGameData, "form", "")
	}
	if r.includeAudiences != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAudiences", r.includeAudiences, "form", "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "form", "")
	}
	if r.suffix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suffix", r.suffix, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMissionRequest struct {
	ctx context.Context
	ApiService *MissionAPIService
	version float32
	accountId *int64
	missionId *int64
	title *string
	description *string
	subType *string
	metaData *string
	startDate *int64
	endDate *int64
	active *bool
	gameLevelIds *string
	creativeIds *string
	audienceIds *string
	offerId *int64
	balance *float64
	advancedReporting *bool
	allocateTickets *bool
	ticketCount *int64
	ticketType *string
	points *int64
	applicationIds *string
	devices *string
	deviceIds *string
	deviceVersions *string
	locations *string
	radius *string
}

// The logged in user.
func (r ApiUpdateMissionRequest) AccountId(accountId int64) ApiUpdateMissionRequest {
	r.accountId = &accountId
	return r
}

// The id of the mission to update.
func (r ApiUpdateMissionRequest) MissionId(missionId int64) ApiUpdateMissionRequest {
	r.missionId = &missionId
	return r
}

// The title of the mission
func (r ApiUpdateMissionRequest) Title(title string) ApiUpdateMissionRequest {
	r.title = &title
	return r
}

// The description of the mission
func (r ApiUpdateMissionRequest) Description(description string) ApiUpdateMissionRequest {
	r.description = &description
	return r
}

// Custom string client apps can use for searching/filtering missions
func (r ApiUpdateMissionRequest) SubType(subType string) ApiUpdateMissionRequest {
	r.subType = &subType
	return r
}

// external custom client defined data
func (r ApiUpdateMissionRequest) MetaData(metaData string) ApiUpdateMissionRequest {
	r.metaData = &metaData
	return r
}

// The date/time to start the mission, send 0 to unset
func (r ApiUpdateMissionRequest) StartDate(startDate int64) ApiUpdateMissionRequest {
	r.startDate = &startDate
	return r
}

// The date/time to end the mission, send 0 to unset
func (r ApiUpdateMissionRequest) EndDate(endDate int64) ApiUpdateMissionRequest {
	r.endDate = &endDate
	return r
}

// Activate/deactivate the mission
func (r ApiUpdateMissionRequest) Active(active bool) ApiUpdateMissionRequest {
	r.active = &active
	return r
}

// the game level ids to include in the mission, comma separated
func (r ApiUpdateMissionRequest) GameLevelIds(gameLevelIds string) ApiUpdateMissionRequest {
	r.gameLevelIds = &gameLevelIds
	return r
}

// 
func (r ApiUpdateMissionRequest) CreativeIds(creativeIds string) ApiUpdateMissionRequest {
	r.creativeIds = &creativeIds
	return r
}

// 
func (r ApiUpdateMissionRequest) AudienceIds(audienceIds string) ApiUpdateMissionRequest {
	r.audienceIds = &audienceIds
	return r
}

// The offerId to give as a reward
func (r ApiUpdateMissionRequest) OfferId(offerId int64) ApiUpdateMissionRequest {
	r.offerId = &offerId
	return r
}

// Replace the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited.
func (r ApiUpdateMissionRequest) Balance(balance float64) ApiUpdateMissionRequest {
	r.balance = &balance
	return r
}

// Flag to mark the mission as eligible for advanced reporting
func (r ApiUpdateMissionRequest) AdvancedReporting(advancedReporting bool) ApiUpdateMissionRequest {
	r.advancedReporting = &advancedReporting
	return r
}

// Flag to indicate owner should receive tickets for completed missions
func (r ApiUpdateMissionRequest) AllocateTickets(allocateTickets bool) ApiUpdateMissionRequest {
	r.allocateTickets = &allocateTickets
	return r
}

// The number of tickets to reward
func (r ApiUpdateMissionRequest) TicketCount(ticketCount int64) ApiUpdateMissionRequest {
	r.ticketCount = &ticketCount
	return r
}

// The type of ticket to reward, null means default type
func (r ApiUpdateMissionRequest) TicketType(ticketType string) ApiUpdateMissionRequest {
	r.ticketType = &ticketType
	return r
}

// The number of points to award for completing a mission
func (r ApiUpdateMissionRequest) Points(points int64) ApiUpdateMissionRequest {
	r.points = &points
	return r
}

// Comma separated list of application ids
func (r ApiUpdateMissionRequest) ApplicationIds(applicationIds string) ApiUpdateMissionRequest {
	r.applicationIds = &applicationIds
	return r
}

// Deprecated parameter for device names
func (r ApiUpdateMissionRequest) Devices(devices string) ApiUpdateMissionRequest {
	r.devices = &devices
	return r
}

// Comma separated list of device ids
func (r ApiUpdateMissionRequest) DeviceIds(deviceIds string) ApiUpdateMissionRequest {
	r.deviceIds = &deviceIds
	return r
}

// Comma separated list of device version ranges
func (r ApiUpdateMissionRequest) DeviceVersions(deviceVersions string) ApiUpdateMissionRequest {
	r.deviceVersions = &deviceVersions
	return r
}

// List of lat/long pairs for mission locations
func (r ApiUpdateMissionRequest) Locations(locations string) ApiUpdateMissionRequest {
	r.locations = &locations
	return r
}

// Comma separated list of radii for locations
func (r ApiUpdateMissionRequest) Radius(radius string) ApiUpdateMissionRequest {
	r.radius = &radius
	return r
}

func (r ApiUpdateMissionRequest) Execute() (*MissionResponse, *http.Response, error) {
	return r.ApiService.UpdateMissionExecute(r)
}

/*
UpdateMission Update Mission

Update a mission.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateMissionRequest
*/
func (a *MissionAPIService) UpdateMission(ctx context.Context, version float32) ApiUpdateMissionRequest {
	return ApiUpdateMissionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return MissionResponse
func (a *MissionAPIService) UpdateMissionExecute(r ApiUpdateMissionRequest) (*MissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MissionAPIService.UpdateMission")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/mission/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.missionId == nil {
		return localVarReturnValue, nil, reportError("missionId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.subType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subType", r.subType, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.gameLevelIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameLevelIds", r.gameLevelIds, "form", "")
	}
	if r.creativeIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creativeIds", r.creativeIds, "form", "")
	}
	if r.audienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIds", r.audienceIds, "form", "")
	}
	if r.offerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	}
	if r.balance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balance", r.balance, "form", "")
	}
	if r.advancedReporting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "advancedReporting", r.advancedReporting, "form", "")
	}
	if r.allocateTickets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allocateTickets", r.allocateTickets, "form", "")
	}
	if r.ticketCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketCount", r.ticketCount, "form", "")
	}
	if r.ticketType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketType", r.ticketType, "form", "")
	}
	if r.points != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "points", r.points, "form", "")
	}
	if r.applicationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "applicationIds", r.applicationIds, "form", "")
	}
	if r.devices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "devices", r.devices, "form", "")
	}
	if r.deviceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceIds", r.deviceIds, "form", "")
	}
	if r.deviceVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceVersions", r.deviceVersions, "form", "")
	}
	if r.locations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locations", r.locations, "form", "")
	}
	if r.radius != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "radius", r.radius, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
