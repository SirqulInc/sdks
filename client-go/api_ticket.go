/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// TicketAPIService TicketAPI service
type TicketAPIService service

type ApiGetTicketCountRequest struct {
	ctx context.Context
	ApiService *TicketAPIService
	version float32
	deviceId *string
	accountId *int64
	gameType *string
	appKey *string
	ticketType *string
}

// the id of the device that owns the tickets
func (r ApiGetTicketCountRequest) DeviceId(deviceId string) ApiGetTicketCountRequest {
	r.deviceId = &deviceId
	return r
}

// the id of the account that owns the tickets
func (r ApiGetTicketCountRequest) AccountId(accountId int64) ApiGetTicketCountRequest {
	r.accountId = &accountId
	return r
}

// this is deprecated.
func (r ApiGetTicketCountRequest) GameType(gameType string) ApiGetTicketCountRequest {
	r.gameType = &gameType
	return r
}

// the applicationkey
func (r ApiGetTicketCountRequest) AppKey(appKey string) ApiGetTicketCountRequest {
	r.appKey = &appKey
	return r
}

// the type of ticket
func (r ApiGetTicketCountRequest) TicketType(ticketType string) ApiGetTicketCountRequest {
	r.ticketType = &ticketType
	return r
}

func (r ApiGetTicketCountRequest) Execute() (*CountResponse, *http.Response, error) {
	return r.ApiService.GetTicketCountExecute(r)
}

/*
GetTicketCount Get Ticket Count

Gets the ticket count.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetTicketCountRequest
*/
func (a *TicketAPIService) GetTicketCount(ctx context.Context, version float32) ApiGetTicketCountRequest {
	return ApiGetTicketCountRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return CountResponse
func (a *TicketAPIService) GetTicketCountExecute(r ApiGetTicketCountRequest) (*CountResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TicketAPIService.GetTicketCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/ticket/count"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.gameType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameType", r.gameType, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.ticketType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketType", r.ticketType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTicketListRequest struct {
	ctx context.Context
	ApiService *TicketAPIService
	version float32
	deviceId *string
	accountId *int64
	ticketObjectType *string
	actionType *string
	ticketIds *string
	objectIds *string
	receiptTokens *string
	gameType *string
	appKey *string
}

// the id of the device that owns the tickets
func (r ApiGetTicketListRequest) DeviceId(deviceId string) ApiGetTicketListRequest {
	r.deviceId = &deviceId
	return r
}

// the id of the account that owns the tickets
func (r ApiGetTicketListRequest) AccountId(accountId int64) ApiGetTicketListRequest {
	r.accountId = &accountId
	return r
}

// comma separated list of TicketObjectType
func (r ApiGetTicketListRequest) TicketObjectType(ticketObjectType string) ApiGetTicketListRequest {
	r.ticketObjectType = &ticketObjectType
	return r
}

// comma separated list of TicketActionType
func (r ApiGetTicketListRequest) ActionType(actionType string) ApiGetTicketListRequest {
	r.actionType = &actionType
	return r
}

// the ids of the tickets to get
func (r ApiGetTicketListRequest) TicketIds(ticketIds string) ApiGetTicketListRequest {
	r.ticketIds = &ticketIds
	return r
}

// the ids of the objects to get
func (r ApiGetTicketListRequest) ObjectIds(objectIds string) ApiGetTicketListRequest {
	r.objectIds = &objectIds
	return r
}

// 
func (r ApiGetTicketListRequest) ReceiptTokens(receiptTokens string) ApiGetTicketListRequest {
	r.receiptTokens = &receiptTokens
	return r
}

// 
func (r ApiGetTicketListRequest) GameType(gameType string) ApiGetTicketListRequest {
	r.gameType = &gameType
	return r
}

// the application key
func (r ApiGetTicketListRequest) AppKey(appKey string) ApiGetTicketListRequest {
	r.appKey = &appKey
	return r
}

func (r ApiGetTicketListRequest) Execute() (*TicketListResponse, *http.Response, error) {
	return r.ApiService.GetTicketListExecute(r)
}

/*
GetTicketList Get Ticket List

Gets the list of tickets.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetTicketListRequest
*/
func (a *TicketAPIService) GetTicketList(ctx context.Context, version float32) ApiGetTicketListRequest {
	return ApiGetTicketListRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return TicketListResponse
func (a *TicketAPIService) GetTicketListExecute(r ApiGetTicketListRequest) (*TicketListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TicketListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TicketAPIService.GetTicketList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/ticket/getList"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.ticketObjectType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketObjectType", r.ticketObjectType, "form", "")
	}
	if r.actionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actionType", r.actionType, "form", "")
	}
	if r.ticketIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketIds", r.ticketIds, "form", "")
	}
	if r.objectIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectIds", r.objectIds, "form", "")
	}
	if r.receiptTokens != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "receiptTokens", r.receiptTokens, "form", "")
	}
	if r.gameType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameType", r.gameType, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGiftPurchaseRequest struct {
	ctx context.Context
	ApiService *TicketAPIService
	version float32
	receiverAccountId *int64
	ticketId *int64
	deviceId *string
	accountId *int64
	assetId *int64
	customMessage *string
	gameType *string
	appKey *string
}

// the id of the account receiving the tickets
func (r ApiGiftPurchaseRequest) ReceiverAccountId(receiverAccountId int64) ApiGiftPurchaseRequest {
	r.receiverAccountId = &receiverAccountId
	return r
}

// the id of the tickets
func (r ApiGiftPurchaseRequest) TicketId(ticketId int64) ApiGiftPurchaseRequest {
	r.ticketId = &ticketId
	return r
}

// the id of the device
func (r ApiGiftPurchaseRequest) DeviceId(deviceId string) ApiGiftPurchaseRequest {
	r.deviceId = &deviceId
	return r
}

// the id of the gift owner
func (r ApiGiftPurchaseRequest) AccountId(accountId int64) ApiGiftPurchaseRequest {
	r.accountId = &accountId
	return r
}

// the id of the asset
func (r ApiGiftPurchaseRequest) AssetId(assetId int64) ApiGiftPurchaseRequest {
	r.assetId = &assetId
	return r
}

// a message that can be written to go along with the gift
func (r ApiGiftPurchaseRequest) CustomMessage(customMessage string) ApiGiftPurchaseRequest {
	r.customMessage = &customMessage
	return r
}

// the type of game associated with the tickets
func (r ApiGiftPurchaseRequest) GameType(gameType string) ApiGiftPurchaseRequest {
	r.gameType = &gameType
	return r
}

// the application key
func (r ApiGiftPurchaseRequest) AppKey(appKey string) ApiGiftPurchaseRequest {
	r.appKey = &appKey
	return r
}

func (r ApiGiftPurchaseRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.GiftPurchaseExecute(r)
}

/*
GiftPurchase Gift Tickets

Gift tickets to another user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGiftPurchaseRequest
*/
func (a *TicketAPIService) GiftPurchase(ctx context.Context, version float32) ApiGiftPurchaseRequest {
	return ApiGiftPurchaseRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *TicketAPIService) GiftPurchaseExecute(r ApiGiftPurchaseRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TicketAPIService.GiftPurchase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/purchase/gift"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.receiverAccountId == nil {
		return localVarReturnValue, nil, reportError("receiverAccountId is required and must be specified")
	}
	if r.ticketId == nil {
		return localVarReturnValue, nil, reportError("ticketId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "receiverAccountId", r.receiverAccountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ticketId", r.ticketId, "form", "")
	if r.assetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "form", "")
	}
	if r.customMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customMessage", r.customMessage, "form", "")
	}
	if r.gameType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameType", r.gameType, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSaveTicketRequest struct {
	ctx context.Context
	ApiService *TicketAPIService
	version float32
	actionType *string
	ticketObjectType *string
	returnNulls *bool
	deviceId *string
	accountId *int64
	gameType *string
	appKey *string
	objectId *int64
	purchaseCode *string
	receiptToken *string
	receiptData *string
	count *int64
	ticketType *string
	purchaseProvider *string
	purchaseType *string
	returnProfileResponse *bool
	includeProfileResponse *bool
	appVersion *string
}

// the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER
func (r ApiSaveTicketRequest) ActionType(actionType string) ApiSaveTicketRequest {
	r.actionType = &actionType
	return r
}

// the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM
func (r ApiSaveTicketRequest) TicketObjectType(ticketObjectType string) ApiSaveTicketRequest {
	r.ticketObjectType = &ticketObjectType
	return r
}

// whether to return nulls or not
func (r ApiSaveTicketRequest) ReturnNulls(returnNulls bool) ApiSaveTicketRequest {
	r.returnNulls = &returnNulls
	return r
}

// the device id that owns the tickets
func (r ApiSaveTicketRequest) DeviceId(deviceId string) ApiSaveTicketRequest {
	r.deviceId = &deviceId
	return r
}

// the account id that owns the tickets
func (r ApiSaveTicketRequest) AccountId(accountId int64) ApiSaveTicketRequest {
	r.accountId = &accountId
	return r
}

// This parameter is deprecated. deprecated, use the appKey
func (r ApiSaveTicketRequest) GameType(gameType string) ApiSaveTicketRequest {
	r.gameType = &gameType
	return r
}

// the application key
func (r ApiSaveTicketRequest) AppKey(appKey string) ApiSaveTicketRequest {
	r.appKey = &appKey
	return r
}

// the ID of the item being purchased
func (r ApiSaveTicketRequest) ObjectId(objectId int64) ApiSaveTicketRequest {
	r.objectId = &objectId
	return r
}

// a unique string identifier defined by the application owner or Executive
func (r ApiSaveTicketRequest) PurchaseCode(purchaseCode string) ApiSaveTicketRequest {
	r.purchaseCode = &purchaseCode
	return r
}

// a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)
func (r ApiSaveTicketRequest) ReceiptToken(receiptToken string) ApiSaveTicketRequest {
	r.receiptToken = &receiptToken
	return r
}

// the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format.
func (r ApiSaveTicketRequest) ReceiptData(receiptData string) ApiSaveTicketRequest {
	r.receiptData = &receiptData
	return r
}

// the count of tickets
func (r ApiSaveTicketRequest) Count(count int64) ApiSaveTicketRequest {
	r.count = &count
	return r
}

// the ticket type
func (r ApiSaveTicketRequest) TicketType(ticketType string) ApiSaveTicketRequest {
	r.ticketType = &ticketType
	return r
}

// the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}
func (r ApiSaveTicketRequest) PurchaseProvider(purchaseProvider string) ApiSaveTicketRequest {
	r.purchaseProvider = &purchaseProvider
	return r
}

// a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }
func (r ApiSaveTicketRequest) PurchaseType(purchaseType string) ApiSaveTicketRequest {
	r.purchaseType = &purchaseType
	return r
}

// returns a ProfileResponse if true, otherwise will return an AppResponse
func (r ApiSaveTicketRequest) ReturnProfileResponse(returnProfileResponse bool) ApiSaveTicketRequest {
	r.returnProfileResponse = &returnProfileResponse
	return r
}

// if returnProfileResponse is false, will return an AppResponse with profile data if true
func (r ApiSaveTicketRequest) IncludeProfileResponse(includeProfileResponse bool) ApiSaveTicketRequest {
	r.includeProfileResponse = &includeProfileResponse
	return r
}

// the application version
func (r ApiSaveTicketRequest) AppVersion(appVersion string) ApiSaveTicketRequest {
	r.appVersion = &appVersion
	return r
}

func (r ApiSaveTicketRequest) Execute() (*ProfileResponse, *http.Response, error) {
	return r.ApiService.SaveTicketExecute(r)
}

/*
SaveTicket Save Ticket

Allow user to acquire a purchase item and generate a ticket record. Used to redeem tickets or add tickets to the system.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSaveTicketRequest
*/
func (a *TicketAPIService) SaveTicket(ctx context.Context, version float32) ApiSaveTicketRequest {
	return ApiSaveTicketRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ProfileResponse
func (a *TicketAPIService) SaveTicketExecute(r ApiSaveTicketRequest) (*ProfileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TicketAPIService.SaveTicket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/ticket/save"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionType == nil {
		return localVarReturnValue, nil, reportError("actionType is required and must be specified")
	}
	if r.ticketObjectType == nil {
		return localVarReturnValue, nil, reportError("ticketObjectType is required and must be specified")
	}

	if r.returnNulls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnNulls", r.returnNulls, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.gameType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameType", r.gameType, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "actionType", r.actionType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ticketObjectType", r.ticketObjectType, "form", "")
	if r.objectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectId", r.objectId, "form", "")
	}
	if r.purchaseCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseCode", r.purchaseCode, "form", "")
	}
	if r.receiptToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "receiptToken", r.receiptToken, "form", "")
	}
	if r.receiptData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "receiptData", r.receiptData, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.ticketType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketType", r.ticketType, "form", "")
	}
	if r.purchaseProvider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseProvider", r.purchaseProvider, "form", "")
	}
	if r.purchaseType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseType", r.purchaseType, "form", "")
	}
	if r.returnProfileResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnProfileResponse", r.returnProfileResponse, "form", "")
	}
	if r.includeProfileResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeProfileResponse", r.includeProfileResponse, "form", "")
	}
	if r.appVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appVersion", r.appVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSaveTicketViaFileUploadRequest struct {
	ctx context.Context
	ApiService *TicketAPIService
	version float32
	actionType *string
	ticketObjectType *string
	receiptData *os.File
	returnNulls *bool
	deviceId *string
	accountId *int64
	gameType *string
	appKey *string
	objectId *int64
	purchaseCode *string
	receiptToken *string
	count *int64
	ticketType *string
	purchaseProvider *string
	purchaseType *string
	returnProfileResponse *bool
	includeProfileResponse *bool
	appVersion *string
}

// the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER }
func (r ApiSaveTicketViaFileUploadRequest) ActionType(actionType string) ApiSaveTicketViaFileUploadRequest {
	r.actionType = &actionType
	return r
}

// the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM}
func (r ApiSaveTicketViaFileUploadRequest) TicketObjectType(ticketObjectType string) ApiSaveTicketViaFileUploadRequest {
	r.ticketObjectType = &ticketObjectType
	return r
}

// the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format.
func (r ApiSaveTicketViaFileUploadRequest) ReceiptData(receiptData *os.File) ApiSaveTicketViaFileUploadRequest {
	r.receiptData = receiptData
	return r
}

// whether to return nulls or not
func (r ApiSaveTicketViaFileUploadRequest) ReturnNulls(returnNulls bool) ApiSaveTicketViaFileUploadRequest {
	r.returnNulls = &returnNulls
	return r
}

// the device id
func (r ApiSaveTicketViaFileUploadRequest) DeviceId(deviceId string) ApiSaveTicketViaFileUploadRequest {
	r.deviceId = &deviceId
	return r
}

// the account id
func (r ApiSaveTicketViaFileUploadRequest) AccountId(accountId int64) ApiSaveTicketViaFileUploadRequest {
	r.accountId = &accountId
	return r
}

// This parameter is deprecated. deprecated, use the appKey
func (r ApiSaveTicketViaFileUploadRequest) GameType(gameType string) ApiSaveTicketViaFileUploadRequest {
	r.gameType = &gameType
	return r
}

// the application key
func (r ApiSaveTicketViaFileUploadRequest) AppKey(appKey string) ApiSaveTicketViaFileUploadRequest {
	r.appKey = &appKey
	return r
}

// the ID of the item being purchased
func (r ApiSaveTicketViaFileUploadRequest) ObjectId(objectId int64) ApiSaveTicketViaFileUploadRequest {
	r.objectId = &objectId
	return r
}

// a unique string identifier defined by the application owner or Executive
func (r ApiSaveTicketViaFileUploadRequest) PurchaseCode(purchaseCode string) ApiSaveTicketViaFileUploadRequest {
	r.purchaseCode = &purchaseCode
	return r
}

// a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)
func (r ApiSaveTicketViaFileUploadRequest) ReceiptToken(receiptToken string) ApiSaveTicketViaFileUploadRequest {
	r.receiptToken = &receiptToken
	return r
}

// the count of tickets
func (r ApiSaveTicketViaFileUploadRequest) Count(count int64) ApiSaveTicketViaFileUploadRequest {
	r.count = &count
	return r
}

// the ticket type
func (r ApiSaveTicketViaFileUploadRequest) TicketType(ticketType string) ApiSaveTicketViaFileUploadRequest {
	r.ticketType = &ticketType
	return r
}

// the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}
func (r ApiSaveTicketViaFileUploadRequest) PurchaseProvider(purchaseProvider string) ApiSaveTicketViaFileUploadRequest {
	r.purchaseProvider = &purchaseProvider
	return r
}

// a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }
func (r ApiSaveTicketViaFileUploadRequest) PurchaseType(purchaseType string) ApiSaveTicketViaFileUploadRequest {
	r.purchaseType = &purchaseType
	return r
}

// returns a ProfileResponse if true, otherwise will return an AppResponse
func (r ApiSaveTicketViaFileUploadRequest) ReturnProfileResponse(returnProfileResponse bool) ApiSaveTicketViaFileUploadRequest {
	r.returnProfileResponse = &returnProfileResponse
	return r
}

// if returnProfileResponse is false, will return an AppResponse with profile data if true
func (r ApiSaveTicketViaFileUploadRequest) IncludeProfileResponse(includeProfileResponse bool) ApiSaveTicketViaFileUploadRequest {
	r.includeProfileResponse = &includeProfileResponse
	return r
}

// the application version
func (r ApiSaveTicketViaFileUploadRequest) AppVersion(appVersion string) ApiSaveTicketViaFileUploadRequest {
	r.appVersion = &appVersion
	return r
}

func (r ApiSaveTicketViaFileUploadRequest) Execute() (*ProfileResponse, *http.Response, error) {
	return r.ApiService.SaveTicketViaFileUploadExecute(r)
}

/*
SaveTicketViaFileUpload Save Ticket with Reciept

Similar to the Save Ticket endpoint but allows the receiptData to be in binary format. This must be a multi-part post

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSaveTicketViaFileUploadRequest
*/
func (a *TicketAPIService) SaveTicketViaFileUpload(ctx context.Context, version float32) ApiSaveTicketViaFileUploadRequest {
	return ApiSaveTicketViaFileUploadRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ProfileResponse
func (a *TicketAPIService) SaveTicketViaFileUploadExecute(r ApiSaveTicketViaFileUploadRequest) (*ProfileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TicketAPIService.SaveTicketViaFileUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/ticket/save/fileUpload"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionType == nil {
		return localVarReturnValue, nil, reportError("actionType is required and must be specified")
	}
	if r.ticketObjectType == nil {
		return localVarReturnValue, nil, reportError("ticketObjectType is required and must be specified")
	}
	if r.receiptData == nil {
		return localVarReturnValue, nil, reportError("receiptData is required and must be specified")
	}

	if r.returnNulls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnNulls", r.returnNulls, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.gameType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameType", r.gameType, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "actionType", r.actionType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ticketObjectType", r.ticketObjectType, "form", "")
	if r.objectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectId", r.objectId, "form", "")
	}
	if r.purchaseCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseCode", r.purchaseCode, "form", "")
	}
	if r.receiptToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "receiptToken", r.receiptToken, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "receiptData", r.receiptData, "form", "")
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.ticketType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketType", r.ticketType, "form", "")
	}
	if r.purchaseProvider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseProvider", r.purchaseProvider, "form", "")
	}
	if r.purchaseType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseType", r.purchaseType, "form", "")
	}
	if r.returnProfileResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnProfileResponse", r.returnProfileResponse, "form", "")
	}
	if r.includeProfileResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeProfileResponse", r.includeProfileResponse, "form", "")
	}
	if r.appVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appVersion", r.appVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTicketOffersRequest struct {
	ctx context.Context
	ApiService *TicketAPIService
	version float32
}

func (r ApiTicketOffersRequest) Execute() (*TicketOfferResponse, *http.Response, error) {
	return r.ApiService.TicketOffersExecute(r)
}

/*
TicketOffers Get Ticket Offers

Get a list offers for tickets owned by sirqul.  Purchasing these will add the number of tickets to the account specified by the offer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiTicketOffersRequest
*/
func (a *TicketAPIService) TicketOffers(ctx context.Context, version float32) ApiTicketOffersRequest {
	return ApiTicketOffersRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return TicketOfferResponse
func (a *TicketAPIService) TicketOffersExecute(r ApiTicketOffersRequest) (*TicketOfferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TicketOfferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TicketAPIService.TicketOffers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/ticket/ticketoffers"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
