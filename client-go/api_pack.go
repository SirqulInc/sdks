/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// PackAPIService PackAPI service
type PackAPIService service

type ApiCreatePackRequest struct {
	ctx context.Context
	ApiService *PackAPIService
	accountId *int64
	title *string
	packOrder *int64
	price *int32
	highest *bool
	allocateTickets *bool
	ticketCount *int64
	description *string
	searchTags *string
	active *bool
	gameType *string
	appKey *string
	packType *string
	sequenceType *string
	backgroundId *int64
	imageId *int64
	startDate *int64
	endDate *int64
	authorOverride *string
	priceType *string
	gameLevelIds *string
	inGame *bool
	ticketType *string
	points *int64
}

// The logged in user.
func (r ApiCreatePackRequest) AccountId(accountId int64) ApiCreatePackRequest {
	r.accountId = &accountId
	return r
}

// The title of the pack
func (r ApiCreatePackRequest) Title(title string) ApiCreatePackRequest {
	r.title = &title
	return r
}

// The order of the pack
func (r ApiCreatePackRequest) PackOrder(packOrder int64) ApiCreatePackRequest {
	r.packOrder = &packOrder
	return r
}

// The price in tickets to purchase this pack
func (r ApiCreatePackRequest) Price(price int32) ApiCreatePackRequest {
	r.price = &price
	return r
}

// The scoring is highest is best
func (r ApiCreatePackRequest) Highest(highest bool) ApiCreatePackRequest {
	r.highest = &highest
	return r
}

// Flag to indicate owner should receive tickets for completed packs
func (r ApiCreatePackRequest) AllocateTickets(allocateTickets bool) ApiCreatePackRequest {
	r.allocateTickets = &allocateTickets
	return r
}

// The number of tickets to reward
func (r ApiCreatePackRequest) TicketCount(ticketCount int64) ApiCreatePackRequest {
	r.ticketCount = &ticketCount
	return r
}

// The description of the pack
func (r ApiCreatePackRequest) Description(description string) ApiCreatePackRequest {
	r.description = &description
	return r
}

// The tags for searching the pack, comma separated
func (r ApiCreatePackRequest) SearchTags(searchTags string) ApiCreatePackRequest {
	r.searchTags = &searchTags
	return r
}

// Activate/deactivate the pack
func (r ApiCreatePackRequest) Active(active bool) ApiCreatePackRequest {
	r.active = &active
	return r
}

// This parameter is deprecated.
func (r ApiCreatePackRequest) GameType(gameType string) ApiCreatePackRequest {
	r.gameType = &gameType
	return r
}

// The application key used to identify the application
func (r ApiCreatePackRequest) AppKey(appKey string) ApiCreatePackRequest {
	r.appKey = &appKey
	return r
}

// The type of the pack
func (r ApiCreatePackRequest) PackType(packType string) ApiCreatePackRequest {
	r.packType = &packType
	return r
}

// The type of game sequence of the pack
func (r ApiCreatePackRequest) SequenceType(sequenceType string) ApiCreatePackRequest {
	r.sequenceType = &sequenceType
	return r
}

// The background asset id of the pack
func (r ApiCreatePackRequest) BackgroundId(backgroundId int64) ApiCreatePackRequest {
	r.backgroundId = &backgroundId
	return r
}

// The image asset id of the pack
func (r ApiCreatePackRequest) ImageId(imageId int64) ApiCreatePackRequest {
	r.imageId = &imageId
	return r
}

// The date/time to start the pack, send 0 to unset
func (r ApiCreatePackRequest) StartDate(startDate int64) ApiCreatePackRequest {
	r.startDate = &startDate
	return r
}

// The date/time to end the pack, send 0 to unset
func (r ApiCreatePackRequest) EndDate(endDate int64) ApiCreatePackRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCreatePackRequest) AuthorOverride(authorOverride string) ApiCreatePackRequest {
	r.authorOverride = &authorOverride
	return r
}

// the type of ticket required to purchase this pack
func (r ApiCreatePackRequest) PriceType(priceType string) ApiCreatePackRequest {
	r.priceType = &priceType
	return r
}

// the game level ids to include in the pack, comma separated
func (r ApiCreatePackRequest) GameLevelIds(gameLevelIds string) ApiCreatePackRequest {
	r.gameLevelIds = &gameLevelIds
	return r
}

// 
func (r ApiCreatePackRequest) InGame(inGame bool) ApiCreatePackRequest {
	r.inGame = &inGame
	return r
}

// The type of ticket to reward, null means default type
func (r ApiCreatePackRequest) TicketType(ticketType string) ApiCreatePackRequest {
	r.ticketType = &ticketType
	return r
}

// The number of points to award for completing a pack
func (r ApiCreatePackRequest) Points(points int64) ApiCreatePackRequest {
	r.points = &points
	return r
}

func (r ApiCreatePackRequest) Execute() (*PackResponse, *http.Response, error) {
	return r.ApiService.CreatePackExecute(r)
}

/*
CreatePack Create Pack

Create a pack.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePackRequest
*/
func (a *PackAPIService) CreatePack(ctx context.Context) ApiCreatePackRequest {
	return ApiCreatePackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PackResponse
func (a *PackAPIService) CreatePackExecute(r ApiCreatePackRequest) (*PackResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackAPIService.CreatePack")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pack/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if r.packOrder == nil {
		return localVarReturnValue, nil, reportError("packOrder is required and must be specified")
	}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if r.highest == nil {
		return localVarReturnValue, nil, reportError("highest is required and must be specified")
	}
	if r.allocateTickets == nil {
		return localVarReturnValue, nil, reportError("allocateTickets is required and must be specified")
	}
	if r.ticketCount == nil {
		return localVarReturnValue, nil, reportError("ticketCount is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.searchTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchTags", r.searchTags, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.gameType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameType", r.gameType, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.packType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packType", r.packType, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "packOrder", r.packOrder, "form", "")
	if r.sequenceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sequenceType", r.sequenceType, "form", "")
	}
	if r.backgroundId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundId", r.backgroundId, "form", "")
	}
	if r.imageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageId", r.imageId, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.authorOverride != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorOverride", r.authorOverride, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "price", r.price, "form", "")
	if r.priceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priceType", r.priceType, "form", "")
	}
	if r.gameLevelIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameLevelIds", r.gameLevelIds, "form", "")
	}
	if r.inGame != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inGame", r.inGame, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "highest", r.highest, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "allocateTickets", r.allocateTickets, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ticketCount", r.ticketCount, "form", "")
	if r.ticketType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketType", r.ticketType, "form", "")
	}
	if r.points != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "points", r.points, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePackRequest struct {
	ctx context.Context
	ApiService *PackAPIService
	accountId *int64
	packId *int64
}

// the id of the logged in user
func (r ApiDeletePackRequest) AccountId(accountId int64) ApiDeletePackRequest {
	r.accountId = &accountId
	return r
}

// the id of the pack to delete
func (r ApiDeletePackRequest) PackId(packId int64) ApiDeletePackRequest {
	r.packId = &packId
	return r
}

func (r ApiDeletePackRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeletePackExecute(r)
}

/*
DeletePack Delete Pack

Delete a pack.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeletePackRequest
*/
func (a *PackAPIService) DeletePack(ctx context.Context) ApiDeletePackRequest {
	return ApiDeletePackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *PackAPIService) DeletePackExecute(r ApiDeletePackRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackAPIService.DeletePack")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pack/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.packId == nil {
		return localVarReturnValue, nil, reportError("packId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "packId", r.packId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPackRequest struct {
	ctx context.Context
	ApiService *PackAPIService
	accountId *int64
	packId *int64
	includeGameData *bool
}

// The logged in user.
func (r ApiGetPackRequest) AccountId(accountId int64) ApiGetPackRequest {
	r.accountId = &accountId
	return r
}

// The id of the pack to return.
func (r ApiGetPackRequest) PackId(packId int64) ApiGetPackRequest {
	r.packId = &packId
	return r
}

// If true include the game level data, otherwise don&#39;t. default is false.
func (r ApiGetPackRequest) IncludeGameData(includeGameData bool) ApiGetPackRequest {
	r.includeGameData = &includeGameData
	return r
}

func (r ApiGetPackRequest) Execute() (*PackResponse, *http.Response, error) {
	return r.ApiService.GetPackExecute(r)
}

/*
GetPack Get Pack

Get a pack.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPackRequest
*/
func (a *PackAPIService) GetPack(ctx context.Context) ApiGetPackRequest {
	return ApiGetPackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PackResponse
func (a *PackAPIService) GetPackExecute(r ApiGetPackRequest) (*PackResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackAPIService.GetPack")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pack/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.packId == nil {
		return localVarReturnValue, nil, reportError("packId is required and must be specified")
	}
	if r.includeGameData == nil {
		return localVarReturnValue, nil, reportError("includeGameData is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "packId", r.packId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "includeGameData", r.includeGameData, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchPacksRequest struct {
	ctx context.Context
	ApiService *PackAPIService
	accountId *int64
	sortField *string
	descending *bool
	keyword *string
	packType *string
	start *int32
	limit *int32
	includeGameData *bool
	includeInactive *bool
	appKey *string
}

// The logged in user.
func (r ApiSearchPacksRequest) AccountId(accountId int64) ApiSearchPacksRequest {
	r.accountId = &accountId
	return r
}

// The field to sort by. Possible values include: TITLE, DESCRIPTION, CREATED, UPDATED
func (r ApiSearchPacksRequest) SortField(sortField string) ApiSearchPacksRequest {
	r.sortField = &sortField
	return r
}

// Determines whether the sorted list is in descending or ascending order
func (r ApiSearchPacksRequest) Descending(descending bool) ApiSearchPacksRequest {
	r.descending = &descending
	return r
}

// Keyword search on the pack name
func (r ApiSearchPacksRequest) Keyword(keyword string) ApiSearchPacksRequest {
	r.keyword = &keyword
	return r
}

// Filters results on pack type
func (r ApiSearchPacksRequest) PackType(packType string) ApiSearchPacksRequest {
	r.packType = &packType
	return r
}

// Start the result set at some index.
func (r ApiSearchPacksRequest) Start(start int32) ApiSearchPacksRequest {
	r.start = &start
	return r
}

// Limit the result to some number.
func (r ApiSearchPacksRequest) Limit(limit int32) ApiSearchPacksRequest {
	r.limit = &limit
	return r
}

// Determines whether to include game data in the results
func (r ApiSearchPacksRequest) IncludeGameData(includeGameData bool) ApiSearchPacksRequest {
	r.includeGameData = &includeGameData
	return r
}

// Determines whether to include inactive results
func (r ApiSearchPacksRequest) IncludeInactive(includeInactive bool) ApiSearchPacksRequest {
	r.includeInactive = &includeInactive
	return r
}

// The application to filter results on
func (r ApiSearchPacksRequest) AppKey(appKey string) ApiSearchPacksRequest {
	r.appKey = &appKey
	return r
}

func (r ApiSearchPacksRequest) Execute() ([]PackResponse, *http.Response, error) {
	return r.ApiService.SearchPacksExecute(r)
}

/*
SearchPacks Search Packs

Search on packs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchPacksRequest
*/
func (a *PackAPIService) SearchPacks(ctx context.Context) ApiSearchPacksRequest {
	return ApiSearchPacksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PackResponse
func (a *PackAPIService) SearchPacksExecute(r ApiSearchPacksRequest) ([]PackResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PackResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackAPIService.SearchPacks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pack/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}
	if r.descending == nil {
		return localVarReturnValue, nil, reportError("descending is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.packType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packType", r.packType, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.includeGameData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGameData", r.includeGameData, "form", "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePackRequest struct {
	ctx context.Context
	ApiService *PackAPIService
	accountId *int64
	packId *int64
	allocateTickets *bool
	ticketCount *int64
	title *string
	description *string
	searchTags *string
	active *bool
	gameType *string
	appKey *string
	packType *string
	packOrder *int64
	sequenceType *string
	backgroundId *int64
	imageId *int64
	startDate *int64
	endDate *int64
	authorOverride *string
	price *int32
	priceType *string
	gameLevelIds *string
	inGame *bool
	highest *bool
	ticketType *string
	points *int64
}

// The logged in user.
func (r ApiUpdatePackRequest) AccountId(accountId int64) ApiUpdatePackRequest {
	r.accountId = &accountId
	return r
}

// The id of the pack to update.
func (r ApiUpdatePackRequest) PackId(packId int64) ApiUpdatePackRequest {
	r.packId = &packId
	return r
}

// Flag to indicate owner should receive tickets for completed packs
func (r ApiUpdatePackRequest) AllocateTickets(allocateTickets bool) ApiUpdatePackRequest {
	r.allocateTickets = &allocateTickets
	return r
}

// The number of tickets to reward
func (r ApiUpdatePackRequest) TicketCount(ticketCount int64) ApiUpdatePackRequest {
	r.ticketCount = &ticketCount
	return r
}

// The title of the pack
func (r ApiUpdatePackRequest) Title(title string) ApiUpdatePackRequest {
	r.title = &title
	return r
}

// The description of the pack
func (r ApiUpdatePackRequest) Description(description string) ApiUpdatePackRequest {
	r.description = &description
	return r
}

// The tags for searching the pack, comma separated
func (r ApiUpdatePackRequest) SearchTags(searchTags string) ApiUpdatePackRequest {
	r.searchTags = &searchTags
	return r
}

// Activate/deactivate the pack
func (r ApiUpdatePackRequest) Active(active bool) ApiUpdatePackRequest {
	r.active = &active
	return r
}

// This parameter is deprecated.
func (r ApiUpdatePackRequest) GameType(gameType string) ApiUpdatePackRequest {
	r.gameType = &gameType
	return r
}

// The application key used to identify the application
func (r ApiUpdatePackRequest) AppKey(appKey string) ApiUpdatePackRequest {
	r.appKey = &appKey
	return r
}

// The type of the pack
func (r ApiUpdatePackRequest) PackType(packType string) ApiUpdatePackRequest {
	r.packType = &packType
	return r
}

// The order of the pack
func (r ApiUpdatePackRequest) PackOrder(packOrder int64) ApiUpdatePackRequest {
	r.packOrder = &packOrder
	return r
}

// The type of game sequence of the pack
func (r ApiUpdatePackRequest) SequenceType(sequenceType string) ApiUpdatePackRequest {
	r.sequenceType = &sequenceType
	return r
}

// The background asset id of the pack
func (r ApiUpdatePackRequest) BackgroundId(backgroundId int64) ApiUpdatePackRequest {
	r.backgroundId = &backgroundId
	return r
}

// The image asset id of the pack
func (r ApiUpdatePackRequest) ImageId(imageId int64) ApiUpdatePackRequest {
	r.imageId = &imageId
	return r
}

// The date/time to start the pack, send 0 to unset
func (r ApiUpdatePackRequest) StartDate(startDate int64) ApiUpdatePackRequest {
	r.startDate = &startDate
	return r
}

// The date/time to end the pack, send 0 to unset
func (r ApiUpdatePackRequest) EndDate(endDate int64) ApiUpdatePackRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUpdatePackRequest) AuthorOverride(authorOverride string) ApiUpdatePackRequest {
	r.authorOverride = &authorOverride
	return r
}

// The price in tickets to purchase this pack
func (r ApiUpdatePackRequest) Price(price int32) ApiUpdatePackRequest {
	r.price = &price
	return r
}

// the type of ticket required to purchase this pack
func (r ApiUpdatePackRequest) PriceType(priceType string) ApiUpdatePackRequest {
	r.priceType = &priceType
	return r
}

// the game level ids to include in the pack, comma separated
func (r ApiUpdatePackRequest) GameLevelIds(gameLevelIds string) ApiUpdatePackRequest {
	r.gameLevelIds = &gameLevelIds
	return r
}

// 
func (r ApiUpdatePackRequest) InGame(inGame bool) ApiUpdatePackRequest {
	r.inGame = &inGame
	return r
}

// The scoring is highest is best
func (r ApiUpdatePackRequest) Highest(highest bool) ApiUpdatePackRequest {
	r.highest = &highest
	return r
}

// The type of ticket to reward, null means default type
func (r ApiUpdatePackRequest) TicketType(ticketType string) ApiUpdatePackRequest {
	r.ticketType = &ticketType
	return r
}

// The number of points to award for completing a pack
func (r ApiUpdatePackRequest) Points(points int64) ApiUpdatePackRequest {
	r.points = &points
	return r
}

func (r ApiUpdatePackRequest) Execute() (*PackResponse, *http.Response, error) {
	return r.ApiService.UpdatePackExecute(r)
}

/*
UpdatePack Update Pack

Update a pack.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdatePackRequest
*/
func (a *PackAPIService) UpdatePack(ctx context.Context) ApiUpdatePackRequest {
	return ApiUpdatePackRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PackResponse
func (a *PackAPIService) UpdatePackExecute(r ApiUpdatePackRequest) (*PackResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackAPIService.UpdatePack")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pack/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.packId == nil {
		return localVarReturnValue, nil, reportError("packId is required and must be specified")
	}
	if r.allocateTickets == nil {
		return localVarReturnValue, nil, reportError("allocateTickets is required and must be specified")
	}
	if r.ticketCount == nil {
		return localVarReturnValue, nil, reportError("ticketCount is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "packId", r.packId, "form", "")
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.searchTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchTags", r.searchTags, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.gameType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameType", r.gameType, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.packType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packType", r.packType, "form", "")
	}
	if r.packOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packOrder", r.packOrder, "form", "")
	}
	if r.sequenceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sequenceType", r.sequenceType, "form", "")
	}
	if r.backgroundId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundId", r.backgroundId, "form", "")
	}
	if r.imageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageId", r.imageId, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.authorOverride != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authorOverride", r.authorOverride, "form", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "price", r.price, "form", "")
	}
	if r.priceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priceType", r.priceType, "form", "")
	}
	if r.gameLevelIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameLevelIds", r.gameLevelIds, "form", "")
	}
	if r.inGame != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inGame", r.inGame, "form", "")
	}
	if r.highest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "highest", r.highest, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "allocateTickets", r.allocateTickets, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ticketCount", r.ticketCount, "form", "")
	if r.ticketType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketType", r.ticketType, "form", "")
	}
	if r.points != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "points", r.points, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
