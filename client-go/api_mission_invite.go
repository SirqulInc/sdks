/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// MissionInviteAPIService MissionInviteAPI service
type MissionInviteAPIService service

type ApiCreateMissionInviteRequest struct {
	ctx context.Context
	ApiService *MissionInviteAPIService
	deviceId *string
	accountId *int64
	missionId *int64
	joinCode *string
	includeGameData *bool
}

// the device id (deviceId or accountId required).
func (r ApiCreateMissionInviteRequest) DeviceId(deviceId string) ApiCreateMissionInviteRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required).
func (r ApiCreateMissionInviteRequest) AccountId(accountId int64) ApiCreateMissionInviteRequest {
	r.accountId = &accountId
	return r
}

// The mission to find the invite for.
func (r ApiCreateMissionInviteRequest) MissionId(missionId int64) ApiCreateMissionInviteRequest {
	r.missionId = &missionId
	return r
}

// code to be entered for user to join the mission
func (r ApiCreateMissionInviteRequest) JoinCode(joinCode string) ApiCreateMissionInviteRequest {
	r.joinCode = &joinCode
	return r
}

// Include the game level data with the mission.
func (r ApiCreateMissionInviteRequest) IncludeGameData(includeGameData bool) ApiCreateMissionInviteRequest {
	r.includeGameData = &includeGameData
	return r
}

func (r ApiCreateMissionInviteRequest) Execute() (*MissionResponse, *http.Response, error) {
	return r.ApiService.CreateMissionInviteExecute(r)
}

/*
CreateMissionInvite Create Mission Invite

Create the mission invite. An account can only be invited to a mission one time. For missions that require user submission and reviewing the permissionableType and permissionableId need to be provided.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateMissionInviteRequest
*/
func (a *MissionInviteAPIService) CreateMissionInvite(ctx context.Context) ApiCreateMissionInviteRequest {
	return ApiCreateMissionInviteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MissionResponse
func (a *MissionInviteAPIService) CreateMissionInviteExecute(r ApiCreateMissionInviteRequest) (*MissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MissionInviteAPIService.CreateMissionInvite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mission/invite/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.missionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	}
	if r.joinCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "joinCode", r.joinCode, "form", "")
	}
	if r.includeGameData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGameData", r.includeGameData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMissionInviteRequest struct {
	ctx context.Context
	ApiService *MissionInviteAPIService
	deviceId *string
	accountId *int64
	missionId *int64
	missionInviteId *int64
	includeGameData *bool
}

// the device id (deviceId or accountId required).
func (r ApiDeleteMissionInviteRequest) DeviceId(deviceId string) ApiDeleteMissionInviteRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required).
func (r ApiDeleteMissionInviteRequest) AccountId(accountId int64) ApiDeleteMissionInviteRequest {
	r.accountId = &accountId
	return r
}

// The mission to find the invite for (missionId or missionInviteId requried).
func (r ApiDeleteMissionInviteRequest) MissionId(missionId int64) ApiDeleteMissionInviteRequest {
	r.missionId = &missionId
	return r
}

// The mission invite id. This checks on the user&#39;s billable for permission (missionId or missionInviteId requried).
func (r ApiDeleteMissionInviteRequest) MissionInviteId(missionInviteId int64) ApiDeleteMissionInviteRequest {
	r.missionInviteId = &missionInviteId
	return r
}

// Include the game level data with the mission.
func (r ApiDeleteMissionInviteRequest) IncludeGameData(includeGameData bool) ApiDeleteMissionInviteRequest {
	r.includeGameData = &includeGameData
	return r
}

func (r ApiDeleteMissionInviteRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteMissionInviteExecute(r)
}

/*
DeleteMissionInvite Delete Mission Invite

Update the mission invite status to quit.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteMissionInviteRequest
*/
func (a *MissionInviteAPIService) DeleteMissionInvite(ctx context.Context) ApiDeleteMissionInviteRequest {
	return ApiDeleteMissionInviteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *MissionInviteAPIService) DeleteMissionInviteExecute(r ApiDeleteMissionInviteRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MissionInviteAPIService.DeleteMissionInvite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mission/invite/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.missionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	}
	if r.missionInviteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionInviteId", r.missionInviteId, "form", "")
	}
	if r.includeGameData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGameData", r.includeGameData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMissionInviteRequest struct {
	ctx context.Context
	ApiService *MissionInviteAPIService
	deviceId *string
	accountId *int64
	missionId *int64
	missionInviteId *int64
	includeGameData *bool
	includeScores *string
}

// the device id (deviceId or accountId required).
func (r ApiGetMissionInviteRequest) DeviceId(deviceId string) ApiGetMissionInviteRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required).
func (r ApiGetMissionInviteRequest) AccountId(accountId int64) ApiGetMissionInviteRequest {
	r.accountId = &accountId
	return r
}

// The mission to find the invite for (missionId or missionInviteId requried).
func (r ApiGetMissionInviteRequest) MissionId(missionId int64) ApiGetMissionInviteRequest {
	r.missionId = &missionId
	return r
}

// The mission invite id. This checks on the user&#39;s billable for permission (missionId or missionInviteId requried).
func (r ApiGetMissionInviteRequest) MissionInviteId(missionInviteId int64) ApiGetMissionInviteRequest {
	r.missionInviteId = &missionInviteId
	return r
}

// Include the game level data with the mission.
func (r ApiGetMissionInviteRequest) IncludeGameData(includeGameData bool) ApiGetMissionInviteRequest {
	r.includeGameData = &includeGameData
	return r
}

// include the scores with the mission
func (r ApiGetMissionInviteRequest) IncludeScores(includeScores string) ApiGetMissionInviteRequest {
	r.includeScores = &includeScores
	return r
}

func (r ApiGetMissionInviteRequest) Execute() (*MissionResponse, *http.Response, error) {
	return r.ApiService.GetMissionInviteExecute(r)
}

/*
GetMissionInvite Get Mission Invite

Get the mission invite. An account can only be invited to a mission one time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMissionInviteRequest
*/
func (a *MissionInviteAPIService) GetMissionInvite(ctx context.Context) ApiGetMissionInviteRequest {
	return ApiGetMissionInviteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MissionResponse
func (a *MissionInviteAPIService) GetMissionInviteExecute(r ApiGetMissionInviteRequest) (*MissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MissionInviteAPIService.GetMissionInvite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mission/invite/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.missionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	}
	if r.missionInviteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionInviteId", r.missionInviteId, "form", "")
	}
	if r.includeGameData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGameData", r.includeGameData, "form", "")
	}
	if r.includeScores != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeScores", r.includeScores, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchMissionInvitesRequest struct {
	ctx context.Context
	ApiService *MissionInviteAPIService
	deviceId *string
	accountId *int64
	appKey *string
	appVersion *string
	missionId *int64
	status *string
	lastUpdated *int64
	start *int32
	limit *int32
	keyword *string
	missionTypes *string
	filterByBillable *bool
	includeGameData *bool
}

// the device id (deviceId or accountId required).
func (r ApiSearchMissionInvitesRequest) DeviceId(deviceId string) ApiSearchMissionInvitesRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required).
func (r ApiSearchMissionInvitesRequest) AccountId(accountId int64) ApiSearchMissionInvitesRequest {
	r.accountId = &accountId
	return r
}

// the app to retrieve the data for, use your application key.
func (r ApiSearchMissionInvitesRequest) AppKey(appKey string) ApiSearchMissionInvitesRequest {
	r.appKey = &appKey
	return r
}

// the application version, used to version the game level data
func (r ApiSearchMissionInvitesRequest) AppVersion(appVersion string) ApiSearchMissionInvitesRequest {
	r.appVersion = &appVersion
	return r
}

// the mission id to filter on
func (r ApiSearchMissionInvitesRequest) MissionId(missionId int64) ApiSearchMissionInvitesRequest {
	r.missionId = &missionId
	return r
}

// The invite status to filter for, comma separated list {AVAILABLE, PENDING, UPDATED, ACCEPTED, ACTIVE, QUIT, COMPLETED, PENDING_REVIEW, REJECTED}
func (r ApiSearchMissionInvitesRequest) Status(status string) ApiSearchMissionInvitesRequest {
	r.status = &status
	return r
}

// Only return invites that have been updated since this date/time (long)
func (r ApiSearchMissionInvitesRequest) LastUpdated(lastUpdated int64) ApiSearchMissionInvitesRequest {
	r.lastUpdated = &lastUpdated
	return r
}

// The index into the record set to start with.
func (r ApiSearchMissionInvitesRequest) Start(start int32) ApiSearchMissionInvitesRequest {
	r.start = &start
	return r
}

// The total number of record to return.
func (r ApiSearchMissionInvitesRequest) Limit(limit int32) ApiSearchMissionInvitesRequest {
	r.limit = &limit
	return r
}

// the keyword to search on
func (r ApiSearchMissionInvitesRequest) Keyword(keyword string) ApiSearchMissionInvitesRequest {
	r.keyword = &keyword
	return r
}

// 
func (r ApiSearchMissionInvitesRequest) MissionTypes(missionTypes string) ApiSearchMissionInvitesRequest {
	r.missionTypes = &missionTypes
	return r
}

// filter results by the account&#39;s billable
func (r ApiSearchMissionInvitesRequest) FilterByBillable(filterByBillable bool) ApiSearchMissionInvitesRequest {
	r.filterByBillable = &filterByBillable
	return r
}

// Include the game level data with the mission.
func (r ApiSearchMissionInvitesRequest) IncludeGameData(includeGameData bool) ApiSearchMissionInvitesRequest {
	r.includeGameData = &includeGameData
	return r
}

func (r ApiSearchMissionInvitesRequest) Execute() ([]MissionResponse, *http.Response, error) {
	return r.ApiService.SearchMissionInvitesExecute(r)
}

/*
SearchMissionInvites Search Mission Invites

Get a list of mission invites that the account has.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchMissionInvitesRequest
*/
func (a *MissionInviteAPIService) SearchMissionInvites(ctx context.Context) ApiSearchMissionInvitesRequest {
	return ApiSearchMissionInvitesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MissionResponse
func (a *MissionInviteAPIService) SearchMissionInvitesExecute(r ApiSearchMissionInvitesRequest) ([]MissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MissionInviteAPIService.SearchMissionInvites")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mission/invite/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.appVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appVersion", r.appVersion, "form", "")
	}
	if r.missionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.lastUpdated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastUpdated", r.lastUpdated, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.missionTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionTypes", r.missionTypes, "form", "")
	}
	if r.filterByBillable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterByBillable", r.filterByBillable, "form", "")
	}
	if r.includeGameData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGameData", r.includeGameData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMissionInviteRequest struct {
	ctx context.Context
	ApiService *MissionInviteAPIService
	deviceId *string
	accountId *int64
	appKey *string
	missionId *int64
	missionInviteId *int64
	packId *int64
	gameLevelId *int64
	status *string
	permissionableType *string
	permissionableId *int64
	includeGameData *bool
}

// the device id (deviceId or accountId required).
func (r ApiUpdateMissionInviteRequest) DeviceId(deviceId string) ApiUpdateMissionInviteRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required).
func (r ApiUpdateMissionInviteRequest) AccountId(accountId int64) ApiUpdateMissionInviteRequest {
	r.accountId = &accountId
	return r
}

// the application key
func (r ApiUpdateMissionInviteRequest) AppKey(appKey string) ApiUpdateMissionInviteRequest {
	r.appKey = &appKey
	return r
}

// The mission to find the invite for (missionId or missionInviteId requried).
func (r ApiUpdateMissionInviteRequest) MissionId(missionId int64) ApiUpdateMissionInviteRequest {
	r.missionId = &missionId
	return r
}

// The mission invite id. This checks on the user&#39;s billable for permission (missionId or missionInviteId requried).
func (r ApiUpdateMissionInviteRequest) MissionInviteId(missionInviteId int64) ApiUpdateMissionInviteRequest {
	r.missionInviteId = &missionInviteId
	return r
}

// the pack id to find the invite for
func (r ApiUpdateMissionInviteRequest) PackId(packId int64) ApiUpdateMissionInviteRequest {
	r.packId = &packId
	return r
}

// the game level id to find the invite for
func (r ApiUpdateMissionInviteRequest) GameLevelId(gameLevelId int64) ApiUpdateMissionInviteRequest {
	r.gameLevelId = &gameLevelId
	return r
}

// The invite status to filter for, comma separated list {AVAILABLE, PENDING, UPDATED, ACCEPTED, ACTIVE, QUIT, COMPLETED, PENDING_REVIEW, REJECTED}
func (r ApiUpdateMissionInviteRequest) Status(status string) ApiUpdateMissionInviteRequest {
	r.status = &status
	return r
}

// This is the content type for missions that require user submission. Note that user submitted content must require a status of PENDING_REVIEW to be accpeted. {ACCOUNT, GAMELEVEL, COLLECTION, ALBUM_CONTEST, THEME_DESCRIPTOR, ALBUM}
func (r ApiUpdateMissionInviteRequest) PermissionableType(permissionableType string) ApiUpdateMissionInviteRequest {
	r.permissionableType = &permissionableType
	return r
}

// The id of the content being submitted.
func (r ApiUpdateMissionInviteRequest) PermissionableId(permissionableId int64) ApiUpdateMissionInviteRequest {
	r.permissionableId = &permissionableId
	return r
}

// Include the game level data with the mission.
func (r ApiUpdateMissionInviteRequest) IncludeGameData(includeGameData bool) ApiUpdateMissionInviteRequest {
	r.includeGameData = &includeGameData
	return r
}

func (r ApiUpdateMissionInviteRequest) Execute() (*MissionResponse, *http.Response, error) {
	return r.ApiService.UpdateMissionInviteExecute(r)
}

/*
UpdateMissionInvite Update Mission Invite

Update the mission invite status. An account can only be invited to a mission one time. For missions that require user submission and reviewing the permissionableType and permissionableId need to be provided.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateMissionInviteRequest
*/
func (a *MissionInviteAPIService) UpdateMissionInvite(ctx context.Context) ApiUpdateMissionInviteRequest {
	return ApiUpdateMissionInviteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MissionResponse
func (a *MissionInviteAPIService) UpdateMissionInviteExecute(r ApiUpdateMissionInviteRequest) (*MissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MissionInviteAPIService.UpdateMissionInvite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mission/invite/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.missionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	}
	if r.missionInviteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionInviteId", r.missionInviteId, "form", "")
	}
	if r.packId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "packId", r.packId, "form", "")
	}
	if r.gameLevelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameLevelId", r.gameLevelId, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.permissionableType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permissionableType", r.permissionableType, "form", "")
	}
	if r.permissionableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permissionableId", r.permissionableId, "form", "")
	}
	if r.includeGameData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGameData", r.includeGameData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
