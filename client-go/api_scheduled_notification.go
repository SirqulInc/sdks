/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ScheduledNotificationAPIService ScheduledNotificationAPI service
type ScheduledNotificationAPIService service

type ApiCreateScheduledNotificationRequest struct {
	ctx context.Context
	ApiService *ScheduledNotificationAPIService
	accountId *int64
	name *string
	type_ *string
	message *string
	contentId *int64
	contentName *string
	contentType *string
	parentId *int64
	parentType *string
	appKey *string
	groupingId *string
	connectionGroupIds *string
	connectionAccountIds *string
	audienceId *int64
	audienceIds *string
	albumIds *string
	reportId *int64
	reportParams *string
	endpointURL *string
	payload *string
	scheduledDate *int64
	startDate *int64
	endDate *int64
	cronExpression *string
	cronType *string
	metaData *string
	conditionalInput *string
	templateType *string
	visibility *string
	active *bool
	sendNow *bool
	eventType *string
	deepLinkURI *string
	sendToAll *bool
}

// The logged in user.
func (r ApiCreateScheduledNotificationRequest) AccountId(accountId int64) ApiCreateScheduledNotificationRequest {
	r.accountId = &accountId
	return r
}

// The name of the scheduled notification
func (r ApiCreateScheduledNotificationRequest) Name(name string) ApiCreateScheduledNotificationRequest {
	r.name = &name
	return r
}

// The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
func (r ApiCreateScheduledNotificationRequest) Type_(type_ string) ApiCreateScheduledNotificationRequest {
	r.type_ = &type_
	return r
}

// The message to send
func (r ApiCreateScheduledNotificationRequest) Message(message string) ApiCreateScheduledNotificationRequest {
	r.message = &message
	return r
}

// The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
func (r ApiCreateScheduledNotificationRequest) ContentId(contentId int64) ApiCreateScheduledNotificationRequest {
	r.contentId = &contentId
	return r
}

// The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
func (r ApiCreateScheduledNotificationRequest) ContentName(contentName string) ApiCreateScheduledNotificationRequest {
	r.contentName = &contentName
	return r
}

// The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
func (r ApiCreateScheduledNotificationRequest) ContentType(contentType string) ApiCreateScheduledNotificationRequest {
	r.contentType = &contentType
	return r
}

// The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
func (r ApiCreateScheduledNotificationRequest) ParentId(parentId int64) ApiCreateScheduledNotificationRequest {
	r.parentId = &parentId
	return r
}

// The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
func (r ApiCreateScheduledNotificationRequest) ParentType(parentType string) ApiCreateScheduledNotificationRequest {
	r.parentType = &parentType
	return r
}

// The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
func (r ApiCreateScheduledNotificationRequest) AppKey(appKey string) ApiCreateScheduledNotificationRequest {
	r.appKey = &appKey
	return r
}

// Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
func (r ApiCreateScheduledNotificationRequest) GroupingId(groupingId string) ApiCreateScheduledNotificationRequest {
	r.groupingId = &groupingId
	return r
}

// The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
func (r ApiCreateScheduledNotificationRequest) ConnectionGroupIds(connectionGroupIds string) ApiCreateScheduledNotificationRequest {
	r.connectionGroupIds = &connectionGroupIds
	return r
}

// The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
func (r ApiCreateScheduledNotificationRequest) ConnectionAccountIds(connectionAccountIds string) ApiCreateScheduledNotificationRequest {
	r.connectionAccountIds = &connectionAccountIds
	return r
}

// This parameter is deprecated. The audience used to generate the list of recipients
func (r ApiCreateScheduledNotificationRequest) AudienceId(audienceId int64) ApiCreateScheduledNotificationRequest {
	r.audienceId = &audienceId
	return r
}

// The audiences used to generate the list of recipients (comma separated list of audience IDs)
func (r ApiCreateScheduledNotificationRequest) AudienceIds(audienceIds string) ApiCreateScheduledNotificationRequest {
	r.audienceIds = &audienceIds
	return r
}

// The album ids to associate with the scheduled notification (comma separated list of album IDs)
func (r ApiCreateScheduledNotificationRequest) AlbumIds(albumIds string) ApiCreateScheduledNotificationRequest {
	r.albumIds = &albumIds
	return r
}

// The report used to generate the the list of recipients
func (r ApiCreateScheduledNotificationRequest) ReportId(reportId int64) ApiCreateScheduledNotificationRequest {
	r.reportId = &reportId
	return r
}

// The parameters to supply to the report used to generate the the list of recipients
func (r ApiCreateScheduledNotificationRequest) ReportParams(reportParams string) ApiCreateScheduledNotificationRequest {
	r.reportParams = &reportParams
	return r
}

// The URL for making an HTTP call
func (r ApiCreateScheduledNotificationRequest) EndpointURL(endpointURL string) ApiCreateScheduledNotificationRequest {
	r.endpointURL = &endpointURL
	return r
}

// The parameters for making an HTTP call
func (r ApiCreateScheduledNotificationRequest) Payload(payload string) ApiCreateScheduledNotificationRequest {
	r.payload = &payload
	return r
}

// The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
func (r ApiCreateScheduledNotificationRequest) ScheduledDate(scheduledDate int64) ApiCreateScheduledNotificationRequest {
	r.scheduledDate = &scheduledDate
	return r
}

// The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
func (r ApiCreateScheduledNotificationRequest) StartDate(startDate int64) ApiCreateScheduledNotificationRequest {
	r.startDate = &startDate
	return r
}

// The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
func (r ApiCreateScheduledNotificationRequest) EndDate(endDate int64) ApiCreateScheduledNotificationRequest {
	r.endDate = &endDate
	return r
}

// The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
func (r ApiCreateScheduledNotificationRequest) CronExpression(cronExpression string) ApiCreateScheduledNotificationRequest {
	r.cronExpression = &cronExpression
	return r
}

// The cron expression type: UNIX, CRON4J, QUARTZ
func (r ApiCreateScheduledNotificationRequest) CronType(cronType string) ApiCreateScheduledNotificationRequest {
	r.cronType = &cronType
	return r
}

// Additional metadata for the scheduled notification
func (r ApiCreateScheduledNotificationRequest) MetaData(metaData string) ApiCreateScheduledNotificationRequest {
	r.metaData = &metaData
	return r
}

// Json input representing conditional logic that has to be met before running the scheduled notification
func (r ApiCreateScheduledNotificationRequest) ConditionalInput(conditionalInput string) ApiCreateScheduledNotificationRequest {
	r.conditionalInput = &conditionalInput
	return r
}

// This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
func (r ApiCreateScheduledNotificationRequest) TemplateType(templateType string) ApiCreateScheduledNotificationRequest {
	r.templateType = &templateType
	return r
}

// Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
func (r ApiCreateScheduledNotificationRequest) Visibility(visibility string) ApiCreateScheduledNotificationRequest {
	r.visibility = &visibility
	return r
}

// Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;.
func (r ApiCreateScheduledNotificationRequest) Active(active bool) ApiCreateScheduledNotificationRequest {
	r.active = &active
	return r
}

// 
func (r ApiCreateScheduledNotificationRequest) SendNow(sendNow bool) ApiCreateScheduledNotificationRequest {
	r.sendNow = &sendNow
	return r
}

// Sets the event type for the notification
func (r ApiCreateScheduledNotificationRequest) EventType(eventType string) ApiCreateScheduledNotificationRequest {
	r.eventType = &eventType
	return r
}

// The payload deep link URI that can be used by the client app to direct users to a screen in the app
func (r ApiCreateScheduledNotificationRequest) DeepLinkURI(deepLinkURI string) ApiCreateScheduledNotificationRequest {
	r.deepLinkURI = &deepLinkURI
	return r
}

// Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
func (r ApiCreateScheduledNotificationRequest) SendToAll(sendToAll bool) ApiCreateScheduledNotificationRequest {
	r.sendToAll = &sendToAll
	return r
}

func (r ApiCreateScheduledNotificationRequest) Execute() (*ScheduledNotificationFullResponse, *http.Response, error) {
	return r.ApiService.CreateScheduledNotificationExecute(r)
}

/*
CreateScheduledNotification Create Scheduled Notification

This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateScheduledNotificationRequest
*/
func (a *ScheduledNotificationAPIService) CreateScheduledNotification(ctx context.Context) ApiCreateScheduledNotificationRequest {
	return ApiCreateScheduledNotificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ScheduledNotificationFullResponse
func (a *ScheduledNotificationAPIService) CreateScheduledNotificationExecute(r ApiCreateScheduledNotificationRequest) (*ScheduledNotificationFullResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScheduledNotificationFullResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduledNotificationAPIService.CreateScheduledNotification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/schedule/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.message == nil {
		return localVarReturnValue, nil, reportError("message is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "message", r.message, "form", "")
	if r.contentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentId", r.contentId, "form", "")
	}
	if r.contentName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentName", r.contentName, "form", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentType", r.contentType, "form", "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentId", r.parentId, "form", "")
	}
	if r.parentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentType", r.parentType, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.groupingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupingId", r.groupingId, "form", "")
	}
	if r.connectionGroupIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionGroupIds", r.connectionGroupIds, "form", "")
	}
	if r.connectionAccountIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountIds", r.connectionAccountIds, "form", "")
	}
	if r.audienceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceId", r.audienceId, "form", "")
	}
	if r.audienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIds", r.audienceIds, "form", "")
	}
	if r.albumIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumIds", r.albumIds, "form", "")
	}
	if r.reportId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reportId", r.reportId, "form", "")
	}
	if r.reportParams != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reportParams", r.reportParams, "form", "")
	}
	if r.endpointURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endpointURL", r.endpointURL, "form", "")
	}
	if r.payload != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payload", r.payload, "form", "")
	}
	if r.scheduledDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduledDate", r.scheduledDate, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.cronExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cronExpression", r.cronExpression, "form", "")
	}
	if r.cronType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cronType", r.cronType, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.conditionalInput != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conditionalInput", r.conditionalInput, "form", "")
	}
	if r.templateType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "templateType", r.templateType, "form", "")
	}
	if r.visibility != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibility", r.visibility, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.sendNow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sendNow", r.sendNow, "form", "")
	}
	if r.eventType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventType", r.eventType, "form", "")
	} else {
		var defaultValue string = "CUSTOM"
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventType", defaultValue, "form", "")
		r.eventType = &defaultValue
	}
	if r.deepLinkURI != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deepLinkURI", r.deepLinkURI, "form", "")
	}
	if r.sendToAll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sendToAll", r.sendToAll, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteScheduledNotificationRequest struct {
	ctx context.Context
	ApiService *ScheduledNotificationAPIService
	accountId *int64
	scheduledNotificationId *int64
	deleteByGroupingId *bool
}

// the id of the logged in user
func (r ApiDeleteScheduledNotificationRequest) AccountId(accountId int64) ApiDeleteScheduledNotificationRequest {
	r.accountId = &accountId
	return r
}

// the id of the scheduled notification to delete
func (r ApiDeleteScheduledNotificationRequest) ScheduledNotificationId(scheduledNotificationId int64) ApiDeleteScheduledNotificationRequest {
	r.scheduledNotificationId = &scheduledNotificationId
	return r
}

// If set to true, also deletes Scheduled Notifications under the same account with the same groupingId.
func (r ApiDeleteScheduledNotificationRequest) DeleteByGroupingId(deleteByGroupingId bool) ApiDeleteScheduledNotificationRequest {
	r.deleteByGroupingId = &deleteByGroupingId
	return r
}

func (r ApiDeleteScheduledNotificationRequest) Execute() (*ScheduledNotificationFullResponse, *http.Response, error) {
	return r.ApiService.DeleteScheduledNotificationExecute(r)
}

/*
DeleteScheduledNotification Delete Scheduled Notification

This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteScheduledNotificationRequest
*/
func (a *ScheduledNotificationAPIService) DeleteScheduledNotification(ctx context.Context) ApiDeleteScheduledNotificationRequest {
	return ApiDeleteScheduledNotificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ScheduledNotificationFullResponse
func (a *ScheduledNotificationAPIService) DeleteScheduledNotificationExecute(r ApiDeleteScheduledNotificationRequest) (*ScheduledNotificationFullResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScheduledNotificationFullResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduledNotificationAPIService.DeleteScheduledNotification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/schedule/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.scheduledNotificationId == nil {
		return localVarReturnValue, nil, reportError("scheduledNotificationId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "scheduledNotificationId", r.scheduledNotificationId, "form", "")
	if r.deleteByGroupingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteByGroupingId", r.deleteByGroupingId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetScheduledNotificationRequest struct {
	ctx context.Context
	ApiService *ScheduledNotificationAPIService
	accountId *int64
	scheduledNotificationId *int64
}

// the id of the account logged in
func (r ApiGetScheduledNotificationRequest) AccountId(accountId int64) ApiGetScheduledNotificationRequest {
	r.accountId = &accountId
	return r
}

// the id of the scheduled notification to get
func (r ApiGetScheduledNotificationRequest) ScheduledNotificationId(scheduledNotificationId int64) ApiGetScheduledNotificationRequest {
	r.scheduledNotificationId = &scheduledNotificationId
	return r
}

func (r ApiGetScheduledNotificationRequest) Execute() (*ScheduledNotificationFullResponse, *http.Response, error) {
	return r.ApiService.GetScheduledNotificationExecute(r)
}

/*
GetScheduledNotification Get Scheduled Notification

Get a ScheduledNotification

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetScheduledNotificationRequest
*/
func (a *ScheduledNotificationAPIService) GetScheduledNotification(ctx context.Context) ApiGetScheduledNotificationRequest {
	return ApiGetScheduledNotificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ScheduledNotificationFullResponse
func (a *ScheduledNotificationAPIService) GetScheduledNotificationExecute(r ApiGetScheduledNotificationRequest) (*ScheduledNotificationFullResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScheduledNotificationFullResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduledNotificationAPIService.GetScheduledNotification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/schedule/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.scheduledNotificationId == nil {
		return localVarReturnValue, nil, reportError("scheduledNotificationId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "scheduledNotificationId", r.scheduledNotificationId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiScheduleNotificationListingsRequest struct {
	ctx context.Context
	ApiService *ScheduledNotificationAPIService
	accountId *int64
	appKey *string
	reportName *string
	message *string
	offset *int32
	recipientReportId *int64
	reportParams *string
	type_ *string
}

// The logged in user.
func (r ApiScheduleNotificationListingsRequest) AccountId(accountId int64) ApiScheduleNotificationListingsRequest {
	r.accountId = &accountId
	return r
}

// The application to target
func (r ApiScheduleNotificationListingsRequest) AppKey(appKey string) ApiScheduleNotificationListingsRequest {
	r.appKey = &appKey
	return r
}

// The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail
func (r ApiScheduleNotificationListingsRequest) ReportName(reportName string) ApiScheduleNotificationListingsRequest {
	r.reportName = &reportName
	return r
}

// The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in
func (r ApiScheduleNotificationListingsRequest) Message(message string) ApiScheduleNotificationListingsRequest {
	r.message = &message
	return r
}

// Time in munites before the event starts to notify recipients
func (r ApiScheduleNotificationListingsRequest) Offset(offset int32) ApiScheduleNotificationListingsRequest {
	r.offset = &offset
	return r
}

// The report id used to generate the recipient list
func (r ApiScheduleNotificationListingsRequest) RecipientReportId(recipientReportId int64) ApiScheduleNotificationListingsRequest {
	r.recipientReportId = &recipientReportId
	return r
}

// The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60; 
func (r ApiScheduleNotificationListingsRequest) ReportParams(reportParams string) ApiScheduleNotificationListingsRequest {
	r.reportParams = &reportParams
	return r
}

// The type of scheduled notification; supported values are: MOBILE_NOTIFICATION
func (r ApiScheduleNotificationListingsRequest) Type_(type_ string) ApiScheduleNotificationListingsRequest {
	r.type_ = &type_
	return r
}

func (r ApiScheduleNotificationListingsRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.ScheduleNotificationListingsExecute(r)
}

/*
ScheduleNotificationListings Generate Schedule Notifications

Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScheduleNotificationListingsRequest
*/
func (a *ScheduledNotificationAPIService) ScheduleNotificationListings(ctx context.Context) ApiScheduleNotificationListingsRequest {
	return ApiScheduleNotificationListingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ScheduledNotificationAPIService) ScheduleNotificationListingsExecute(r ApiScheduleNotificationListingsRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduledNotificationAPIService.ScheduleNotificationListings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/schedule/generate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.reportName == nil {
		return localVarReturnValue, nil, reportError("reportName is required and must be specified")
	}
	if r.message == nil {
		return localVarReturnValue, nil, reportError("message is required and must be specified")
	}
	if r.offset == nil {
		return localVarReturnValue, nil, reportError("offset is required and must be specified")
	}
	if r.recipientReportId == nil {
		return localVarReturnValue, nil, reportError("recipientReportId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "reportName", r.reportName, "form", "")
	if r.reportParams != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reportParams", r.reportParams, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "message", r.message, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "recipientReportId", r.recipientReportId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchScheduledNotificationsRequest struct {
	ctx context.Context
	ApiService *ScheduledNotificationAPIService
	accountId *int64
	groupingId *string
	audienceId *int64
	filter *string
	types *string
	contentIds *string
	contentTypes *string
	parentIds *string
	parentTypes *string
	statuses *string
	templateTypes *string
	appKey *string
	keyword *string
	sortField *string
	descending *bool
	start *int32
	limit *int32
	activeOnly *bool
	groupByGroupingId *bool
	returnAudienceAccountCount *bool
}

// The logged in user.
func (r ApiSearchScheduledNotificationsRequest) AccountId(accountId int64) ApiSearchScheduledNotificationsRequest {
	r.accountId = &accountId
	return r
}

// Filter results by a grouping identifier defined by the client
func (r ApiSearchScheduledNotificationsRequest) GroupingId(groupingId string) ApiSearchScheduledNotificationsRequest {
	r.groupingId = &groupingId
	return r
}

// Filter results by audience
func (r ApiSearchScheduledNotificationsRequest) AudienceId(audienceId int64) ApiSearchScheduledNotificationsRequest {
	r.audienceId = &audienceId
	return r
}

// a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications.
func (r ApiSearchScheduledNotificationsRequest) Filter(filter string) ApiSearchScheduledNotificationsRequest {
	r.filter = &filter
	return r
}

// Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION
func (r ApiSearchScheduledNotificationsRequest) Types(types string) ApiSearchScheduledNotificationsRequest {
	r.types = &types
	return r
}

// search using content IDs
func (r ApiSearchScheduledNotificationsRequest) ContentIds(contentIds string) ApiSearchScheduledNotificationsRequest {
	r.contentIds = &contentIds
	return r
}

// search using content types
func (r ApiSearchScheduledNotificationsRequest) ContentTypes(contentTypes string) ApiSearchScheduledNotificationsRequest {
	r.contentTypes = &contentTypes
	return r
}

// search using parent IDs
func (r ApiSearchScheduledNotificationsRequest) ParentIds(parentIds string) ApiSearchScheduledNotificationsRequest {
	r.parentIds = &parentIds
	return r
}

// search using parent types
func (r ApiSearchScheduledNotificationsRequest) ParentTypes(parentTypes string) ApiSearchScheduledNotificationsRequest {
	r.parentTypes = &parentTypes
	return r
}

// Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending
func (r ApiSearchScheduledNotificationsRequest) Statuses(statuses string) ApiSearchScheduledNotificationsRequest {
	r.statuses = &statuses
	return r
}

// 
func (r ApiSearchScheduledNotificationsRequest) TemplateTypes(templateTypes string) ApiSearchScheduledNotificationsRequest {
	r.templateTypes = &templateTypes
	return r
}

// Filter the list by a specific application
func (r ApiSearchScheduledNotificationsRequest) AppKey(appKey string) ApiSearchScheduledNotificationsRequest {
	r.appKey = &appKey
	return r
}

// Keyword search on the scheduled notification names.
func (r ApiSearchScheduledNotificationsRequest) Keyword(keyword string) ApiSearchScheduledNotificationsRequest {
	r.keyword = &keyword
	return r
}

// The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date
func (r ApiSearchScheduledNotificationsRequest) SortField(sortField string) ApiSearchScheduledNotificationsRequest {
	r.sortField = &sortField
	return r
}

// Determines whether the sorted list is in descending or ascending order
func (r ApiSearchScheduledNotificationsRequest) Descending(descending bool) ApiSearchScheduledNotificationsRequest {
	r.descending = &descending
	return r
}

// Start the result set at some index.
func (r ApiSearchScheduledNotificationsRequest) Start(start int32) ApiSearchScheduledNotificationsRequest {
	r.start = &start
	return r
}

// Limit the result to some number.
func (r ApiSearchScheduledNotificationsRequest) Limit(limit int32) ApiSearchScheduledNotificationsRequest {
	r.limit = &limit
	return r
}

// Determines whether to return only active results
func (r ApiSearchScheduledNotificationsRequest) ActiveOnly(activeOnly bool) ApiSearchScheduledNotificationsRequest {
	r.activeOnly = &activeOnly
	return r
}

// Determines whether to group results with the same groupingId together.
func (r ApiSearchScheduledNotificationsRequest) GroupByGroupingId(groupByGroupingId bool) ApiSearchScheduledNotificationsRequest {
	r.groupByGroupingId = &groupByGroupingId
	return r
}

// If true, include audience account counts in the response
func (r ApiSearchScheduledNotificationsRequest) ReturnAudienceAccountCount(returnAudienceAccountCount bool) ApiSearchScheduledNotificationsRequest {
	r.returnAudienceAccountCount = &returnAudienceAccountCount
	return r
}

func (r ApiSearchScheduledNotificationsRequest) Execute() (*ScheduledNotificationFullResponse, *http.Response, error) {
	return r.ApiService.SearchScheduledNotificationsExecute(r)
}

/*
SearchScheduledNotifications Search Scheduled Notifications

This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.

In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchScheduledNotificationsRequest
*/
func (a *ScheduledNotificationAPIService) SearchScheduledNotifications(ctx context.Context) ApiSearchScheduledNotificationsRequest {
	return ApiSearchScheduledNotificationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ScheduledNotificationFullResponse
func (a *ScheduledNotificationAPIService) SearchScheduledNotificationsExecute(r ApiSearchScheduledNotificationsRequest) (*ScheduledNotificationFullResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScheduledNotificationFullResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduledNotificationAPIService.SearchScheduledNotifications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/schedule/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.groupingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupingId", r.groupingId, "form", "")
	}
	if r.audienceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceId", r.audienceId, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.types != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "types", r.types, "form", "")
	}
	if r.contentIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentIds", r.contentIds, "form", "")
	}
	if r.contentTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentTypes", r.contentTypes, "form", "")
	}
	if r.parentIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentIds", r.parentIds, "form", "")
	}
	if r.parentTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentTypes", r.parentTypes, "form", "")
	}
	if r.statuses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", r.statuses, "form", "")
	}
	if r.templateTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "templateTypes", r.templateTypes, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	}
	if r.groupByGroupingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupByGroupingId", r.groupByGroupingId, "form", "")
	}
	if r.returnAudienceAccountCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnAudienceAccountCount", r.returnAudienceAccountCount, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateScheduledNotificationRequest struct {
	ctx context.Context
	ApiService *ScheduledNotificationAPIService
	scheduledNotificationId *int64
	accountId *int64
	name *string
	type_ *string
	message *string
	payload *string
	contentId *int64
	contentName *string
	contentType *string
	parentId *int64
	parentType *string
	appKey *string
	groupingId *string
	connectionGroupIds *string
	connectionAccountIds *string
	audienceId *int64
	audienceIds *string
	albumIds *string
	reportId *int64
	reportParams *string
	endpointURL *string
	scheduledDate *int64
	startDate *int64
	endDate *int64
	cronExpression *string
	cronType *string
	metaData *string
	conditionalInput *string
	templateType *string
	visibility *string
	active *bool
	errorMessage *string
	status *string
	updateByGroupingId *bool
	sendNow *bool
	eventType *string
	deepLinkURI *string
	sendToAll *bool
}

// The id of scheduled notification to update
func (r ApiUpdateScheduledNotificationRequest) ScheduledNotificationId(scheduledNotificationId int64) ApiUpdateScheduledNotificationRequest {
	r.scheduledNotificationId = &scheduledNotificationId
	return r
}

// The logged in user.
func (r ApiUpdateScheduledNotificationRequest) AccountId(accountId int64) ApiUpdateScheduledNotificationRequest {
	r.accountId = &accountId
	return r
}

// The name of the scheduled notification
func (r ApiUpdateScheduledNotificationRequest) Name(name string) ApiUpdateScheduledNotificationRequest {
	r.name = &name
	return r
}

// The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
func (r ApiUpdateScheduledNotificationRequest) Type_(type_ string) ApiUpdateScheduledNotificationRequest {
	r.type_ = &type_
	return r
}

// The message to send
func (r ApiUpdateScheduledNotificationRequest) Message(message string) ApiUpdateScheduledNotificationRequest {
	r.message = &message
	return r
}

// The parameters for making an HTTP call
func (r ApiUpdateScheduledNotificationRequest) Payload(payload string) ApiUpdateScheduledNotificationRequest {
	r.payload = &payload
	return r
}

// The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
func (r ApiUpdateScheduledNotificationRequest) ContentId(contentId int64) ApiUpdateScheduledNotificationRequest {
	r.contentId = &contentId
	return r
}

// The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
func (r ApiUpdateScheduledNotificationRequest) ContentName(contentName string) ApiUpdateScheduledNotificationRequest {
	r.contentName = &contentName
	return r
}

// The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
func (r ApiUpdateScheduledNotificationRequest) ContentType(contentType string) ApiUpdateScheduledNotificationRequest {
	r.contentType = &contentType
	return r
}

// The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
func (r ApiUpdateScheduledNotificationRequest) ParentId(parentId int64) ApiUpdateScheduledNotificationRequest {
	r.parentId = &parentId
	return r
}

// The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
func (r ApiUpdateScheduledNotificationRequest) ParentType(parentType string) ApiUpdateScheduledNotificationRequest {
	r.parentType = &parentType
	return r
}

// The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
func (r ApiUpdateScheduledNotificationRequest) AppKey(appKey string) ApiUpdateScheduledNotificationRequest {
	r.appKey = &appKey
	return r
}

// Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
func (r ApiUpdateScheduledNotificationRequest) GroupingId(groupingId string) ApiUpdateScheduledNotificationRequest {
	r.groupingId = &groupingId
	return r
}

// The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
func (r ApiUpdateScheduledNotificationRequest) ConnectionGroupIds(connectionGroupIds string) ApiUpdateScheduledNotificationRequest {
	r.connectionGroupIds = &connectionGroupIds
	return r
}

// The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
func (r ApiUpdateScheduledNotificationRequest) ConnectionAccountIds(connectionAccountIds string) ApiUpdateScheduledNotificationRequest {
	r.connectionAccountIds = &connectionAccountIds
	return r
}

// This parameter is deprecated. The audience used to generate the list of recipients
func (r ApiUpdateScheduledNotificationRequest) AudienceId(audienceId int64) ApiUpdateScheduledNotificationRequest {
	r.audienceId = &audienceId
	return r
}

// The audiences used to generate the list of recipients (comma separated list of audience IDs)
func (r ApiUpdateScheduledNotificationRequest) AudienceIds(audienceIds string) ApiUpdateScheduledNotificationRequest {
	r.audienceIds = &audienceIds
	return r
}

// The album ids to associate with the scheduled notification (comma separated list of album IDs)
func (r ApiUpdateScheduledNotificationRequest) AlbumIds(albumIds string) ApiUpdateScheduledNotificationRequest {
	r.albumIds = &albumIds
	return r
}

// The report used to generate the the list of recipients
func (r ApiUpdateScheduledNotificationRequest) ReportId(reportId int64) ApiUpdateScheduledNotificationRequest {
	r.reportId = &reportId
	return r
}

// The parameters to supply to the report used to generate the the list of recipients
func (r ApiUpdateScheduledNotificationRequest) ReportParams(reportParams string) ApiUpdateScheduledNotificationRequest {
	r.reportParams = &reportParams
	return r
}

// The URL for making an HTTP call
func (r ApiUpdateScheduledNotificationRequest) EndpointURL(endpointURL string) ApiUpdateScheduledNotificationRequest {
	r.endpointURL = &endpointURL
	return r
}

// The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
func (r ApiUpdateScheduledNotificationRequest) ScheduledDate(scheduledDate int64) ApiUpdateScheduledNotificationRequest {
	r.scheduledDate = &scheduledDate
	return r
}

// The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
func (r ApiUpdateScheduledNotificationRequest) StartDate(startDate int64) ApiUpdateScheduledNotificationRequest {
	r.startDate = &startDate
	return r
}

// The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
func (r ApiUpdateScheduledNotificationRequest) EndDate(endDate int64) ApiUpdateScheduledNotificationRequest {
	r.endDate = &endDate
	return r
}

// The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
func (r ApiUpdateScheduledNotificationRequest) CronExpression(cronExpression string) ApiUpdateScheduledNotificationRequest {
	r.cronExpression = &cronExpression
	return r
}

// The cron expression type: UNIX, CRON4J, QUARTZ
func (r ApiUpdateScheduledNotificationRequest) CronType(cronType string) ApiUpdateScheduledNotificationRequest {
	r.cronType = &cronType
	return r
}

// Additional metadata for the scheduled notification
func (r ApiUpdateScheduledNotificationRequest) MetaData(metaData string) ApiUpdateScheduledNotificationRequest {
	r.metaData = &metaData
	return r
}

// Json input representing conditional logic that has to be met before running the scheduled notification
func (r ApiUpdateScheduledNotificationRequest) ConditionalInput(conditionalInput string) ApiUpdateScheduledNotificationRequest {
	r.conditionalInput = &conditionalInput
	return r
}

// This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
func (r ApiUpdateScheduledNotificationRequest) TemplateType(templateType string) ApiUpdateScheduledNotificationRequest {
	r.templateType = &templateType
	return r
}

// Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
func (r ApiUpdateScheduledNotificationRequest) Visibility(visibility string) ApiUpdateScheduledNotificationRequest {
	r.visibility = &visibility
	return r
}

// Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule.
func (r ApiUpdateScheduledNotificationRequest) Active(active bool) ApiUpdateScheduledNotificationRequest {
	r.active = &active
	return r
}

// the error message associated with the scheduled notification
func (r ApiUpdateScheduledNotificationRequest) ErrorMessage(errorMessage string) ApiUpdateScheduledNotificationRequest {
	r.errorMessage = &errorMessage
	return r
}

// the status of the scheduled notification
func (r ApiUpdateScheduledNotificationRequest) Status(status string) ApiUpdateScheduledNotificationRequest {
	r.status = &status
	return r
}

// also updates ScheduledNotifications with the same groupingId and account
func (r ApiUpdateScheduledNotificationRequest) UpdateByGroupingId(updateByGroupingId bool) ApiUpdateScheduledNotificationRequest {
	r.updateByGroupingId = &updateByGroupingId
	return r
}

// whether to send the scheduled notification now or not
func (r ApiUpdateScheduledNotificationRequest) SendNow(sendNow bool) ApiUpdateScheduledNotificationRequest {
	r.sendNow = &sendNow
	return r
}

// Sets the event type for the notification
func (r ApiUpdateScheduledNotificationRequest) EventType(eventType string) ApiUpdateScheduledNotificationRequest {
	r.eventType = &eventType
	return r
}

// The payload deep link URI that can be used by the client app to direct users to a screen in the app
func (r ApiUpdateScheduledNotificationRequest) DeepLinkURI(deepLinkURI string) ApiUpdateScheduledNotificationRequest {
	r.deepLinkURI = &deepLinkURI
	return r
}

// Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
func (r ApiUpdateScheduledNotificationRequest) SendToAll(sendToAll bool) ApiUpdateScheduledNotificationRequest {
	r.sendToAll = &sendToAll
	return r
}

func (r ApiUpdateScheduledNotificationRequest) Execute() (*ScheduledNotificationFullResponse, *http.Response, error) {
	return r.ApiService.UpdateScheduledNotificationExecute(r)
}

/*
UpdateScheduledNotification Update Scheduled Notification

This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.

Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateScheduledNotificationRequest
*/
func (a *ScheduledNotificationAPIService) UpdateScheduledNotification(ctx context.Context) ApiUpdateScheduledNotificationRequest {
	return ApiUpdateScheduledNotificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ScheduledNotificationFullResponse
func (a *ScheduledNotificationAPIService) UpdateScheduledNotificationExecute(r ApiUpdateScheduledNotificationRequest) (*ScheduledNotificationFullResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScheduledNotificationFullResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduledNotificationAPIService.UpdateScheduledNotification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notification/schedule/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.scheduledNotificationId == nil {
		return localVarReturnValue, nil, reportError("scheduledNotificationId is required and must be specified")
	}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "scheduledNotificationId", r.scheduledNotificationId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.message != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "message", r.message, "form", "")
	}
	if r.payload != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payload", r.payload, "form", "")
	}
	if r.contentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentId", r.contentId, "form", "")
	}
	if r.contentName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentName", r.contentName, "form", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentType", r.contentType, "form", "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentId", r.parentId, "form", "")
	}
	if r.parentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentType", r.parentType, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.groupingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupingId", r.groupingId, "form", "")
	}
	if r.connectionGroupIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionGroupIds", r.connectionGroupIds, "form", "")
	}
	if r.connectionAccountIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountIds", r.connectionAccountIds, "form", "")
	}
	if r.audienceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceId", r.audienceId, "form", "")
	}
	if r.audienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIds", r.audienceIds, "form", "")
	}
	if r.albumIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumIds", r.albumIds, "form", "")
	}
	if r.reportId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reportId", r.reportId, "form", "")
	}
	if r.reportParams != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reportParams", r.reportParams, "form", "")
	}
	if r.endpointURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endpointURL", r.endpointURL, "form", "")
	}
	if r.scheduledDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduledDate", r.scheduledDate, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.cronExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cronExpression", r.cronExpression, "form", "")
	}
	if r.cronType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cronType", r.cronType, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.conditionalInput != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conditionalInput", r.conditionalInput, "form", "")
	}
	if r.templateType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "templateType", r.templateType, "form", "")
	}
	if r.visibility != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visibility", r.visibility, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.errorMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "errorMessage", r.errorMessage, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.updateByGroupingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateByGroupingId", r.updateByGroupingId, "form", "")
	}
	if r.sendNow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sendNow", r.sendNow, "form", "")
	}
	if r.eventType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventType", r.eventType, "form", "")
	} else {
		var defaultValue string = "CUSTOM"
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventType", defaultValue, "form", "")
		r.eventType = &defaultValue
	}
	if r.deepLinkURI != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deepLinkURI", r.deepLinkURI, "form", "")
	}
	if r.sendToAll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sendToAll", r.sendToAll, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
