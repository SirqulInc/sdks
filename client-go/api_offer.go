/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// OfferAPIService OfferAPI service
type OfferAPIService service

type ApiBatchUpdateOfferLocationsRequest struct {
	ctx context.Context
	ApiService *OfferAPIService
	version float32
	data *string
	deviceId *string
	accountId *int64
}

// JSON string in the following format: &#x60;&#x60;&#x60;json [{   \&quot;offerLocationId\&quot;: 1705,   \&quot;latitude\&quot;: 54.0,   \&quot;longitude\&quot;: -122.0,   \&quot;altitude\&quot;: 1.0,   \&quot;locationDetail\&quot;: \&quot;floor 1\&quot;,   \&quot;locationDescription\&quot;: \&quot;behind the Coke sign\&quot; }, {   \&quot;offerLocationId\&quot;: 1704,   \&quot;latitude\&quot;: 54.1,   \&quot;longitude\&quot;: -122.1 }] &#x60;&#x60;&#x60; 
func (r ApiBatchUpdateOfferLocationsRequest) Data(data string) ApiBatchUpdateOfferLocationsRequest {
	r.data = &data
	return r
}

// The device id (deviceId or accountId required)
func (r ApiBatchUpdateOfferLocationsRequest) DeviceId(deviceId string) ApiBatchUpdateOfferLocationsRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiBatchUpdateOfferLocationsRequest) AccountId(accountId int64) ApiBatchUpdateOfferLocationsRequest {
	r.accountId = &accountId
	return r
}

func (r ApiBatchUpdateOfferLocationsRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.BatchUpdateOfferLocationsExecute(r)
}

/*
BatchUpdateOfferLocations Update Offer Locations

Batch update offer locations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiBatchUpdateOfferLocationsRequest
*/
func (a *OfferAPIService) BatchUpdateOfferLocations(ctx context.Context, version float32) ApiBatchUpdateOfferLocationsRequest {
	return ApiBatchUpdateOfferLocationsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *OfferAPIService) BatchUpdateOfferLocationsExecute(r ApiBatchUpdateOfferLocationsRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OfferAPIService.BatchUpdateOfferLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/retailer/offer/location/batchUpdate"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "data", r.data, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOfferRequest struct {
	ctx context.Context
	ApiService *OfferAPIService
	version float32
	includeOfferLocations *bool
	title *string
	barcodeType *string
	noExpiration *bool
	availableLimit *int32
	availableLimitPerUser *int32
	addedLimit *int32
	viewLimit *int32
	maxPrints *int32
	ticketPrice *int64
	fullPrice *float64
	discountPrice *float64
	offerType *string
	specialOfferType *string
	offerVisibility *string
	active *bool
	deviceId *string
	accountId *int64
	tags *string
	parentOfferId *int64
	retailerLocationIds *string
	offerLocations *string
	subTitle *string
	details *string
	subDetails *string
	finePrint *string
	barcodeEntry *string
	externalRedeemOptions *string
	externalUrl *string
	externalId *string
	ticketsRewardType *string
	ticketsReward *int64
	activated *int64
	expires *int64
	ticketPriceType *string
	showRemaining *bool
	showRedeemed *bool
	replaced *bool
	featured *bool
	categoryIds *string
	filterIds *string
	barcodeAssetId *int64
	imageAssetId *int64
	imageAssetId1 *int64
	imageAssetId2 *int64
	imageAssetId3 *int64
	imageAssetId4 *int64
	imageAssetId5 *int64
	publisher *string
	redeemableStart *int64
	redeemableEnd *int64
	brand *string
	productType *string
	conditionType *string
	isbn *string
	asin *string
	catalogNumbers *string
	department *string
	features *string
	minimumPrice *float64
	width *float64
	height *float64
	depth *float64
	weight *float64
	unit *string
	studio *string
	parentalRating *string
	publishDate *int64
	availabilityDate *int64
	sizeId *int64
	listingId *int64
	mediaType *string
	duration *int32
	author *string
	releaseDate *int64
	collectionIds *string
	rebootTimeHour *int32
	rebootTimeMinute *int32
	idleTimeoutInSecond *int32
	serialNumber *string
	udid *string
	deviceType *string
	devicePower *float64
	deviceInterference *float64
	availability *string
	availabilitySummary *string
}

// If true return all the offer locations associated with the offer
func (r ApiCreateOfferRequest) IncludeOfferLocations(includeOfferLocations bool) ApiCreateOfferRequest {
	r.includeOfferLocations = &includeOfferLocations
	return r
}

// The title (255 char limit)
func (r ApiCreateOfferRequest) Title(title string) ApiCreateOfferRequest {
	r.title = &title
	return r
}

// The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}
func (r ApiCreateOfferRequest) BarcodeType(barcodeType string) ApiCreateOfferRequest {
	r.barcodeType = &barcodeType
	return r
}

// Overrides the expiration date so that the offer does not expire
func (r ApiCreateOfferRequest) NoExpiration(noExpiration bool) ApiCreateOfferRequest {
	r.noExpiration = &noExpiration
	return r
}

// The limit of how many times the offer can be used by consumers
func (r ApiCreateOfferRequest) AvailableLimit(availableLimit int32) ApiCreateOfferRequest {
	r.availableLimit = &availableLimit
	return r
}

// The limit of how many times a user can used the same offer
func (r ApiCreateOfferRequest) AvailableLimitPerUser(availableLimitPerUser int32) ApiCreateOfferRequest {
	r.availableLimitPerUser = &availableLimitPerUser
	return r
}

// The limit of how many times the offer can be added to consumer wallets
func (r ApiCreateOfferRequest) AddedLimit(addedLimit int32) ApiCreateOfferRequest {
	r.addedLimit = &addedLimit
	return r
}

// The limit of how many times the offer can be viewed
func (r ApiCreateOfferRequest) ViewLimit(viewLimit int32) ApiCreateOfferRequest {
	r.viewLimit = &viewLimit
	return r
}

// The maximum number of times the offer can be printed
func (r ApiCreateOfferRequest) MaxPrints(maxPrints int32) ApiCreateOfferRequest {
	r.maxPrints = &maxPrints
	return r
}

// The cost of the offer in tickets
func (r ApiCreateOfferRequest) TicketPrice(ticketPrice int64) ApiCreateOfferRequest {
	r.ticketPrice = &ticketPrice
	return r
}

// The retail/full price cost of the offer in real currency
func (r ApiCreateOfferRequest) FullPrice(fullPrice float64) ApiCreateOfferRequest {
	r.fullPrice = &fullPrice
	return r
}

// The cost of the offer at a discounted price (what the consumer pays)
func (r ApiCreateOfferRequest) DiscountPrice(discountPrice float64) ApiCreateOfferRequest {
	r.discountPrice = &discountPrice
	return r
}

// The offer type {VOUCHER, COUPON, PRODUCT, EVENT, MEDIA, DEVICE}
func (r ApiCreateOfferRequest) OfferType(offerType string) ApiCreateOfferRequest {
	r.offerType = &offerType
	return r
}

// The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
func (r ApiCreateOfferRequest) SpecialOfferType(specialOfferType string) ApiCreateOfferRequest {
	r.specialOfferType = &specialOfferType
	return r
}

// The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}
func (r ApiCreateOfferRequest) OfferVisibility(offerVisibility string) ApiCreateOfferRequest {
	r.offerVisibility = &offerVisibility
	return r
}

// Sets the active flag
func (r ApiCreateOfferRequest) Active(active bool) ApiCreateOfferRequest {
	r.active = &active
	return r
}

// The device id (deviceId or accountId required)
func (r ApiCreateOfferRequest) DeviceId(deviceId string) ApiCreateOfferRequest {
	r.deviceId = &deviceId
	return r
}

// The account id (deviceId or accountId required)
func (r ApiCreateOfferRequest) AccountId(accountId int64) ApiCreateOfferRequest {
	r.accountId = &accountId
	return r
}

// Custom string field for doing full-text searches
func (r ApiCreateOfferRequest) Tags(tags string) ApiCreateOfferRequest {
	r.tags = &tags
	return r
}

// the parent offer id
func (r ApiCreateOfferRequest) ParentOfferId(parentOfferId int64) ApiCreateOfferRequest {
	r.parentOfferId = &parentOfferId
	return r
}

// Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
func (r ApiCreateOfferRequest) RetailerLocationIds(retailerLocationIds string) ApiCreateOfferRequest {
	r.retailerLocationIds = &retailerLocationIds
	return r
}

// A list of json data that has offer location specific values.
func (r ApiCreateOfferRequest) OfferLocations(offerLocations string) ApiCreateOfferRequest {
	r.offerLocations = &offerLocations
	return r
}

// The sub title (255 char limit)
func (r ApiCreateOfferRequest) SubTitle(subTitle string) ApiCreateOfferRequest {
	r.subTitle = &subTitle
	return r
}

// The details
func (r ApiCreateOfferRequest) Details(details string) ApiCreateOfferRequest {
	r.details = &details
	return r
}

// A string for custom details (255 char limit)
func (r ApiCreateOfferRequest) SubDetails(subDetails string) ApiCreateOfferRequest {
	r.subDetails = &subDetails
	return r
}

// The fine print
func (r ApiCreateOfferRequest) FinePrint(finePrint string) ApiCreateOfferRequest {
	r.finePrint = &finePrint
	return r
}

// The bar code entry string
func (r ApiCreateOfferRequest) BarcodeEntry(barcodeEntry string) ApiCreateOfferRequest {
	r.barcodeEntry = &barcodeEntry
	return r
}

// An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer
func (r ApiCreateOfferRequest) ExternalRedeemOptions(externalRedeemOptions string) ApiCreateOfferRequest {
	r.externalRedeemOptions = &externalRedeemOptions
	return r
}

// The clickUrl of the offer
func (r ApiCreateOfferRequest) ExternalUrl(externalUrl string) ApiCreateOfferRequest {
	r.externalUrl = &externalUrl
	return r
}

// an external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer
func (r ApiCreateOfferRequest) ExternalId(externalId string) ApiCreateOfferRequest {
	r.externalId = &externalId
	return r
}

// The type of ticket to reward, null means default type
func (r ApiCreateOfferRequest) TicketsRewardType(ticketsRewardType string) ApiCreateOfferRequest {
	r.ticketsRewardType = &ticketsRewardType
	return r
}

// Determines how many tickets are awarded
func (r ApiCreateOfferRequest) TicketsReward(ticketsReward int64) ApiCreateOfferRequest {
	r.ticketsReward = &ticketsReward
	return r
}

// The date of when the offer will be visible to consumers
func (r ApiCreateOfferRequest) Activated(activated int64) ApiCreateOfferRequest {
	r.activated = &activated
	return r
}

// The date of when the offer expires
func (r ApiCreateOfferRequest) Expires(expires int64) ApiCreateOfferRequest {
	r.expires = &expires
	return r
}

// the type of ticket needed to buy offer
func (r ApiCreateOfferRequest) TicketPriceType(ticketPriceType string) ApiCreateOfferRequest {
	r.ticketPriceType = &ticketPriceType
	return r
}

// show remaining offers available
func (r ApiCreateOfferRequest) ShowRemaining(showRemaining bool) ApiCreateOfferRequest {
	r.showRemaining = &showRemaining
	return r
}

// show how many offers have been redeemed
func (r ApiCreateOfferRequest) ShowRedeemed(showRedeemed bool) ApiCreateOfferRequest {
	r.showRedeemed = &showRedeemed
	return r
}

// 
func (r ApiCreateOfferRequest) Replaced(replaced bool) ApiCreateOfferRequest {
	r.replaced = &replaced
	return r
}

// flag if offer is featured or not
func (r ApiCreateOfferRequest) Featured(featured bool) ApiCreateOfferRequest {
	r.featured = &featured
	return r
}

// Comma separated list of category ids
func (r ApiCreateOfferRequest) CategoryIds(categoryIds string) ApiCreateOfferRequest {
	r.categoryIds = &categoryIds
	return r
}

// Comma separated list of filter ids
func (r ApiCreateOfferRequest) FilterIds(filterIds string) ApiCreateOfferRequest {
	r.filterIds = &filterIds
	return r
}

// The id of the barcode asset
func (r ApiCreateOfferRequest) BarcodeAssetId(barcodeAssetId int64) ApiCreateOfferRequest {
	r.barcodeAssetId = &barcodeAssetId
	return r
}

// The id of the an offer asset
func (r ApiCreateOfferRequest) ImageAssetId(imageAssetId int64) ApiCreateOfferRequest {
	r.imageAssetId = &imageAssetId
	return r
}

// The id of the an offer asset
func (r ApiCreateOfferRequest) ImageAssetId1(imageAssetId1 int64) ApiCreateOfferRequest {
	r.imageAssetId1 = &imageAssetId1
	return r
}

// The id of the an offer asset
func (r ApiCreateOfferRequest) ImageAssetId2(imageAssetId2 int64) ApiCreateOfferRequest {
	r.imageAssetId2 = &imageAssetId2
	return r
}

// The id of the an offer asset
func (r ApiCreateOfferRequest) ImageAssetId3(imageAssetId3 int64) ApiCreateOfferRequest {
	r.imageAssetId3 = &imageAssetId3
	return r
}

// The id of the an offer asset
func (r ApiCreateOfferRequest) ImageAssetId4(imageAssetId4 int64) ApiCreateOfferRequest {
	r.imageAssetId4 = &imageAssetId4
	return r
}

// The id of the an offer asset
func (r ApiCreateOfferRequest) ImageAssetId5(imageAssetId5 int64) ApiCreateOfferRequest {
	r.imageAssetId5 = &imageAssetId5
	return r
}

// The maker of the item.
func (r ApiCreateOfferRequest) Publisher(publisher string) ApiCreateOfferRequest {
	r.publisher = &publisher
	return r
}

// The redeemable start date/time of the offer.
func (r ApiCreateOfferRequest) RedeemableStart(redeemableStart int64) ApiCreateOfferRequest {
	r.redeemableStart = &redeemableStart
	return r
}

// The redeemable start date/time of the offer.
func (r ApiCreateOfferRequest) RedeemableEnd(redeemableEnd int64) ApiCreateOfferRequest {
	r.redeemableEnd = &redeemableEnd
	return r
}

// The brand. OfferType PRODUCT only.
func (r ApiCreateOfferRequest) Brand(brand string) ApiCreateOfferRequest {
	r.brand = &brand
	return r
}

// The product type. OfferType PRODUCT only.
func (r ApiCreateOfferRequest) ProductType(productType string) ApiCreateOfferRequest {
	r.productType = &productType
	return r
}

// The condition. OfferType PRODUCT only.
func (r ApiCreateOfferRequest) ConditionType(conditionType string) ApiCreateOfferRequest {
	r.conditionType = &conditionType
	return r
}

// The ISBN id. OfferType PRODUCT only.
func (r ApiCreateOfferRequest) Isbn(isbn string) ApiCreateOfferRequest {
	r.isbn = &isbn
	return r
}

// The ASIN id. OfferType PRODUCT only.
func (r ApiCreateOfferRequest) Asin(asin string) ApiCreateOfferRequest {
	r.asin = &asin
	return r
}

// The list of catelog numbers, comma seperated. OfferType PRODUCT only.
func (r ApiCreateOfferRequest) CatalogNumbers(catalogNumbers string) ApiCreateOfferRequest {
	r.catalogNumbers = &catalogNumbers
	return r
}

// The department name. The OfferType PRODUCT only.
func (r ApiCreateOfferRequest) Department(department string) ApiCreateOfferRequest {
	r.department = &department
	return r
}

// The list of features, comma seperated. OfferType PRODUCT only.
func (r ApiCreateOfferRequest) Features(features string) ApiCreateOfferRequest {
	r.features = &features
	return r
}

// The MAP price. OfferType PRODUCT only.
func (r ApiCreateOfferRequest) MinimumPrice(minimumPrice float64) ApiCreateOfferRequest {
	r.minimumPrice = &minimumPrice
	return r
}

// The width of the item. OfferType PRODUCT only.
func (r ApiCreateOfferRequest) Width(width float64) ApiCreateOfferRequest {
	r.width = &width
	return r
}

// The height of the item. OfferType PRODUCT only.
func (r ApiCreateOfferRequest) Height(height float64) ApiCreateOfferRequest {
	r.height = &height
	return r
}

// The depth of the item. OfferType PRODUCT only.
func (r ApiCreateOfferRequest) Depth(depth float64) ApiCreateOfferRequest {
	r.depth = &depth
	return r
}

// The weight of the item. OfferType PRODUCT only.
func (r ApiCreateOfferRequest) Weight(weight float64) ApiCreateOfferRequest {
	r.weight = &weight
	return r
}

// The unit of measurement. OfferType PRODUCT only.
func (r ApiCreateOfferRequest) Unit(unit string) ApiCreateOfferRequest {
	r.unit = &unit
	return r
}

// The studio name. OfferType PRODUCT only.
func (r ApiCreateOfferRequest) Studio(studio string) ApiCreateOfferRequest {
	r.studio = &studio
	return r
}

// The parental control rating. OfferType PRODUCT only.
func (r ApiCreateOfferRequest) ParentalRating(parentalRating string) ApiCreateOfferRequest {
	r.parentalRating = &parentalRating
	return r
}

// The date published. OfferType PRODUCT only.
func (r ApiCreateOfferRequest) PublishDate(publishDate int64) ApiCreateOfferRequest {
	r.publishDate = &publishDate
	return r
}

// The date available. OfferType PRODUCT only.
func (r ApiCreateOfferRequest) AvailabilityDate(availabilityDate int64) ApiCreateOfferRequest {
	r.availabilityDate = &availabilityDate
	return r
}

// 
func (r ApiCreateOfferRequest) SizeId(sizeId int64) ApiCreateOfferRequest {
	r.sizeId = &sizeId
	return r
}

// The ID of the event listing
func (r ApiCreateOfferRequest) ListingId(listingId int64) ApiCreateOfferRequest {
	r.listingId = &listingId
	return r
}

// the media type of the offer
func (r ApiCreateOfferRequest) MediaType(mediaType string) ApiCreateOfferRequest {
	r.mediaType = &mediaType
	return r
}

// The total playing time of the media item. OfferType MEDIA only.
func (r ApiCreateOfferRequest) Duration(duration int32) ApiCreateOfferRequest {
	r.duration = &duration
	return r
}

// The created/author of the media item. OfferType MEDIA only.
func (r ApiCreateOfferRequest) Author(author string) ApiCreateOfferRequest {
	r.author = &author
	return r
}

// The date/time of when the media item was originally released. OfferType MEDIA only.
func (r ApiCreateOfferRequest) ReleaseDate(releaseDate int64) ApiCreateOfferRequest {
	r.releaseDate = &releaseDate
	return r
}

// 
func (r ApiCreateOfferRequest) CollectionIds(collectionIds string) ApiCreateOfferRequest {
	r.collectionIds = &collectionIds
	return r
}

// The reboot hour time ranging from 0 to 23
func (r ApiCreateOfferRequest) RebootTimeHour(rebootTimeHour int32) ApiCreateOfferRequest {
	r.rebootTimeHour = &rebootTimeHour
	return r
}

// The reboot minute time ranging from 0 to 59
func (r ApiCreateOfferRequest) RebootTimeMinute(rebootTimeMinute int32) ApiCreateOfferRequest {
	r.rebootTimeMinute = &rebootTimeMinute
	return r
}

// If the device is idle for idleTimeoutInSecond then the device should timeout
func (r ApiCreateOfferRequest) IdleTimeoutInSecond(idleTimeoutInSecond int32) ApiCreateOfferRequest {
	r.idleTimeoutInSecond = &idleTimeoutInSecond
	return r
}

// The serial number on the device
func (r ApiCreateOfferRequest) SerialNumber(serialNumber string) ApiCreateOfferRequest {
	r.serialNumber = &serialNumber
	return r
}

// The unique device id for the device
func (r ApiCreateOfferRequest) Udid(udid string) ApiCreateOfferRequest {
	r.udid = &udid
	return r
}

// The type of the device, for example: \&quot;Kiosk\&quot;, \&quot;Beacon\&quot;.
func (r ApiCreateOfferRequest) DeviceType(deviceType string) ApiCreateOfferRequest {
	r.deviceType = &deviceType
	return r
}

// Edysen device power level setting
func (r ApiCreateOfferRequest) DevicePower(devicePower float64) ApiCreateOfferRequest {
	r.devicePower = &devicePower
	return r
}

// Edysen device inteference setting
func (r ApiCreateOfferRequest) DeviceInterference(deviceInterference float64) ApiCreateOfferRequest {
	r.deviceInterference = &deviceInterference
	return r
}

// 
func (r ApiCreateOfferRequest) Availability(availability string) ApiCreateOfferRequest {
	r.availability = &availability
	return r
}

// 
func (r ApiCreateOfferRequest) AvailabilitySummary(availabilitySummary string) ApiCreateOfferRequest {
	r.availabilitySummary = &availabilitySummary
	return r
}

func (r ApiCreateOfferRequest) Execute() (*RetailerOfferResponse, *http.Response, error) {
	return r.ApiService.CreateOfferExecute(r)
}

/*
CreateOffer Create Offer

Create an offer and assign it to the provided retailer locations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateOfferRequest
*/
func (a *OfferAPIService) CreateOffer(ctx context.Context, version float32) ApiCreateOfferRequest {
	return ApiCreateOfferRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return RetailerOfferResponse
func (a *OfferAPIService) CreateOfferExecute(r ApiCreateOfferRequest) (*RetailerOfferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RetailerOfferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OfferAPIService.CreateOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/retailer/offer/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.includeOfferLocations == nil {
		return localVarReturnValue, nil, reportError("includeOfferLocations is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if r.barcodeType == nil {
		return localVarReturnValue, nil, reportError("barcodeType is required and must be specified")
	}
	if r.noExpiration == nil {
		return localVarReturnValue, nil, reportError("noExpiration is required and must be specified")
	}
	if r.availableLimit == nil {
		return localVarReturnValue, nil, reportError("availableLimit is required and must be specified")
	}
	if r.availableLimitPerUser == nil {
		return localVarReturnValue, nil, reportError("availableLimitPerUser is required and must be specified")
	}
	if r.addedLimit == nil {
		return localVarReturnValue, nil, reportError("addedLimit is required and must be specified")
	}
	if r.viewLimit == nil {
		return localVarReturnValue, nil, reportError("viewLimit is required and must be specified")
	}
	if r.maxPrints == nil {
		return localVarReturnValue, nil, reportError("maxPrints is required and must be specified")
	}
	if r.ticketPrice == nil {
		return localVarReturnValue, nil, reportError("ticketPrice is required and must be specified")
	}
	if r.fullPrice == nil {
		return localVarReturnValue, nil, reportError("fullPrice is required and must be specified")
	}
	if r.discountPrice == nil {
		return localVarReturnValue, nil, reportError("discountPrice is required and must be specified")
	}
	if r.offerType == nil {
		return localVarReturnValue, nil, reportError("offerType is required and must be specified")
	}
	if r.specialOfferType == nil {
		return localVarReturnValue, nil, reportError("specialOfferType is required and must be specified")
	}
	if r.offerVisibility == nil {
		return localVarReturnValue, nil, reportError("offerVisibility is required and must be specified")
	}
	if r.active == nil {
		return localVarReturnValue, nil, reportError("active is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	if r.parentOfferId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentOfferId", r.parentOfferId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "includeOfferLocations", r.includeOfferLocations, "form", "")
	if r.retailerLocationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationIds", r.retailerLocationIds, "form", "")
	}
	if r.offerLocations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocations", r.offerLocations, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	if r.subTitle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subTitle", r.subTitle, "form", "")
	}
	if r.details != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "details", r.details, "form", "")
	}
	if r.subDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subDetails", r.subDetails, "form", "")
	}
	if r.finePrint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finePrint", r.finePrint, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "barcodeType", r.barcodeType, "form", "")
	if r.barcodeEntry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "barcodeEntry", r.barcodeEntry, "form", "")
	}
	if r.externalRedeemOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalRedeemOptions", r.externalRedeemOptions, "form", "")
	}
	if r.externalUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalUrl", r.externalUrl, "form", "")
	}
	if r.externalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalId", r.externalId, "form", "")
	}
	if r.ticketsRewardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketsRewardType", r.ticketsRewardType, "form", "")
	}
	if r.ticketsReward != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketsReward", r.ticketsReward, "form", "")
	}
	if r.activated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activated", r.activated, "form", "")
	}
	if r.expires != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expires", r.expires, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "noExpiration", r.noExpiration, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "availableLimit", r.availableLimit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "availableLimitPerUser", r.availableLimitPerUser, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "addedLimit", r.addedLimit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "viewLimit", r.viewLimit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "maxPrints", r.maxPrints, "form", "")
	if r.ticketPriceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketPriceType", r.ticketPriceType, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ticketPrice", r.ticketPrice, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "fullPrice", r.fullPrice, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "discountPrice", r.discountPrice, "form", "")
	if r.showRemaining != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showRemaining", r.showRemaining, "form", "")
	}
	if r.showRedeemed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showRedeemed", r.showRedeemed, "form", "")
	}
	if r.replaced != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "replaced", r.replaced, "form", "")
	}
	if r.featured != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "featured", r.featured, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "offerType", r.offerType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "specialOfferType", r.specialOfferType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "offerVisibility", r.offerVisibility, "form", "")
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.filterIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterIds", r.filterIds, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	if r.barcodeAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "barcodeAssetId", r.barcodeAssetId, "form", "")
	}
	if r.imageAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId", r.imageAssetId, "form", "")
	}
	if r.imageAssetId1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId1", r.imageAssetId1, "form", "")
	}
	if r.imageAssetId2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId2", r.imageAssetId2, "form", "")
	}
	if r.imageAssetId3 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId3", r.imageAssetId3, "form", "")
	}
	if r.imageAssetId4 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId4", r.imageAssetId4, "form", "")
	}
	if r.imageAssetId5 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId5", r.imageAssetId5, "form", "")
	}
	if r.publisher != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publisher", r.publisher, "form", "")
	}
	if r.redeemableStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemableStart", r.redeemableStart, "form", "")
	}
	if r.redeemableEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemableEnd", r.redeemableEnd, "form", "")
	}
	if r.brand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "brand", r.brand, "form", "")
	}
	if r.productType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "productType", r.productType, "form", "")
	}
	if r.conditionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conditionType", r.conditionType, "form", "")
	}
	if r.isbn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isbn", r.isbn, "form", "")
	}
	if r.asin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asin", r.asin, "form", "")
	}
	if r.catalogNumbers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "catalogNumbers", r.catalogNumbers, "form", "")
	}
	if r.department != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "department", r.department, "form", "")
	}
	if r.features != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "features", r.features, "form", "")
	}
	if r.minimumPrice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minimumPrice", r.minimumPrice, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	}
	if r.weight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "weight", r.weight, "form", "")
	}
	if r.unit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unit", r.unit, "form", "")
	}
	if r.studio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "studio", r.studio, "form", "")
	}
	if r.parentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentalRating", r.parentalRating, "form", "")
	}
	if r.publishDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publishDate", r.publishDate, "form", "")
	}
	if r.availabilityDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availabilityDate", r.availabilityDate, "form", "")
	}
	if r.sizeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sizeId", r.sizeId, "form", "")
	}
	if r.listingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listingId", r.listingId, "form", "")
	}
	if r.mediaType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaType", r.mediaType, "form", "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "form", "")
	}
	if r.author != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "author", r.author, "form", "")
	}
	if r.releaseDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "releaseDate", r.releaseDate, "form", "")
	}
	if r.collectionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "collectionIds", r.collectionIds, "form", "")
	}
	if r.rebootTimeHour != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rebootTimeHour", r.rebootTimeHour, "form", "")
	}
	if r.rebootTimeMinute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rebootTimeMinute", r.rebootTimeMinute, "form", "")
	}
	if r.idleTimeoutInSecond != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idleTimeoutInSecond", r.idleTimeoutInSecond, "form", "")
	}
	if r.serialNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialNumber", r.serialNumber, "form", "")
	}
	if r.udid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udid", r.udid, "form", "")
	}
	if r.deviceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceType", r.deviceType, "form", "")
	}
	if r.devicePower != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "devicePower", r.devicePower, "form", "")
	}
	if r.deviceInterference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceInterference", r.deviceInterference, "form", "")
	}
	if r.availability != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availability", r.availability, "form", "")
	}
	if r.availabilitySummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availabilitySummary", r.availabilitySummary, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOfferRequest struct {
	ctx context.Context
	ApiService *OfferAPIService
	version float32
	offerId *int64
	deviceId *string
	accountId *int64
}

// The ID of the offer to be deleted
func (r ApiDeleteOfferRequest) OfferId(offerId int64) ApiDeleteOfferRequest {
	r.offerId = &offerId
	return r
}

// The device id (deviceId or accountId required)
func (r ApiDeleteOfferRequest) DeviceId(deviceId string) ApiDeleteOfferRequest {
	r.deviceId = &deviceId
	return r
}

// The account used to perform the delete, must have rights to edit the offer.
func (r ApiDeleteOfferRequest) AccountId(accountId int64) ApiDeleteOfferRequest {
	r.accountId = &accountId
	return r
}

func (r ApiDeleteOfferRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteOfferExecute(r)
}

/*
DeleteOffer Delete Offer

Set the deleted timestamp to current time. This effectively deletes the offer since all queries should ignore any records with a deleted time stamp.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteOfferRequest
*/
func (a *OfferAPIService) DeleteOffer(ctx context.Context, version float32) ApiDeleteOfferRequest {
	return ApiDeleteOfferRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *OfferAPIService) DeleteOfferExecute(r ApiDeleteOfferRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OfferAPIService.DeleteOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/retailer/offer/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.offerId == nil {
		return localVarReturnValue, nil, reportError("offerId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOfferLocationRequest struct {
	ctx context.Context
	ApiService *OfferAPIService
	version float32
	offerLocationId *int64
	deviceId *string
	accountId *int64
}

// The ID of the offer location to be deleted
func (r ApiDeleteOfferLocationRequest) OfferLocationId(offerLocationId int64) ApiDeleteOfferLocationRequest {
	r.offerLocationId = &offerLocationId
	return r
}

// The device id (deviceId or accountId required)
func (r ApiDeleteOfferLocationRequest) DeviceId(deviceId string) ApiDeleteOfferLocationRequest {
	r.deviceId = &deviceId
	return r
}

// The account used to perform the delete, must have rights to edit the offer location.
func (r ApiDeleteOfferLocationRequest) AccountId(accountId int64) ApiDeleteOfferLocationRequest {
	r.accountId = &accountId
	return r
}

func (r ApiDeleteOfferLocationRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteOfferLocationExecute(r)
}

/*
DeleteOfferLocation Delete Offer Location

Set the deleted timestamp to current time. This effectively deletes the offer location since all queries should ignore any records with a deleted time stamp.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteOfferLocationRequest
*/
func (a *OfferAPIService) DeleteOfferLocation(ctx context.Context, version float32) ApiDeleteOfferLocationRequest {
	return ApiDeleteOfferLocationRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *OfferAPIService) DeleteOfferLocationExecute(r ApiDeleteOfferLocationRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OfferAPIService.DeleteOfferLocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/retailer/offer/location/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.offerLocationId == nil {
		return localVarReturnValue, nil, reportError("offerLocationId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationId", r.offerLocationId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOfferRequest struct {
	ctx context.Context
	ApiService *OfferAPIService
	version float32
	offerId *int64
	includeOfferLocations *bool
	deviceId *string
	accountId *int64
}

// The id of the offer
func (r ApiGetOfferRequest) OfferId(offerId int64) ApiGetOfferRequest {
	r.offerId = &offerId
	return r
}

// 
func (r ApiGetOfferRequest) IncludeOfferLocations(includeOfferLocations bool) ApiGetOfferRequest {
	r.includeOfferLocations = &includeOfferLocations
	return r
}

// The device id (deviceId or accountId required)
func (r ApiGetOfferRequest) DeviceId(deviceId string) ApiGetOfferRequest {
	r.deviceId = &deviceId
	return r
}

// The account id (deviceId or accountId required)
func (r ApiGetOfferRequest) AccountId(accountId int64) ApiGetOfferRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetOfferRequest) Execute() (*RetailerOfferResponse, *http.Response, error) {
	return r.ApiService.GetOfferExecute(r)
}

/*
GetOffer Get Offer

Gets the details of an offer that the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetOfferRequest
*/
func (a *OfferAPIService) GetOffer(ctx context.Context, version float32) ApiGetOfferRequest {
	return ApiGetOfferRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return RetailerOfferResponse
func (a *OfferAPIService) GetOfferExecute(r ApiGetOfferRequest) (*RetailerOfferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RetailerOfferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OfferAPIService.GetOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/retailer/offer/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.offerId == nil {
		return localVarReturnValue, nil, reportError("offerId is required and must be specified")
	}
	if r.includeOfferLocations == nil {
		return localVarReturnValue, nil, reportError("includeOfferLocations is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "includeOfferLocations", r.includeOfferLocations, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOfferDetailsRequest struct {
	ctx context.Context
	ApiService *OfferAPIService
	version float32
	deviceId *string
	accountId *int64
	offerId *int64
	offerLocationId *int64
	distance *float64
	latitude *float64
	longitude *float64
	includeOfferLocations *bool
	includeRetailerLocations *bool
	includeChildOffers *bool
}

// The device id for returning account information (i.e. favorites)
func (r ApiGetOfferDetailsRequest) DeviceId(deviceId string) ApiGetOfferDetailsRequest {
	r.deviceId = &deviceId
	return r
}

// The account id for returning account information (i.e. favorites)
func (r ApiGetOfferDetailsRequest) AccountId(accountId int64) ApiGetOfferDetailsRequest {
	r.accountId = &accountId
	return r
}

// The offer id (either offeLocationId or offerId must be provided)
func (r ApiGetOfferDetailsRequest) OfferId(offerId int64) ApiGetOfferDetailsRequest {
	r.offerId = &offerId
	return r
}

// The offer location id (either offeLocationId or offerId must be provided)
func (r ApiGetOfferDetailsRequest) OfferLocationId(offerLocationId int64) ApiGetOfferDetailsRequest {
	r.offerLocationId = &offerLocationId
	return r
}

// The distance of the offer from the user&#39;s current location (this is returned when the offer is searched)
func (r ApiGetOfferDetailsRequest) Distance(distance float64) ApiGetOfferDetailsRequest {
	r.distance = &distance
	return r
}

// The latitude to calculate distance from the offer
func (r ApiGetOfferDetailsRequest) Latitude(latitude float64) ApiGetOfferDetailsRequest {
	r.latitude = &latitude
	return r
}

// The longitude to calculate distance from the offer
func (r ApiGetOfferDetailsRequest) Longitude(longitude float64) ApiGetOfferDetailsRequest {
	r.longitude = &longitude
	return r
}

// Determines whether to return offer locations for the offer
func (r ApiGetOfferDetailsRequest) IncludeOfferLocations(includeOfferLocations bool) ApiGetOfferDetailsRequest {
	r.includeOfferLocations = &includeOfferLocations
	return r
}

// Determines whether to return the retailer location info for each offer location response (includeOfferLocations must also be true for this to work)
func (r ApiGetOfferDetailsRequest) IncludeRetailerLocations(includeRetailerLocations bool) ApiGetOfferDetailsRequest {
	r.includeRetailerLocations = &includeRetailerLocations
	return r
}

// Determines whether to include child offers in the response
func (r ApiGetOfferDetailsRequest) IncludeChildOffers(includeChildOffers bool) ApiGetOfferDetailsRequest {
	r.includeChildOffers = &includeChildOffers
	return r
}

func (r ApiGetOfferDetailsRequest) Execute() (*OfferResponse, *http.Response, error) {
	return r.ApiService.GetOfferDetailsExecute(r)
}

/*
GetOfferDetails Get Offer

Gets offer or offer location details as a consumer.  Will check if it is a favorite if the deviceId/accountId is provided.  If the offerId is provided it will look up the main offer and ignore the the offerLocationId. If no offerId is provided then an offerLocationId must be specified.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetOfferDetailsRequest
*/
func (a *OfferAPIService) GetOfferDetails(ctx context.Context, version float32) ApiGetOfferDetailsRequest {
	return ApiGetOfferDetailsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OfferResponse
func (a *OfferAPIService) GetOfferDetailsExecute(r ApiGetOfferDetailsRequest) (*OfferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OfferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OfferAPIService.GetOfferDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/offer/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.offerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	}
	if r.offerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationId", r.offerLocationId, "form", "")
	}
	if r.distance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distance", r.distance, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.includeOfferLocations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOfferLocations", r.includeOfferLocations, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOfferLocations", defaultValue, "form", "")
		r.includeOfferLocations = &defaultValue
	}
	if r.includeRetailerLocations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRetailerLocations", r.includeRetailerLocations, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRetailerLocations", defaultValue, "form", "")
		r.includeRetailerLocations = &defaultValue
	}
	if r.includeChildOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeChildOffers", r.includeChildOffers, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeChildOffers", defaultValue, "form", "")
		r.includeChildOffers = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOfferListCountsRequest struct {
	ctx context.Context
	ApiService *OfferAPIService
	version float32
	latitude *float64
	longitude *float64
	searchRange *float32
	distanceUnit *string
}

// The latitude of where the search will center at
func (r ApiGetOfferListCountsRequest) Latitude(latitude float64) ApiGetOfferListCountsRequest {
	r.latitude = &latitude
	return r
}

// The longitude of where the search will center at
func (r ApiGetOfferListCountsRequest) Longitude(longitude float64) ApiGetOfferListCountsRequest {
	r.longitude = &longitude
	return r
}

// The range of the search
func (r ApiGetOfferListCountsRequest) SearchRange(searchRange float32) ApiGetOfferListCountsRequest {
	r.searchRange = &searchRange
	return r
}

// The units to use for distance calculations (e.g. MILES, KILOMETERS)
func (r ApiGetOfferListCountsRequest) DistanceUnit(distanceUnit string) ApiGetOfferListCountsRequest {
	r.distanceUnit = &distanceUnit
	return r
}

func (r ApiGetOfferListCountsRequest) Execute() (*ListCountResponse, *http.Response, error) {
	return r.ApiService.GetOfferListCountsExecute(r)
}

/*
GetOfferListCounts Get Offers (Counts)

Gets the offer list counts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetOfferListCountsRequest
*/
func (a *OfferAPIService) GetOfferListCounts(ctx context.Context, version float32) ApiGetOfferListCountsRequest {
	return ApiGetOfferListCountsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ListCountResponse
func (a *OfferAPIService) GetOfferListCountsExecute(r ApiGetOfferListCountsRequest) (*ListCountResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListCountResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OfferAPIService.GetOfferListCounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/offer/lists/count"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.latitude == nil {
		return localVarReturnValue, nil, reportError("latitude is required and must be specified")
	}
	if r.longitude == nil {
		return localVarReturnValue, nil, reportError("longitude is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	if r.searchRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchRange", r.searchRange, "form", "")
	} else {
		var defaultValue float32 = 5
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchRange", defaultValue, "form", "")
		r.searchRange = &defaultValue
	}
	if r.distanceUnit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distanceUnit", r.distanceUnit, "form", "")
	} else {
		var defaultValue string = "MILES"
		parameterAddToHeaderOrQuery(localVarQueryParams, "distanceUnit", defaultValue, "form", "")
		r.distanceUnit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOfferLocationRequest struct {
	ctx context.Context
	ApiService *OfferAPIService
	version float32
	offerLocationId *int64
	udid *string
}

// the id of the offer location to get
func (r ApiGetOfferLocationRequest) OfferLocationId(offerLocationId int64) ApiGetOfferLocationRequest {
	r.offerLocationId = &offerLocationId
	return r
}

// the UDID of the device
func (r ApiGetOfferLocationRequest) Udid(udid string) ApiGetOfferLocationRequest {
	r.udid = &udid
	return r
}

func (r ApiGetOfferLocationRequest) Execute() (*OfferShortResponse, *http.Response, error) {
	return r.ApiService.GetOfferLocationExecute(r)
}

/*
GetOfferLocation Get Offer Location

Gets the offer location by offer location id or udid (of a device)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetOfferLocationRequest
*/
func (a *OfferAPIService) GetOfferLocation(ctx context.Context, version float32) ApiGetOfferLocationRequest {
	return ApiGetOfferLocationRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OfferShortResponse
func (a *OfferAPIService) GetOfferLocationExecute(r ApiGetOfferLocationRequest) (*OfferShortResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OfferShortResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OfferAPIService.GetOfferLocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/offer/location/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationId", r.offerLocationId, "form", "")
	}
	if r.udid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udid", r.udid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOfferLocationsForRetailersRequest struct {
	ctx context.Context
	ApiService *OfferAPIService
	version float32
	sortField *string
	descending *bool
	start *int32
	limit *int32
	activeOnly *bool
	includeRetailerLocation *bool
	deviceId *string
	accountId *int64
	keyword *string
	retailerId *int64
	retailerLocationId *int64
	offerType *string
	specialOfferType *string
	barcodeType *string
	barcodeEntry *string
	isbn *string
	asin *string
	deviceStatus *string
	needsNotificationSent *bool
	lastNotificationSent *int64
}

// The column to sort the results on. Default is \&quot;TITLE\&quot;, which will sort the results by the offer title. Possible input values: {CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, RETAILER_ID,RETAILER_LOCATION_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}
func (r ApiGetOfferLocationsForRetailersRequest) SortField(sortField string) ApiGetOfferLocationsForRetailersRequest {
	r.sortField = &sortField
	return r
}

// The order to return the results. Default is false, which will return the results in ascending order.
func (r ApiGetOfferLocationsForRetailersRequest) Descending(descending bool) ApiGetOfferLocationsForRetailersRequest {
	r.descending = &descending
	return r
}

// The index into the record set to start with. Default is 0.
func (r ApiGetOfferLocationsForRetailersRequest) Start(start int32) ApiGetOfferLocationsForRetailersRequest {
	r.start = &start
	return r
}

// The total number of records to return. Default is 20.
func (r ApiGetOfferLocationsForRetailersRequest) Limit(limit int32) ApiGetOfferLocationsForRetailersRequest {
	r.limit = &limit
	return r
}

// Determines whether to return only active results. Default is false.
func (r ApiGetOfferLocationsForRetailersRequest) ActiveOnly(activeOnly bool) ApiGetOfferLocationsForRetailersRequest {
	r.activeOnly = &activeOnly
	return r
}

// 
func (r ApiGetOfferLocationsForRetailersRequest) IncludeRetailerLocation(includeRetailerLocation bool) ApiGetOfferLocationsForRetailersRequest {
	r.includeRetailerLocation = &includeRetailerLocation
	return r
}

// The device id (deviceId or accountId required)
func (r ApiGetOfferLocationsForRetailersRequest) DeviceId(deviceId string) ApiGetOfferLocationsForRetailersRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiGetOfferLocationsForRetailersRequest) AccountId(accountId int64) ApiGetOfferLocationsForRetailersRequest {
	r.accountId = &accountId
	return r
}

// The keyword used to search
func (r ApiGetOfferLocationsForRetailersRequest) Keyword(keyword string) ApiGetOfferLocationsForRetailersRequest {
	r.keyword = &keyword
	return r
}

// Filter results for a specific retailer
func (r ApiGetOfferLocationsForRetailersRequest) RetailerId(retailerId int64) ApiGetOfferLocationsForRetailersRequest {
	r.retailerId = &retailerId
	return r
}

// Filter results for a specific retailer location
func (r ApiGetOfferLocationsForRetailersRequest) RetailerLocationId(retailerLocationId int64) ApiGetOfferLocationsForRetailersRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers
func (r ApiGetOfferLocationsForRetailersRequest) OfferType(offerType string) ApiGetOfferLocationsForRetailersRequest {
	r.offerType = &offerType
	return r
}

// Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials
func (r ApiGetOfferLocationsForRetailersRequest) SpecialOfferType(specialOfferType string) ApiGetOfferLocationsForRetailersRequest {
	r.specialOfferType = &specialOfferType
	return r
}

// 
func (r ApiGetOfferLocationsForRetailersRequest) BarcodeType(barcodeType string) ApiGetOfferLocationsForRetailersRequest {
	r.barcodeType = &barcodeType
	return r
}

// 
func (r ApiGetOfferLocationsForRetailersRequest) BarcodeEntry(barcodeEntry string) ApiGetOfferLocationsForRetailersRequest {
	r.barcodeEntry = &barcodeEntry
	return r
}

// 
func (r ApiGetOfferLocationsForRetailersRequest) Isbn(isbn string) ApiGetOfferLocationsForRetailersRequest {
	r.isbn = &isbn
	return r
}

// 
func (r ApiGetOfferLocationsForRetailersRequest) Asin(asin string) ApiGetOfferLocationsForRetailersRequest {
	r.asin = &asin
	return r
}

// Edysen device status, running, warning, or down
func (r ApiGetOfferLocationsForRetailersRequest) DeviceStatus(deviceStatus string) ApiGetOfferLocationsForRetailersRequest {
	r.deviceStatus = &deviceStatus
	return r
}

// 
func (r ApiGetOfferLocationsForRetailersRequest) NeedsNotificationSent(needsNotificationSent bool) ApiGetOfferLocationsForRetailersRequest {
	r.needsNotificationSent = &needsNotificationSent
	return r
}

// 
func (r ApiGetOfferLocationsForRetailersRequest) LastNotificationSent(lastNotificationSent int64) ApiGetOfferLocationsForRetailersRequest {
	r.lastNotificationSent = &lastNotificationSent
	return r
}

func (r ApiGetOfferLocationsForRetailersRequest) Execute() ([]OfferShortResponse, *http.Response, error) {
	return r.ApiService.GetOfferLocationsForRetailersExecute(r)
}

/*
GetOfferLocationsForRetailers Search Offer Locations

Searches on offer locations, which are records that represent an offer that has been assigned to a retailer location. If an offer does not have any locations assigned, then it will NOT be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetOfferLocationsForRetailersRequest
*/
func (a *OfferAPIService) GetOfferLocationsForRetailers(ctx context.Context, version float32) ApiGetOfferLocationsForRetailersRequest {
	return ApiGetOfferLocationsForRetailersRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []OfferShortResponse
func (a *OfferAPIService) GetOfferLocationsForRetailersExecute(r ApiGetOfferLocationsForRetailersRequest) ([]OfferShortResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OfferShortResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OfferAPIService.GetOfferLocationsForRetailers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/retailer/offer/location/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}
	if r.descending == nil {
		return localVarReturnValue, nil, reportError("descending is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.activeOnly == nil {
		return localVarReturnValue, nil, reportError("activeOnly is required and must be specified")
	}
	if r.includeRetailerLocation == nil {
		return localVarReturnValue, nil, reportError("includeRetailerLocation is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.retailerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerId", r.retailerId, "form", "")
	}
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	if r.offerType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerType", r.offerType, "form", "")
	}
	if r.specialOfferType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "specialOfferType", r.specialOfferType, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "includeRetailerLocation", r.includeRetailerLocation, "form", "")
	if r.barcodeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "barcodeType", r.barcodeType, "form", "")
	}
	if r.barcodeEntry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "barcodeEntry", r.barcodeEntry, "form", "")
	}
	if r.isbn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isbn", r.isbn, "form", "")
	}
	if r.asin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asin", r.asin, "form", "")
	}
	if r.deviceStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceStatus", r.deviceStatus, "form", "")
	}
	if r.needsNotificationSent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "needsNotificationSent", r.needsNotificationSent, "form", "")
	}
	if r.lastNotificationSent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastNotificationSent", r.lastNotificationSent, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOffersForRetailersRequest struct {
	ctx context.Context
	ApiService *OfferAPIService
	version float32
	offerVisibility *string
	sortField *string
	descending *bool
	start *int32
	limit *int32
	availableOnly *bool
	activeOnly *bool
	includeCategories *bool
	includeFilters *bool
	includeOfferLocations *bool
	deviceId *string
	accountId *int64
	categoryIds *string
	filterIds *string
	q *string
	keyword *string
	retailerId *int64
	retailerLocationId *int64
	couponType *string
	offerType *string
	offerTypes *string
	specialOfferType *string
	i *int32
	l *int32
	barcodeType *string
	barcodeEntry *string
	isbn *string
	asin *string
	deviceStatus *string
	needsNotificationSent *bool
	lastNotificationSent *int64
}

// 
func (r ApiGetOffersForRetailersRequest) OfferVisibility(offerVisibility string) ApiGetOffersForRetailersRequest {
	r.offerVisibility = &offerVisibility
	return r
}

// The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY
func (r ApiGetOffersForRetailersRequest) SortField(sortField string) ApiGetOffersForRetailersRequest {
	r.sortField = &sortField
	return r
}

// The order to return the search results
func (r ApiGetOffersForRetailersRequest) Descending(descending bool) ApiGetOffersForRetailersRequest {
	r.descending = &descending
	return r
}

// The record to begin the return set on
func (r ApiGetOffersForRetailersRequest) Start(start int32) ApiGetOffersForRetailersRequest {
	r.start = &start
	return r
}

// The number of records to return
func (r ApiGetOffersForRetailersRequest) Limit(limit int32) ApiGetOffersForRetailersRequest {
	r.limit = &limit
	return r
}

// Return only results that are currently being promoted (is activated and not expired)
func (r ApiGetOffersForRetailersRequest) AvailableOnly(availableOnly bool) ApiGetOffersForRetailersRequest {
	r.availableOnly = &availableOnly
	return r
}

// Return only active results
func (r ApiGetOffersForRetailersRequest) ActiveOnly(activeOnly bool) ApiGetOffersForRetailersRequest {
	r.activeOnly = &activeOnly
	return r
}

// 
func (r ApiGetOffersForRetailersRequest) IncludeCategories(includeCategories bool) ApiGetOffersForRetailersRequest {
	r.includeCategories = &includeCategories
	return r
}

// 
func (r ApiGetOffersForRetailersRequest) IncludeFilters(includeFilters bool) ApiGetOffersForRetailersRequest {
	r.includeFilters = &includeFilters
	return r
}

// 
func (r ApiGetOffersForRetailersRequest) IncludeOfferLocations(includeOfferLocations bool) ApiGetOffersForRetailersRequest {
	r.includeOfferLocations = &includeOfferLocations
	return r
}

// The device id (deviceId or accountId required)
func (r ApiGetOffersForRetailersRequest) DeviceId(deviceId string) ApiGetOffersForRetailersRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiGetOffersForRetailersRequest) AccountId(accountId int64) ApiGetOffersForRetailersRequest {
	r.accountId = &accountId
	return r
}

// 
func (r ApiGetOffersForRetailersRequest) CategoryIds(categoryIds string) ApiGetOffersForRetailersRequest {
	r.categoryIds = &categoryIds
	return r
}

// 
func (r ApiGetOffersForRetailersRequest) FilterIds(filterIds string) ApiGetOffersForRetailersRequest {
	r.filterIds = &filterIds
	return r
}

// This parameter is deprecated.
func (r ApiGetOffersForRetailersRequest) Q(q string) ApiGetOffersForRetailersRequest {
	r.q = &q
	return r
}

// The keyword used to search
func (r ApiGetOffersForRetailersRequest) Keyword(keyword string) ApiGetOffersForRetailersRequest {
	r.keyword = &keyword
	return r
}

// the id of the retailer
func (r ApiGetOffersForRetailersRequest) RetailerId(retailerId int64) ApiGetOffersForRetailersRequest {
	r.retailerId = &retailerId
	return r
}

// the id of the retailer location
func (r ApiGetOffersForRetailersRequest) RetailerLocationId(retailerLocationId int64) ApiGetOffersForRetailersRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// This parameter is deprecated.
func (r ApiGetOffersForRetailersRequest) CouponType(couponType string) ApiGetOffersForRetailersRequest {
	r.couponType = &couponType
	return r
}

// This parameter is deprecated. Use offer types. Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers
func (r ApiGetOffersForRetailersRequest) OfferType(offerType string) ApiGetOffersForRetailersRequest {
	r.offerType = &offerType
	return r
}

// Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}
func (r ApiGetOffersForRetailersRequest) OfferTypes(offerTypes string) ApiGetOffersForRetailersRequest {
	r.offerTypes = &offerTypes
	return r
}

// Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials
func (r ApiGetOffersForRetailersRequest) SpecialOfferType(specialOfferType string) ApiGetOffersForRetailersRequest {
	r.specialOfferType = &specialOfferType
	return r
}

// This parameter is deprecated.
func (r ApiGetOffersForRetailersRequest) I(i int32) ApiGetOffersForRetailersRequest {
	r.i = &i
	return r
}

// This parameter is deprecated.
func (r ApiGetOffersForRetailersRequest) L(l int32) ApiGetOffersForRetailersRequest {
	r.l = &l
	return r
}

// 
func (r ApiGetOffersForRetailersRequest) BarcodeType(barcodeType string) ApiGetOffersForRetailersRequest {
	r.barcodeType = &barcodeType
	return r
}

// 
func (r ApiGetOffersForRetailersRequest) BarcodeEntry(barcodeEntry string) ApiGetOffersForRetailersRequest {
	r.barcodeEntry = &barcodeEntry
	return r
}

// 
func (r ApiGetOffersForRetailersRequest) Isbn(isbn string) ApiGetOffersForRetailersRequest {
	r.isbn = &isbn
	return r
}

// 
func (r ApiGetOffersForRetailersRequest) Asin(asin string) ApiGetOffersForRetailersRequest {
	r.asin = &asin
	return r
}

// Edysen device status
func (r ApiGetOffersForRetailersRequest) DeviceStatus(deviceStatus string) ApiGetOffersForRetailersRequest {
	r.deviceStatus = &deviceStatus
	return r
}

// 
func (r ApiGetOffersForRetailersRequest) NeedsNotificationSent(needsNotificationSent bool) ApiGetOffersForRetailersRequest {
	r.needsNotificationSent = &needsNotificationSent
	return r
}

// 
func (r ApiGetOffersForRetailersRequest) LastNotificationSent(lastNotificationSent int64) ApiGetOffersForRetailersRequest {
	r.lastNotificationSent = &lastNotificationSent
	return r
}

func (r ApiGetOffersForRetailersRequest) Execute() ([]OfferResponse, *http.Response, error) {
	return r.ApiService.GetOffersForRetailersExecute(r)
}

/*
GetOffersForRetailers Search Offers

Searches on offers that the account has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetOffersForRetailersRequest
*/
func (a *OfferAPIService) GetOffersForRetailers(ctx context.Context, version float32) ApiGetOffersForRetailersRequest {
	return ApiGetOffersForRetailersRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []OfferResponse
func (a *OfferAPIService) GetOffersForRetailersExecute(r ApiGetOffersForRetailersRequest) ([]OfferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OfferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OfferAPIService.GetOffersForRetailers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/retailer/offer/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.offerVisibility == nil {
		return localVarReturnValue, nil, reportError("offerVisibility is required and must be specified")
	}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}
	if r.descending == nil {
		return localVarReturnValue, nil, reportError("descending is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.availableOnly == nil {
		return localVarReturnValue, nil, reportError("availableOnly is required and must be specified")
	}
	if r.activeOnly == nil {
		return localVarReturnValue, nil, reportError("activeOnly is required and must be specified")
	}
	if r.includeCategories == nil {
		return localVarReturnValue, nil, reportError("includeCategories is required and must be specified")
	}
	if r.includeFilters == nil {
		return localVarReturnValue, nil, reportError("includeFilters is required and must be specified")
	}
	if r.includeOfferLocations == nil {
		return localVarReturnValue, nil, reportError("includeOfferLocations is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.filterIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterIds", r.filterIds, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.retailerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerId", r.retailerId, "form", "")
	}
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	if r.couponType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "couponType", r.couponType, "form", "")
	}
	if r.offerType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerType", r.offerType, "form", "")
	}
	if r.offerTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerTypes", r.offerTypes, "form", "")
	}
	if r.specialOfferType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "specialOfferType", r.specialOfferType, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "offerVisibility", r.offerVisibility, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	if r.i != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_i", r.i, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	if r.l != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_l", r.l, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "availableOnly", r.availableOnly, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "includeCategories", r.includeCategories, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "includeFilters", r.includeFilters, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "includeOfferLocations", r.includeOfferLocations, "form", "")
	if r.barcodeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "barcodeType", r.barcodeType, "form", "")
	}
	if r.barcodeEntry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "barcodeEntry", r.barcodeEntry, "form", "")
	}
	if r.isbn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isbn", r.isbn, "form", "")
	}
	if r.asin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asin", r.asin, "form", "")
	}
	if r.deviceStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceStatus", r.deviceStatus, "form", "")
	}
	if r.needsNotificationSent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "needsNotificationSent", r.needsNotificationSent, "form", "")
	}
	if r.lastNotificationSent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastNotificationSent", r.lastNotificationSent, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRedeemOfferTransactionRequest struct {
	ctx context.Context
	ApiService *OfferAPIService
	version float32
	offerTransactionId *int64
	status *int32
	deviceId *string
	accountId *int64
	offerLocationId *int64
}

// the OfferTransaction ID of the transaction being redeemed
func (r ApiRedeemOfferTransactionRequest) OfferTransactionId(offerTransactionId int64) ApiRedeemOfferTransactionRequest {
	r.offerTransactionId = &offerTransactionId
	return r
}

// the status to set the offer transaction to - 1 sets it to redeemable and 2 sets it to redeemed
func (r ApiRedeemOfferTransactionRequest) Status(status int32) ApiRedeemOfferTransactionRequest {
	r.status = &status
	return r
}

// the device id (deviceId or accountId required)
func (r ApiRedeemOfferTransactionRequest) DeviceId(deviceId string) ApiRedeemOfferTransactionRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiRedeemOfferTransactionRequest) AccountId(accountId int64) ApiRedeemOfferTransactionRequest {
	r.accountId = &accountId
	return r
}

// the OfferLocation ID where the offer is being redeemed
func (r ApiRedeemOfferTransactionRequest) OfferLocationId(offerLocationId int64) ApiRedeemOfferTransactionRequest {
	r.offerLocationId = &offerLocationId
	return r
}

func (r ApiRedeemOfferTransactionRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.RedeemOfferTransactionExecute(r)
}

/*
RedeemOfferTransaction Update Offer Transaction

Redeems an offer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiRedeemOfferTransactionRequest
*/
func (a *OfferAPIService) RedeemOfferTransaction(ctx context.Context, version float32) ApiRedeemOfferTransactionRequest {
	return ApiRedeemOfferTransactionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *OfferAPIService) RedeemOfferTransactionExecute(r ApiRedeemOfferTransactionRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OfferAPIService.RedeemOfferTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/retailer/offer/transaction/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.offerTransactionId == nil {
		return localVarReturnValue, nil, reportError("offerTransactionId is required and must be specified")
	}
	if r.status == nil {
		return localVarReturnValue, nil, reportError("status is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "offerTransactionId", r.offerTransactionId, "form", "")
	if r.offerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationId", r.offerLocationId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchOfferTransactionsForRetailersRequest struct {
	ctx context.Context
	ApiService *OfferAPIService
	version float32
	sortField *string
	descending *bool
	start *int32
	limit *int32
	activeOnly *bool
	deviceId *string
	accountId *int64
	q *string
	keyword *string
	retailerId *int64
	retailerLocationId *int64
	offerId *int64
	offerLocationId *int64
	redeemed *bool
	reservationsOnly *bool
	couponType *string
	offerType *string
	specialOfferType *string
	customerAccountIds *string
	categoryIds *string
	redeemableStartDate *int64
	redeemableEndDate *int64
	i *int32
	l *int32
}

// Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}
func (r ApiSearchOfferTransactionsForRetailersRequest) SortField(sortField string) ApiSearchOfferTransactionsForRetailersRequest {
	r.sortField = &sortField
	return r
}

// Determines whether the results are in descending order
func (r ApiSearchOfferTransactionsForRetailersRequest) Descending(descending bool) ApiSearchOfferTransactionsForRetailersRequest {
	r.descending = &descending
	return r
}

// The start index for pagination
func (r ApiSearchOfferTransactionsForRetailersRequest) Start(start int32) ApiSearchOfferTransactionsForRetailersRequest {
	r.start = &start
	return r
}

// The limit for pagination
func (r ApiSearchOfferTransactionsForRetailersRequest) Limit(limit int32) ApiSearchOfferTransactionsForRetailersRequest {
	r.limit = &limit
	return r
}

// Determines whether to only return active offer transactions
func (r ApiSearchOfferTransactionsForRetailersRequest) ActiveOnly(activeOnly bool) ApiSearchOfferTransactionsForRetailersRequest {
	r.activeOnly = &activeOnly
	return r
}

// The device id (deviceId or accountId required)
func (r ApiSearchOfferTransactionsForRetailersRequest) DeviceId(deviceId string) ApiSearchOfferTransactionsForRetailersRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiSearchOfferTransactionsForRetailersRequest) AccountId(accountId int64) ApiSearchOfferTransactionsForRetailersRequest {
	r.accountId = &accountId
	return r
}

// This parameter is deprecated.
func (r ApiSearchOfferTransactionsForRetailersRequest) Q(q string) ApiSearchOfferTransactionsForRetailersRequest {
	r.q = &q
	return r
}

// The keyword to search for
func (r ApiSearchOfferTransactionsForRetailersRequest) Keyword(keyword string) ApiSearchOfferTransactionsForRetailersRequest {
	r.keyword = &keyword
	return r
}

// Filter results for this retailer
func (r ApiSearchOfferTransactionsForRetailersRequest) RetailerId(retailerId int64) ApiSearchOfferTransactionsForRetailersRequest {
	r.retailerId = &retailerId
	return r
}

// Filter results for this retailer location
func (r ApiSearchOfferTransactionsForRetailersRequest) RetailerLocationId(retailerLocationId int64) ApiSearchOfferTransactionsForRetailersRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// Filter results for this offer
func (r ApiSearchOfferTransactionsForRetailersRequest) OfferId(offerId int64) ApiSearchOfferTransactionsForRetailersRequest {
	r.offerId = &offerId
	return r
}

// Filter results for this offer location
func (r ApiSearchOfferTransactionsForRetailersRequest) OfferLocationId(offerLocationId int64) ApiSearchOfferTransactionsForRetailersRequest {
	r.offerLocationId = &offerLocationId
	return r
}

// if true return redeemed transactions (status 2), if false return active transactions (status 0 or 1)
func (r ApiSearchOfferTransactionsForRetailersRequest) Redeemed(redeemed bool) ApiSearchOfferTransactionsForRetailersRequest {
	r.redeemed = &redeemed
	return r
}

// returns only reservation transactions if true
func (r ApiSearchOfferTransactionsForRetailersRequest) ReservationsOnly(reservationsOnly bool) ApiSearchOfferTransactionsForRetailersRequest {
	r.reservationsOnly = &reservationsOnly
	return r
}

// This parameter is deprecated.
func (r ApiSearchOfferTransactionsForRetailersRequest) CouponType(couponType string) ApiSearchOfferTransactionsForRetailersRequest {
	r.couponType = &couponType
	return r
}

// Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers
func (r ApiSearchOfferTransactionsForRetailersRequest) OfferType(offerType string) ApiSearchOfferTransactionsForRetailersRequest {
	r.offerType = &offerType
	return r
}

// Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials
func (r ApiSearchOfferTransactionsForRetailersRequest) SpecialOfferType(specialOfferType string) ApiSearchOfferTransactionsForRetailersRequest {
	r.specialOfferType = &specialOfferType
	return r
}

// Filter results by accounts
func (r ApiSearchOfferTransactionsForRetailersRequest) CustomerAccountIds(customerAccountIds string) ApiSearchOfferTransactionsForRetailersRequest {
	r.customerAccountIds = &customerAccountIds
	return r
}

// 
func (r ApiSearchOfferTransactionsForRetailersRequest) CategoryIds(categoryIds string) ApiSearchOfferTransactionsForRetailersRequest {
	r.categoryIds = &categoryIds
	return r
}

// 
func (r ApiSearchOfferTransactionsForRetailersRequest) RedeemableStartDate(redeemableStartDate int64) ApiSearchOfferTransactionsForRetailersRequest {
	r.redeemableStartDate = &redeemableStartDate
	return r
}

// 
func (r ApiSearchOfferTransactionsForRetailersRequest) RedeemableEndDate(redeemableEndDate int64) ApiSearchOfferTransactionsForRetailersRequest {
	r.redeemableEndDate = &redeemableEndDate
	return r
}

// This parameter is deprecated.
func (r ApiSearchOfferTransactionsForRetailersRequest) I(i int32) ApiSearchOfferTransactionsForRetailersRequest {
	r.i = &i
	return r
}

// This parameter is deprecated.
func (r ApiSearchOfferTransactionsForRetailersRequest) L(l int32) ApiSearchOfferTransactionsForRetailersRequest {
	r.l = &l
	return r
}

func (r ApiSearchOfferTransactionsForRetailersRequest) Execute() ([]OfferTransactionResponse, *http.Response, error) {
	return r.ApiService.SearchOfferTransactionsForRetailersExecute(r)
}

/*
SearchOfferTransactionsForRetailers Search Offer Transactions

Searches on offer transactions for offers that the account has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchOfferTransactionsForRetailersRequest
*/
func (a *OfferAPIService) SearchOfferTransactionsForRetailers(ctx context.Context, version float32) ApiSearchOfferTransactionsForRetailersRequest {
	return ApiSearchOfferTransactionsForRetailersRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []OfferTransactionResponse
func (a *OfferAPIService) SearchOfferTransactionsForRetailersExecute(r ApiSearchOfferTransactionsForRetailersRequest) ([]OfferTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OfferTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OfferAPIService.SearchOfferTransactionsForRetailers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/retailer/offer/transaction/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}
	if r.descending == nil {
		return localVarReturnValue, nil, reportError("descending is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.activeOnly == nil {
		return localVarReturnValue, nil, reportError("activeOnly is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.retailerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerId", r.retailerId, "form", "")
	}
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	if r.offerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	}
	if r.offerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationId", r.offerLocationId, "form", "")
	}
	if r.redeemed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemed", r.redeemed, "form", "")
	}
	if r.reservationsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservationsOnly", r.reservationsOnly, "form", "")
	}
	if r.couponType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "couponType", r.couponType, "form", "")
	}
	if r.offerType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerType", r.offerType, "form", "")
	}
	if r.specialOfferType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "specialOfferType", r.specialOfferType, "form", "")
	}
	if r.customerAccountIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customerAccountIds", r.customerAccountIds, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.redeemableStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemableStartDate", r.redeemableStartDate, "form", "")
	}
	if r.redeemableEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemableEndDate", r.redeemableEndDate, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	if r.i != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_i", r.i, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	if r.l != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "_l", r.l, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchOffersForConsumerRequest struct {
	ctx context.Context
	ApiService *OfferAPIService
	version float32
	latitude *float64
	longitude *float64
	recommendationType *string
	locationId *int64
	start *int32
	limit *int32
	maxRecommendations *int32
	distanceUnit *string
	appKey *string
	deviceId *string
	accountId *int64
	searchRange *float64
	tags *string
	supportedPostalCodes *string
	keyword *string
	categories *string
	filters *string
	offerTypes *string
	type_ *string
	sortField *string
	recommendOfferIds *string
	retailerLocationIds *string
	offerId *int64
	includeMission *bool
	includeCategories *bool
	includeFilters *bool
	includeExpired *bool
	includeFavorite *bool
	closestOfferOnly *bool
	searchExpression *string
	groupBy *string
}

// The latitude of where the search will center at
func (r ApiSearchOffersForConsumerRequest) Latitude(latitude float64) ApiSearchOffersForConsumerRequest {
	r.latitude = &latitude
	return r
}

// The longitude of where the search will center at
func (r ApiSearchOffersForConsumerRequest) Longitude(longitude float64) ApiSearchOffersForConsumerRequest {
	r.longitude = &longitude
	return r
}

// The method to use to gather recommendations: WALLET base relevance on items in users wallets CLICKS base relevance on items users have clicked on BLENDED blend using all methods available
func (r ApiSearchOffersForConsumerRequest) RecommendationType(recommendationType string) ApiSearchOffersForConsumerRequest {
	r.recommendationType = &recommendationType
	return r
}

// This parameter is deprecated. The location id
func (r ApiSearchOffersForConsumerRequest) LocationId(locationId int64) ApiSearchOffersForConsumerRequest {
	r.locationId = &locationId
	return r
}

// The start index for pagination
func (r ApiSearchOffersForConsumerRequest) Start(start int32) ApiSearchOffersForConsumerRequest {
	r.start = &start
	return r
}

// The limit for pagination
func (r ApiSearchOffersForConsumerRequest) Limit(limit int32) ApiSearchOffersForConsumerRequest {
	r.limit = &limit
	return r
}

// 
func (r ApiSearchOffersForConsumerRequest) MaxRecommendations(maxRecommendations int32) ApiSearchOffersForConsumerRequest {
	r.maxRecommendations = &maxRecommendations
	return r
}

// 
func (r ApiSearchOffersForConsumerRequest) DistanceUnit(distanceUnit string) ApiSearchOffersForConsumerRequest {
	r.distanceUnit = &distanceUnit
	return r
}

// The application key used to identify the application
func (r ApiSearchOffersForConsumerRequest) AppKey(appKey string) ApiSearchOffersForConsumerRequest {
	r.appKey = &appKey
	return r
}

// The device id for returning account information (i.e. offer transactions made by the user)
func (r ApiSearchOffersForConsumerRequest) DeviceId(deviceId string) ApiSearchOffersForConsumerRequest {
	r.deviceId = &deviceId
	return r
}

// The account id for returning account information (i.e. offer transactions made by the user)
func (r ApiSearchOffersForConsumerRequest) AccountId(accountId int64) ApiSearchOffersForConsumerRequest {
	r.accountId = &accountId
	return r
}

// The range of the search
func (r ApiSearchOffersForConsumerRequest) SearchRange(searchRange float64) ApiSearchOffersForConsumerRequest {
	r.searchRange = &searchRange
	return r
}

// Does a full-text search on tags
func (r ApiSearchOffersForConsumerRequest) Tags(tags string) ApiSearchOffersForConsumerRequest {
	r.tags = &tags
	return r
}

// supported postal codes
func (r ApiSearchOffersForConsumerRequest) SupportedPostalCodes(supportedPostalCodes string) ApiSearchOffersForConsumerRequest {
	r.supportedPostalCodes = &supportedPostalCodes
	return r
}

// The keyword to filter results by
func (r ApiSearchOffersForConsumerRequest) Keyword(keyword string) ApiSearchOffersForConsumerRequest {
	r.keyword = &keyword
	return r
}

// Comma separate list of category ids
func (r ApiSearchOffersForConsumerRequest) Categories(categories string) ApiSearchOffersForConsumerRequest {
	r.categories = &categories
	return r
}

// Comma separated list of filter ids
func (r ApiSearchOffersForConsumerRequest) Filters(filters string) ApiSearchOffersForConsumerRequest {
	r.filters = &filters
	return r
}

// Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}
func (r ApiSearchOffersForConsumerRequest) OfferTypes(offerTypes string) ApiSearchOffersForConsumerRequest {
	r.offerTypes = &offerTypes
	return r
}

// The special offer type {ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
func (r ApiSearchOffersForConsumerRequest) Type_(type_ string) ApiSearchOffersForConsumerRequest {
	r.type_ = &type_
	return r
}

// The field to sort the result set on:DISTANCE Sort the offers nearest to farthest BUSINESS_NAME Sort the offers alphabetically by location name SHUFFLE Sort the nearest offers randomly USERPREFS accountId must accompany this parameter. Gives the first X recommendations where X equals the parameter maxRecommendations
func (r ApiSearchOffersForConsumerRequest) SortField(sortField string) ApiSearchOffersForConsumerRequest {
	r.sortField = &sortField
	return r
}

// Return recommendations based on these offers IDs
func (r ApiSearchOffersForConsumerRequest) RecommendOfferIds(recommendOfferIds string) ApiSearchOffersForConsumerRequest {
	r.recommendOfferIds = &recommendOfferIds
	return r
}

// Only return offer locations for the specific retailer locations.
func (r ApiSearchOffersForConsumerRequest) RetailerLocationIds(retailerLocationIds string) ApiSearchOffersForConsumerRequest {
	r.retailerLocationIds = &retailerLocationIds
	return r
}

// Only return offer locations for the specific offer.
func (r ApiSearchOffersForConsumerRequest) OfferId(offerId int64) ApiSearchOffersForConsumerRequest {
	r.offerId = &offerId
	return r
}

// If true include the mission response as part of the offer. Default is false.
func (r ApiSearchOffersForConsumerRequest) IncludeMission(includeMission bool) ApiSearchOffersForConsumerRequest {
	r.includeMission = &includeMission
	return r
}

// If true include the category list response as part of the offer. Default is false.
func (r ApiSearchOffersForConsumerRequest) IncludeCategories(includeCategories bool) ApiSearchOffersForConsumerRequest {
	r.includeCategories = &includeCategories
	return r
}

// If true include the filter list response as part of the offer. Default is false.
func (r ApiSearchOffersForConsumerRequest) IncludeFilters(includeFilters bool) ApiSearchOffersForConsumerRequest {
	r.includeFilters = &includeFilters
	return r
}

// If true then ignore the expired dates. Default is false.
func (r ApiSearchOffersForConsumerRequest) IncludeExpired(includeExpired bool) ApiSearchOffersForConsumerRequest {
	r.includeExpired = &includeExpired
	return r
}

// If true then ignore the favorite. Default is false.
func (r ApiSearchOffersForConsumerRequest) IncludeFavorite(includeFavorite bool) ApiSearchOffersForConsumerRequest {
	r.includeFavorite = &includeFavorite
	return r
}

// This parameter is deprecated. see groupBy. If true then it only returns the offer location for an offer closest to the given lat/lon
func (r ApiSearchOffersForConsumerRequest) ClosestOfferOnly(closestOfferOnly bool) ApiSearchOffersForConsumerRequest {
	r.closestOfferOnly = &closestOfferOnly
	return r
}

// 
func (r ApiSearchOffersForConsumerRequest) SearchExpression(searchExpression string) ApiSearchOffersForConsumerRequest {
	r.searchExpression = &searchExpression
	return r
}

// groups the results by a certain field. For example, if you want to return the closest offer location of an offer, then pass in groupBy&#x3D;OFFER_ID and sortField&#x3D;DISTANCE (to sort by distance).
func (r ApiSearchOffersForConsumerRequest) GroupBy(groupBy string) ApiSearchOffersForConsumerRequest {
	r.groupBy = &groupBy
	return r
}

func (r ApiSearchOffersForConsumerRequest) Execute() (*OfferListResponse, *http.Response, error) {
	return r.ApiService.SearchOffersForConsumerExecute(r)
}

/*
SearchOffersForConsumer Search Offers

Searches for offers as a consumer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchOffersForConsumerRequest
*/
func (a *OfferAPIService) SearchOffersForConsumer(ctx context.Context, version float32) ApiSearchOffersForConsumerRequest {
	return ApiSearchOffersForConsumerRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OfferListResponse
func (a *OfferAPIService) SearchOffersForConsumerExecute(r ApiSearchOffersForConsumerRequest) (*OfferListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OfferListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OfferAPIService.SearchOffersForConsumer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/offer/lists"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.latitude == nil {
		return localVarReturnValue, nil, reportError("latitude is required and must be specified")
	}
	if r.longitude == nil {
		return localVarReturnValue, nil, reportError("longitude is required and must be specified")
	}
	if r.recommendationType == nil {
		return localVarReturnValue, nil, reportError("recommendationType is required and must be specified")
	}
	if r.locationId == nil {
		return localVarReturnValue, nil, reportError("locationId is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.maxRecommendations == nil {
		return localVarReturnValue, nil, reportError("maxRecommendations is required and must be specified")
	}
	if r.distanceUnit == nil {
		return localVarReturnValue, nil, reportError("distanceUnit is required and must be specified")
	}

	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	if r.searchRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchRange", r.searchRange, "form", "")
	} else {
		var defaultValue float64 = 5
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchRange", defaultValue, "form", "")
		r.searchRange = &defaultValue
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	if r.supportedPostalCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "supportedPostalCodes", r.supportedPostalCodes, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.categories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categories", r.categories, "form", "")
	}
	if r.filters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters", r.filters, "form", "")
	}
	if r.offerTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerTypes", r.offerTypes, "form", "")
	} else {
		var defaultValue string = "COUPON, VOUCHER"
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerTypes", defaultValue, "form", "")
		r.offerTypes = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.recommendOfferIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recommendOfferIds", r.recommendOfferIds, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "recommendationType", r.recommendationType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "locationId", r.locationId, "form", "")
	if r.retailerLocationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationIds", r.retailerLocationIds, "form", "")
	}
	if r.offerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	}
	if r.includeMission != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeMission", r.includeMission, "form", "")
	}
	if r.includeCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCategories", r.includeCategories, "form", "")
	}
	if r.includeFilters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFilters", r.includeFilters, "form", "")
	}
	if r.includeExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeExpired", r.includeExpired, "form", "")
	}
	if r.includeFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFavorite", r.includeFavorite, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "maxRecommendations", r.maxRecommendations, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "distanceUnit", r.distanceUnit, "form", "")
	if r.closestOfferOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closestOfferOnly", r.closestOfferOnly, "form", "")
	}
	if r.searchExpression != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchExpression", r.searchExpression, "form", "")
	}
	if r.groupBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupBy", r.groupBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTopOfferTransactionsRequest struct {
	ctx context.Context
	ApiService *OfferAPIService
	version float32
	start *int32
	limit *int32
}

// The index into the record set to start with. Default is 0.
func (r ApiTopOfferTransactionsRequest) Start(start int32) ApiTopOfferTransactionsRequest {
	r.start = &start
	return r
}

// The total number of record to return. Default id 20.
func (r ApiTopOfferTransactionsRequest) Limit(limit int32) ApiTopOfferTransactionsRequest {
	r.limit = &limit
	return r
}

func (r ApiTopOfferTransactionsRequest) Execute() (*OfferListResponse, *http.Response, error) {
	return r.ApiService.TopOfferTransactionsExecute(r)
}

/*
TopOfferTransactions Get Offers (Top)

Gets the top active offers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiTopOfferTransactionsRequest
*/
func (a *OfferAPIService) TopOfferTransactions(ctx context.Context, version float32) ApiTopOfferTransactionsRequest {
	return ApiTopOfferTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return OfferListResponse
func (a *OfferAPIService) TopOfferTransactionsExecute(r ApiTopOfferTransactionsRequest) (*OfferListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OfferListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OfferAPIService.TopOfferTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/offer/top"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOfferRequest struct {
	ctx context.Context
	ApiService *OfferAPIService
	version float32
	offerId *int64
	includeOfferLocations *bool
	deviceId *string
	accountId *int64
	parentOfferId *int64
	retailerLocationIds *string
	offerLocations *string
	tags *string
	title *string
	subTitle *string
	details *string
	subDetails *string
	finePrint *string
	barcodeType *string
	barcodeEntry *string
	externalRedeemOptions *string
	externalUrl *string
	externalId *string
	ticketsRewardType *string
	ticketsReward *int64
	activated *int64
	expires *int64
	noExpiration *bool
	availableLimit *int32
	availableLimitPerUser *int32
	addedLimit *int32
	viewLimit *int32
	maxPrints *int32
	ticketPriceType *string
	ticketPrice *int64
	fullPrice *float64
	discountPrice *float64
	showRemaining *bool
	showRedeemed *bool
	replaced *bool
	featured *bool
	offerType *string
	specialOfferType *string
	offerVisibility *string
	categoryIds *string
	filterIds *string
	active *bool
	barcodeAssetId *int64
	imageAssetId *int64
	imageAssetId1 *int64
	imageAssetId2 *int64
	imageAssetId3 *int64
	imageAssetId4 *int64
	imageAssetId5 *int64
	publisher *string
	redeemableStart *int64
	redeemableEnd *int64
	brand *string
	productType *string
	conditionType *string
	isbn *string
	asin *string
	catalogNumbers *string
	department *string
	features *string
	minimumPrice *float64
	width *float64
	height *float64
	depth *float64
	weight *float64
	unit *string
	studio *string
	parentalRating *string
	publishDate *int64
	availabilityDate *int64
	sizeId *int64
	listingId *int64
	mediaType *string
	duration *int32
	author *string
	releaseDate *int64
	collectionIds *string
	rebootTimeHour *int32
	rebootTimeMinute *int32
	idleTimeoutInSecond *int32
	serialNumber *string
	udid *string
	deviceType *string
	devicePower *float64
	deviceInterference *float64
	availability *string
	availabilitySummary *string
}

// The offer to update
func (r ApiUpdateOfferRequest) OfferId(offerId int64) ApiUpdateOfferRequest {
	r.offerId = &offerId
	return r
}

// If true return all the offer locations associated with the offer
func (r ApiUpdateOfferRequest) IncludeOfferLocations(includeOfferLocations bool) ApiUpdateOfferRequest {
	r.includeOfferLocations = &includeOfferLocations
	return r
}

// The device id (deviceId or accountId required)
func (r ApiUpdateOfferRequest) DeviceId(deviceId string) ApiUpdateOfferRequest {
	r.deviceId = &deviceId
	return r
}

// The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)
func (r ApiUpdateOfferRequest) AccountId(accountId int64) ApiUpdateOfferRequest {
	r.accountId = &accountId
	return r
}

// 
func (r ApiUpdateOfferRequest) ParentOfferId(parentOfferId int64) ApiUpdateOfferRequest {
	r.parentOfferId = &parentOfferId
	return r
}

// Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
func (r ApiUpdateOfferRequest) RetailerLocationIds(retailerLocationIds string) ApiUpdateOfferRequest {
	r.retailerLocationIds = &retailerLocationIds
	return r
}

// A list of json data that has offer location specific values.
func (r ApiUpdateOfferRequest) OfferLocations(offerLocations string) ApiUpdateOfferRequest {
	r.offerLocations = &offerLocations
	return r
}

// Custom string field for doing full-text searches
func (r ApiUpdateOfferRequest) Tags(tags string) ApiUpdateOfferRequest {
	r.tags = &tags
	return r
}

// The title (255 char limit)
func (r ApiUpdateOfferRequest) Title(title string) ApiUpdateOfferRequest {
	r.title = &title
	return r
}

// The sub title (255 char limit)
func (r ApiUpdateOfferRequest) SubTitle(subTitle string) ApiUpdateOfferRequest {
	r.subTitle = &subTitle
	return r
}

// The details
func (r ApiUpdateOfferRequest) Details(details string) ApiUpdateOfferRequest {
	r.details = &details
	return r
}

// A string for custom details (255 char limit)
func (r ApiUpdateOfferRequest) SubDetails(subDetails string) ApiUpdateOfferRequest {
	r.subDetails = &subDetails
	return r
}

// The fine print
func (r ApiUpdateOfferRequest) FinePrint(finePrint string) ApiUpdateOfferRequest {
	r.finePrint = &finePrint
	return r
}

// The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}
func (r ApiUpdateOfferRequest) BarcodeType(barcodeType string) ApiUpdateOfferRequest {
	r.barcodeType = &barcodeType
	return r
}

// The bar code entry string
func (r ApiUpdateOfferRequest) BarcodeEntry(barcodeEntry string) ApiUpdateOfferRequest {
	r.barcodeEntry = &barcodeEntry
	return r
}

// An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.
func (r ApiUpdateOfferRequest) ExternalRedeemOptions(externalRedeemOptions string) ApiUpdateOfferRequest {
	r.externalRedeemOptions = &externalRedeemOptions
	return r
}

// The clickUrl of the offer
func (r ApiUpdateOfferRequest) ExternalUrl(externalUrl string) ApiUpdateOfferRequest {
	r.externalUrl = &externalUrl
	return r
}

// 
func (r ApiUpdateOfferRequest) ExternalId(externalId string) ApiUpdateOfferRequest {
	r.externalId = &externalId
	return r
}

// The type of ticket to reward, null means default type
func (r ApiUpdateOfferRequest) TicketsRewardType(ticketsRewardType string) ApiUpdateOfferRequest {
	r.ticketsRewardType = &ticketsRewardType
	return r
}

// Determines how many tickets are awarded
func (r ApiUpdateOfferRequest) TicketsReward(ticketsReward int64) ApiUpdateOfferRequest {
	r.ticketsReward = &ticketsReward
	return r
}

// The date of when the offer will be visible to consumers
func (r ApiUpdateOfferRequest) Activated(activated int64) ApiUpdateOfferRequest {
	r.activated = &activated
	return r
}

// The date of when the offer expires
func (r ApiUpdateOfferRequest) Expires(expires int64) ApiUpdateOfferRequest {
	r.expires = &expires
	return r
}

// Overrides the expiration date so that the offer does not expire
func (r ApiUpdateOfferRequest) NoExpiration(noExpiration bool) ApiUpdateOfferRequest {
	r.noExpiration = &noExpiration
	return r
}

// The limit of how many times the offer can be used by consumers
func (r ApiUpdateOfferRequest) AvailableLimit(availableLimit int32) ApiUpdateOfferRequest {
	r.availableLimit = &availableLimit
	return r
}

// The limit of how many times a user can used the same offer
func (r ApiUpdateOfferRequest) AvailableLimitPerUser(availableLimitPerUser int32) ApiUpdateOfferRequest {
	r.availableLimitPerUser = &availableLimitPerUser
	return r
}

// The limit of how many times the offer can be added to consumer wallets
func (r ApiUpdateOfferRequest) AddedLimit(addedLimit int32) ApiUpdateOfferRequest {
	r.addedLimit = &addedLimit
	return r
}

// 
func (r ApiUpdateOfferRequest) ViewLimit(viewLimit int32) ApiUpdateOfferRequest {
	r.viewLimit = &viewLimit
	return r
}

// The maximum number of times the offer can be printed
func (r ApiUpdateOfferRequest) MaxPrints(maxPrints int32) ApiUpdateOfferRequest {
	r.maxPrints = &maxPrints
	return r
}

// the type of ticket needed to buy the offer
func (r ApiUpdateOfferRequest) TicketPriceType(ticketPriceType string) ApiUpdateOfferRequest {
	r.ticketPriceType = &ticketPriceType
	return r
}

// The cost of the offer in tickets
func (r ApiUpdateOfferRequest) TicketPrice(ticketPrice int64) ApiUpdateOfferRequest {
	r.ticketPrice = &ticketPrice
	return r
}

// The retail/full price cost of the offer in real currency
func (r ApiUpdateOfferRequest) FullPrice(fullPrice float64) ApiUpdateOfferRequest {
	r.fullPrice = &fullPrice
	return r
}

// The cost of the offer at a discounted price (what the consumer pays)
func (r ApiUpdateOfferRequest) DiscountPrice(discountPrice float64) ApiUpdateOfferRequest {
	r.discountPrice = &discountPrice
	return r
}

// show remaining offers available
func (r ApiUpdateOfferRequest) ShowRemaining(showRemaining bool) ApiUpdateOfferRequest {
	r.showRemaining = &showRemaining
	return r
}

// show how many offers have been redeemed
func (r ApiUpdateOfferRequest) ShowRedeemed(showRedeemed bool) ApiUpdateOfferRequest {
	r.showRedeemed = &showRedeemed
	return r
}

// 
func (r ApiUpdateOfferRequest) Replaced(replaced bool) ApiUpdateOfferRequest {
	r.replaced = &replaced
	return r
}

// whether the offer is featured or not
func (r ApiUpdateOfferRequest) Featured(featured bool) ApiUpdateOfferRequest {
	r.featured = &featured
	return r
}

// The offer type {VOUCHER, COUPON, PRODUCT, MEDIA, EVENT}
func (r ApiUpdateOfferRequest) OfferType(offerType string) ApiUpdateOfferRequest {
	r.offerType = &offerType
	return r
}

// The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
func (r ApiUpdateOfferRequest) SpecialOfferType(specialOfferType string) ApiUpdateOfferRequest {
	r.specialOfferType = &specialOfferType
	return r
}

// The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}
func (r ApiUpdateOfferRequest) OfferVisibility(offerVisibility string) ApiUpdateOfferRequest {
	r.offerVisibility = &offerVisibility
	return r
}

// Comma separated list of category ids
func (r ApiUpdateOfferRequest) CategoryIds(categoryIds string) ApiUpdateOfferRequest {
	r.categoryIds = &categoryIds
	return r
}

// Comma separated list of filter ids
func (r ApiUpdateOfferRequest) FilterIds(filterIds string) ApiUpdateOfferRequest {
	r.filterIds = &filterIds
	return r
}

// Sets the active flag
func (r ApiUpdateOfferRequest) Active(active bool) ApiUpdateOfferRequest {
	r.active = &active
	return r
}

// The id of the barcode asset
func (r ApiUpdateOfferRequest) BarcodeAssetId(barcodeAssetId int64) ApiUpdateOfferRequest {
	r.barcodeAssetId = &barcodeAssetId
	return r
}

// The id of the an offer asset
func (r ApiUpdateOfferRequest) ImageAssetId(imageAssetId int64) ApiUpdateOfferRequest {
	r.imageAssetId = &imageAssetId
	return r
}

// The id of the an offer asset
func (r ApiUpdateOfferRequest) ImageAssetId1(imageAssetId1 int64) ApiUpdateOfferRequest {
	r.imageAssetId1 = &imageAssetId1
	return r
}

// The id of the an offer asset
func (r ApiUpdateOfferRequest) ImageAssetId2(imageAssetId2 int64) ApiUpdateOfferRequest {
	r.imageAssetId2 = &imageAssetId2
	return r
}

// The id of the an offer asset
func (r ApiUpdateOfferRequest) ImageAssetId3(imageAssetId3 int64) ApiUpdateOfferRequest {
	r.imageAssetId3 = &imageAssetId3
	return r
}

// The id of the an offer asset
func (r ApiUpdateOfferRequest) ImageAssetId4(imageAssetId4 int64) ApiUpdateOfferRequest {
	r.imageAssetId4 = &imageAssetId4
	return r
}

// The id of the an offer asset
func (r ApiUpdateOfferRequest) ImageAssetId5(imageAssetId5 int64) ApiUpdateOfferRequest {
	r.imageAssetId5 = &imageAssetId5
	return r
}

// The maker of the item.
func (r ApiUpdateOfferRequest) Publisher(publisher string) ApiUpdateOfferRequest {
	r.publisher = &publisher
	return r
}

// The redeemable start date/time of the offer.
func (r ApiUpdateOfferRequest) RedeemableStart(redeemableStart int64) ApiUpdateOfferRequest {
	r.redeemableStart = &redeemableStart
	return r
}

// The redeemable start date/time of the offer.
func (r ApiUpdateOfferRequest) RedeemableEnd(redeemableEnd int64) ApiUpdateOfferRequest {
	r.redeemableEnd = &redeemableEnd
	return r
}

// The brand. OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) Brand(brand string) ApiUpdateOfferRequest {
	r.brand = &brand
	return r
}

// The product type. OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) ProductType(productType string) ApiUpdateOfferRequest {
	r.productType = &productType
	return r
}

// The condition. OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) ConditionType(conditionType string) ApiUpdateOfferRequest {
	r.conditionType = &conditionType
	return r
}

// The ISBN id. OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) Isbn(isbn string) ApiUpdateOfferRequest {
	r.isbn = &isbn
	return r
}

// The ASIN id. OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) Asin(asin string) ApiUpdateOfferRequest {
	r.asin = &asin
	return r
}

// The list of catelog numbers, comma seperated. OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) CatalogNumbers(catalogNumbers string) ApiUpdateOfferRequest {
	r.catalogNumbers = &catalogNumbers
	return r
}

// The department name. The OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) Department(department string) ApiUpdateOfferRequest {
	r.department = &department
	return r
}

// The list of features, comma seperated. OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) Features(features string) ApiUpdateOfferRequest {
	r.features = &features
	return r
}

// The MAP price. OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) MinimumPrice(minimumPrice float64) ApiUpdateOfferRequest {
	r.minimumPrice = &minimumPrice
	return r
}

// The width of the item. OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) Width(width float64) ApiUpdateOfferRequest {
	r.width = &width
	return r
}

// The height of the item. OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) Height(height float64) ApiUpdateOfferRequest {
	r.height = &height
	return r
}

// The depth of the item. OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) Depth(depth float64) ApiUpdateOfferRequest {
	r.depth = &depth
	return r
}

// The weight of the item. OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) Weight(weight float64) ApiUpdateOfferRequest {
	r.weight = &weight
	return r
}

// The unit of measurement. OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) Unit(unit string) ApiUpdateOfferRequest {
	r.unit = &unit
	return r
}

// The studio name. OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) Studio(studio string) ApiUpdateOfferRequest {
	r.studio = &studio
	return r
}

// The parental control rating. OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) ParentalRating(parentalRating string) ApiUpdateOfferRequest {
	r.parentalRating = &parentalRating
	return r
}

// The date published. OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) PublishDate(publishDate int64) ApiUpdateOfferRequest {
	r.publishDate = &publishDate
	return r
}

// The date available. OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) AvailabilityDate(availabilityDate int64) ApiUpdateOfferRequest {
	r.availabilityDate = &availabilityDate
	return r
}

// The size Id. OfferType PRODUCT only.
func (r ApiUpdateOfferRequest) SizeId(sizeId int64) ApiUpdateOfferRequest {
	r.sizeId = &sizeId
	return r
}

// The ID of the event listing
func (r ApiUpdateOfferRequest) ListingId(listingId int64) ApiUpdateOfferRequest {
	r.listingId = &listingId
	return r
}

// 
func (r ApiUpdateOfferRequest) MediaType(mediaType string) ApiUpdateOfferRequest {
	r.mediaType = &mediaType
	return r
}

// The total playing time of the media item. OfferType MEDIA only.
func (r ApiUpdateOfferRequest) Duration(duration int32) ApiUpdateOfferRequest {
	r.duration = &duration
	return r
}

// The created/author of the media item. OfferType MEDIA only.
func (r ApiUpdateOfferRequest) Author(author string) ApiUpdateOfferRequest {
	r.author = &author
	return r
}

// The date/time of when the media item was originally released. OfferType MEDIA only.
func (r ApiUpdateOfferRequest) ReleaseDate(releaseDate int64) ApiUpdateOfferRequest {
	r.releaseDate = &releaseDate
	return r
}

// 
func (r ApiUpdateOfferRequest) CollectionIds(collectionIds string) ApiUpdateOfferRequest {
	r.collectionIds = &collectionIds
	return r
}

// The reboot hour time ranging from 0 to 23
func (r ApiUpdateOfferRequest) RebootTimeHour(rebootTimeHour int32) ApiUpdateOfferRequest {
	r.rebootTimeHour = &rebootTimeHour
	return r
}

// The reboot minute time ranging from 0 to 59
func (r ApiUpdateOfferRequest) RebootTimeMinute(rebootTimeMinute int32) ApiUpdateOfferRequest {
	r.rebootTimeMinute = &rebootTimeMinute
	return r
}

// If the device is idle for idleTimeoutInSecond then the device should timeout
func (r ApiUpdateOfferRequest) IdleTimeoutInSecond(idleTimeoutInSecond int32) ApiUpdateOfferRequest {
	r.idleTimeoutInSecond = &idleTimeoutInSecond
	return r
}

// The serial number on the device
func (r ApiUpdateOfferRequest) SerialNumber(serialNumber string) ApiUpdateOfferRequest {
	r.serialNumber = &serialNumber
	return r
}

// The unique device id for the device
func (r ApiUpdateOfferRequest) Udid(udid string) ApiUpdateOfferRequest {
	r.udid = &udid
	return r
}

// The type of the device, for example: \&quot;Kiosk\&quot;, \&quot;Beacon\&quot;.
func (r ApiUpdateOfferRequest) DeviceType(deviceType string) ApiUpdateOfferRequest {
	r.deviceType = &deviceType
	return r
}

// RSSI reading at 1 meter from device (-10 to -140)
func (r ApiUpdateOfferRequest) DevicePower(devicePower float64) ApiUpdateOfferRequest {
	r.devicePower = &devicePower
	return r
}

// 
func (r ApiUpdateOfferRequest) DeviceInterference(deviceInterference float64) ApiUpdateOfferRequest {
	r.deviceInterference = &deviceInterference
	return r
}

// 
func (r ApiUpdateOfferRequest) Availability(availability string) ApiUpdateOfferRequest {
	r.availability = &availability
	return r
}

// 
func (r ApiUpdateOfferRequest) AvailabilitySummary(availabilitySummary string) ApiUpdateOfferRequest {
	r.availabilitySummary = &availabilitySummary
	return r
}

func (r ApiUpdateOfferRequest) Execute() (*RetailerOfferResponse, *http.Response, error) {
	return r.ApiService.UpdateOfferExecute(r)
}

/*
UpdateOffer Update Offer

Update an offer, must provide a current list of retailer locations or the current offer locations will be marked as deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateOfferRequest
*/
func (a *OfferAPIService) UpdateOffer(ctx context.Context, version float32) ApiUpdateOfferRequest {
	return ApiUpdateOfferRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return RetailerOfferResponse
func (a *OfferAPIService) UpdateOfferExecute(r ApiUpdateOfferRequest) (*RetailerOfferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RetailerOfferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OfferAPIService.UpdateOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/retailer/offer/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.offerId == nil {
		return localVarReturnValue, nil, reportError("offerId is required and must be specified")
	}
	if r.includeOfferLocations == nil {
		return localVarReturnValue, nil, reportError("includeOfferLocations is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	if r.parentOfferId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentOfferId", r.parentOfferId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "includeOfferLocations", r.includeOfferLocations, "form", "")
	if r.retailerLocationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationIds", r.retailerLocationIds, "form", "")
	}
	if r.offerLocations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocations", r.offerLocations, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.subTitle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subTitle", r.subTitle, "form", "")
	}
	if r.details != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "details", r.details, "form", "")
	}
	if r.subDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subDetails", r.subDetails, "form", "")
	}
	if r.finePrint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finePrint", r.finePrint, "form", "")
	}
	if r.barcodeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "barcodeType", r.barcodeType, "form", "")
	}
	if r.barcodeEntry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "barcodeEntry", r.barcodeEntry, "form", "")
	}
	if r.externalRedeemOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalRedeemOptions", r.externalRedeemOptions, "form", "")
	}
	if r.externalUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalUrl", r.externalUrl, "form", "")
	}
	if r.externalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalId", r.externalId, "form", "")
	}
	if r.ticketsRewardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketsRewardType", r.ticketsRewardType, "form", "")
	}
	if r.ticketsReward != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketsReward", r.ticketsReward, "form", "")
	}
	if r.activated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activated", r.activated, "form", "")
	}
	if r.expires != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expires", r.expires, "form", "")
	}
	if r.noExpiration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noExpiration", r.noExpiration, "form", "")
	}
	if r.availableLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableLimit", r.availableLimit, "form", "")
	}
	if r.availableLimitPerUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableLimitPerUser", r.availableLimitPerUser, "form", "")
	}
	if r.addedLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addedLimit", r.addedLimit, "form", "")
	}
	if r.viewLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewLimit", r.viewLimit, "form", "")
	}
	if r.maxPrints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxPrints", r.maxPrints, "form", "")
	}
	if r.ticketPriceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketPriceType", r.ticketPriceType, "form", "")
	}
	if r.ticketPrice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketPrice", r.ticketPrice, "form", "")
	}
	if r.fullPrice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fullPrice", r.fullPrice, "form", "")
	}
	if r.discountPrice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "discountPrice", r.discountPrice, "form", "")
	}
	if r.showRemaining != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showRemaining", r.showRemaining, "form", "")
	}
	if r.showRedeemed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showRedeemed", r.showRedeemed, "form", "")
	}
	if r.replaced != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "replaced", r.replaced, "form", "")
	}
	if r.featured != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "featured", r.featured, "form", "")
	}
	if r.offerType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerType", r.offerType, "form", "")
	}
	if r.specialOfferType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "specialOfferType", r.specialOfferType, "form", "")
	}
	if r.offerVisibility != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerVisibility", r.offerVisibility, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.filterIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterIds", r.filterIds, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.barcodeAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "barcodeAssetId", r.barcodeAssetId, "form", "")
	}
	if r.imageAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId", r.imageAssetId, "form", "")
	}
	if r.imageAssetId1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId1", r.imageAssetId1, "form", "")
	}
	if r.imageAssetId2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId2", r.imageAssetId2, "form", "")
	}
	if r.imageAssetId3 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId3", r.imageAssetId3, "form", "")
	}
	if r.imageAssetId4 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId4", r.imageAssetId4, "form", "")
	}
	if r.imageAssetId5 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId5", r.imageAssetId5, "form", "")
	}
	if r.publisher != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publisher", r.publisher, "form", "")
	}
	if r.redeemableStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemableStart", r.redeemableStart, "form", "")
	}
	if r.redeemableEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemableEnd", r.redeemableEnd, "form", "")
	}
	if r.brand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "brand", r.brand, "form", "")
	}
	if r.productType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "productType", r.productType, "form", "")
	}
	if r.conditionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conditionType", r.conditionType, "form", "")
	}
	if r.isbn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isbn", r.isbn, "form", "")
	}
	if r.asin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asin", r.asin, "form", "")
	}
	if r.catalogNumbers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "catalogNumbers", r.catalogNumbers, "form", "")
	}
	if r.department != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "department", r.department, "form", "")
	}
	if r.features != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "features", r.features, "form", "")
	}
	if r.minimumPrice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minimumPrice", r.minimumPrice, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	}
	if r.weight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "weight", r.weight, "form", "")
	}
	if r.unit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unit", r.unit, "form", "")
	}
	if r.studio != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "studio", r.studio, "form", "")
	}
	if r.parentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentalRating", r.parentalRating, "form", "")
	}
	if r.publishDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publishDate", r.publishDate, "form", "")
	}
	if r.availabilityDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availabilityDate", r.availabilityDate, "form", "")
	}
	if r.sizeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sizeId", r.sizeId, "form", "")
	}
	if r.listingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listingId", r.listingId, "form", "")
	}
	if r.mediaType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaType", r.mediaType, "form", "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "form", "")
	}
	if r.author != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "author", r.author, "form", "")
	}
	if r.releaseDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "releaseDate", r.releaseDate, "form", "")
	}
	if r.collectionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "collectionIds", r.collectionIds, "form", "")
	}
	if r.rebootTimeHour != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rebootTimeHour", r.rebootTimeHour, "form", "")
	}
	if r.rebootTimeMinute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rebootTimeMinute", r.rebootTimeMinute, "form", "")
	}
	if r.idleTimeoutInSecond != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idleTimeoutInSecond", r.idleTimeoutInSecond, "form", "")
	}
	if r.serialNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialNumber", r.serialNumber, "form", "")
	}
	if r.udid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udid", r.udid, "form", "")
	}
	if r.deviceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceType", r.deviceType, "form", "")
	}
	if r.devicePower != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "devicePower", r.devicePower, "form", "")
	}
	if r.deviceInterference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceInterference", r.deviceInterference, "form", "")
	}
	if r.availability != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availability", r.availability, "form", "")
	}
	if r.availabilitySummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availabilitySummary", r.availabilitySummary, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOfferStatusRequest struct {
	ctx context.Context
	ApiService *OfferAPIService
	version float32
	offerIds *string
	active *bool
	deviceId *string
	accountId *int64
}

// Comma separated list of offer ids
func (r ApiUpdateOfferStatusRequest) OfferIds(offerIds string) ApiUpdateOfferStatusRequest {
	r.offerIds = &offerIds
	return r
}

// Determines whether to make the offer active as well
func (r ApiUpdateOfferStatusRequest) Active(active bool) ApiUpdateOfferStatusRequest {
	r.active = &active
	return r
}

// The device id (deviceId or accountId required)
func (r ApiUpdateOfferStatusRequest) DeviceId(deviceId string) ApiUpdateOfferStatusRequest {
	r.deviceId = &deviceId
	return r
}

// The account used to perform the activation, must have rights to edit the offer.
func (r ApiUpdateOfferStatusRequest) AccountId(accountId int64) ApiUpdateOfferStatusRequest {
	r.accountId = &accountId
	return r
}

func (r ApiUpdateOfferStatusRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.UpdateOfferStatusExecute(r)
}

/*
UpdateOfferStatus Activate Offer

Sets the activated date on offers. This will make offers visible for consumers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateOfferStatusRequest
*/
func (a *OfferAPIService) UpdateOfferStatus(ctx context.Context, version float32) ApiUpdateOfferStatusRequest {
	return ApiUpdateOfferStatusRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *OfferAPIService) UpdateOfferStatusExecute(r ApiUpdateOfferStatusRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OfferAPIService.UpdateOfferStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/retailer/offer/status"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.offerIds == nil {
		return localVarReturnValue, nil, reportError("offerIds is required and must be specified")
	}
	if r.active == nil {
		return localVarReturnValue, nil, reportError("active is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "offerIds", r.offerIds, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
