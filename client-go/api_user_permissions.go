/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// UserPermissionsAPIService UserPermissionsAPI service
type UserPermissionsAPIService service

type ApiAddUsersToPermissionableRequest struct {
	ctx context.Context
	ApiService *UserPermissionsAPIService
	permissionableType *string
	permissionableId *int64
	deviceId *string
	accountId *int64
	read *bool
	write *bool
	delete *bool
	add *bool
	connectionIds *string
	connectionAccountIds *string
	connectionGroupIds *string
	pending *bool
	admin *bool
	includeFriendGroup *bool
	latitude *float64
	longitude *float64
	audienceIds *string
}

// the permissionable type of the object
func (r ApiAddUsersToPermissionableRequest) PermissionableType(permissionableType string) ApiAddUsersToPermissionableRequest {
	r.permissionableType = &permissionableType
	return r
}

// the id of the permissionable object
func (r ApiAddUsersToPermissionableRequest) PermissionableId(permissionableId int64) ApiAddUsersToPermissionableRequest {
	r.permissionableId = &permissionableId
	return r
}

// the device id (deviceId or accountId required)
func (r ApiAddUsersToPermissionableRequest) DeviceId(deviceId string) ApiAddUsersToPermissionableRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiAddUsersToPermissionableRequest) AccountId(accountId int64) ApiAddUsersToPermissionableRequest {
	r.accountId = &accountId
	return r
}

// the read permission of the users/groups
func (r ApiAddUsersToPermissionableRequest) Read(read bool) ApiAddUsersToPermissionableRequest {
	r.read = &read
	return r
}

// the write permission of the users/groups
func (r ApiAddUsersToPermissionableRequest) Write(write bool) ApiAddUsersToPermissionableRequest {
	r.write = &write
	return r
}

// the delete permission of the users/groups
func (r ApiAddUsersToPermissionableRequest) Delete(delete bool) ApiAddUsersToPermissionableRequest {
	r.delete = &delete
	return r
}

// the add permission of the users/groups
func (r ApiAddUsersToPermissionableRequest) Add(add bool) ApiAddUsersToPermissionableRequest {
	r.add = &add
	return r
}

// a comma separated list of connection ids (NOT the account ids)
func (r ApiAddUsersToPermissionableRequest) ConnectionIds(connectionIds string) ApiAddUsersToPermissionableRequest {
	r.connectionIds = &connectionIds
	return r
}

// a comma separated list of account ids
func (r ApiAddUsersToPermissionableRequest) ConnectionAccountIds(connectionAccountIds string) ApiAddUsersToPermissionableRequest {
	r.connectionAccountIds = &connectionAccountIds
	return r
}

// a comma separated list of connection group ids (these are groups made by the user)
func (r ApiAddUsersToPermissionableRequest) ConnectionGroupIds(connectionGroupIds string) ApiAddUsersToPermissionableRequest {
	r.connectionGroupIds = &connectionGroupIds
	return r
}

// sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept)
func (r ApiAddUsersToPermissionableRequest) Pending(pending bool) ApiAddUsersToPermissionableRequest {
	r.pending = &pending
	return r
}

// sets whether the added users will become admins or not
func (r ApiAddUsersToPermissionableRequest) Admin(admin bool) ApiAddUsersToPermissionableRequest {
	r.admin = &admin
	return r
}

// flag to determine whether to include the built-in \&quot;friends\&quot; group
func (r ApiAddUsersToPermissionableRequest) IncludeFriendGroup(includeFriendGroup bool) ApiAddUsersToPermissionableRequest {
	r.includeFriendGroup = &includeFriendGroup
	return r
}

// the current latitude of the user
func (r ApiAddUsersToPermissionableRequest) Latitude(latitude float64) ApiAddUsersToPermissionableRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiAddUsersToPermissionableRequest) Longitude(longitude float64) ApiAddUsersToPermissionableRequest {
	r.longitude = &longitude
	return r
}

// comma separated list of audience ids. This is a feature only available to the permissionable&#39;s application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used.
func (r ApiAddUsersToPermissionableRequest) AudienceIds(audienceIds string) ApiAddUsersToPermissionableRequest {
	r.audienceIds = &audienceIds
	return r
}

func (r ApiAddUsersToPermissionableRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.AddUsersToPermissionableExecute(r)
}

/*
AddUsersToPermissionable Add User

Adds a user to a permissionable object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddUsersToPermissionableRequest
*/
func (a *UserPermissionsAPIService) AddUsersToPermissionable(ctx context.Context) ApiAddUsersToPermissionableRequest {
	return ApiAddUsersToPermissionableRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *UserPermissionsAPIService) AddUsersToPermissionableExecute(r ApiAddUsersToPermissionableRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserPermissionsAPIService.AddUsersToPermissionable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/permissions/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.permissionableType == nil {
		return localVarReturnValue, nil, reportError("permissionableType is required and must be specified")
	}
	if r.permissionableId == nil {
		return localVarReturnValue, nil, reportError("permissionableId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "permissionableType", r.permissionableType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "permissionableId", r.permissionableId, "form", "")
	if r.read != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "read", r.read, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "read", defaultValue, "form", "")
		r.read = &defaultValue
	}
	if r.write != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "write", r.write, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "write", defaultValue, "form", "")
		r.write = &defaultValue
	}
	if r.delete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delete", r.delete, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "delete", defaultValue, "form", "")
		r.delete = &defaultValue
	}
	if r.add != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "add", r.add, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "add", defaultValue, "form", "")
		r.add = &defaultValue
	}
	if r.connectionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionIds", r.connectionIds, "form", "")
	}
	if r.connectionAccountIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountIds", r.connectionAccountIds, "form", "")
	}
	if r.connectionGroupIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionGroupIds", r.connectionGroupIds, "form", "")
	}
	if r.pending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pending", r.pending, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "pending", defaultValue, "form", "")
		r.pending = &defaultValue
	}
	if r.admin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "admin", r.admin, "form", "")
	}
	if r.includeFriendGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFriendGroup", r.includeFriendGroup, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFriendGroup", defaultValue, "form", "")
		r.includeFriendGroup = &defaultValue
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.audienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIds", r.audienceIds, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApprovePermissionableRequest struct {
	ctx context.Context
	ApiService *UserPermissionsAPIService
	permissionableType *string
	permissionableId *int64
	deviceId *string
	accountId *int64
	approvalStatus *string
}

// The permissionable type of the object
func (r ApiApprovePermissionableRequest) PermissionableType(permissionableType string) ApiApprovePermissionableRequest {
	r.permissionableType = &permissionableType
	return r
}

// The id of the permissionable object
func (r ApiApprovePermissionableRequest) PermissionableId(permissionableId int64) ApiApprovePermissionableRequest {
	r.permissionableId = &permissionableId
	return r
}

// A unique ID given by the device (deviceId or accountId required)
func (r ApiApprovePermissionableRequest) DeviceId(deviceId string) ApiApprovePermissionableRequest {
	r.deviceId = &deviceId
	return r
}

// The account ID of the user (deviceId or accountId required)
func (r ApiApprovePermissionableRequest) AccountId(accountId int64) ApiApprovePermissionableRequest {
	r.accountId = &accountId
	return r
}

// The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
func (r ApiApprovePermissionableRequest) ApprovalStatus(approvalStatus string) ApiApprovePermissionableRequest {
	r.approvalStatus = &approvalStatus
	return r
}

func (r ApiApprovePermissionableRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.ApprovePermissionableExecute(r)
}

/*
ApprovePermissionable Approve Permissionable

Sets the approval status of a permissionable object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApprovePermissionableRequest
*/
func (a *UserPermissionsAPIService) ApprovePermissionable(ctx context.Context) ApiApprovePermissionableRequest {
	return ApiApprovePermissionableRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *UserPermissionsAPIService) ApprovePermissionableExecute(r ApiApprovePermissionableRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserPermissionsAPIService.ApprovePermissionable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/permissionable/approve"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.permissionableType == nil {
		return localVarReturnValue, nil, reportError("permissionableType is required and must be specified")
	}
	if r.permissionableId == nil {
		return localVarReturnValue, nil, reportError("permissionableId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "permissionableType", r.permissionableType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "permissionableId", r.permissionableId, "form", "")
	if r.approvalStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalStatus", r.approvalStatus, "form", "")
	} else {
		var defaultValue string = "APPROVED"
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalStatus", defaultValue, "form", "")
		r.approvalStatus = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLeaveFromPermissionableRequest struct {
	ctx context.Context
	ApiService *UserPermissionsAPIService
	permissionableType *string
	permissionableId *int64
	deviceId *string
	accountId *int64
	latitude *float64
	longitude *float64
}

// the permissionable type PermissionableType
func (r ApiLeaveFromPermissionableRequest) PermissionableType(permissionableType string) ApiLeaveFromPermissionableRequest {
	r.permissionableType = &permissionableType
	return r
}

// the id of the permissionable object
func (r ApiLeaveFromPermissionableRequest) PermissionableId(permissionableId int64) ApiLeaveFromPermissionableRequest {
	r.permissionableId = &permissionableId
	return r
}

// the device id (deviceId or accountId required)
func (r ApiLeaveFromPermissionableRequest) DeviceId(deviceId string) ApiLeaveFromPermissionableRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiLeaveFromPermissionableRequest) AccountId(accountId int64) ApiLeaveFromPermissionableRequest {
	r.accountId = &accountId
	return r
}

// the current latitude of the user
func (r ApiLeaveFromPermissionableRequest) Latitude(latitude float64) ApiLeaveFromPermissionableRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiLeaveFromPermissionableRequest) Longitude(longitude float64) ApiLeaveFromPermissionableRequest {
	r.longitude = &longitude
	return r
}

func (r ApiLeaveFromPermissionableRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.LeaveFromPermissionableExecute(r)
}

/*
LeaveFromPermissionable Leave

Used when the user wants to leave from someone else's permissionable object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLeaveFromPermissionableRequest
*/
func (a *UserPermissionsAPIService) LeaveFromPermissionable(ctx context.Context) ApiLeaveFromPermissionableRequest {
	return ApiLeaveFromPermissionableRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *UserPermissionsAPIService) LeaveFromPermissionableExecute(r ApiLeaveFromPermissionableRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserPermissionsAPIService.LeaveFromPermissionable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/permissions/leave"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.permissionableType == nil {
		return localVarReturnValue, nil, reportError("permissionableType is required and must be specified")
	}
	if r.permissionableId == nil {
		return localVarReturnValue, nil, reportError("permissionableId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "permissionableType", r.permissionableType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "permissionableId", r.permissionableId, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveUsersFromPermissionableRequest struct {
	ctx context.Context
	ApiService *UserPermissionsAPIService
	permissionableType *string
	permissionableId *int64
	deviceId *string
	accountId *int64
	connectionIds *string
	connectionAccountIds *string
	connectionGroupIds *string
	removeFriendGroup *bool
	latitude *float64
	longitude *float64
	audienceIds *string
}

// the permissionable type of the object
func (r ApiRemoveUsersFromPermissionableRequest) PermissionableType(permissionableType string) ApiRemoveUsersFromPermissionableRequest {
	r.permissionableType = &permissionableType
	return r
}

// the id of the permissionable object
func (r ApiRemoveUsersFromPermissionableRequest) PermissionableId(permissionableId int64) ApiRemoveUsersFromPermissionableRequest {
	r.permissionableId = &permissionableId
	return r
}

// the device id (deviceId or accountId required)
func (r ApiRemoveUsersFromPermissionableRequest) DeviceId(deviceId string) ApiRemoveUsersFromPermissionableRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiRemoveUsersFromPermissionableRequest) AccountId(accountId int64) ApiRemoveUsersFromPermissionableRequest {
	r.accountId = &accountId
	return r
}

// a comma separated list of connection ids (NOT the account ids)
func (r ApiRemoveUsersFromPermissionableRequest) ConnectionIds(connectionIds string) ApiRemoveUsersFromPermissionableRequest {
	r.connectionIds = &connectionIds
	return r
}

// a comma separated list of account ids
func (r ApiRemoveUsersFromPermissionableRequest) ConnectionAccountIds(connectionAccountIds string) ApiRemoveUsersFromPermissionableRequest {
	r.connectionAccountIds = &connectionAccountIds
	return r
}

// a comma separated list of connection group ids (these are groups made by the user)
func (r ApiRemoveUsersFromPermissionableRequest) ConnectionGroupIds(connectionGroupIds string) ApiRemoveUsersFromPermissionableRequest {
	r.connectionGroupIds = &connectionGroupIds
	return r
}

// flag to determine whether to remove the built-in \&quot;friends\&quot; group
func (r ApiRemoveUsersFromPermissionableRequest) RemoveFriendGroup(removeFriendGroup bool) ApiRemoveUsersFromPermissionableRequest {
	r.removeFriendGroup = &removeFriendGroup
	return r
}

// the current latitude of the user
func (r ApiRemoveUsersFromPermissionableRequest) Latitude(latitude float64) ApiRemoveUsersFromPermissionableRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiRemoveUsersFromPermissionableRequest) Longitude(longitude float64) ApiRemoveUsersFromPermissionableRequest {
	r.longitude = &longitude
	return r
}

// comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used.
func (r ApiRemoveUsersFromPermissionableRequest) AudienceIds(audienceIds string) ApiRemoveUsersFromPermissionableRequest {
	r.audienceIds = &audienceIds
	return r
}

func (r ApiRemoveUsersFromPermissionableRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.RemoveUsersFromPermissionableExecute(r)
}

/*
RemoveUsersFromPermissionable Remove User

Used to remove someone (assuming they have permission) from a permissionable object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoveUsersFromPermissionableRequest
*/
func (a *UserPermissionsAPIService) RemoveUsersFromPermissionable(ctx context.Context) ApiRemoveUsersFromPermissionableRequest {
	return ApiRemoveUsersFromPermissionableRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *UserPermissionsAPIService) RemoveUsersFromPermissionableExecute(r ApiRemoveUsersFromPermissionableRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserPermissionsAPIService.RemoveUsersFromPermissionable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/consumer/permissions/remove"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.permissionableType == nil {
		return localVarReturnValue, nil, reportError("permissionableType is required and must be specified")
	}
	if r.permissionableId == nil {
		return localVarReturnValue, nil, reportError("permissionableId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "permissionableType", r.permissionableType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "permissionableId", r.permissionableId, "form", "")
	if r.connectionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionIds", r.connectionIds, "form", "")
	}
	if r.connectionAccountIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountIds", r.connectionAccountIds, "form", "")
	}
	if r.connectionGroupIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionGroupIds", r.connectionGroupIds, "form", "")
	}
	if r.removeFriendGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "removeFriendGroup", r.removeFriendGroup, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "removeFriendGroup", defaultValue, "form", "")
		r.removeFriendGroup = &defaultValue
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.audienceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audienceIds", r.audienceIds, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchPermissionablesRequest struct {
	ctx context.Context
	ApiService *UserPermissionsAPIService
	deviceId *string
	accountId *int64
	connectionAccountId *int64
	connectionAccountIds *string
	permissionableType *string
	permissionableId *int64
	keyword *string
	sortField *string
	descending *bool
	pending *bool
	admin *bool
	start *int32
	limit *int32
}

// A unique ID given by the device (deviceId or accountId required)
func (r ApiSearchPermissionablesRequest) DeviceId(deviceId string) ApiSearchPermissionablesRequest {
	r.deviceId = &deviceId
	return r
}

// The account ID of the user (deviceId or accountId required)
func (r ApiSearchPermissionablesRequest) AccountId(accountId int64) ApiSearchPermissionablesRequest {
	r.accountId = &accountId
	return r
}

// Filter results for a specific user account
func (r ApiSearchPermissionablesRequest) ConnectionAccountId(connectionAccountId int64) ApiSearchPermissionablesRequest {
	r.connectionAccountId = &connectionAccountId
	return r
}

// Comma separated list of account IDs to filter results with
func (r ApiSearchPermissionablesRequest) ConnectionAccountIds(connectionAccountIds string) ApiSearchPermissionablesRequest {
	r.connectionAccountIds = &connectionAccountIds
	return r
}

// Filter user permissions by the permissionable object type
func (r ApiSearchPermissionablesRequest) PermissionableType(permissionableType string) ApiSearchPermissionablesRequest {
	r.permissionableType = &permissionableType
	return r
}

// The id of the permissionable object to filter by
func (r ApiSearchPermissionablesRequest) PermissionableId(permissionableId int64) ApiSearchPermissionablesRequest {
	r.permissionableId = &permissionableId
	return r
}

// Keyword to search within permissionable records
func (r ApiSearchPermissionablesRequest) Keyword(keyword string) ApiSearchPermissionablesRequest {
	r.keyword = &keyword
	return r
}

// Field to sort results on
func (r ApiSearchPermissionablesRequest) SortField(sortField string) ApiSearchPermissionablesRequest {
	r.sortField = &sortField
	return r
}

// Sort descending when true
func (r ApiSearchPermissionablesRequest) Descending(descending bool) ApiSearchPermissionablesRequest {
	r.descending = &descending
	return r
}

// Return user permissions that are pending
func (r ApiSearchPermissionablesRequest) Pending(pending bool) ApiSearchPermissionablesRequest {
	r.pending = &pending
	return r
}

// Return user permissions that are admins
func (r ApiSearchPermissionablesRequest) Admin(admin bool) ApiSearchPermissionablesRequest {
	r.admin = &admin
	return r
}

// the start index for pagination
func (r ApiSearchPermissionablesRequest) Start(start int32) ApiSearchPermissionablesRequest {
	r.start = &start
	return r
}

// the limit for pagination
func (r ApiSearchPermissionablesRequest) Limit(limit int32) ApiSearchPermissionablesRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchPermissionablesRequest) Execute() ([]UserPermissionsResponse, *http.Response, error) {
	return r.ApiService.SearchPermissionablesExecute(r)
}

/*
SearchPermissionables Search Permissionables

Search on UserPermissions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchPermissionablesRequest
*/
func (a *UserPermissionsAPIService) SearchPermissionables(ctx context.Context) ApiSearchPermissionablesRequest {
	return ApiSearchPermissionablesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UserPermissionsResponse
func (a *UserPermissionsAPIService) SearchPermissionablesExecute(r ApiSearchPermissionablesRequest) ([]UserPermissionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UserPermissionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserPermissionsAPIService.SearchPermissionables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/permissions/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.connectionAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountId", r.connectionAccountId, "form", "")
	}
	if r.connectionAccountIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountIds", r.connectionAccountIds, "form", "")
	}
	if r.permissionableType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permissionableType", r.permissionableType, "form", "")
	}
	if r.permissionableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permissionableId", r.permissionableId, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.pending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pending", r.pending, "form", "")
	}
	if r.admin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "admin", r.admin, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchPermissionablesFollowingDistanceRequest struct {
	ctx context.Context
	ApiService *UserPermissionsAPIService
	latitude *float64
	longitude *float64
	deviceId *string
	accountId *int64
	connectionAccountId *int64
	connectionAccountIds *string
	permissionableType *string
	permissionableId *int64
	searchRange *float64
	keyword *string
	pending *bool
	admin *bool
	start *int32
	limit *int32
}

// The latitude of the current account
func (r ApiSearchPermissionablesFollowingDistanceRequest) Latitude(latitude float64) ApiSearchPermissionablesFollowingDistanceRequest {
	r.latitude = &latitude
	return r
}

// The longitude of the current account
func (r ApiSearchPermissionablesFollowingDistanceRequest) Longitude(longitude float64) ApiSearchPermissionablesFollowingDistanceRequest {
	r.longitude = &longitude
	return r
}

// A unique ID given by the device (deviceId or accountId required)
func (r ApiSearchPermissionablesFollowingDistanceRequest) DeviceId(deviceId string) ApiSearchPermissionablesFollowingDistanceRequest {
	r.deviceId = &deviceId
	return r
}

// The account ID of the user (deviceId or accountId required)
func (r ApiSearchPermissionablesFollowingDistanceRequest) AccountId(accountId int64) ApiSearchPermissionablesFollowingDistanceRequest {
	r.accountId = &accountId
	return r
}

// Filter results for a specific user account
func (r ApiSearchPermissionablesFollowingDistanceRequest) ConnectionAccountId(connectionAccountId int64) ApiSearchPermissionablesFollowingDistanceRequest {
	r.connectionAccountId = &connectionAccountId
	return r
}

// Comma separated list of account IDs to filter results with
func (r ApiSearchPermissionablesFollowingDistanceRequest) ConnectionAccountIds(connectionAccountIds string) ApiSearchPermissionablesFollowingDistanceRequest {
	r.connectionAccountIds = &connectionAccountIds
	return r
}

// Filter user permissions by the permissionable object type
func (r ApiSearchPermissionablesFollowingDistanceRequest) PermissionableType(permissionableType string) ApiSearchPermissionablesFollowingDistanceRequest {
	r.permissionableType = &permissionableType
	return r
}

// The id of the permissionable object to filter by
func (r ApiSearchPermissionablesFollowingDistanceRequest) PermissionableId(permissionableId int64) ApiSearchPermissionablesFollowingDistanceRequest {
	r.permissionableId = &permissionableId
	return r
}

// The search range in miles
func (r ApiSearchPermissionablesFollowingDistanceRequest) SearchRange(searchRange float64) ApiSearchPermissionablesFollowingDistanceRequest {
	r.searchRange = &searchRange
	return r
}

// Keyword to search within permissionable records
func (r ApiSearchPermissionablesFollowingDistanceRequest) Keyword(keyword string) ApiSearchPermissionablesFollowingDistanceRequest {
	r.keyword = &keyword
	return r
}

// Return user permissions that are pending
func (r ApiSearchPermissionablesFollowingDistanceRequest) Pending(pending bool) ApiSearchPermissionablesFollowingDistanceRequest {
	r.pending = &pending
	return r
}

// Return user permissions that are admins
func (r ApiSearchPermissionablesFollowingDistanceRequest) Admin(admin bool) ApiSearchPermissionablesFollowingDistanceRequest {
	r.admin = &admin
	return r
}

// The start index for pagination
func (r ApiSearchPermissionablesFollowingDistanceRequest) Start(start int32) ApiSearchPermissionablesFollowingDistanceRequest {
	r.start = &start
	return r
}

// The limit for pagination
func (r ApiSearchPermissionablesFollowingDistanceRequest) Limit(limit int32) ApiSearchPermissionablesFollowingDistanceRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchPermissionablesFollowingDistanceRequest) Execute() ([]UserPermissionsResponse, *http.Response, error) {
	return r.ApiService.SearchPermissionablesFollowingDistanceExecute(r)
}

/*
SearchPermissionablesFollowingDistance Search Permissionables by Distnace

Search on UserPermissions by distance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchPermissionablesFollowingDistanceRequest
*/
func (a *UserPermissionsAPIService) SearchPermissionablesFollowingDistance(ctx context.Context) ApiSearchPermissionablesFollowingDistanceRequest {
	return ApiSearchPermissionablesFollowingDistanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UserPermissionsResponse
func (a *UserPermissionsAPIService) SearchPermissionablesFollowingDistanceExecute(r ApiSearchPermissionablesFollowingDistanceRequest) ([]UserPermissionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UserPermissionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserPermissionsAPIService.SearchPermissionablesFollowingDistance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/permissions/distancesearch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.latitude == nil {
		return localVarReturnValue, nil, reportError("latitude is required and must be specified")
	}
	if r.longitude == nil {
		return localVarReturnValue, nil, reportError("longitude is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.connectionAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountId", r.connectionAccountId, "form", "")
	}
	if r.connectionAccountIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionAccountIds", r.connectionAccountIds, "form", "")
	}
	if r.permissionableType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permissionableType", r.permissionableType, "form", "")
	}
	if r.permissionableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permissionableId", r.permissionableId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	if r.searchRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchRange", r.searchRange, "form", "")
	} else {
		var defaultValue float64 = 5
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchRange", defaultValue, "form", "")
		r.searchRange = &defaultValue
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.pending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pending", r.pending, "form", "")
	}
	if r.admin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "admin", r.admin, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
