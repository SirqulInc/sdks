/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// RatingAPIService RatingAPI service
type RatingAPIService service

type ApiCreateRatingRequest struct {
	ctx context.Context
	ApiService *RatingAPIService
	ratableType *string
	ratableId *int64
	ratingValue *int32
	deviceId *string
	accountId *int64
	categoryId *int64
	display *string
	description *string
	locationDescription *string
	latitude *float64
	longitude *float64
}

// The ratable object type {RETAILER_LOCATION}
func (r ApiCreateRatingRequest) RatableType(ratableType string) ApiCreateRatingRequest {
	r.ratableType = &ratableType
	return r
}

// The id of the ratable object
func (r ApiCreateRatingRequest) RatableId(ratableId int64) ApiCreateRatingRequest {
	r.ratableId = &ratableId
	return r
}

// The integer value of 0-100
func (r ApiCreateRatingRequest) RatingValue(ratingValue int32) ApiCreateRatingRequest {
	r.ratingValue = &ratingValue
	return r
}

// The unique device identifier that made the request (either deviceId or accountId must be used)
func (r ApiCreateRatingRequest) DeviceId(deviceId string) ApiCreateRatingRequest {
	r.deviceId = &deviceId
	return r
}

// The unique accountId that made the request (either deviceId or accountId must be used)
func (r ApiCreateRatingRequest) AccountId(accountId int64) ApiCreateRatingRequest {
	r.accountId = &accountId
	return r
}

// 
func (r ApiCreateRatingRequest) CategoryId(categoryId int64) ApiCreateRatingRequest {
	r.categoryId = &categoryId
	return r
}

// A subject title for the user rating (limited to 255 characters)
func (r ApiCreateRatingRequest) Display(display string) ApiCreateRatingRequest {
	r.display = &display
	return r
}

// The description of the rating
func (r ApiCreateRatingRequest) Description(description string) ApiCreateRatingRequest {
	r.description = &description
	return r
}

// The description of the location
func (r ApiCreateRatingRequest) LocationDescription(locationDescription string) ApiCreateRatingRequest {
	r.locationDescription = &locationDescription
	return r
}

// The current location of the user
func (r ApiCreateRatingRequest) Latitude(latitude float64) ApiCreateRatingRequest {
	r.latitude = &latitude
	return r
}

// The current location of the user
func (r ApiCreateRatingRequest) Longitude(longitude float64) ApiCreateRatingRequest {
	r.longitude = &longitude
	return r
}

func (r ApiCreateRatingRequest) Execute() (*RatingResponse, *http.Response, error) {
	return r.ApiService.CreateRatingExecute(r)
}

/*
CreateRating Create Rating

This is used to leave rating on a ratable object (i.e. retailer locations). Each user can only rate on a ratable object once per category. If a user rates on the same object and category, the previous rating will be overwritten. Leaving a rating on a ratable object will be visible to everyone who has access to view the object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRatingRequest
*/
func (a *RatingAPIService) CreateRating(ctx context.Context) ApiCreateRatingRequest {
	return ApiCreateRatingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RatingResponse
func (a *RatingAPIService) CreateRatingExecute(r ApiCreateRatingRequest) (*RatingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RatingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatingAPIService.CreateRating")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rating/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ratableType == nil {
		return localVarReturnValue, nil, reportError("ratableType is required and must be specified")
	}
	if r.ratableId == nil {
		return localVarReturnValue, nil, reportError("ratableId is required and must be specified")
	}
	if r.ratingValue == nil {
		return localVarReturnValue, nil, reportError("ratingValue is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ratableType", r.ratableType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ratableId", r.ratableId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ratingValue", r.ratingValue, "form", "")
	if r.categoryId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryId", r.categoryId, "form", "")
	}
	if r.display != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "display", r.display, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.locationDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locationDescription", r.locationDescription, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRatingRequest struct {
	ctx context.Context
	ApiService *RatingAPIService
	ratingId *int64
	deviceId *string
	accountId *int64
}

// The ID of the rating to delete
func (r ApiDeleteRatingRequest) RatingId(ratingId int64) ApiDeleteRatingRequest {
	r.ratingId = &ratingId
	return r
}

// The unique device identifier that made the request (either deviceId or accountId must be used)
func (r ApiDeleteRatingRequest) DeviceId(deviceId string) ApiDeleteRatingRequest {
	r.deviceId = &deviceId
	return r
}

// The unique accountId that made the request (either deviceId or accountId must be used)
func (r ApiDeleteRatingRequest) AccountId(accountId int64) ApiDeleteRatingRequest {
	r.accountId = &accountId
	return r
}

func (r ApiDeleteRatingRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteRatingExecute(r)
}

/*
DeleteRating Delete Rating

Sets a rating as deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteRatingRequest
*/
func (a *RatingAPIService) DeleteRating(ctx context.Context) ApiDeleteRatingRequest {
	return ApiDeleteRatingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *RatingAPIService) DeleteRatingExecute(r ApiDeleteRatingRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatingAPIService.DeleteRating")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rating/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ratingId == nil {
		return localVarReturnValue, nil, reportError("ratingId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ratingId", r.ratingId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchLocationRatingIndexesRequest struct {
	ctx context.Context
	ApiService *RatingAPIService
	categoryIds *string
	keyword *string
	locationType *string
	sortField *string
	descending *bool
	start *int32
	limit *int32
	searchRange *float64
	latitude *float64
	longitude *float64
	returnOverallRating *bool
	distanceUnit *string
	returnRetailer *bool
	returnAssets *bool
	returnOffers *bool
	returnCategories *bool
	returnFilters *bool
}

// Comma separated list of category ids to filter the results by
func (r ApiSearchLocationRatingIndexesRequest) CategoryIds(categoryIds string) ApiSearchLocationRatingIndexesRequest {
	r.categoryIds = &categoryIds
	return r
}

// The keyword used to search
func (r ApiSearchLocationRatingIndexesRequest) Keyword(keyword string) ApiSearchLocationRatingIndexesRequest {
	r.keyword = &keyword
	return r
}

// The type of location to filter the results by
func (r ApiSearchLocationRatingIndexesRequest) LocationType(locationType string) ApiSearchLocationRatingIndexesRequest {
	r.locationType = &locationType
	return r
}

// The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}
func (r ApiSearchLocationRatingIndexesRequest) SortField(sortField string) ApiSearchLocationRatingIndexesRequest {
	r.sortField = &sortField
	return r
}

// The order to return the search results
func (r ApiSearchLocationRatingIndexesRequest) Descending(descending bool) ApiSearchLocationRatingIndexesRequest {
	r.descending = &descending
	return r
}

// The record to begin the return set on
func (r ApiSearchLocationRatingIndexesRequest) Start(start int32) ApiSearchLocationRatingIndexesRequest {
	r.start = &start
	return r
}

// The number of records to return
func (r ApiSearchLocationRatingIndexesRequest) Limit(limit int32) ApiSearchLocationRatingIndexesRequest {
	r.limit = &limit
	return r
}

// The search radius in kilometers to filter results
func (r ApiSearchLocationRatingIndexesRequest) SearchRange(searchRange float64) ApiSearchLocationRatingIndexesRequest {
	r.searchRange = &searchRange
	return r
}

// The current location of the user
func (r ApiSearchLocationRatingIndexesRequest) Latitude(latitude float64) ApiSearchLocationRatingIndexesRequest {
	r.latitude = &latitude
	return r
}

// The current location of the user
func (r ApiSearchLocationRatingIndexesRequest) Longitude(longitude float64) ApiSearchLocationRatingIndexesRequest {
	r.longitude = &longitude
	return r
}

// Determines whether to return the overall rating record instead
func (r ApiSearchLocationRatingIndexesRequest) ReturnOverallRating(returnOverallRating bool) ApiSearchLocationRatingIndexesRequest {
	r.returnOverallRating = &returnOverallRating
	return r
}

// 
func (r ApiSearchLocationRatingIndexesRequest) DistanceUnit(distanceUnit string) ApiSearchLocationRatingIndexesRequest {
	r.distanceUnit = &distanceUnit
	return r
}

// whether to return the retailer or not
func (r ApiSearchLocationRatingIndexesRequest) ReturnRetailer(returnRetailer bool) ApiSearchLocationRatingIndexesRequest {
	r.returnRetailer = &returnRetailer
	return r
}

// whether to return the assets or not
func (r ApiSearchLocationRatingIndexesRequest) ReturnAssets(returnAssets bool) ApiSearchLocationRatingIndexesRequest {
	r.returnAssets = &returnAssets
	return r
}

// whether to return the offers or not
func (r ApiSearchLocationRatingIndexesRequest) ReturnOffers(returnOffers bool) ApiSearchLocationRatingIndexesRequest {
	r.returnOffers = &returnOffers
	return r
}

// whether to return the categories or not
func (r ApiSearchLocationRatingIndexesRequest) ReturnCategories(returnCategories bool) ApiSearchLocationRatingIndexesRequest {
	r.returnCategories = &returnCategories
	return r
}

// whether to return the filters or not
func (r ApiSearchLocationRatingIndexesRequest) ReturnFilters(returnFilters bool) ApiSearchLocationRatingIndexesRequest {
	r.returnFilters = &returnFilters
	return r
}

func (r ApiSearchLocationRatingIndexesRequest) Execute() ([]RatingIndexResponse, *http.Response, error) {
	return r.ApiService.SearchLocationRatingIndexesExecute(r)
}

/*
SearchLocationRatingIndexes Search Location Rating Indexes

Search for retailer locations by averages near you.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchLocationRatingIndexesRequest
*/
func (a *RatingAPIService) SearchLocationRatingIndexes(ctx context.Context) ApiSearchLocationRatingIndexesRequest {
	return ApiSearchLocationRatingIndexesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RatingIndexResponse
func (a *RatingAPIService) SearchLocationRatingIndexesExecute(r ApiSearchLocationRatingIndexesRequest) ([]RatingIndexResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RatingIndexResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatingAPIService.SearchLocationRatingIndexes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/location/rating/index/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.locationType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locationType", r.locationType, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.searchRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchRange", r.searchRange, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.returnOverallRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnOverallRating", r.returnOverallRating, "form", "")
	}
	if r.distanceUnit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distanceUnit", r.distanceUnit, "form", "")
	}
	if r.returnRetailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRetailer", r.returnRetailer, "form", "")
	}
	if r.returnAssets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnAssets", r.returnAssets, "form", "")
	}
	if r.returnOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnOffers", r.returnOffers, "form", "")
	}
	if r.returnCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnCategories", r.returnCategories, "form", "")
	}
	if r.returnFilters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnFilters", r.returnFilters, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchRatingIndexesRequest struct {
	ctx context.Context
	ApiService *RatingAPIService
	ratableType *string
	ratableIds *string
	categoryIds *string
	secondaryType *string
	keyword *string
	sortField *string
	descending *bool
	start *int32
	limit *int32
	latitude *float64
	longitude *float64
	returnRatable *bool
	returnOverallRating *bool
}

// Filter results by a ratable type {RETAILER_LOCATION}
func (r ApiSearchRatingIndexesRequest) RatableType(ratableType string) ApiSearchRatingIndexesRequest {
	r.ratableType = &ratableType
	return r
}

// Comma separated list of ratable ids to filter the resuts by
func (r ApiSearchRatingIndexesRequest) RatableIds(ratableIds string) ApiSearchRatingIndexesRequest {
	r.ratableIds = &ratableIds
	return r
}

// Comma separated list of category ids to filter the results by
func (r ApiSearchRatingIndexesRequest) CategoryIds(categoryIds string) ApiSearchRatingIndexesRequest {
	r.categoryIds = &categoryIds
	return r
}

// 
func (r ApiSearchRatingIndexesRequest) SecondaryType(secondaryType string) ApiSearchRatingIndexesRequest {
	r.secondaryType = &secondaryType
	return r
}

// The keyword used to search
func (r ApiSearchRatingIndexesRequest) Keyword(keyword string) ApiSearchRatingIndexesRequest {
	r.keyword = &keyword
	return r
}

// The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}
func (r ApiSearchRatingIndexesRequest) SortField(sortField string) ApiSearchRatingIndexesRequest {
	r.sortField = &sortField
	return r
}

// The order to return the search results
func (r ApiSearchRatingIndexesRequest) Descending(descending bool) ApiSearchRatingIndexesRequest {
	r.descending = &descending
	return r
}

// The record to begin the return set on
func (r ApiSearchRatingIndexesRequest) Start(start int32) ApiSearchRatingIndexesRequest {
	r.start = &start
	return r
}

// The number of records to return
func (r ApiSearchRatingIndexesRequest) Limit(limit int32) ApiSearchRatingIndexesRequest {
	r.limit = &limit
	return r
}

// 
func (r ApiSearchRatingIndexesRequest) Latitude(latitude float64) ApiSearchRatingIndexesRequest {
	r.latitude = &latitude
	return r
}

// 
func (r ApiSearchRatingIndexesRequest) Longitude(longitude float64) ApiSearchRatingIndexesRequest {
	r.longitude = &longitude
	return r
}

// Determines whether to return the ratable object in the response
func (r ApiSearchRatingIndexesRequest) ReturnRatable(returnRatable bool) ApiSearchRatingIndexesRequest {
	r.returnRatable = &returnRatable
	return r
}

// Determines whether to return the overall rating record instead
func (r ApiSearchRatingIndexesRequest) ReturnOverallRating(returnOverallRating bool) ApiSearchRatingIndexesRequest {
	r.returnOverallRating = &returnOverallRating
	return r
}

func (r ApiSearchRatingIndexesRequest) Execute() ([]RatingIndexResponse, *http.Response, error) {
	return r.ApiService.SearchRatingIndexesExecute(r)
}

/*
SearchRatingIndexes Search Rating Indexes

Search for ratable items by averages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchRatingIndexesRequest
*/
func (a *RatingAPIService) SearchRatingIndexes(ctx context.Context) ApiSearchRatingIndexesRequest {
	return ApiSearchRatingIndexesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RatingIndexResponse
func (a *RatingAPIService) SearchRatingIndexesExecute(r ApiSearchRatingIndexesRequest) ([]RatingIndexResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RatingIndexResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatingAPIService.SearchRatingIndexes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rating/index/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ratableType == nil {
		return localVarReturnValue, nil, reportError("ratableType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ratableType", r.ratableType, "form", "")
	if r.ratableIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratableIds", r.ratableIds, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.secondaryType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secondaryType", r.secondaryType, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	if r.returnRatable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnRatable", r.returnRatable, "form", "")
	}
	if r.returnOverallRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnOverallRating", r.returnOverallRating, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchRatingsRequest struct {
	ctx context.Context
	ApiService *RatingAPIService
	deviceId *string
	accountId *int64
	filterAccountId *int64
	ratableType *string
	ratableId *int64
	categoryIds *string
	keyword *string
	sortField *string
	descending *bool
	start *int32
	limit *int32
}

// The device id (deviceId or accountId required)
func (r ApiSearchRatingsRequest) DeviceId(deviceId string) ApiSearchRatingsRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiSearchRatingsRequest) AccountId(accountId int64) ApiSearchRatingsRequest {
	r.accountId = &accountId
	return r
}

// Filter results for a particular account
func (r ApiSearchRatingsRequest) FilterAccountId(filterAccountId int64) ApiSearchRatingsRequest {
	r.filterAccountId = &filterAccountId
	return r
}

// The ratable object type {RETAILER_LOCATION}
func (r ApiSearchRatingsRequest) RatableType(ratableType string) ApiSearchRatingsRequest {
	r.ratableType = &ratableType
	return r
}

// The id of the ratable object
func (r ApiSearchRatingsRequest) RatableId(ratableId int64) ApiSearchRatingsRequest {
	r.ratableId = &ratableId
	return r
}

// Comma separated list of category ids to filter the results by
func (r ApiSearchRatingsRequest) CategoryIds(categoryIds string) ApiSearchRatingsRequest {
	r.categoryIds = &categoryIds
	return r
}

// The keyword used to search
func (r ApiSearchRatingsRequest) Keyword(keyword string) ApiSearchRatingsRequest {
	r.keyword = &keyword
	return r
}

// The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, OWNER_DISPLAY, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, VALUE}
func (r ApiSearchRatingsRequest) SortField(sortField string) ApiSearchRatingsRequest {
	r.sortField = &sortField
	return r
}

// The order to return the search results
func (r ApiSearchRatingsRequest) Descending(descending bool) ApiSearchRatingsRequest {
	r.descending = &descending
	return r
}

// The record to begin the return set on
func (r ApiSearchRatingsRequest) Start(start int32) ApiSearchRatingsRequest {
	r.start = &start
	return r
}

// The number of records to return
func (r ApiSearchRatingsRequest) Limit(limit int32) ApiSearchRatingsRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchRatingsRequest) Execute() ([]RatingResponse, *http.Response, error) {
	return r.ApiService.SearchRatingsExecute(r)
}

/*
SearchRatings Search Ratings

Search for ratings on a ratable object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchRatingsRequest
*/
func (a *RatingAPIService) SearchRatings(ctx context.Context) ApiSearchRatingsRequest {
	return ApiSearchRatingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RatingResponse
func (a *RatingAPIService) SearchRatingsExecute(r ApiSearchRatingsRequest) ([]RatingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RatingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatingAPIService.SearchRatings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rating/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.filterAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterAccountId", r.filterAccountId, "form", "")
	}
	if r.ratableType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratableType", r.ratableType, "form", "")
	}
	if r.ratableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratableId", r.ratableId, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRatingRequest struct {
	ctx context.Context
	ApiService *RatingAPIService
	ratingId *int64
	deviceId *string
	accountId *int64
	ratingValue *int32
	categoryId *int64
	display *string
	description *string
	locationDescription *string
	latitude *float64
	longitude *float64
}

// The id of the rating (Note: this is not the ratable object id)
func (r ApiUpdateRatingRequest) RatingId(ratingId int64) ApiUpdateRatingRequest {
	r.ratingId = &ratingId
	return r
}

// The unique device identifier that made the request (either deviceId or accountId must be used)
func (r ApiUpdateRatingRequest) DeviceId(deviceId string) ApiUpdateRatingRequest {
	r.deviceId = &deviceId
	return r
}

// The unique accountId that made the request (either deviceId or accountId must be used)
func (r ApiUpdateRatingRequest) AccountId(accountId int64) ApiUpdateRatingRequest {
	r.accountId = &accountId
	return r
}

// The rating value to update
func (r ApiUpdateRatingRequest) RatingValue(ratingValue int32) ApiUpdateRatingRequest {
	r.ratingValue = &ratingValue
	return r
}

// 
func (r ApiUpdateRatingRequest) CategoryId(categoryId int64) ApiUpdateRatingRequest {
	r.categoryId = &categoryId
	return r
}

// A subject title for the user rating (limited to 255 characters)
func (r ApiUpdateRatingRequest) Display(display string) ApiUpdateRatingRequest {
	r.display = &display
	return r
}

// The description of the rating
func (r ApiUpdateRatingRequest) Description(description string) ApiUpdateRatingRequest {
	r.description = &description
	return r
}

// The description of the location
func (r ApiUpdateRatingRequest) LocationDescription(locationDescription string) ApiUpdateRatingRequest {
	r.locationDescription = &locationDescription
	return r
}

// The current location of the user
func (r ApiUpdateRatingRequest) Latitude(latitude float64) ApiUpdateRatingRequest {
	r.latitude = &latitude
	return r
}

// The current location of the user
func (r ApiUpdateRatingRequest) Longitude(longitude float64) ApiUpdateRatingRequest {
	r.longitude = &longitude
	return r
}

func (r ApiUpdateRatingRequest) Execute() (*RatingResponse, *http.Response, error) {
	return r.ApiService.UpdateRatingExecute(r)
}

/*
UpdateRating Update Rating

Update an existing rating. Only the creator of the rating have permission to update.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateRatingRequest
*/
func (a *RatingAPIService) UpdateRating(ctx context.Context) ApiUpdateRatingRequest {
	return ApiUpdateRatingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RatingResponse
func (a *RatingAPIService) UpdateRatingExecute(r ApiUpdateRatingRequest) (*RatingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RatingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RatingAPIService.UpdateRating")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rating/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ratingId == nil {
		return localVarReturnValue, nil, reportError("ratingId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ratingId", r.ratingId, "form", "")
	if r.ratingValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ratingValue", r.ratingValue, "form", "")
	}
	if r.categoryId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryId", r.categoryId, "form", "")
	}
	if r.display != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "display", r.display, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.locationDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locationDescription", r.locationDescription, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
