/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// LeaderboardAPIService LeaderboardAPI service
type LeaderboardAPIService service

type ApiCreateLeaderboardRequest struct {
	ctx context.Context
	ApiService *LeaderboardAPIService
	version float32
	accountId *int64
	appKey *string
	rankType *string
	leaderboardMode *string
	iconMedia *os.File
	iconAssetId *int64
	bannerMedia *os.File
	bannerAssetId *int64
	limitation *int32
	sortField *string
	title *string
	description *string
	metaData *string
}

// The account id of the user creating the leaderboard.
func (r ApiCreateLeaderboardRequest) AccountId(accountId int64) ApiCreateLeaderboardRequest {
	r.accountId = &accountId
	return r
}

// The application key
func (r ApiCreateLeaderboardRequest) AppKey(appKey string) ApiCreateLeaderboardRequest {
	r.appKey = &appKey
	return r
}

// a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS
func (r ApiCreateLeaderboardRequest) RankType(rankType string) ApiCreateLeaderboardRequest {
	r.rankType = &rankType
	return r
}

// the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking); LOCAL - filters results by select users and on users that have logged into the same device; SEARCH - does a GLOBAL search by keyword; CUSTOM - does a LOCAL search by keyword
func (r ApiCreateLeaderboardRequest) LeaderboardMode(leaderboardMode string) ApiCreateLeaderboardRequest {
	r.leaderboardMode = &leaderboardMode
	return r
}

// a MultipartFile containing the icon image of the leaderboard (this will only be used if \&quot;iconAssetId\&quot; is empty)
func (r ApiCreateLeaderboardRequest) IconMedia(iconMedia *os.File) ApiCreateLeaderboardRequest {
	r.iconMedia = iconMedia
	return r
}

// The asset ID to set the leaderboard icon
func (r ApiCreateLeaderboardRequest) IconAssetId(iconAssetId int64) ApiCreateLeaderboardRequest {
	r.iconAssetId = &iconAssetId
	return r
}

// a MultipartFile containing the icon banner of the leaderboard (this will only be used if \&quot;bannerAssetId\&quot; is empty)
func (r ApiCreateLeaderboardRequest) BannerMedia(bannerMedia *os.File) ApiCreateLeaderboardRequest {
	r.bannerMedia = bannerMedia
	return r
}

// The asset ID to set the leaderboard banner
func (r ApiCreateLeaderboardRequest) BannerAssetId(bannerAssetId int64) ApiCreateLeaderboardRequest {
	r.bannerAssetId = &bannerAssetId
	return r
}

// limit number of rankings for each leaderboard
func (r ApiCreateLeaderboardRequest) Limitation(limitation int32) ApiCreateLeaderboardRequest {
	r.limitation = &limitation
	return r
}

// determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST
func (r ApiCreateLeaderboardRequest) SortField(sortField string) ApiCreateLeaderboardRequest {
	r.sortField = &sortField
	return r
}

// leaderboard&#39;s title
func (r ApiCreateLeaderboardRequest) Title(title string) ApiCreateLeaderboardRequest {
	r.title = &title
	return r
}

// leaderboard&#39;s description
func (r ApiCreateLeaderboardRequest) Description(description string) ApiCreateLeaderboardRequest {
	r.description = &description
	return r
}

// custom meta data for the leaderboard
func (r ApiCreateLeaderboardRequest) MetaData(metaData string) ApiCreateLeaderboardRequest {
	r.metaData = &metaData
	return r
}

func (r ApiCreateLeaderboardRequest) Execute() (*LeaderboardResponse, *http.Response, error) {
	return r.ApiService.CreateLeaderboardExecute(r)
}

/*
CreateLeaderboard Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation

Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateLeaderboardRequest
*/
func (a *LeaderboardAPIService) CreateLeaderboard(ctx context.Context, version float32) ApiCreateLeaderboardRequest {
	return ApiCreateLeaderboardRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return LeaderboardResponse
func (a *LeaderboardAPIService) CreateLeaderboardExecute(r ApiCreateLeaderboardRequest) (*LeaderboardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LeaderboardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeaderboardAPIService.CreateLeaderboard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/leaderboard/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.rankType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rankType", r.rankType, "form", "")
	}
	if r.leaderboardMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "leaderboardMode", r.leaderboardMode, "form", "")
	}
	if r.iconMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iconMedia", r.iconMedia, "form", "")
	}
	if r.iconAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iconAssetId", r.iconAssetId, "form", "")
	}
	if r.bannerMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bannerMedia", r.bannerMedia, "form", "")
	}
	if r.bannerAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bannerAssetId", r.bannerAssetId, "form", "")
	}
	if r.limitation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limitation", r.limitation, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteLeaderboardRequest struct {
	ctx context.Context
	ApiService *LeaderboardAPIService
	version float32
	leaderboardId *int64
	accountId *int64
}

// The leaderboard id to delete.
func (r ApiDeleteLeaderboardRequest) LeaderboardId(leaderboardId int64) ApiDeleteLeaderboardRequest {
	r.leaderboardId = &leaderboardId
	return r
}

// The account id of the user making the request.
func (r ApiDeleteLeaderboardRequest) AccountId(accountId int64) ApiDeleteLeaderboardRequest {
	r.accountId = &accountId
	return r
}

func (r ApiDeleteLeaderboardRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteLeaderboardExecute(r)
}

/*
DeleteLeaderboard Delete the Leader Board

Removes a leader board id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteLeaderboardRequest
*/
func (a *LeaderboardAPIService) DeleteLeaderboard(ctx context.Context, version float32) ApiDeleteLeaderboardRequest {
	return ApiDeleteLeaderboardRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *LeaderboardAPIService) DeleteLeaderboardExecute(r ApiDeleteLeaderboardRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeaderboardAPIService.DeleteLeaderboard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/leaderboard/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.leaderboardId == nil {
		return localVarReturnValue, nil, reportError("leaderboardId is required and must be specified")
	}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "leaderboardId", r.leaderboardId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLeaderboardRequest struct {
	ctx context.Context
	ApiService *LeaderboardAPIService
	version float32
	leaderboardId *int64
	accountId *int64
	includeFullRankingList *bool
}

// The leaderboard id.
func (r ApiGetLeaderboardRequest) LeaderboardId(leaderboardId int64) ApiGetLeaderboardRequest {
	r.leaderboardId = &leaderboardId
	return r
}

// A valid account.
func (r ApiGetLeaderboardRequest) AccountId(accountId int64) ApiGetLeaderboardRequest {
	r.accountId = &accountId
	return r
}

// set to true if need to return the leaderboard&#39;s full ranking list
func (r ApiGetLeaderboardRequest) IncludeFullRankingList(includeFullRankingList bool) ApiGetLeaderboardRequest {
	r.includeFullRankingList = &includeFullRankingList
	return r
}

func (r ApiGetLeaderboardRequest) Execute() (*LeaderboardResponse, *http.Response, error) {
	return r.ApiService.GetLeaderboardExecute(r)
}

/*
GetLeaderboard Read a leaderboard by id and retrieve the matching ranking list

Read a leaderboard by id and retrieve the matching ranking list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetLeaderboardRequest
*/
func (a *LeaderboardAPIService) GetLeaderboard(ctx context.Context, version float32) ApiGetLeaderboardRequest {
	return ApiGetLeaderboardRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return LeaderboardResponse
func (a *LeaderboardAPIService) GetLeaderboardExecute(r ApiGetLeaderboardRequest) (*LeaderboardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LeaderboardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeaderboardAPIService.GetLeaderboard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/leaderboard/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.leaderboardId == nil {
		return localVarReturnValue, nil, reportError("leaderboardId is required and must be specified")
	}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "leaderboardId", r.leaderboardId, "form", "")
	if r.includeFullRankingList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFullRankingList", r.includeFullRankingList, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchLeaderboardsRequest struct {
	ctx context.Context
	ApiService *LeaderboardAPIService
	version float32
	accountId *int64
	appKey *string
	globalOnly *bool
	keyword *string
	leaderboardIds *string
	rankTypes *string
	sortField *string
	descending *bool
	includeInactive *bool
	includeAppResponse *bool
	start *int32
	limit *int32
}

// The account id of the user requesting the search.
func (r ApiSearchLeaderboardsRequest) AccountId(accountId int64) ApiSearchLeaderboardsRequest {
	r.accountId = &accountId
	return r
}

// The application key.
func (r ApiSearchLeaderboardsRequest) AppKey(appKey string) ApiSearchLeaderboardsRequest {
	r.appKey = &appKey
	return r
}

// only include global leaderboards (this overrides the appKey filter)
func (r ApiSearchLeaderboardsRequest) GlobalOnly(globalOnly bool) ApiSearchLeaderboardsRequest {
	r.globalOnly = &globalOnly
	return r
}

// keyword to search by title
func (r ApiSearchLeaderboardsRequest) Keyword(keyword string) ApiSearchLeaderboardsRequest {
	r.keyword = &keyword
	return r
}

// comma separated list of leaderboard ids to filter results with
func (r ApiSearchLeaderboardsRequest) LeaderboardIds(leaderboardIds string) ApiSearchLeaderboardsRequest {
	r.leaderboardIds = &leaderboardIds
	return r
}

// comma separated list of rankType to filter results with
func (r ApiSearchLeaderboardsRequest) RankTypes(rankTypes string) ApiSearchLeaderboardsRequest {
	r.rankTypes = &rankTypes
	return r
}

// sortField of the result, from LeaderboardApiMap (TITLE, DESCRIPTION, CREATED, UPDATED, RANK_TYPE, RANK_MODE)
func (r ApiSearchLeaderboardsRequest) SortField(sortField string) ApiSearchLeaderboardsRequest {
	r.sortField = &sortField
	return r
}

// Determines whether the sorted list is in descending or ascending order
func (r ApiSearchLeaderboardsRequest) Descending(descending bool) ApiSearchLeaderboardsRequest {
	r.descending = &descending
	return r
}

// include inactive in the result
func (r ApiSearchLeaderboardsRequest) IncludeInactive(includeInactive bool) ApiSearchLeaderboardsRequest {
	r.includeInactive = &includeInactive
	return r
}

// determines whether to include the application response for each leaderboard
func (r ApiSearchLeaderboardsRequest) IncludeAppResponse(includeAppResponse bool) ApiSearchLeaderboardsRequest {
	r.includeAppResponse = &includeAppResponse
	return r
}

// Start the result set at some index.
func (r ApiSearchLeaderboardsRequest) Start(start int32) ApiSearchLeaderboardsRequest {
	r.start = &start
	return r
}

// Limit the result to some number.
func (r ApiSearchLeaderboardsRequest) Limit(limit int32) ApiSearchLeaderboardsRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchLeaderboardsRequest) Execute() (*LeaderboardResponse, *http.Response, error) {
	return r.ApiService.SearchLeaderboardsExecute(r)
}

/*
SearchLeaderboards Search leaderboard and retrieve the matching ranking list

Search leaderboard and retrieve the matching ranking list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchLeaderboardsRequest
*/
func (a *LeaderboardAPIService) SearchLeaderboards(ctx context.Context, version float32) ApiSearchLeaderboardsRequest {
	return ApiSearchLeaderboardsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return LeaderboardResponse
func (a *LeaderboardAPIService) SearchLeaderboardsExecute(r ApiSearchLeaderboardsRequest) (*LeaderboardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LeaderboardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeaderboardAPIService.SearchLeaderboards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/leaderboard/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.globalOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "globalOnly", r.globalOnly, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.leaderboardIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "leaderboardIds", r.leaderboardIds, "form", "")
	}
	if r.rankTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rankTypes", r.rankTypes, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "form", "")
	}
	if r.includeAppResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAppResponse", r.includeAppResponse, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateLeaderboardRequest struct {
	ctx context.Context
	ApiService *LeaderboardAPIService
	version float32
	leaderboardId *int64
	accountId *int64
	appKey *string
	rankType *string
	leaderboardMode *string
	sortField *string
	iconMedia *os.File
	iconAssetId *int64
	bannerMedia *os.File
	bannerAssetId *int64
	limitation *int32
	active *bool
	title *string
	description *string
	metaData *string
}

// The leaderboard id to update.
func (r ApiUpdateLeaderboardRequest) LeaderboardId(leaderboardId int64) ApiUpdateLeaderboardRequest {
	r.leaderboardId = &leaderboardId
	return r
}

// The account id of the user updating the leaderboard.
func (r ApiUpdateLeaderboardRequest) AccountId(accountId int64) ApiUpdateLeaderboardRequest {
	r.accountId = &accountId
	return r
}

// The application key
func (r ApiUpdateLeaderboardRequest) AppKey(appKey string) ApiUpdateLeaderboardRequest {
	r.appKey = &appKey
	return r
}

// a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters.
func (r ApiUpdateLeaderboardRequest) RankType(rankType string) ApiUpdateLeaderboardRequest {
	r.rankType = &rankType
	return r
}

// the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM
func (r ApiUpdateLeaderboardRequest) LeaderboardMode(leaderboardMode string) ApiUpdateLeaderboardRequest {
	r.leaderboardMode = &leaderboardMode
	return r
}

// determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST
func (r ApiUpdateLeaderboardRequest) SortField(sortField string) ApiUpdateLeaderboardRequest {
	r.sortField = &sortField
	return r
}

// a MultipartFile containing the icon image of the leaderboard (this will only be used if \&quot;iconAssetId\&quot; is empty)
func (r ApiUpdateLeaderboardRequest) IconMedia(iconMedia *os.File) ApiUpdateLeaderboardRequest {
	r.iconMedia = iconMedia
	return r
}

// The asset ID to set the leaderboard icon
func (r ApiUpdateLeaderboardRequest) IconAssetId(iconAssetId int64) ApiUpdateLeaderboardRequest {
	r.iconAssetId = &iconAssetId
	return r
}

// a MultipartFile containing the icon banner of the leaderboard (this will only be used if \&quot;bannerAssetId\&quot; is empty)
func (r ApiUpdateLeaderboardRequest) BannerMedia(bannerMedia *os.File) ApiUpdateLeaderboardRequest {
	r.bannerMedia = bannerMedia
	return r
}

// The asset ID to set the leaderboard banner
func (r ApiUpdateLeaderboardRequest) BannerAssetId(bannerAssetId int64) ApiUpdateLeaderboardRequest {
	r.bannerAssetId = &bannerAssetId
	return r
}

// limit number of rankings for each leaderboard
func (r ApiUpdateLeaderboardRequest) Limitation(limitation int32) ApiUpdateLeaderboardRequest {
	r.limitation = &limitation
	return r
}

// Whether the leaderboard is active
func (r ApiUpdateLeaderboardRequest) Active(active bool) ApiUpdateLeaderboardRequest {
	r.active = &active
	return r
}

// leaderboard&#39;s title
func (r ApiUpdateLeaderboardRequest) Title(title string) ApiUpdateLeaderboardRequest {
	r.title = &title
	return r
}

// leaderboard&#39;s description
func (r ApiUpdateLeaderboardRequest) Description(description string) ApiUpdateLeaderboardRequest {
	r.description = &description
	return r
}

// custom meta data for the leaderboard
func (r ApiUpdateLeaderboardRequest) MetaData(metaData string) ApiUpdateLeaderboardRequest {
	r.metaData = &metaData
	return r
}

func (r ApiUpdateLeaderboardRequest) Execute() (*LeaderboardResponse, *http.Response, error) {
	return r.ApiService.UpdateLeaderboardExecute(r)
}

/*
UpdateLeaderboard Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation

Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateLeaderboardRequest
*/
func (a *LeaderboardAPIService) UpdateLeaderboard(ctx context.Context, version float32) ApiUpdateLeaderboardRequest {
	return ApiUpdateLeaderboardRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return LeaderboardResponse
func (a *LeaderboardAPIService) UpdateLeaderboardExecute(r ApiUpdateLeaderboardRequest) (*LeaderboardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LeaderboardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LeaderboardAPIService.UpdateLeaderboard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/leaderboard/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.leaderboardId == nil {
		return localVarReturnValue, nil, reportError("leaderboardId is required and must be specified")
	}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "leaderboardId", r.leaderboardId, "form", "")
	if r.rankType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rankType", r.rankType, "form", "")
	}
	if r.leaderboardMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "leaderboardMode", r.leaderboardMode, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.iconMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iconMedia", r.iconMedia, "form", "")
	}
	if r.iconAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iconAssetId", r.iconAssetId, "form", "")
	}
	if r.bannerMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bannerMedia", r.bannerMedia, "form", "")
	}
	if r.bannerAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bannerAssetId", r.bannerAssetId, "form", "")
	}
	if r.limitation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limitation", r.limitation, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
