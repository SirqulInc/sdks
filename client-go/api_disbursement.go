/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// DisbursementAPIService DisbursementAPI service
type DisbursementAPIService service

type ApiCheckDisbursementsRequest struct {
	ctx context.Context
	ApiService *DisbursementAPIService
	disbursementId *int64
}

// the ID of the disbursement being checked on
func (r ApiCheckDisbursementsRequest) DisbursementId(disbursementId int64) ApiCheckDisbursementsRequest {
	r.disbursementId = &disbursementId
	return r
}

func (r ApiCheckDisbursementsRequest) Execute() (*DisbursementResponse, *http.Response, error) {
	return r.ApiService.CheckDisbursementsExecute(r)
}

/*
CheckDisbursements Check Disbursements

Checks the status of a captured disbrusement to see if it has been settled.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCheckDisbursementsRequest
*/
func (a *DisbursementAPIService) CheckDisbursements(ctx context.Context) ApiCheckDisbursementsRequest {
	return ApiCheckDisbursementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DisbursementResponse
func (a *DisbursementAPIService) CheckDisbursementsExecute(r ApiCheckDisbursementsRequest) (*DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementAPIService.CheckDisbursements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursement/check"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.disbursementId == nil {
		return localVarReturnValue, nil, reportError("disbursementId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "disbursementId", r.disbursementId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDisbursementRequest struct {
	ctx context.Context
	ApiService *DisbursementAPIService
	accountId *int64
	receiverAccountId *int64
	originalSenderAccountId *int64
	amount *float32
	provider *string
	scheduledDate *int64
	title *string
	comment *string
	externalId *string
	introspectionParams *string
}

// the ID of the logging in user (must be an EXECUTIVE account)
func (r ApiCreateDisbursementRequest) AccountId(accountId int64) ApiCreateDisbursementRequest {
	r.accountId = &accountId
	return r
}

// the ID of the account receiving the disbursement
func (r ApiCreateDisbursementRequest) ReceiverAccountId(receiverAccountId int64) ApiCreateDisbursementRequest {
	r.receiverAccountId = &receiverAccountId
	return r
}

// the ID of the original sender account
func (r ApiCreateDisbursementRequest) OriginalSenderAccountId(originalSenderAccountId int64) ApiCreateDisbursementRequest {
	r.originalSenderAccountId = &originalSenderAccountId
	return r
}

// the dollar amount of the disbursement
func (r ApiCreateDisbursementRequest) Amount(amount float32) ApiCreateDisbursementRequest {
	r.amount = &amount
	return r
}

// the provider (e.g. Authorize.net, Bill.com, etc.)
func (r ApiCreateDisbursementRequest) Provider(provider string) ApiCreateDisbursementRequest {
	r.provider = &provider
	return r
}

// the date that the disbursement is scheduled to go out to the payment provider
func (r ApiCreateDisbursementRequest) ScheduledDate(scheduledDate int64) ApiCreateDisbursementRequest {
	r.scheduledDate = &scheduledDate
	return r
}

// a title given for the disbursement
func (r ApiCreateDisbursementRequest) Title(title string) ApiCreateDisbursementRequest {
	r.title = &title
	return r
}

// a comment that could be made for a disbursement
func (r ApiCreateDisbursementRequest) Comment(comment string) ApiCreateDisbursementRequest {
	r.comment = &comment
	return r
}

// external ID, which can be used as a way to reference the disbursement
func (r ApiCreateDisbursementRequest) ExternalId(externalId string) ApiCreateDisbursementRequest {
	r.externalId = &externalId
	return r
}

// This is for specifying parameters to make an http callback request for validating that the disbursement is valid
func (r ApiCreateDisbursementRequest) IntrospectionParams(introspectionParams string) ApiCreateDisbursementRequest {
	r.introspectionParams = &introspectionParams
	return r
}

func (r ApiCreateDisbursementRequest) Execute() (*DisbursementResponse, *http.Response, error) {
	return r.ApiService.CreateDisbursementExecute(r)
}

/*
CreateDisbursement Create Disbursement

Creates a Disbursement for sending money to a retailer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDisbursementRequest
*/
func (a *DisbursementAPIService) CreateDisbursement(ctx context.Context) ApiCreateDisbursementRequest {
	return ApiCreateDisbursementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DisbursementResponse
func (a *DisbursementAPIService) CreateDisbursementExecute(r ApiCreateDisbursementRequest) (*DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementAPIService.CreateDisbursement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursement/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.receiverAccountId == nil {
		return localVarReturnValue, nil, reportError("receiverAccountId is required and must be specified")
	}
	if r.originalSenderAccountId == nil {
		return localVarReturnValue, nil, reportError("originalSenderAccountId is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.provider == nil {
		return localVarReturnValue, nil, reportError("provider is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "receiverAccountId", r.receiverAccountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "originalSenderAccountId", r.originalSenderAccountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "provider", r.provider, "form", "")
	if r.scheduledDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduledDate", r.scheduledDate, "form", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.comment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "comment", r.comment, "form", "")
	}
	if r.externalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalId", r.externalId, "form", "")
	}
	if r.introspectionParams != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "introspectionParams", r.introspectionParams, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDisbursementRequest struct {
	ctx context.Context
	ApiService *DisbursementAPIService
	accountId *int64
	disbursementId *int64
}

// The logged in user.
func (r ApiGetDisbursementRequest) AccountId(accountId int64) ApiGetDisbursementRequest {
	r.accountId = &accountId
	return r
}

// the id of the disbursement
func (r ApiGetDisbursementRequest) DisbursementId(disbursementId int64) ApiGetDisbursementRequest {
	r.disbursementId = &disbursementId
	return r
}

func (r ApiGetDisbursementRequest) Execute() (*DisbursementResponse, *http.Response, error) {
	return r.ApiService.GetDisbursementExecute(r)
}

/*
GetDisbursement Get Disbursement

Get Disbursement details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDisbursementRequest
*/
func (a *DisbursementAPIService) GetDisbursement(ctx context.Context) ApiGetDisbursementRequest {
	return ApiGetDisbursementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DisbursementResponse
func (a *DisbursementAPIService) GetDisbursementExecute(r ApiGetDisbursementRequest) (*DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementAPIService.GetDisbursement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursement/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.disbursementId == nil {
		return localVarReturnValue, nil, reportError("disbursementId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "disbursementId", r.disbursementId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchDisbursementsRequest struct {
	ctx context.Context
	ApiService *DisbursementAPIService
	accountId *int64
	receiverAccountId *int64
	statuses *string
	providers *string
	beforeDate *int64
	afterDate *int64
	start *int32
	limit *int32
	activeOnly *bool
	externalId *string
}

// the id of the logged in user
func (r ApiSearchDisbursementsRequest) AccountId(accountId int64) ApiSearchDisbursementsRequest {
	r.accountId = &accountId
	return r
}

// filter results by the id of the account receiving the disbursement
func (r ApiSearchDisbursementsRequest) ReceiverAccountId(receiverAccountId int64) ApiSearchDisbursementsRequest {
	r.receiverAccountId = &receiverAccountId
	return r
}

// comma separated list of status values to search for, possilbe values include: NEW, APPROVED, VALIDATING, ERROR, AUTHORIZED, CAPTURED, SETTLED
func (r ApiSearchDisbursementsRequest) Statuses(statuses string) ApiSearchDisbursementsRequest {
	r.statuses = &statuses
	return r
}

// comma separated list of payment providers to search for, possbile values include: AUTHORIZE_NET, AMAZON_FPS, BILL_COM
func (r ApiSearchDisbursementsRequest) Providers(providers string) ApiSearchDisbursementsRequest {
	r.providers = &providers
	return r
}

// the date for searching disbursements before it has been processed
func (r ApiSearchDisbursementsRequest) BeforeDate(beforeDate int64) ApiSearchDisbursementsRequest {
	r.beforeDate = &beforeDate
	return r
}

// the date for searching disbursements before it has been processed
func (r ApiSearchDisbursementsRequest) AfterDate(afterDate int64) ApiSearchDisbursementsRequest {
	r.afterDate = &afterDate
	return r
}

// the start index for pagination
func (r ApiSearchDisbursementsRequest) Start(start int32) ApiSearchDisbursementsRequest {
	r.start = &start
	return r
}

// the limit per result set for pagination
func (r ApiSearchDisbursementsRequest) Limit(limit int32) ApiSearchDisbursementsRequest {
	r.limit = &limit
	return r
}

// search on disbursements that are active only
func (r ApiSearchDisbursementsRequest) ActiveOnly(activeOnly bool) ApiSearchDisbursementsRequest {
	r.activeOnly = &activeOnly
	return r
}

// search results by this external ID (that can be used to reference the disbursement)
func (r ApiSearchDisbursementsRequest) ExternalId(externalId string) ApiSearchDisbursementsRequest {
	r.externalId = &externalId
	return r
}

func (r ApiSearchDisbursementsRequest) Execute() ([]DisbursementResponse, *http.Response, error) {
	return r.ApiService.SearchDisbursementsExecute(r)
}

/*
SearchDisbursements Search Disbursements

Search Disbursements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchDisbursementsRequest
*/
func (a *DisbursementAPIService) SearchDisbursements(ctx context.Context) ApiSearchDisbursementsRequest {
	return ApiSearchDisbursementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DisbursementResponse
func (a *DisbursementAPIService) SearchDisbursementsExecute(r ApiSearchDisbursementsRequest) ([]DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementAPIService.SearchDisbursements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursement/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.receiverAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "receiverAccountId", r.receiverAccountId, "form", "")
	}
	if r.statuses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", r.statuses, "form", "")
	}
	if r.providers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "providers", r.providers, "form", "")
	}
	if r.beforeDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beforeDate", r.beforeDate, "form", "")
	}
	if r.afterDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "afterDate", r.afterDate, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", defaultValue, "form", "")
		r.activeOnly = &defaultValue
	}
	if r.externalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalId", r.externalId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDisbursementRequest struct {
	ctx context.Context
	ApiService *DisbursementAPIService
	accountId *int64
	disbursementId *int64
	amount *float32
	provider *string
	scheduledDate *int64
	title *string
	comment *string
	externalId *string
	retry *bool
	introspectionParams *string
}

// the id of the logged in user
func (r ApiUpdateDisbursementRequest) AccountId(accountId int64) ApiUpdateDisbursementRequest {
	r.accountId = &accountId
	return r
}

// the id of the disbursement being updated
func (r ApiUpdateDisbursementRequest) DisbursementId(disbursementId int64) ApiUpdateDisbursementRequest {
	r.disbursementId = &disbursementId
	return r
}

// the disbursement dollar amount being updated
func (r ApiUpdateDisbursementRequest) Amount(amount float32) ApiUpdateDisbursementRequest {
	r.amount = &amount
	return r
}

// the payments and/or billing provider (e.g. Authorize.net, Bill.com, etc.)
func (r ApiUpdateDisbursementRequest) Provider(provider string) ApiUpdateDisbursementRequest {
	r.provider = &provider
	return r
}

// the date that the disbursement is scheduled to go out to the payment provider
func (r ApiUpdateDisbursementRequest) ScheduledDate(scheduledDate int64) ApiUpdateDisbursementRequest {
	r.scheduledDate = &scheduledDate
	return r
}

// the title given to the disbursement
func (r ApiUpdateDisbursementRequest) Title(title string) ApiUpdateDisbursementRequest {
	r.title = &title
	return r
}

// a comment that can be made on a disbursement
func (r ApiUpdateDisbursementRequest) Comment(comment string) ApiUpdateDisbursementRequest {
	r.comment = &comment
	return r
}

// an external ID that can be used to reference the disbursement
func (r ApiUpdateDisbursementRequest) ExternalId(externalId string) ApiUpdateDisbursementRequest {
	r.externalId = &externalId
	return r
}

// determines whether to try sending the disbursement again in the case of a previous failure
func (r ApiUpdateDisbursementRequest) Retry(retry bool) ApiUpdateDisbursementRequest {
	r.retry = &retry
	return r
}

// for specifying parameters to make an http callback request for validating that the disbursement is valid
func (r ApiUpdateDisbursementRequest) IntrospectionParams(introspectionParams string) ApiUpdateDisbursementRequest {
	r.introspectionParams = &introspectionParams
	return r
}

func (r ApiUpdateDisbursementRequest) Execute() (*DisbursementResponse, *http.Response, error) {
	return r.ApiService.UpdateDisbursementExecute(r)
}

/*
UpdateDisbursement Update Disbursement

Update Disbursement

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateDisbursementRequest
*/
func (a *DisbursementAPIService) UpdateDisbursement(ctx context.Context) ApiUpdateDisbursementRequest {
	return ApiUpdateDisbursementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DisbursementResponse
func (a *DisbursementAPIService) UpdateDisbursementExecute(r ApiUpdateDisbursementRequest) (*DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementAPIService.UpdateDisbursement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursement/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.disbursementId == nil {
		return localVarReturnValue, nil, reportError("disbursementId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "disbursementId", r.disbursementId, "form", "")
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "form", "")
	}
	if r.provider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider", r.provider, "form", "")
	}
	if r.scheduledDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduledDate", r.scheduledDate, "form", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.comment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "comment", r.comment, "form", "")
	}
	if r.externalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalId", r.externalId, "form", "")
	}
	if r.retry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retry", r.retry, "form", "")
	}
	if r.introspectionParams != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "introspectionParams", r.introspectionParams, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
