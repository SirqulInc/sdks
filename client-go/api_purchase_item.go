/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PurchaseItemAPIService PurchaseItemAPI service
type PurchaseItemAPIService service

type ApiCreatePurchaseItemRequest struct {
	ctx context.Context
	ApiService *PurchaseItemAPIService
	version float32
	appKey *string
	name *string
	purchaseType *string
	deviceId *string
	accountId *int64
	description *string
	tickets *int32
	price *float32
	purchaseCode *string
	secretKey *string
	purchaseLimit *int32
	serviceAction *string
	coverAssetId *int64
	promoAssetId *int64
	giftable *bool
	assetable *bool
	allocateTickets *bool
	ticketType *string
	points *int64
	offerLocationId *int64
}

// The application key that the purchase can be used in
func (r ApiCreatePurchaseItemRequest) AppKey(appKey string) ApiCreatePurchaseItemRequest {
	r.appKey = &appKey
	return r
}

// The name of the purchase item
func (r ApiCreatePurchaseItemRequest) Name(name string) ApiCreatePurchaseItemRequest {
	r.name = &name
	return r
}

// The purchase provider &lt;ul&gt; &lt;li&gt;SIRQUL - the Sirqul store to make purchases using tickets&lt;/li&gt; &lt;li&gt;IOS - the iTunes store for iPhone, iPod, iPod Touch&lt;/li&gt; &lt;li&gt;GOOGLE - the Google Play store&lt;/li&gt; &lt;li&gt;AMAZON - the Amazon Android store&lt;/li&gt; &lt;li&gt;MAC - the iTunes store for OSX&lt;/li&gt; &lt;li&gt;WP8 - the Windows Phone 8 store&lt;/li&gt; &lt;li&gt;FREE - used for purchase items that are free (can be used for development/testing purposes)&lt;/li&gt; &lt;/ul&gt;
func (r ApiCreatePurchaseItemRequest) PurchaseType(purchaseType string) ApiCreatePurchaseItemRequest {
	r.purchaseType = &purchaseType
	return r
}

// The device id (deviceId or accountId required)
func (r ApiCreatePurchaseItemRequest) DeviceId(deviceId string) ApiCreatePurchaseItemRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiCreatePurchaseItemRequest) AccountId(accountId int64) ApiCreatePurchaseItemRequest {
	r.accountId = &accountId
	return r
}

// The description of the purchase item
func (r ApiCreatePurchaseItemRequest) Description(description string) ApiCreatePurchaseItemRequest {
	r.description = &description
	return r
}

// How much the purchase item is worth in tickets
func (r ApiCreatePurchaseItemRequest) Tickets(tickets int32) ApiCreatePurchaseItemRequest {
	r.tickets = &tickets
	return r
}

// How much the purchase item will cost in real money
func (r ApiCreatePurchaseItemRequest) Price(price float32) ApiCreatePurchaseItemRequest {
	r.price = &price
	return r
}

// The unique identifier used by purchase providers to identify in-app-purchases
func (r ApiCreatePurchaseItemRequest) PurchaseCode(purchaseCode string) ApiCreatePurchaseItemRequest {
	r.purchaseCode = &purchaseCode
	return r
}

// A secret key from purchase providers that would be used for validation
func (r ApiCreatePurchaseItemRequest) SecretKey(secretKey string) ApiCreatePurchaseItemRequest {
	r.secretKey = &secretKey
	return r
}

// How many times a user acquire the same purchase item
func (r ApiCreatePurchaseItemRequest) PurchaseLimit(purchaseLimit int32) ApiCreatePurchaseItemRequest {
	r.purchaseLimit = &purchaseLimit
	return r
}

// Determines whether the purchase item will enable certain features &lt;ul&gt; &lt;li&gt;DAY_PREMIUM - subscribes a user for a day of membership&lt;/li&gt; &lt;li&gt;WEEK_PREMIUM - subscribes a user for a week of membership&lt;/li&gt; &lt;li&gt;MONTH_PREMIUM - subscribes a user for a month of membership&lt;/li&gt; &lt;li&gt;ADD_TICKET - allows a user to add more tickets to their account&lt;/li&gt; &lt;li&gt;ADD_GIFT - allows a user to send/recieve the purchase item as a gift&lt;/li&gt; &lt;/ul&gt;
func (r ApiCreatePurchaseItemRequest) ServiceAction(serviceAction string) ApiCreatePurchaseItemRequest {
	r.serviceAction = &serviceAction
	return r
}

// The cover image of the purchase item
func (r ApiCreatePurchaseItemRequest) CoverAssetId(coverAssetId int64) ApiCreatePurchaseItemRequest {
	r.coverAssetId = &coverAssetId
	return r
}

// An application specific asset that can be used to store/provide additional data
func (r ApiCreatePurchaseItemRequest) PromoAssetId(promoAssetId int64) ApiCreatePurchaseItemRequest {
	r.promoAssetId = &promoAssetId
	return r
}

// Determines whether the purchase item can be gifted to other users
func (r ApiCreatePurchaseItemRequest) Giftable(giftable bool) ApiCreatePurchaseItemRequest {
	r.giftable = &giftable
	return r
}

// Determines whether users can attach their own media/asset to the purchase item
func (r ApiCreatePurchaseItemRequest) Assetable(assetable bool) ApiCreatePurchaseItemRequest {
	r.assetable = &assetable
	return r
}

// Flag to indicate owner should receive tickets for completed missions
func (r ApiCreatePurchaseItemRequest) AllocateTickets(allocateTickets bool) ApiCreatePurchaseItemRequest {
	r.allocateTickets = &allocateTickets
	return r
}

// The type of ticket to reward, null means default type
func (r ApiCreatePurchaseItemRequest) TicketType(ticketType string) ApiCreatePurchaseItemRequest {
	r.ticketType = &ticketType
	return r
}

// The number of points to award for completing a mission
func (r ApiCreatePurchaseItemRequest) Points(points int64) ApiCreatePurchaseItemRequest {
	r.points = &points
	return r
}

// The offer location that will get added to the user&#39;s wallet after purchase.
func (r ApiCreatePurchaseItemRequest) OfferLocationId(offerLocationId int64) ApiCreatePurchaseItemRequest {
	r.offerLocationId = &offerLocationId
	return r
}

func (r ApiCreatePurchaseItemRequest) Execute() (*PurchaseItemFullResponse, *http.Response, error) {
	return r.ApiService.CreatePurchaseItemExecute(r)
}

/*
CreatePurchaseItem Create Purchase

Creates a purchase item for in app purchases

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreatePurchaseItemRequest
*/
func (a *PurchaseItemAPIService) CreatePurchaseItem(ctx context.Context, version float32) ApiCreatePurchaseItemRequest {
	return ApiCreatePurchaseItemRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return PurchaseItemFullResponse
func (a *PurchaseItemAPIService) CreatePurchaseItemExecute(r ApiCreatePurchaseItemRequest) (*PurchaseItemFullResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PurchaseItemFullResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PurchaseItemAPIService.CreatePurchaseItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/purchase/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.purchaseType == nil {
		return localVarReturnValue, nil, reportError("purchaseType is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.tickets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tickets", r.tickets, "form", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "price", r.price, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseType", r.purchaseType, "form", "")
	if r.purchaseCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseCode", r.purchaseCode, "form", "")
	}
	if r.secretKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secretKey", r.secretKey, "form", "")
	}
	if r.purchaseLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseLimit", r.purchaseLimit, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseLimit", defaultValue, "form", "")
		r.purchaseLimit = &defaultValue
	}
	if r.serviceAction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serviceAction", r.serviceAction, "form", "")
	}
	if r.coverAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coverAssetId", r.coverAssetId, "form", "")
	}
	if r.promoAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "promoAssetId", r.promoAssetId, "form", "")
	}
	if r.giftable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "giftable", r.giftable, "form", "")
	}
	if r.assetable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetable", r.assetable, "form", "")
	}
	if r.allocateTickets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allocateTickets", r.allocateTickets, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "allocateTickets", defaultValue, "form", "")
		r.allocateTickets = &defaultValue
	}
	if r.ticketType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketType", r.ticketType, "form", "")
	}
	if r.points != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "points", r.points, "form", "")
	}
	if r.offerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationId", r.offerLocationId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePurchaseItemRequest struct {
	ctx context.Context
	ApiService *PurchaseItemAPIService
	version float32
	purchaseItemId *int64
	deviceId *string
	accountId *int64
}

// The purchase item id
func (r ApiDeletePurchaseItemRequest) PurchaseItemId(purchaseItemId int64) ApiDeletePurchaseItemRequest {
	r.purchaseItemId = &purchaseItemId
	return r
}

// The device id (deviceId or accountId required)
func (r ApiDeletePurchaseItemRequest) DeviceId(deviceId string) ApiDeletePurchaseItemRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiDeletePurchaseItemRequest) AccountId(accountId int64) ApiDeletePurchaseItemRequest {
	r.accountId = &accountId
	return r
}

func (r ApiDeletePurchaseItemRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeletePurchaseItemExecute(r)
}

/*
DeletePurchaseItem Delete Purchase

Marks the purchase item as deleted

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeletePurchaseItemRequest
*/
func (a *PurchaseItemAPIService) DeletePurchaseItem(ctx context.Context, version float32) ApiDeletePurchaseItemRequest {
	return ApiDeletePurchaseItemRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *PurchaseItemAPIService) DeletePurchaseItemExecute(r ApiDeletePurchaseItemRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PurchaseItemAPIService.DeletePurchaseItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/purchase/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.purchaseItemId == nil {
		return localVarReturnValue, nil, reportError("purchaseItemId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseItemId", r.purchaseItemId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPurchaseItemRequest struct {
	ctx context.Context
	ApiService *PurchaseItemAPIService
	version float32
	purchaseItemId *int64
	deviceId *string
	accountId *int64
}

// The purchase item id
func (r ApiGetPurchaseItemRequest) PurchaseItemId(purchaseItemId int64) ApiGetPurchaseItemRequest {
	r.purchaseItemId = &purchaseItemId
	return r
}

// The device id (deviceId or accountId required)
func (r ApiGetPurchaseItemRequest) DeviceId(deviceId string) ApiGetPurchaseItemRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiGetPurchaseItemRequest) AccountId(accountId int64) ApiGetPurchaseItemRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetPurchaseItemRequest) Execute() (*PurchaseItemFullResponse, *http.Response, error) {
	return r.ApiService.GetPurchaseItemExecute(r)
}

/*
GetPurchaseItem Get Purchase

Get detailed information about a purchase item

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetPurchaseItemRequest
*/
func (a *PurchaseItemAPIService) GetPurchaseItem(ctx context.Context, version float32) ApiGetPurchaseItemRequest {
	return ApiGetPurchaseItemRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return PurchaseItemFullResponse
func (a *PurchaseItemAPIService) GetPurchaseItemExecute(r ApiGetPurchaseItemRequest) (*PurchaseItemFullResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PurchaseItemFullResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PurchaseItemAPIService.GetPurchaseItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/purchase/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.purchaseItemId == nil {
		return localVarReturnValue, nil, reportError("purchaseItemId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseItemId", r.purchaseItemId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchPurchaseItemsRequest struct {
	ctx context.Context
	ApiService *PurchaseItemAPIService
	version float32
	deviceId *string
	accountId *int64
	appKey *string
	filterByBillable *bool
	purchaseType *string
	serviceAction *string
	keyword *string
	sortField *string
	descending *bool
	start *int32
	limit *int32
	activeOnly *bool
}

// The device id (deviceId or accountId required)
func (r ApiSearchPurchaseItemsRequest) DeviceId(deviceId string) ApiSearchPurchaseItemsRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiSearchPurchaseItemsRequest) AccountId(accountId int64) ApiSearchPurchaseItemsRequest {
	r.accountId = &accountId
	return r
}

// The application key to filter results by application
func (r ApiSearchPurchaseItemsRequest) AppKey(appKey string) ApiSearchPurchaseItemsRequest {
	r.appKey = &appKey
	return r
}

// Determines whether to filter results by the user&#39;s billable entity
func (r ApiSearchPurchaseItemsRequest) FilterByBillable(filterByBillable bool) ApiSearchPurchaseItemsRequest {
	r.filterByBillable = &filterByBillable
	return r
}

// A comma separated list of purchase providers to filter by. Possible values include: &lt;ul&gt; &lt;li&gt;SIRQUL - purchases from the Sirqul store using tickets&lt;/li&gt; &lt;li&gt;IOS - purchases from the iTunes store for iPhone, iPod, iPod Touch&lt;/li&gt; &lt;li&gt;GOOGLE - purchases from the Google Play store&lt;/li&gt; &lt;li&gt;AMAZON - purchases from the Amazon Android store&lt;/li&gt; &lt;li&gt;MAC - purchases from the iTunes store for OSX&lt;/li&gt; &lt;li&gt;WP8 - purchases from the Windows Phone 8 store&lt;/li&gt; &lt;li&gt;FREE - purchases that are free (can be used for development/testing purposes)&lt;/li&gt; &lt;/ul&gt;
func (r ApiSearchPurchaseItemsRequest) PurchaseType(purchaseType string) ApiSearchPurchaseItemsRequest {
	r.purchaseType = &purchaseType
	return r
}

// A comma separated list of service actions to filter results by. Possible values include: &lt;ul&gt; &lt;li&gt;DAY_PREMIUM - purchases that subscribes a user for a day of membership&lt;/li&gt; &lt;li&gt;WEEK_PREMIUM - purchases that subscribes a user for a week of membership&lt;/li&gt; &lt;li&gt;MONTH_PREMIUM - purchases that subscribes a user for a month of membership&lt;/li&gt; &lt;li&gt;ADD_TICKET - purchases that allow users to add more tickets&lt;/li&gt; &lt;li&gt;ADD_GIFT - purchases that allow users to recieve gifts&lt;/li&gt; &lt;/ul&gt;
func (r ApiSearchPurchaseItemsRequest) ServiceAction(serviceAction string) ApiSearchPurchaseItemsRequest {
	r.serviceAction = &serviceAction
	return r
}

// The keyword used to search
func (r ApiSearchPurchaseItemsRequest) Keyword(keyword string) ApiSearchPurchaseItemsRequest {
	r.keyword = &keyword
	return r
}

// The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY
func (r ApiSearchPurchaseItemsRequest) SortField(sortField string) ApiSearchPurchaseItemsRequest {
	r.sortField = &sortField
	return r
}

// The order to return the search results
func (r ApiSearchPurchaseItemsRequest) Descending(descending bool) ApiSearchPurchaseItemsRequest {
	r.descending = &descending
	return r
}

// The record to begin the return set on
func (r ApiSearchPurchaseItemsRequest) Start(start int32) ApiSearchPurchaseItemsRequest {
	r.start = &start
	return r
}

// The number of records to return
func (r ApiSearchPurchaseItemsRequest) Limit(limit int32) ApiSearchPurchaseItemsRequest {
	r.limit = &limit
	return r
}

// Return only active results
func (r ApiSearchPurchaseItemsRequest) ActiveOnly(activeOnly bool) ApiSearchPurchaseItemsRequest {
	r.activeOnly = &activeOnly
	return r
}

func (r ApiSearchPurchaseItemsRequest) Execute() ([]PurchaseItemResponse, *http.Response, error) {
	return r.ApiService.SearchPurchaseItemsExecute(r)
}

/*
SearchPurchaseItems Search Purchases

Search for purchasable items from the system

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchPurchaseItemsRequest
*/
func (a *PurchaseItemAPIService) SearchPurchaseItems(ctx context.Context, version float32) ApiSearchPurchaseItemsRequest {
	return ApiSearchPurchaseItemsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []PurchaseItemResponse
func (a *PurchaseItemAPIService) SearchPurchaseItemsExecute(r ApiSearchPurchaseItemsRequest) ([]PurchaseItemResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PurchaseItemResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PurchaseItemAPIService.SearchPurchaseItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/purchase/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.filterByBillable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterByBillable", r.filterByBillable, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterByBillable", defaultValue, "form", "")
		r.filterByBillable = &defaultValue
	}
	if r.purchaseType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseType", r.purchaseType, "form", "")
	}
	if r.serviceAction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serviceAction", r.serviceAction, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	} else {
		var defaultValue string = "NAME"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", defaultValue, "form", "")
		r.sortField = &defaultValue
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", defaultValue, "form", "")
		r.descending = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", defaultValue, "form", "")
		r.activeOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePurchaseItemRequest struct {
	ctx context.Context
	ApiService *PurchaseItemAPIService
	version float32
	purchaseItemId *int64
	deviceId *string
	accountId *int64
	name *string
	description *string
	tickets *int32
	price *float32
	purchaseType *string
	purchaseCode *string
	secretKey *string
	purchaseLimit *int32
	serviceAction *string
	coverAssetId *int64
	promoAssetId *int64
	giftable *bool
	assetable *bool
	active *bool
	allocateTickets *bool
	ticketType *string
	points *int64
	offerLocationId *int64
}

// The purchase item id
func (r ApiUpdatePurchaseItemRequest) PurchaseItemId(purchaseItemId int64) ApiUpdatePurchaseItemRequest {
	r.purchaseItemId = &purchaseItemId
	return r
}

// The device id (deviceId or accountId required)
func (r ApiUpdatePurchaseItemRequest) DeviceId(deviceId string) ApiUpdatePurchaseItemRequest {
	r.deviceId = &deviceId
	return r
}

// The account id of the user (deviceId or accountId required)
func (r ApiUpdatePurchaseItemRequest) AccountId(accountId int64) ApiUpdatePurchaseItemRequest {
	r.accountId = &accountId
	return r
}

// The name of the purchase item
func (r ApiUpdatePurchaseItemRequest) Name(name string) ApiUpdatePurchaseItemRequest {
	r.name = &name
	return r
}

// The description of the purchase item
func (r ApiUpdatePurchaseItemRequest) Description(description string) ApiUpdatePurchaseItemRequest {
	r.description = &description
	return r
}

// How much the purchase item is worth in tickets
func (r ApiUpdatePurchaseItemRequest) Tickets(tickets int32) ApiUpdatePurchaseItemRequest {
	r.tickets = &tickets
	return r
}

// How much the purchase item will cost in real money
func (r ApiUpdatePurchaseItemRequest) Price(price float32) ApiUpdatePurchaseItemRequest {
	r.price = &price
	return r
}

// The purchase provider &lt;ul&gt; &lt;li&gt;SIRQUL - the Sirqul store to make purchases using tickets&lt;/li&gt; &lt;li&gt;IOS - the iTunes store for iPhone, iPod, iPod Touch&lt;/li&gt; &lt;li&gt;GOOGLE - the Google Play store&lt;/li&gt; &lt;li&gt;AMAZON - the Amazon Android store&lt;/li&gt; &lt;li&gt;MAC - the iTunes store for OSX&lt;/li&gt; &lt;li&gt;WP8 - the Windows Phone 8 store&lt;/li&gt; &lt;li&gt;FREE - used for purchase items that are free (can be used for development/testing purposes)&lt;/li&gt; &lt;/ul&gt;
func (r ApiUpdatePurchaseItemRequest) PurchaseType(purchaseType string) ApiUpdatePurchaseItemRequest {
	r.purchaseType = &purchaseType
	return r
}

// The unique identifier used by purchase providers to identify in-app-purchases
func (r ApiUpdatePurchaseItemRequest) PurchaseCode(purchaseCode string) ApiUpdatePurchaseItemRequest {
	r.purchaseCode = &purchaseCode
	return r
}

// A secret key from purchase providers that would be used for validation
func (r ApiUpdatePurchaseItemRequest) SecretKey(secretKey string) ApiUpdatePurchaseItemRequest {
	r.secretKey = &secretKey
	return r
}

// How many times a user acquire the same purchase item
func (r ApiUpdatePurchaseItemRequest) PurchaseLimit(purchaseLimit int32) ApiUpdatePurchaseItemRequest {
	r.purchaseLimit = &purchaseLimit
	return r
}

// Determines whether the purchase item will enable certain features &lt;ul&gt; &lt;li&gt;DAY_PREMIUM - subscribes a user for a day of membership&lt;/li&gt; &lt;li&gt;WEEK_PREMIUM - subscribes a user for a week of membership&lt;/li&gt; &lt;li&gt;MONTH_PREMIUM - subscribes a user for a month of membership&lt;/li&gt; &lt;li&gt;ADD_TICKET - allows a user to add more tickets to their account&lt;/li&gt; &lt;li&gt;ADD_GIFT - allows a user to send/recieve the purchase item as a gift&lt;/li&gt; &lt;/ul&gt;
func (r ApiUpdatePurchaseItemRequest) ServiceAction(serviceAction string) ApiUpdatePurchaseItemRequest {
	r.serviceAction = &serviceAction
	return r
}

// The cover image of the purchase item
func (r ApiUpdatePurchaseItemRequest) CoverAssetId(coverAssetId int64) ApiUpdatePurchaseItemRequest {
	r.coverAssetId = &coverAssetId
	return r
}

// An application specific asset that can be used to store/provide additional data
func (r ApiUpdatePurchaseItemRequest) PromoAssetId(promoAssetId int64) ApiUpdatePurchaseItemRequest {
	r.promoAssetId = &promoAssetId
	return r
}

// Determines whether the purchase item can be gifted to other users
func (r ApiUpdatePurchaseItemRequest) Giftable(giftable bool) ApiUpdatePurchaseItemRequest {
	r.giftable = &giftable
	return r
}

// Determines whether users can attach their own media/asset to the purchase item
func (r ApiUpdatePurchaseItemRequest) Assetable(assetable bool) ApiUpdatePurchaseItemRequest {
	r.assetable = &assetable
	return r
}

// Sets whether the purchase item is active or inactive (hidden from consumers)
func (r ApiUpdatePurchaseItemRequest) Active(active bool) ApiUpdatePurchaseItemRequest {
	r.active = &active
	return r
}

// Flag to indicate owner should receive tickets for completed missions
func (r ApiUpdatePurchaseItemRequest) AllocateTickets(allocateTickets bool) ApiUpdatePurchaseItemRequest {
	r.allocateTickets = &allocateTickets
	return r
}

// The type of ticket to reward, null means default type
func (r ApiUpdatePurchaseItemRequest) TicketType(ticketType string) ApiUpdatePurchaseItemRequest {
	r.ticketType = &ticketType
	return r
}

// The number of points to award for completing a mission
func (r ApiUpdatePurchaseItemRequest) Points(points int64) ApiUpdatePurchaseItemRequest {
	r.points = &points
	return r
}

// The offer location that will get added to the user&#39;s wallet after purchase.
func (r ApiUpdatePurchaseItemRequest) OfferLocationId(offerLocationId int64) ApiUpdatePurchaseItemRequest {
	r.offerLocationId = &offerLocationId
	return r
}

func (r ApiUpdatePurchaseItemRequest) Execute() (*PurchaseItemFullResponse, *http.Response, error) {
	return r.ApiService.UpdatePurchaseItemExecute(r)
}

/*
UpdatePurchaseItem Update Purchase

Updates a purchase item for in app purchases

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdatePurchaseItemRequest
*/
func (a *PurchaseItemAPIService) UpdatePurchaseItem(ctx context.Context, version float32) ApiUpdatePurchaseItemRequest {
	return ApiUpdatePurchaseItemRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return PurchaseItemFullResponse
func (a *PurchaseItemAPIService) UpdatePurchaseItemExecute(r ApiUpdatePurchaseItemRequest) (*PurchaseItemFullResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PurchaseItemFullResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PurchaseItemAPIService.UpdatePurchaseItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/purchase/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.purchaseItemId == nil {
		return localVarReturnValue, nil, reportError("purchaseItemId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseItemId", r.purchaseItemId, "form", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.tickets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tickets", r.tickets, "form", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "price", r.price, "form", "")
	}
	if r.purchaseType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseType", r.purchaseType, "form", "")
	}
	if r.purchaseCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseCode", r.purchaseCode, "form", "")
	}
	if r.secretKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secretKey", r.secretKey, "form", "")
	}
	if r.purchaseLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseLimit", r.purchaseLimit, "form", "")
	}
	if r.serviceAction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serviceAction", r.serviceAction, "form", "")
	}
	if r.coverAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coverAssetId", r.coverAssetId, "form", "")
	}
	if r.promoAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "promoAssetId", r.promoAssetId, "form", "")
	}
	if r.giftable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "giftable", r.giftable, "form", "")
	}
	if r.assetable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetable", r.assetable, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.allocateTickets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allocateTickets", r.allocateTickets, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "allocateTickets", defaultValue, "form", "")
		r.allocateTickets = &defaultValue
	}
	if r.ticketType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketType", r.ticketType, "form", "")
	}
	if r.points != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "points", r.points, "form", "")
	}
	if r.offerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationId", r.offerLocationId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
