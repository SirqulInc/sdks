/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AssignmentAPIService AssignmentAPI service
type AssignmentAPIService service

type ApiAssigmentAssigneeAccountSearchRequest struct {
	ctx context.Context
	ApiService *AssignmentAPIService
	version float32
	accountId *int64
	keyword *string
}

// The account id sending the request
func (r ApiAssigmentAssigneeAccountSearchRequest) AccountId(accountId int64) ApiAssigmentAssigneeAccountSearchRequest {
	r.accountId = &accountId
	return r
}

// The keyword to filter the returned results
func (r ApiAssigmentAssigneeAccountSearchRequest) Keyword(keyword string) ApiAssigmentAssigneeAccountSearchRequest {
	r.keyword = &keyword
	return r
}

func (r ApiAssigmentAssigneeAccountSearchRequest) Execute() ([]AccountMiniResponse, *http.Response, error) {
	return r.ApiService.AssigmentAssigneeAccountSearchExecute(r)
}

/*
AssigmentAssigneeAccountSearch Search Assignment Assignees

Search for avaiable users for creating or updating assignment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAssigmentAssigneeAccountSearchRequest
*/
func (a *AssignmentAPIService) AssigmentAssigneeAccountSearch(ctx context.Context, version float32) ApiAssigmentAssigneeAccountSearchRequest {
	return ApiAssigmentAssigneeAccountSearchRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []AccountMiniResponse
func (a *AssignmentAPIService) AssigmentAssigneeAccountSearchExecute(r ApiAssigmentAssigneeAccountSearchRequest) ([]AccountMiniResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AccountMiniResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssignmentAPIService.AssigmentAssigneeAccountSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/assignment/assignee/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssignmentCreateRequest struct {
	ctx context.Context
	ApiService *AssignmentAPIService
	version float32
	accountId *int64
	name *string
	assigneeAccountId *int64
	description *string
	retailerLocationId *int64
	tags *string
	active *bool
}

// the user account id
func (r ApiAssignmentCreateRequest) AccountId(accountId int64) ApiAssignmentCreateRequest {
	r.accountId = &accountId
	return r
}

// the name for the assignment
func (r ApiAssignmentCreateRequest) Name(name string) ApiAssignmentCreateRequest {
	r.name = &name
	return r
}

// the account id to assign to
func (r ApiAssignmentCreateRequest) AssigneeAccountId(assigneeAccountId int64) ApiAssignmentCreateRequest {
	r.assigneeAccountId = &assigneeAccountId
	return r
}

// the desciprtion for the assignment
func (r ApiAssignmentCreateRequest) Description(description string) ApiAssignmentCreateRequest {
	r.description = &description
	return r
}

// the retailer location id
func (r ApiAssignmentCreateRequest) RetailerLocationId(retailerLocationId int64) ApiAssignmentCreateRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// the tags
func (r ApiAssignmentCreateRequest) Tags(tags string) ApiAssignmentCreateRequest {
	r.tags = &tags
	return r
}

// determines whether the assignment is active or inactive
func (r ApiAssignmentCreateRequest) Active(active bool) ApiAssignmentCreateRequest {
	r.active = &active
	return r
}

func (r ApiAssignmentCreateRequest) Execute() (*AssignmentResponse, *http.Response, error) {
	return r.ApiService.AssignmentCreateExecute(r)
}

/*
AssignmentCreate Create Assignment

Create an assignment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAssignmentCreateRequest
*/
func (a *AssignmentAPIService) AssignmentCreate(ctx context.Context, version float32) ApiAssignmentCreateRequest {
	return ApiAssignmentCreateRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return AssignmentResponse
func (a *AssignmentAPIService) AssignmentCreateExecute(r ApiAssignmentCreateRequest) (*AssignmentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssignmentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssignmentAPIService.AssignmentCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/assignment/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.assigneeAccountId == nil {
		return localVarReturnValue, nil, reportError("assigneeAccountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeAccountId", r.assigneeAccountId, "form", "")
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssignmentDeleteRequest struct {
	ctx context.Context
	ApiService *AssignmentAPIService
	version float32
	accountId *int64
	assignmentId *int64
}

// the user account id
func (r ApiAssignmentDeleteRequest) AccountId(accountId int64) ApiAssignmentDeleteRequest {
	r.accountId = &accountId
	return r
}

// the assignment id
func (r ApiAssignmentDeleteRequest) AssignmentId(assignmentId int64) ApiAssignmentDeleteRequest {
	r.assignmentId = &assignmentId
	return r
}

func (r ApiAssignmentDeleteRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.AssignmentDeleteExecute(r)
}

/*
AssignmentDelete Delete Assignment

Delete an assignment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAssignmentDeleteRequest
*/
func (a *AssignmentAPIService) AssignmentDelete(ctx context.Context, version float32) ApiAssignmentDeleteRequest {
	return ApiAssignmentDeleteRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AssignmentAPIService) AssignmentDeleteExecute(r ApiAssignmentDeleteRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssignmentAPIService.AssignmentDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/assignment/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.assignmentId == nil {
		return localVarReturnValue, nil, reportError("assignmentId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "assignmentId", r.assignmentId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssignmentGetRequest struct {
	ctx context.Context
	ApiService *AssignmentAPIService
	version float32
	accountId *int64
	assignmentId *int64
}

// the user account id
func (r ApiAssignmentGetRequest) AccountId(accountId int64) ApiAssignmentGetRequest {
	r.accountId = &accountId
	return r
}

// the assignment id
func (r ApiAssignmentGetRequest) AssignmentId(assignmentId int64) ApiAssignmentGetRequest {
	r.assignmentId = &assignmentId
	return r
}

func (r ApiAssignmentGetRequest) Execute() (*AssignmentResponse, *http.Response, error) {
	return r.ApiService.AssignmentGetExecute(r)
}

/*
AssignmentGet Get Assignment

Get the details of an assignment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAssignmentGetRequest
*/
func (a *AssignmentAPIService) AssignmentGet(ctx context.Context, version float32) ApiAssignmentGetRequest {
	return ApiAssignmentGetRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return AssignmentResponse
func (a *AssignmentAPIService) AssignmentGetExecute(r ApiAssignmentGetRequest) (*AssignmentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssignmentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssignmentAPIService.AssignmentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/assignment/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.assignmentId == nil {
		return localVarReturnValue, nil, reportError("assignmentId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "assignmentId", r.assignmentId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssignmentSearchRequest struct {
	ctx context.Context
	ApiService *AssignmentAPIService
	version float32
	accountId *int64
	sortField *string
	descending *bool
	activeOnly *bool
	start *int32
	limit *int32
	creatorAccountId *int64
	assigneeAccountIds *string
	retailerLocationIds *string
	currentStatusType *string
	keyword *string
}

// the account sending the request
func (r ApiAssignmentSearchRequest) AccountId(accountId int64) ApiAssignmentSearchRequest {
	r.accountId = &accountId
	return r
}

// sort by table field
func (r ApiAssignmentSearchRequest) SortField(sortField string) ApiAssignmentSearchRequest {
	r.sortField = &sortField
	return r
}

// return results in descending order or not
func (r ApiAssignmentSearchRequest) Descending(descending bool) ApiAssignmentSearchRequest {
	r.descending = &descending
	return r
}

// return active results only or not
func (r ApiAssignmentSearchRequest) ActiveOnly(activeOnly bool) ApiAssignmentSearchRequest {
	r.activeOnly = &activeOnly
	return r
}

// The record to begin the return set on
func (r ApiAssignmentSearchRequest) Start(start int32) ApiAssignmentSearchRequest {
	r.start = &start
	return r
}

// The number of records to return
func (r ApiAssignmentSearchRequest) Limit(limit int32) ApiAssignmentSearchRequest {
	r.limit = &limit
	return r
}

// the creator of the assignment
func (r ApiAssignmentSearchRequest) CreatorAccountId(creatorAccountId int64) ApiAssignmentSearchRequest {
	r.creatorAccountId = &creatorAccountId
	return r
}

// filter results by assignee accounts. If not provided, all assignments that are assigned to accounts that are managed by the requested account will be returned.
func (r ApiAssignmentSearchRequest) AssigneeAccountIds(assigneeAccountIds string) ApiAssignmentSearchRequest {
	r.assigneeAccountIds = &assigneeAccountIds
	return r
}

// filter results by retailer locations
func (r ApiAssignmentSearchRequest) RetailerLocationIds(retailerLocationIds string) ApiAssignmentSearchRequest {
	r.retailerLocationIds = &retailerLocationIds
	return r
}

// filter results by assignment status
func (r ApiAssignmentSearchRequest) CurrentStatusType(currentStatusType string) ApiAssignmentSearchRequest {
	r.currentStatusType = &currentStatusType
	return r
}

// filter results by keyword search that matches the assignee, creator, or retailer location name
func (r ApiAssignmentSearchRequest) Keyword(keyword string) ApiAssignmentSearchRequest {
	r.keyword = &keyword
	return r
}

func (r ApiAssignmentSearchRequest) Execute() ([]AssignmentResponse, *http.Response, error) {
	return r.ApiService.AssignmentSearchExecute(r)
}

/*
AssignmentSearch Search Assignments

Search for assignments by the given parameters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAssignmentSearchRequest
*/
func (a *AssignmentAPIService) AssignmentSearch(ctx context.Context, version float32) ApiAssignmentSearchRequest {
	return ApiAssignmentSearchRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []AssignmentResponse
func (a *AssignmentAPIService) AssignmentSearchExecute(r ApiAssignmentSearchRequest) ([]AssignmentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AssignmentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssignmentAPIService.AssignmentSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/assignment/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}
	if r.descending == nil {
		return localVarReturnValue, nil, reportError("descending is required and must be specified")
	}
	if r.activeOnly == nil {
		return localVarReturnValue, nil, reportError("activeOnly is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.creatorAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creatorAccountId", r.creatorAccountId, "form", "")
	}
	if r.assigneeAccountIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeAccountIds", r.assigneeAccountIds, "form", "")
	}
	if r.retailerLocationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationIds", r.retailerLocationIds, "form", "")
	}
	if r.currentStatusType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentStatusType", r.currentStatusType, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssignmentStatusCreateRequest struct {
	ctx context.Context
	ApiService *AssignmentAPIService
	version float32
	accountId *int64
	assignmentId *int64
	scheduledNotificationId *int64
	toDo *string
	connection *string
	method *string
	status *string
	closure *string
	message *string
	followUp *int64
	active *bool
}

// the user account id
func (r ApiAssignmentStatusCreateRequest) AccountId(accountId int64) ApiAssignmentStatusCreateRequest {
	r.accountId = &accountId
	return r
}

// the assignment id
func (r ApiAssignmentStatusCreateRequest) AssignmentId(assignmentId int64) ApiAssignmentStatusCreateRequest {
	r.assignmentId = &assignmentId
	return r
}

// the scheduled notification id for reminders
func (r ApiAssignmentStatusCreateRequest) ScheduledNotificationId(scheduledNotificationId int64) ApiAssignmentStatusCreateRequest {
	r.scheduledNotificationId = &scheduledNotificationId
	return r
}

// the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT
func (r ApiAssignmentStatusCreateRequest) ToDo(toDo string) ApiAssignmentStatusCreateRequest {
	r.toDo = &toDo
	return r
}

// the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED
func (r ApiAssignmentStatusCreateRequest) Connection(connection string) ApiAssignmentStatusCreateRequest {
	r.connection = &connection
	return r
}

// the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL
func (r ApiAssignmentStatusCreateRequest) Method(method string) ApiAssignmentStatusCreateRequest {
	r.method = &method
	return r
}

// the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED
func (r ApiAssignmentStatusCreateRequest) Status(status string) ApiAssignmentStatusCreateRequest {
	r.status = &status
	return r
}

// the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB
func (r ApiAssignmentStatusCreateRequest) Closure(closure string) ApiAssignmentStatusCreateRequest {
	r.closure = &closure
	return r
}

// the message from the assignee
func (r ApiAssignmentStatusCreateRequest) Message(message string) ApiAssignmentStatusCreateRequest {
	r.message = &message
	return r
}

// the date to follow up by
func (r ApiAssignmentStatusCreateRequest) FollowUp(followUp int64) ApiAssignmentStatusCreateRequest {
	r.followUp = &followUp
	return r
}

// determines whether the assignment status is active or inactive
func (r ApiAssignmentStatusCreateRequest) Active(active bool) ApiAssignmentStatusCreateRequest {
	r.active = &active
	return r
}

func (r ApiAssignmentStatusCreateRequest) Execute() (*AssignmentStatusResponse, *http.Response, error) {
	return r.ApiService.AssignmentStatusCreateExecute(r)
}

/*
AssignmentStatusCreate Create Assignment Status

Create an assignment status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAssignmentStatusCreateRequest
*/
func (a *AssignmentAPIService) AssignmentStatusCreate(ctx context.Context, version float32) ApiAssignmentStatusCreateRequest {
	return ApiAssignmentStatusCreateRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return AssignmentStatusResponse
func (a *AssignmentAPIService) AssignmentStatusCreateExecute(r ApiAssignmentStatusCreateRequest) (*AssignmentStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssignmentStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssignmentAPIService.AssignmentStatusCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/assignment/status/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.assignmentId == nil {
		return localVarReturnValue, nil, reportError("assignmentId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "assignmentId", r.assignmentId, "form", "")
	if r.scheduledNotificationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduledNotificationId", r.scheduledNotificationId, "form", "")
	}
	if r.toDo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toDo", r.toDo, "form", "")
	}
	if r.connection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connection", r.connection, "form", "")
	}
	if r.method != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "method", r.method, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.closure != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closure", r.closure, "form", "")
	}
	if r.message != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "message", r.message, "form", "")
	}
	if r.followUp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUp", r.followUp, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssignmentStatusDeleteRequest struct {
	ctx context.Context
	ApiService *AssignmentAPIService
	version float32
	accountId *int64
	assignmentStatusId *int64
}

// the user account id
func (r ApiAssignmentStatusDeleteRequest) AccountId(accountId int64) ApiAssignmentStatusDeleteRequest {
	r.accountId = &accountId
	return r
}

// the assignment status id
func (r ApiAssignmentStatusDeleteRequest) AssignmentStatusId(assignmentStatusId int64) ApiAssignmentStatusDeleteRequest {
	r.assignmentStatusId = &assignmentStatusId
	return r
}

func (r ApiAssignmentStatusDeleteRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.AssignmentStatusDeleteExecute(r)
}

/*
AssignmentStatusDelete Deletes Assignment Status

Deletes an assignment status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAssignmentStatusDeleteRequest
*/
func (a *AssignmentAPIService) AssignmentStatusDelete(ctx context.Context, version float32) ApiAssignmentStatusDeleteRequest {
	return ApiAssignmentStatusDeleteRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AssignmentAPIService) AssignmentStatusDeleteExecute(r ApiAssignmentStatusDeleteRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssignmentAPIService.AssignmentStatusDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/assignment/status/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.assignmentStatusId == nil {
		return localVarReturnValue, nil, reportError("assignmentStatusId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "assignmentStatusId", r.assignmentStatusId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssignmentStatusGetRequest struct {
	ctx context.Context
	ApiService *AssignmentAPIService
	version float32
	accountId *int64
	assignmentStatusId *int64
}

// the user account id
func (r ApiAssignmentStatusGetRequest) AccountId(accountId int64) ApiAssignmentStatusGetRequest {
	r.accountId = &accountId
	return r
}

// the assignment status id
func (r ApiAssignmentStatusGetRequest) AssignmentStatusId(assignmentStatusId int64) ApiAssignmentStatusGetRequest {
	r.assignmentStatusId = &assignmentStatusId
	return r
}

func (r ApiAssignmentStatusGetRequest) Execute() (*AssignmentStatusResponse, *http.Response, error) {
	return r.ApiService.AssignmentStatusGetExecute(r)
}

/*
AssignmentStatusGet Get Assignment Status

Get an assignment status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAssignmentStatusGetRequest
*/
func (a *AssignmentAPIService) AssignmentStatusGet(ctx context.Context, version float32) ApiAssignmentStatusGetRequest {
	return ApiAssignmentStatusGetRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return AssignmentStatusResponse
func (a *AssignmentAPIService) AssignmentStatusGetExecute(r ApiAssignmentStatusGetRequest) (*AssignmentStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssignmentStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssignmentAPIService.AssignmentStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/assignment/status/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.assignmentStatusId == nil {
		return localVarReturnValue, nil, reportError("assignmentStatusId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "assignmentStatusId", r.assignmentStatusId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssignmentStatusSearchRequest struct {
	ctx context.Context
	ApiService *AssignmentAPIService
	version float32
	accountId *int64
	sortField *string
	descending *bool
	activeOnly *bool
	start *int32
	limit *int32
	assignmentId *int64
	creatorAccountId *int64
	assigneeAccountId *int64
	retailerLocationId *int64
	statusType *string
	keyword *string
}

// the user account id
func (r ApiAssignmentStatusSearchRequest) AccountId(accountId int64) ApiAssignmentStatusSearchRequest {
	r.accountId = &accountId
	return r
}

// the field to sort by. Possible values include: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, CURRENT_STATUS, TODO, CONNECTION, METHOD, STATUS, CLOSURE, MESSAGE, FOLLOW_UP
func (r ApiAssignmentStatusSearchRequest) SortField(sortField string) ApiAssignmentStatusSearchRequest {
	r.sortField = &sortField
	return r
}

// determines whether the sorted list is in descending or ascending order
func (r ApiAssignmentStatusSearchRequest) Descending(descending bool) ApiAssignmentStatusSearchRequest {
	r.descending = &descending
	return r
}

// determines whether to only return active results
func (r ApiAssignmentStatusSearchRequest) ActiveOnly(activeOnly bool) ApiAssignmentStatusSearchRequest {
	r.activeOnly = &activeOnly
	return r
}

// the start index for pagination
func (r ApiAssignmentStatusSearchRequest) Start(start int32) ApiAssignmentStatusSearchRequest {
	r.start = &start
	return r
}

// the limit for pagination
func (r ApiAssignmentStatusSearchRequest) Limit(limit int32) ApiAssignmentStatusSearchRequest {
	r.limit = &limit
	return r
}

// the assignment id
func (r ApiAssignmentStatusSearchRequest) AssignmentId(assignmentId int64) ApiAssignmentStatusSearchRequest {
	r.assignmentId = &assignmentId
	return r
}

// filter results by the account who created the status
func (r ApiAssignmentStatusSearchRequest) CreatorAccountId(creatorAccountId int64) ApiAssignmentStatusSearchRequest {
	r.creatorAccountId = &creatorAccountId
	return r
}

// filter results by the assignee account
func (r ApiAssignmentStatusSearchRequest) AssigneeAccountId(assigneeAccountId int64) ApiAssignmentStatusSearchRequest {
	r.assigneeAccountId = &assigneeAccountId
	return r
}

// filter results by by retailer location
func (r ApiAssignmentStatusSearchRequest) RetailerLocationId(retailerLocationId int64) ApiAssignmentStatusSearchRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// filter results by the status type
func (r ApiAssignmentStatusSearchRequest) StatusType(statusType string) ApiAssignmentStatusSearchRequest {
	r.statusType = &statusType
	return r
}

// filter results by keyword search
func (r ApiAssignmentStatusSearchRequest) Keyword(keyword string) ApiAssignmentStatusSearchRequest {
	r.keyword = &keyword
	return r
}

func (r ApiAssignmentStatusSearchRequest) Execute() ([]AssignmentStatusResponse, *http.Response, error) {
	return r.ApiService.AssignmentStatusSearchExecute(r)
}

/*
AssignmentStatusSearch Search Assignment Statuses

Search on assignment statuses.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAssignmentStatusSearchRequest
*/
func (a *AssignmentAPIService) AssignmentStatusSearch(ctx context.Context, version float32) ApiAssignmentStatusSearchRequest {
	return ApiAssignmentStatusSearchRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []AssignmentStatusResponse
func (a *AssignmentAPIService) AssignmentStatusSearchExecute(r ApiAssignmentStatusSearchRequest) ([]AssignmentStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AssignmentStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssignmentAPIService.AssignmentStatusSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/assignment/status/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}
	if r.descending == nil {
		return localVarReturnValue, nil, reportError("descending is required and must be specified")
	}
	if r.activeOnly == nil {
		return localVarReturnValue, nil, reportError("activeOnly is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.assignmentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assignmentId", r.assignmentId, "form", "")
	}
	if r.creatorAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creatorAccountId", r.creatorAccountId, "form", "")
	}
	if r.assigneeAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeAccountId", r.assigneeAccountId, "form", "")
	}
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	if r.statusType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statusType", r.statusType, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssignmentStatusUpdateRequest struct {
	ctx context.Context
	ApiService *AssignmentAPIService
	version float32
	accountId *int64
	assignmentStatusId *int64
	scheduledNotificationId *int64
	toDo *string
	connection *string
	method *string
	status *string
	closure *string
	message *string
	followUp *int64
	active *bool
}

// the user account id
func (r ApiAssignmentStatusUpdateRequest) AccountId(accountId int64) ApiAssignmentStatusUpdateRequest {
	r.accountId = &accountId
	return r
}

// the assignment status id
func (r ApiAssignmentStatusUpdateRequest) AssignmentStatusId(assignmentStatusId int64) ApiAssignmentStatusUpdateRequest {
	r.assignmentStatusId = &assignmentStatusId
	return r
}

// the scheduled notification id for reminders
func (r ApiAssignmentStatusUpdateRequest) ScheduledNotificationId(scheduledNotificationId int64) ApiAssignmentStatusUpdateRequest {
	r.scheduledNotificationId = &scheduledNotificationId
	return r
}

// the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT
func (r ApiAssignmentStatusUpdateRequest) ToDo(toDo string) ApiAssignmentStatusUpdateRequest {
	r.toDo = &toDo
	return r
}

// the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED
func (r ApiAssignmentStatusUpdateRequest) Connection(connection string) ApiAssignmentStatusUpdateRequest {
	r.connection = &connection
	return r
}

// the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL
func (r ApiAssignmentStatusUpdateRequest) Method(method string) ApiAssignmentStatusUpdateRequest {
	r.method = &method
	return r
}

// the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED
func (r ApiAssignmentStatusUpdateRequest) Status(status string) ApiAssignmentStatusUpdateRequest {
	r.status = &status
	return r
}

// the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB
func (r ApiAssignmentStatusUpdateRequest) Closure(closure string) ApiAssignmentStatusUpdateRequest {
	r.closure = &closure
	return r
}

// the message from the assignee
func (r ApiAssignmentStatusUpdateRequest) Message(message string) ApiAssignmentStatusUpdateRequest {
	r.message = &message
	return r
}

// the date to follow up by
func (r ApiAssignmentStatusUpdateRequest) FollowUp(followUp int64) ApiAssignmentStatusUpdateRequest {
	r.followUp = &followUp
	return r
}

// determines whether the assignment status is active or inactive
func (r ApiAssignmentStatusUpdateRequest) Active(active bool) ApiAssignmentStatusUpdateRequest {
	r.active = &active
	return r
}

func (r ApiAssignmentStatusUpdateRequest) Execute() (*AssignmentStatusResponse, *http.Response, error) {
	return r.ApiService.AssignmentStatusUpdateExecute(r)
}

/*
AssignmentStatusUpdate Update Assignment Status

Updates an assignment status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAssignmentStatusUpdateRequest
*/
func (a *AssignmentAPIService) AssignmentStatusUpdate(ctx context.Context, version float32) ApiAssignmentStatusUpdateRequest {
	return ApiAssignmentStatusUpdateRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return AssignmentStatusResponse
func (a *AssignmentAPIService) AssignmentStatusUpdateExecute(r ApiAssignmentStatusUpdateRequest) (*AssignmentStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssignmentStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssignmentAPIService.AssignmentStatusUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/assignment/status/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.assignmentStatusId == nil {
		return localVarReturnValue, nil, reportError("assignmentStatusId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "assignmentStatusId", r.assignmentStatusId, "form", "")
	if r.scheduledNotificationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduledNotificationId", r.scheduledNotificationId, "form", "")
	}
	if r.toDo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toDo", r.toDo, "form", "")
	}
	if r.connection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connection", r.connection, "form", "")
	}
	if r.method != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "method", r.method, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.closure != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "closure", r.closure, "form", "")
	}
	if r.message != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "message", r.message, "form", "")
	}
	if r.followUp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "followUp", r.followUp, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssignmentUpdateRequest struct {
	ctx context.Context
	ApiService *AssignmentAPIService
	version float32
	accountId *int64
	assignmentId *int64
	name *string
	description *string
	assigneeAccountId *int64
	retailerLocationId *int64
	tags *string
	active *bool
}

// the user account id
func (r ApiAssignmentUpdateRequest) AccountId(accountId int64) ApiAssignmentUpdateRequest {
	r.accountId = &accountId
	return r
}

// the assignment id
func (r ApiAssignmentUpdateRequest) AssignmentId(assignmentId int64) ApiAssignmentUpdateRequest {
	r.assignmentId = &assignmentId
	return r
}

// the name of the assignment
func (r ApiAssignmentUpdateRequest) Name(name string) ApiAssignmentUpdateRequest {
	r.name = &name
	return r
}

// the description of the assignment
func (r ApiAssignmentUpdateRequest) Description(description string) ApiAssignmentUpdateRequest {
	r.description = &description
	return r
}

// the account id to assign to
func (r ApiAssignmentUpdateRequest) AssigneeAccountId(assigneeAccountId int64) ApiAssignmentUpdateRequest {
	r.assigneeAccountId = &assigneeAccountId
	return r
}

// the retailer location id
func (r ApiAssignmentUpdateRequest) RetailerLocationId(retailerLocationId int64) ApiAssignmentUpdateRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// the tags
func (r ApiAssignmentUpdateRequest) Tags(tags string) ApiAssignmentUpdateRequest {
	r.tags = &tags
	return r
}

// determines whether the assignment is active or inactive
func (r ApiAssignmentUpdateRequest) Active(active bool) ApiAssignmentUpdateRequest {
	r.active = &active
	return r
}

func (r ApiAssignmentUpdateRequest) Execute() (*AssignmentResponse, *http.Response, error) {
	return r.ApiService.AssignmentUpdateExecute(r)
}

/*
AssignmentUpdate Update Assignment

Updates an assignment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAssignmentUpdateRequest
*/
func (a *AssignmentAPIService) AssignmentUpdate(ctx context.Context, version float32) ApiAssignmentUpdateRequest {
	return ApiAssignmentUpdateRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return AssignmentResponse
func (a *AssignmentAPIService) AssignmentUpdateExecute(r ApiAssignmentUpdateRequest) (*AssignmentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssignmentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssignmentAPIService.AssignmentUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/assignment/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.assignmentId == nil {
		return localVarReturnValue, nil, reportError("assignmentId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "assignmentId", r.assignmentId, "form", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.assigneeAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigneeAccountId", r.assigneeAccountId, "form", "")
	}
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
