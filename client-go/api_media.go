/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// MediaAPIService MediaAPI service
type MediaAPIService service

type ApiCreateMediaRequest struct {
	ctx context.Context
	ApiService *MediaAPIService
	version float32
	accountId *int64
	title *string
	barcodeType *string
	noExpiration *bool
	availableLimit *int32
	availableLimitPerUser *int32
	addedLimit *int32
	viewLimit *int32
	maxPrints *int32
	ticketPrice *int64
	fullPrice *float64
	discountPrice *float64
	specialOfferType *string
	offerVisibility *string
	active *bool
	retailerLocationIds *string
	subTitle *string
	details *string
	subDetails *string
	finePrint *string
	barcodeEntry *string
	externalRedeemOptions *string
	externalUrl *string
	ticketsRewardType *string
	ticketsReward *int64
	activated *int64
	expires *int64
	ticketPriceType *string
	showRemaining *bool
	showRedeemed *bool
	replaced *bool
	featured *bool
	categoryIds *string
	filterIds *string
	barcodeAssetId *int64
	imageAssetId *int64
	imageAssetId1 *int64
	imageAssetId2 *int64
	imageAssetId3 *int64
	imageAssetId4 *int64
	imageAssetId5 *int64
	publisher *string
	redeemableStart *int64
	redeemableEnd *int64
	conditionType *string
	isbn *string
	asin *string
	catalogNumbers *string
	parentalRating *string
	availabilityDate *int64
	mediaType *string
	duration *int32
	author *string
	releaseDate *int64
	collectionIds *string
	availability *string
	availabilitySummary *string
}

// The account id of the logged in user
func (r ApiCreateMediaRequest) AccountId(accountId int64) ApiCreateMediaRequest {
	r.accountId = &accountId
	return r
}

// The title (255 char limit)
func (r ApiCreateMediaRequest) Title(title string) ApiCreateMediaRequest {
	r.title = &title
	return r
}

// The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}
func (r ApiCreateMediaRequest) BarcodeType(barcodeType string) ApiCreateMediaRequest {
	r.barcodeType = &barcodeType
	return r
}

// Overrides the expiration date so that the offer does not expire
func (r ApiCreateMediaRequest) NoExpiration(noExpiration bool) ApiCreateMediaRequest {
	r.noExpiration = &noExpiration
	return r
}

// The limit of how many times the offer can be used by consumers
func (r ApiCreateMediaRequest) AvailableLimit(availableLimit int32) ApiCreateMediaRequest {
	r.availableLimit = &availableLimit
	return r
}

// The limit of how many times a user can used the same offer
func (r ApiCreateMediaRequest) AvailableLimitPerUser(availableLimitPerUser int32) ApiCreateMediaRequest {
	r.availableLimitPerUser = &availableLimitPerUser
	return r
}

// The limit of how many times the offer can be added to consumer wallets
func (r ApiCreateMediaRequest) AddedLimit(addedLimit int32) ApiCreateMediaRequest {
	r.addedLimit = &addedLimit
	return r
}

// The limit of how many times the offer can be viewed
func (r ApiCreateMediaRequest) ViewLimit(viewLimit int32) ApiCreateMediaRequest {
	r.viewLimit = &viewLimit
	return r
}

// The maximum number of times the offer can be printed
func (r ApiCreateMediaRequest) MaxPrints(maxPrints int32) ApiCreateMediaRequest {
	r.maxPrints = &maxPrints
	return r
}

// The cost of the offer in tickets
func (r ApiCreateMediaRequest) TicketPrice(ticketPrice int64) ApiCreateMediaRequest {
	r.ticketPrice = &ticketPrice
	return r
}

// The retail/full price cost of the offer in real currency
func (r ApiCreateMediaRequest) FullPrice(fullPrice float64) ApiCreateMediaRequest {
	r.fullPrice = &fullPrice
	return r
}

// The cost of the offer at a discounted price (what the consumer pays)
func (r ApiCreateMediaRequest) DiscountPrice(discountPrice float64) ApiCreateMediaRequest {
	r.discountPrice = &discountPrice
	return r
}

// The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
func (r ApiCreateMediaRequest) SpecialOfferType(specialOfferType string) ApiCreateMediaRequest {
	r.specialOfferType = &specialOfferType
	return r
}

// The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}
func (r ApiCreateMediaRequest) OfferVisibility(offerVisibility string) ApiCreateMediaRequest {
	r.offerVisibility = &offerVisibility
	return r
}

// Sets the active flag
func (r ApiCreateMediaRequest) Active(active bool) ApiCreateMediaRequest {
	r.active = &active
	return r
}

// Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
func (r ApiCreateMediaRequest) RetailerLocationIds(retailerLocationIds string) ApiCreateMediaRequest {
	r.retailerLocationIds = &retailerLocationIds
	return r
}

// The sub title (255 char limit)
func (r ApiCreateMediaRequest) SubTitle(subTitle string) ApiCreateMediaRequest {
	r.subTitle = &subTitle
	return r
}

// The details of the media
func (r ApiCreateMediaRequest) Details(details string) ApiCreateMediaRequest {
	r.details = &details
	return r
}

// A string for custom details (255 char limit)
func (r ApiCreateMediaRequest) SubDetails(subDetails string) ApiCreateMediaRequest {
	r.subDetails = &subDetails
	return r
}

// The fine print of the media
func (r ApiCreateMediaRequest) FinePrint(finePrint string) ApiCreateMediaRequest {
	r.finePrint = &finePrint
	return r
}

// The bar code entry string
func (r ApiCreateMediaRequest) BarcodeEntry(barcodeEntry string) ApiCreateMediaRequest {
	r.barcodeEntry = &barcodeEntry
	return r
}

// An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer
func (r ApiCreateMediaRequest) ExternalRedeemOptions(externalRedeemOptions string) ApiCreateMediaRequest {
	r.externalRedeemOptions = &externalRedeemOptions
	return r
}

// The clickUrl of the offer
func (r ApiCreateMediaRequest) ExternalUrl(externalUrl string) ApiCreateMediaRequest {
	r.externalUrl = &externalUrl
	return r
}

// The type of ticket to reward, null means default type
func (r ApiCreateMediaRequest) TicketsRewardType(ticketsRewardType string) ApiCreateMediaRequest {
	r.ticketsRewardType = &ticketsRewardType
	return r
}

// Determines how many tickets are awarded
func (r ApiCreateMediaRequest) TicketsReward(ticketsReward int64) ApiCreateMediaRequest {
	r.ticketsReward = &ticketsReward
	return r
}

// The date of when the offer will be visible to consumers
func (r ApiCreateMediaRequest) Activated(activated int64) ApiCreateMediaRequest {
	r.activated = &activated
	return r
}

// The date of when the offer expires
func (r ApiCreateMediaRequest) Expires(expires int64) ApiCreateMediaRequest {
	r.expires = &expires
	return r
}

// the type of ticket needed to buy offer
func (r ApiCreateMediaRequest) TicketPriceType(ticketPriceType string) ApiCreateMediaRequest {
	r.ticketPriceType = &ticketPriceType
	return r
}

// show how many of the media is remaining (if there is a limit)
func (r ApiCreateMediaRequest) ShowRemaining(showRemaining bool) ApiCreateMediaRequest {
	r.showRemaining = &showRemaining
	return r
}

// show how many of the media has been redeemed
func (r ApiCreateMediaRequest) ShowRedeemed(showRedeemed bool) ApiCreateMediaRequest {
	r.showRedeemed = &showRedeemed
	return r
}

// if the media has been replaced
func (r ApiCreateMediaRequest) Replaced(replaced bool) ApiCreateMediaRequest {
	r.replaced = &replaced
	return r
}

// if the media should be featured or not
func (r ApiCreateMediaRequest) Featured(featured bool) ApiCreateMediaRequest {
	r.featured = &featured
	return r
}

// Comma separated list of category ids
func (r ApiCreateMediaRequest) CategoryIds(categoryIds string) ApiCreateMediaRequest {
	r.categoryIds = &categoryIds
	return r
}

// Comma separated list of filter ids
func (r ApiCreateMediaRequest) FilterIds(filterIds string) ApiCreateMediaRequest {
	r.filterIds = &filterIds
	return r
}

// The id of the barcode asset
func (r ApiCreateMediaRequest) BarcodeAssetId(barcodeAssetId int64) ApiCreateMediaRequest {
	r.barcodeAssetId = &barcodeAssetId
	return r
}

// The id of the an offer asset
func (r ApiCreateMediaRequest) ImageAssetId(imageAssetId int64) ApiCreateMediaRequest {
	r.imageAssetId = &imageAssetId
	return r
}

// The id of the an offer asset
func (r ApiCreateMediaRequest) ImageAssetId1(imageAssetId1 int64) ApiCreateMediaRequest {
	r.imageAssetId1 = &imageAssetId1
	return r
}

// The id of the an offer asset
func (r ApiCreateMediaRequest) ImageAssetId2(imageAssetId2 int64) ApiCreateMediaRequest {
	r.imageAssetId2 = &imageAssetId2
	return r
}

// The id of the an offer asset
func (r ApiCreateMediaRequest) ImageAssetId3(imageAssetId3 int64) ApiCreateMediaRequest {
	r.imageAssetId3 = &imageAssetId3
	return r
}

// The id of the an offer asset
func (r ApiCreateMediaRequest) ImageAssetId4(imageAssetId4 int64) ApiCreateMediaRequest {
	r.imageAssetId4 = &imageAssetId4
	return r
}

// The id of the an offer asset
func (r ApiCreateMediaRequest) ImageAssetId5(imageAssetId5 int64) ApiCreateMediaRequest {
	r.imageAssetId5 = &imageAssetId5
	return r
}

// The maker of the item.
func (r ApiCreateMediaRequest) Publisher(publisher string) ApiCreateMediaRequest {
	r.publisher = &publisher
	return r
}

// The redeemable start date/time of the offer.
func (r ApiCreateMediaRequest) RedeemableStart(redeemableStart int64) ApiCreateMediaRequest {
	r.redeemableStart = &redeemableStart
	return r
}

// The redeemable start date/time of the offer.
func (r ApiCreateMediaRequest) RedeemableEnd(redeemableEnd int64) ApiCreateMediaRequest {
	r.redeemableEnd = &redeemableEnd
	return r
}

// The condition type of the media
func (r ApiCreateMediaRequest) ConditionType(conditionType string) ApiCreateMediaRequest {
	r.conditionType = &conditionType
	return r
}

// The ISBN id
func (r ApiCreateMediaRequest) Isbn(isbn string) ApiCreateMediaRequest {
	r.isbn = &isbn
	return r
}

// The ASIN id
func (r ApiCreateMediaRequest) Asin(asin string) ApiCreateMediaRequest {
	r.asin = &asin
	return r
}

// The list of catelog numbers, comma seperated
func (r ApiCreateMediaRequest) CatalogNumbers(catalogNumbers string) ApiCreateMediaRequest {
	r.catalogNumbers = &catalogNumbers
	return r
}

// The parental control rating
func (r ApiCreateMediaRequest) ParentalRating(parentalRating string) ApiCreateMediaRequest {
	r.parentalRating = &parentalRating
	return r
}

// The date the media is available to use
func (r ApiCreateMediaRequest) AvailabilityDate(availabilityDate int64) ApiCreateMediaRequest {
	r.availabilityDate = &availabilityDate
	return r
}

// the media type
func (r ApiCreateMediaRequest) MediaType(mediaType string) ApiCreateMediaRequest {
	r.mediaType = &mediaType
	return r
}

// The total playing time of the media item
func (r ApiCreateMediaRequest) Duration(duration int32) ApiCreateMediaRequest {
	r.duration = &duration
	return r
}

// The created/author of the media item
func (r ApiCreateMediaRequest) Author(author string) ApiCreateMediaRequest {
	r.author = &author
	return r
}

// The date/time of when the media item was originally released
func (r ApiCreateMediaRequest) ReleaseDate(releaseDate int64) ApiCreateMediaRequest {
	r.releaseDate = &releaseDate
	return r
}

// the IDs of the collections this media should be assigned to
func (r ApiCreateMediaRequest) CollectionIds(collectionIds string) ApiCreateMediaRequest {
	r.collectionIds = &collectionIds
	return r
}

// ability to assign if this media should active or not
func (r ApiCreateMediaRequest) Availability(availability string) ApiCreateMediaRequest {
	r.availability = &availability
	return r
}

// ability to assign when the media expires
func (r ApiCreateMediaRequest) AvailabilitySummary(availabilitySummary string) ApiCreateMediaRequest {
	r.availabilitySummary = &availabilitySummary
	return r
}

func (r ApiCreateMediaRequest) Execute() (*MediaOfferResponse, *http.Response, error) {
	return r.ApiService.CreateMediaExecute(r)
}

/*
CreateMedia Create Media

Create a media offering.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateMediaRequest
*/
func (a *MediaAPIService) CreateMedia(ctx context.Context, version float32) ApiCreateMediaRequest {
	return ApiCreateMediaRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return MediaOfferResponse
func (a *MediaAPIService) CreateMediaExecute(r ApiCreateMediaRequest) (*MediaOfferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MediaOfferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaAPIService.CreateMedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/media/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if r.barcodeType == nil {
		return localVarReturnValue, nil, reportError("barcodeType is required and must be specified")
	}
	if r.noExpiration == nil {
		return localVarReturnValue, nil, reportError("noExpiration is required and must be specified")
	}
	if r.availableLimit == nil {
		return localVarReturnValue, nil, reportError("availableLimit is required and must be specified")
	}
	if r.availableLimitPerUser == nil {
		return localVarReturnValue, nil, reportError("availableLimitPerUser is required and must be specified")
	}
	if r.addedLimit == nil {
		return localVarReturnValue, nil, reportError("addedLimit is required and must be specified")
	}
	if r.viewLimit == nil {
		return localVarReturnValue, nil, reportError("viewLimit is required and must be specified")
	}
	if r.maxPrints == nil {
		return localVarReturnValue, nil, reportError("maxPrints is required and must be specified")
	}
	if r.ticketPrice == nil {
		return localVarReturnValue, nil, reportError("ticketPrice is required and must be specified")
	}
	if r.fullPrice == nil {
		return localVarReturnValue, nil, reportError("fullPrice is required and must be specified")
	}
	if r.discountPrice == nil {
		return localVarReturnValue, nil, reportError("discountPrice is required and must be specified")
	}
	if r.specialOfferType == nil {
		return localVarReturnValue, nil, reportError("specialOfferType is required and must be specified")
	}
	if r.offerVisibility == nil {
		return localVarReturnValue, nil, reportError("offerVisibility is required and must be specified")
	}
	if r.active == nil {
		return localVarReturnValue, nil, reportError("active is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.retailerLocationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationIds", r.retailerLocationIds, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	if r.subTitle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subTitle", r.subTitle, "form", "")
	}
	if r.details != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "details", r.details, "form", "")
	}
	if r.subDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subDetails", r.subDetails, "form", "")
	}
	if r.finePrint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finePrint", r.finePrint, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "barcodeType", r.barcodeType, "form", "")
	if r.barcodeEntry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "barcodeEntry", r.barcodeEntry, "form", "")
	}
	if r.externalRedeemOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalRedeemOptions", r.externalRedeemOptions, "form", "")
	}
	if r.externalUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalUrl", r.externalUrl, "form", "")
	}
	if r.ticketsRewardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketsRewardType", r.ticketsRewardType, "form", "")
	}
	if r.ticketsReward != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketsReward", r.ticketsReward, "form", "")
	}
	if r.activated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activated", r.activated, "form", "")
	}
	if r.expires != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expires", r.expires, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "noExpiration", r.noExpiration, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "availableLimit", r.availableLimit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "availableLimitPerUser", r.availableLimitPerUser, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "addedLimit", r.addedLimit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "viewLimit", r.viewLimit, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "maxPrints", r.maxPrints, "form", "")
	if r.ticketPriceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketPriceType", r.ticketPriceType, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ticketPrice", r.ticketPrice, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "fullPrice", r.fullPrice, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "discountPrice", r.discountPrice, "form", "")
	if r.showRemaining != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showRemaining", r.showRemaining, "form", "")
	}
	if r.showRedeemed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showRedeemed", r.showRedeemed, "form", "")
	}
	if r.replaced != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "replaced", r.replaced, "form", "")
	}
	if r.featured != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "featured", r.featured, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "specialOfferType", r.specialOfferType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "offerVisibility", r.offerVisibility, "form", "")
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.filterIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterIds", r.filterIds, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	if r.barcodeAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "barcodeAssetId", r.barcodeAssetId, "form", "")
	}
	if r.imageAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId", r.imageAssetId, "form", "")
	}
	if r.imageAssetId1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId1", r.imageAssetId1, "form", "")
	}
	if r.imageAssetId2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId2", r.imageAssetId2, "form", "")
	}
	if r.imageAssetId3 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId3", r.imageAssetId3, "form", "")
	}
	if r.imageAssetId4 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId4", r.imageAssetId4, "form", "")
	}
	if r.imageAssetId5 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId5", r.imageAssetId5, "form", "")
	}
	if r.publisher != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publisher", r.publisher, "form", "")
	}
	if r.redeemableStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemableStart", r.redeemableStart, "form", "")
	}
	if r.redeemableEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemableEnd", r.redeemableEnd, "form", "")
	}
	if r.conditionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conditionType", r.conditionType, "form", "")
	}
	if r.isbn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isbn", r.isbn, "form", "")
	}
	if r.asin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asin", r.asin, "form", "")
	}
	if r.catalogNumbers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "catalogNumbers", r.catalogNumbers, "form", "")
	}
	if r.parentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentalRating", r.parentalRating, "form", "")
	}
	if r.availabilityDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availabilityDate", r.availabilityDate, "form", "")
	}
	if r.mediaType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaType", r.mediaType, "form", "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "form", "")
	}
	if r.author != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "author", r.author, "form", "")
	}
	if r.releaseDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "releaseDate", r.releaseDate, "form", "")
	}
	if r.collectionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "collectionIds", r.collectionIds, "form", "")
	}
	if r.availability != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availability", r.availability, "form", "")
	}
	if r.availabilitySummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availabilitySummary", r.availabilitySummary, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMediaRequest struct {
	ctx context.Context
	ApiService *MediaAPIService
	version float32
	accountId *int64
	mediaId *int64
}

// the id of the logged in user
func (r ApiDeleteMediaRequest) AccountId(accountId int64) ApiDeleteMediaRequest {
	r.accountId = &accountId
	return r
}

// the ID of the media to delete
func (r ApiDeleteMediaRequest) MediaId(mediaId int64) ApiDeleteMediaRequest {
	r.mediaId = &mediaId
	return r
}

func (r ApiDeleteMediaRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteMediaExecute(r)
}

/*
DeleteMedia Delete Media

Delete a media offering that the user has permissions to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteMediaRequest
*/
func (a *MediaAPIService) DeleteMedia(ctx context.Context, version float32) ApiDeleteMediaRequest {
	return ApiDeleteMediaRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *MediaAPIService) DeleteMediaExecute(r ApiDeleteMediaRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaAPIService.DeleteMedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/media/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.mediaId == nil {
		return localVarReturnValue, nil, reportError("mediaId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "mediaId", r.mediaId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMediaRequest struct {
	ctx context.Context
	ApiService *MediaAPIService
	version float32
	accountId *int64
	mediaId *int64
}

// the id of the logged in user
func (r ApiGetMediaRequest) AccountId(accountId int64) ApiGetMediaRequest {
	r.accountId = &accountId
	return r
}

// the id of the media to get
func (r ApiGetMediaRequest) MediaId(mediaId int64) ApiGetMediaRequest {
	r.mediaId = &mediaId
	return r
}

func (r ApiGetMediaRequest) Execute() (*MediaOfferResponse, *http.Response, error) {
	return r.ApiService.GetMediaExecute(r)
}

/*
GetMedia Media Get

Get a media offering.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetMediaRequest
*/
func (a *MediaAPIService) GetMedia(ctx context.Context, version float32) ApiGetMediaRequest {
	return ApiGetMediaRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return MediaOfferResponse
func (a *MediaAPIService) GetMediaExecute(r ApiGetMediaRequest) (*MediaOfferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MediaOfferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaAPIService.GetMedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/media/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.mediaId == nil {
		return localVarReturnValue, nil, reportError("mediaId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "mediaId", r.mediaId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchMediaRequest struct {
	ctx context.Context
	ApiService *MediaAPIService
	version float32
	accountId *int64
	activeOnly *bool
	sortField *string
	descending *bool
	keyword *string
	categoryIds *string
	filterIds *string
	start *int32
	limit *int32
}

// The logged in user.
func (r ApiSearchMediaRequest) AccountId(accountId int64) ApiSearchMediaRequest {
	r.accountId = &accountId
	return r
}

// Return only active results
func (r ApiSearchMediaRequest) ActiveOnly(activeOnly bool) ApiSearchMediaRequest {
	r.activeOnly = &activeOnly
	return r
}

// The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, AVAILABILITY_DATE, RELEASE_DATE
func (r ApiSearchMediaRequest) SortField(sortField string) ApiSearchMediaRequest {
	r.sortField = &sortField
	return r
}

// The order to return the search results
func (r ApiSearchMediaRequest) Descending(descending bool) ApiSearchMediaRequest {
	r.descending = &descending
	return r
}

// The keyword used to search
func (r ApiSearchMediaRequest) Keyword(keyword string) ApiSearchMediaRequest {
	r.keyword = &keyword
	return r
}

// 
func (r ApiSearchMediaRequest) CategoryIds(categoryIds string) ApiSearchMediaRequest {
	r.categoryIds = &categoryIds
	return r
}

// 
func (r ApiSearchMediaRequest) FilterIds(filterIds string) ApiSearchMediaRequest {
	r.filterIds = &filterIds
	return r
}

// The record to begin the return set on
func (r ApiSearchMediaRequest) Start(start int32) ApiSearchMediaRequest {
	r.start = &start
	return r
}

// The number of records to return
func (r ApiSearchMediaRequest) Limit(limit int32) ApiSearchMediaRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchMediaRequest) Execute() ([]MediaOfferResponse, *http.Response, error) {
	return r.ApiService.SearchMediaExecute(r)
}

/*
SearchMedia Search Media

Searches on events that the account has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchMediaRequest
*/
func (a *MediaAPIService) SearchMedia(ctx context.Context, version float32) ApiSearchMediaRequest {
	return ApiSearchMediaRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []MediaOfferResponse
func (a *MediaAPIService) SearchMediaExecute(r ApiSearchMediaRequest) ([]MediaOfferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MediaOfferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaAPIService.SearchMedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/media/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.activeOnly == nil {
		return localVarReturnValue, nil, reportError("activeOnly is required and must be specified")
	}
	if r.sortField == nil {
		return localVarReturnValue, nil, reportError("sortField is required and must be specified")
	}
	if r.descending == nil {
		return localVarReturnValue, nil, reportError("descending is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.filterIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterIds", r.filterIds, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMediaRequest struct {
	ctx context.Context
	ApiService *MediaAPIService
	version float32
	accountId *int64
	mediaId *int64
	retailerLocationIds *string
	offerLocations *string
	title *string
	subTitle *string
	details *string
	subDetails *string
	finePrint *string
	barcodeType *string
	barcodeEntry *string
	externalRedeemOptions *string
	externalUrl *string
	ticketsRewardType *string
	ticketsReward *int64
	activated *int64
	expires *int64
	noExpiration *bool
	availableLimit *int32
	availableLimitPerUser *int32
	addedLimit *int32
	viewLimit *int32
	maxPrints *int32
	ticketPriceType *string
	ticketPrice *int64
	fullPrice *float64
	discountPrice *float64
	showRemaining *bool
	showRedeemed *bool
	replaced *bool
	featured *bool
	specialOfferType *string
	offerVisibility *string
	categoryIds *string
	filterIds *string
	active *bool
	barcodeAssetId *int64
	imageAssetId *int64
	imageAssetId1 *int64
	imageAssetId2 *int64
	imageAssetId3 *int64
	imageAssetId4 *int64
	imageAssetId5 *int64
	publisher *string
	redeemableStart *int64
	redeemableEnd *int64
	conditionType *string
	isbn *string
	asin *string
	catalogNumbers *string
	availabilityDate *int64
	parentalRating *string
	mediaType *string
	duration *int32
	author *string
	releaseDate *int64
	collectionIds *string
	availability *string
	availabilitySummary *string
}

// The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)
func (r ApiUpdateMediaRequest) AccountId(accountId int64) ApiUpdateMediaRequest {
	r.accountId = &accountId
	return r
}

// 
func (r ApiUpdateMediaRequest) MediaId(mediaId int64) ApiUpdateMediaRequest {
	r.mediaId = &mediaId
	return r
}

// Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
func (r ApiUpdateMediaRequest) RetailerLocationIds(retailerLocationIds string) ApiUpdateMediaRequest {
	r.retailerLocationIds = &retailerLocationIds
	return r
}

// A list of json data that has offer location specific values.
func (r ApiUpdateMediaRequest) OfferLocations(offerLocations string) ApiUpdateMediaRequest {
	r.offerLocations = &offerLocations
	return r
}

// The title (255 char limit)
func (r ApiUpdateMediaRequest) Title(title string) ApiUpdateMediaRequest {
	r.title = &title
	return r
}

// The sub title (255 char limit)
func (r ApiUpdateMediaRequest) SubTitle(subTitle string) ApiUpdateMediaRequest {
	r.subTitle = &subTitle
	return r
}

// The details
func (r ApiUpdateMediaRequest) Details(details string) ApiUpdateMediaRequest {
	r.details = &details
	return r
}

// A string for custom details (255 char limit)
func (r ApiUpdateMediaRequest) SubDetails(subDetails string) ApiUpdateMediaRequest {
	r.subDetails = &subDetails
	return r
}

// The fine print
func (r ApiUpdateMediaRequest) FinePrint(finePrint string) ApiUpdateMediaRequest {
	r.finePrint = &finePrint
	return r
}

// The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}
func (r ApiUpdateMediaRequest) BarcodeType(barcodeType string) ApiUpdateMediaRequest {
	r.barcodeType = &barcodeType
	return r
}

// The bar code entry string
func (r ApiUpdateMediaRequest) BarcodeEntry(barcodeEntry string) ApiUpdateMediaRequest {
	r.barcodeEntry = &barcodeEntry
	return r
}

// An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.
func (r ApiUpdateMediaRequest) ExternalRedeemOptions(externalRedeemOptions string) ApiUpdateMediaRequest {
	r.externalRedeemOptions = &externalRedeemOptions
	return r
}

// The clickUrl of the offer
func (r ApiUpdateMediaRequest) ExternalUrl(externalUrl string) ApiUpdateMediaRequest {
	r.externalUrl = &externalUrl
	return r
}

// The type of ticket to reward, null means default type
func (r ApiUpdateMediaRequest) TicketsRewardType(ticketsRewardType string) ApiUpdateMediaRequest {
	r.ticketsRewardType = &ticketsRewardType
	return r
}

// Determines how many tickets are awarded
func (r ApiUpdateMediaRequest) TicketsReward(ticketsReward int64) ApiUpdateMediaRequest {
	r.ticketsReward = &ticketsReward
	return r
}

// The date of when the offer will be visible to consumers
func (r ApiUpdateMediaRequest) Activated(activated int64) ApiUpdateMediaRequest {
	r.activated = &activated
	return r
}

// The date of when the offer expires
func (r ApiUpdateMediaRequest) Expires(expires int64) ApiUpdateMediaRequest {
	r.expires = &expires
	return r
}

// Overrides the expiration date so that the offer does not expire
func (r ApiUpdateMediaRequest) NoExpiration(noExpiration bool) ApiUpdateMediaRequest {
	r.noExpiration = &noExpiration
	return r
}

// The limit of how many times the offer can be used by consumers
func (r ApiUpdateMediaRequest) AvailableLimit(availableLimit int32) ApiUpdateMediaRequest {
	r.availableLimit = &availableLimit
	return r
}

// The limit of how many times a user can used the same offer
func (r ApiUpdateMediaRequest) AvailableLimitPerUser(availableLimitPerUser int32) ApiUpdateMediaRequest {
	r.availableLimitPerUser = &availableLimitPerUser
	return r
}

// The limit of how many times the offer can be added to consumer wallets
func (r ApiUpdateMediaRequest) AddedLimit(addedLimit int32) ApiUpdateMediaRequest {
	r.addedLimit = &addedLimit
	return r
}

// 
func (r ApiUpdateMediaRequest) ViewLimit(viewLimit int32) ApiUpdateMediaRequest {
	r.viewLimit = &viewLimit
	return r
}

// The maximum number of times the offer can be printed
func (r ApiUpdateMediaRequest) MaxPrints(maxPrints int32) ApiUpdateMediaRequest {
	r.maxPrints = &maxPrints
	return r
}

// the type of ticket needed to buy the offer
func (r ApiUpdateMediaRequest) TicketPriceType(ticketPriceType string) ApiUpdateMediaRequest {
	r.ticketPriceType = &ticketPriceType
	return r
}

// The cost of the offer in tickets
func (r ApiUpdateMediaRequest) TicketPrice(ticketPrice int64) ApiUpdateMediaRequest {
	r.ticketPrice = &ticketPrice
	return r
}

// The retail/full price cost of the offer in real currency
func (r ApiUpdateMediaRequest) FullPrice(fullPrice float64) ApiUpdateMediaRequest {
	r.fullPrice = &fullPrice
	return r
}

// The cost of the offer at a discounted price (what the consumer pays)
func (r ApiUpdateMediaRequest) DiscountPrice(discountPrice float64) ApiUpdateMediaRequest {
	r.discountPrice = &discountPrice
	return r
}

// The show remaining
func (r ApiUpdateMediaRequest) ShowRemaining(showRemaining bool) ApiUpdateMediaRequest {
	r.showRemaining = &showRemaining
	return r
}

// The show redeemed
func (r ApiUpdateMediaRequest) ShowRedeemed(showRedeemed bool) ApiUpdateMediaRequest {
	r.showRedeemed = &showRedeemed
	return r
}

// The replaced
func (r ApiUpdateMediaRequest) Replaced(replaced bool) ApiUpdateMediaRequest {
	r.replaced = &replaced
	return r
}

// The featured
func (r ApiUpdateMediaRequest) Featured(featured bool) ApiUpdateMediaRequest {
	r.featured = &featured
	return r
}

// The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
func (r ApiUpdateMediaRequest) SpecialOfferType(specialOfferType string) ApiUpdateMediaRequest {
	r.specialOfferType = &specialOfferType
	return r
}

// The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}
func (r ApiUpdateMediaRequest) OfferVisibility(offerVisibility string) ApiUpdateMediaRequest {
	r.offerVisibility = &offerVisibility
	return r
}

// Comma separated list of category ids
func (r ApiUpdateMediaRequest) CategoryIds(categoryIds string) ApiUpdateMediaRequest {
	r.categoryIds = &categoryIds
	return r
}

// Comma separated list of filter ids
func (r ApiUpdateMediaRequest) FilterIds(filterIds string) ApiUpdateMediaRequest {
	r.filterIds = &filterIds
	return r
}

// Sets the active flag
func (r ApiUpdateMediaRequest) Active(active bool) ApiUpdateMediaRequest {
	r.active = &active
	return r
}

// The id of the barcode asset
func (r ApiUpdateMediaRequest) BarcodeAssetId(barcodeAssetId int64) ApiUpdateMediaRequest {
	r.barcodeAssetId = &barcodeAssetId
	return r
}

// The id of the an offer asset
func (r ApiUpdateMediaRequest) ImageAssetId(imageAssetId int64) ApiUpdateMediaRequest {
	r.imageAssetId = &imageAssetId
	return r
}

// The id of the an offer asset
func (r ApiUpdateMediaRequest) ImageAssetId1(imageAssetId1 int64) ApiUpdateMediaRequest {
	r.imageAssetId1 = &imageAssetId1
	return r
}

// The id of the an offer asset
func (r ApiUpdateMediaRequest) ImageAssetId2(imageAssetId2 int64) ApiUpdateMediaRequest {
	r.imageAssetId2 = &imageAssetId2
	return r
}

// The id of the an offer asset
func (r ApiUpdateMediaRequest) ImageAssetId3(imageAssetId3 int64) ApiUpdateMediaRequest {
	r.imageAssetId3 = &imageAssetId3
	return r
}

// The id of the an offer asset
func (r ApiUpdateMediaRequest) ImageAssetId4(imageAssetId4 int64) ApiUpdateMediaRequest {
	r.imageAssetId4 = &imageAssetId4
	return r
}

// The id of the an offer asset
func (r ApiUpdateMediaRequest) ImageAssetId5(imageAssetId5 int64) ApiUpdateMediaRequest {
	r.imageAssetId5 = &imageAssetId5
	return r
}

// The maker of the item.
func (r ApiUpdateMediaRequest) Publisher(publisher string) ApiUpdateMediaRequest {
	r.publisher = &publisher
	return r
}

// The redeemable start date/time of the offer.
func (r ApiUpdateMediaRequest) RedeemableStart(redeemableStart int64) ApiUpdateMediaRequest {
	r.redeemableStart = &redeemableStart
	return r
}

// The redeemable start date/time of the offer.
func (r ApiUpdateMediaRequest) RedeemableEnd(redeemableEnd int64) ApiUpdateMediaRequest {
	r.redeemableEnd = &redeemableEnd
	return r
}

// The condition. OfferType PRODUCT only.
func (r ApiUpdateMediaRequest) ConditionType(conditionType string) ApiUpdateMediaRequest {
	r.conditionType = &conditionType
	return r
}

// The ISBN id. OfferType PRODUCT only.
func (r ApiUpdateMediaRequest) Isbn(isbn string) ApiUpdateMediaRequest {
	r.isbn = &isbn
	return r
}

// The ASIN id. OfferType PRODUCT only.
func (r ApiUpdateMediaRequest) Asin(asin string) ApiUpdateMediaRequest {
	r.asin = &asin
	return r
}

// The list of catelog numbers, comma seperated. OfferType PRODUCT only.
func (r ApiUpdateMediaRequest) CatalogNumbers(catalogNumbers string) ApiUpdateMediaRequest {
	r.catalogNumbers = &catalogNumbers
	return r
}

// The date available. OfferType PRODUCT only.
func (r ApiUpdateMediaRequest) AvailabilityDate(availabilityDate int64) ApiUpdateMediaRequest {
	r.availabilityDate = &availabilityDate
	return r
}

// The parental control rating. OfferType PRODUCT only.
func (r ApiUpdateMediaRequest) ParentalRating(parentalRating string) ApiUpdateMediaRequest {
	r.parentalRating = &parentalRating
	return r
}

// 
func (r ApiUpdateMediaRequest) MediaType(mediaType string) ApiUpdateMediaRequest {
	r.mediaType = &mediaType
	return r
}

// The total playing time of the media item. OfferType MEDIA only.
func (r ApiUpdateMediaRequest) Duration(duration int32) ApiUpdateMediaRequest {
	r.duration = &duration
	return r
}

// The created/author of the media item. OfferType MEDIA only.
func (r ApiUpdateMediaRequest) Author(author string) ApiUpdateMediaRequest {
	r.author = &author
	return r
}

// The date/time of when the media item was originally released. OfferType MEDIA only.
func (r ApiUpdateMediaRequest) ReleaseDate(releaseDate int64) ApiUpdateMediaRequest {
	r.releaseDate = &releaseDate
	return r
}

// 
func (r ApiUpdateMediaRequest) CollectionIds(collectionIds string) ApiUpdateMediaRequest {
	r.collectionIds = &collectionIds
	return r
}

// 
func (r ApiUpdateMediaRequest) Availability(availability string) ApiUpdateMediaRequest {
	r.availability = &availability
	return r
}

// 
func (r ApiUpdateMediaRequest) AvailabilitySummary(availabilitySummary string) ApiUpdateMediaRequest {
	r.availabilitySummary = &availabilitySummary
	return r
}

func (r ApiUpdateMediaRequest) Execute() (*MediaOfferResponse, *http.Response, error) {
	return r.ApiService.UpdateMediaExecute(r)
}

/*
UpdateMedia Update Media

Update a media offering.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateMediaRequest
*/
func (a *MediaAPIService) UpdateMedia(ctx context.Context, version float32) ApiUpdateMediaRequest {
	return ApiUpdateMediaRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return MediaOfferResponse
func (a *MediaAPIService) UpdateMediaExecute(r ApiUpdateMediaRequest) (*MediaOfferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MediaOfferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaAPIService.UpdateMedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/media/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.mediaId == nil {
		return localVarReturnValue, nil, reportError("mediaId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "mediaId", r.mediaId, "form", "")
	if r.retailerLocationIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationIds", r.retailerLocationIds, "form", "")
	}
	if r.offerLocations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocations", r.offerLocations, "form", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.subTitle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subTitle", r.subTitle, "form", "")
	}
	if r.details != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "details", r.details, "form", "")
	}
	if r.subDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subDetails", r.subDetails, "form", "")
	}
	if r.finePrint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finePrint", r.finePrint, "form", "")
	}
	if r.barcodeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "barcodeType", r.barcodeType, "form", "")
	}
	if r.barcodeEntry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "barcodeEntry", r.barcodeEntry, "form", "")
	}
	if r.externalRedeemOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalRedeemOptions", r.externalRedeemOptions, "form", "")
	}
	if r.externalUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalUrl", r.externalUrl, "form", "")
	}
	if r.ticketsRewardType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketsRewardType", r.ticketsRewardType, "form", "")
	}
	if r.ticketsReward != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketsReward", r.ticketsReward, "form", "")
	}
	if r.activated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activated", r.activated, "form", "")
	}
	if r.expires != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expires", r.expires, "form", "")
	}
	if r.noExpiration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noExpiration", r.noExpiration, "form", "")
	}
	if r.availableLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableLimit", r.availableLimit, "form", "")
	}
	if r.availableLimitPerUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availableLimitPerUser", r.availableLimitPerUser, "form", "")
	}
	if r.addedLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addedLimit", r.addedLimit, "form", "")
	}
	if r.viewLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewLimit", r.viewLimit, "form", "")
	}
	if r.maxPrints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxPrints", r.maxPrints, "form", "")
	}
	if r.ticketPriceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketPriceType", r.ticketPriceType, "form", "")
	}
	if r.ticketPrice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ticketPrice", r.ticketPrice, "form", "")
	}
	if r.fullPrice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fullPrice", r.fullPrice, "form", "")
	}
	if r.discountPrice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "discountPrice", r.discountPrice, "form", "")
	}
	if r.showRemaining != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showRemaining", r.showRemaining, "form", "")
	}
	if r.showRedeemed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showRedeemed", r.showRedeemed, "form", "")
	}
	if r.replaced != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "replaced", r.replaced, "form", "")
	}
	if r.featured != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "featured", r.featured, "form", "")
	}
	if r.specialOfferType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "specialOfferType", r.specialOfferType, "form", "")
	}
	if r.offerVisibility != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerVisibility", r.offerVisibility, "form", "")
	}
	if r.categoryIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categoryIds", r.categoryIds, "form", "")
	}
	if r.filterIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterIds", r.filterIds, "form", "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.barcodeAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "barcodeAssetId", r.barcodeAssetId, "form", "")
	}
	if r.imageAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId", r.imageAssetId, "form", "")
	}
	if r.imageAssetId1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId1", r.imageAssetId1, "form", "")
	}
	if r.imageAssetId2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId2", r.imageAssetId2, "form", "")
	}
	if r.imageAssetId3 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId3", r.imageAssetId3, "form", "")
	}
	if r.imageAssetId4 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId4", r.imageAssetId4, "form", "")
	}
	if r.imageAssetId5 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageAssetId5", r.imageAssetId5, "form", "")
	}
	if r.publisher != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publisher", r.publisher, "form", "")
	}
	if r.redeemableStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemableStart", r.redeemableStart, "form", "")
	}
	if r.redeemableEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemableEnd", r.redeemableEnd, "form", "")
	}
	if r.conditionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conditionType", r.conditionType, "form", "")
	}
	if r.isbn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isbn", r.isbn, "form", "")
	}
	if r.asin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asin", r.asin, "form", "")
	}
	if r.catalogNumbers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "catalogNumbers", r.catalogNumbers, "form", "")
	}
	if r.availabilityDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availabilityDate", r.availabilityDate, "form", "")
	}
	if r.parentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentalRating", r.parentalRating, "form", "")
	}
	if r.mediaType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaType", r.mediaType, "form", "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "form", "")
	}
	if r.author != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "author", r.author, "form", "")
	}
	if r.releaseDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "releaseDate", r.releaseDate, "form", "")
	}
	if r.collectionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "collectionIds", r.collectionIds, "form", "")
	}
	if r.availability != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availability", r.availability, "form", "")
	}
	if r.availabilitySummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availabilitySummary", r.availabilitySummary, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
