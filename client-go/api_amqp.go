/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// AMQPAPIService AMQPAPI service
type AMQPAPIService service

type ApiConsumerCreateRequest struct {
	ctx context.Context
	ApiService *AMQPAPIService
	appKey *string
	name *string
	hostname *string
	username *string
	password *string
	dataMapping *string
	deviceId *string
	accountId *int64
	port *int32
	virtualHost *string
	exchanger *string
	exchangerType *string
	workers *int32
	useSSL *bool
}

// The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
func (r ApiConsumerCreateRequest) AppKey(appKey string) ApiConsumerCreateRequest {
	r.appKey = &appKey
	return r
}

// The name of the queue to connect to
func (r ApiConsumerCreateRequest) Name(name string) ApiConsumerCreateRequest {
	r.name = &name
	return r
}

// The hostname of the server the queue is hosted on
func (r ApiConsumerCreateRequest) Hostname(hostname string) ApiConsumerCreateRequest {
	r.hostname = &hostname
	return r
}

// The username to access the server the queue is hosted on
func (r ApiConsumerCreateRequest) Username(username string) ApiConsumerCreateRequest {
	r.username = &username
	return r
}

// The password to access the queue to connect to
func (r ApiConsumerCreateRequest) Password(password string) ApiConsumerCreateRequest {
	r.password = &password
	return r
}

// The data mapping information in the format of AMQPRequest
func (r ApiConsumerCreateRequest) DataMapping(dataMapping string) ApiConsumerCreateRequest {
	r.dataMapping = &dataMapping
	return r
}

// The client deviceID
func (r ApiConsumerCreateRequest) DeviceId(deviceId string) ApiConsumerCreateRequest {
	r.deviceId = &deviceId
	return r
}

// The logged in user ID
func (r ApiConsumerCreateRequest) AccountId(accountId int64) ApiConsumerCreateRequest {
	r.accountId = &accountId
	return r
}

// The port of the server the queue is hosted on
func (r ApiConsumerCreateRequest) Port(port int32) ApiConsumerCreateRequest {
	r.port = &port
	return r
}

// The virtual host defined on the server the queue is associated on
func (r ApiConsumerCreateRequest) VirtualHost(virtualHost string) ApiConsumerCreateRequest {
	r.virtualHost = &virtualHost
	return r
}

// The exchanger of the queue to connect to
func (r ApiConsumerCreateRequest) Exchanger(exchanger string) ApiConsumerCreateRequest {
	r.exchanger = &exchanger
	return r
}

// The exchanger type of the queue to connect to
func (r ApiConsumerCreateRequest) ExchangerType(exchangerType string) ApiConsumerCreateRequest {
	r.exchangerType = &exchangerType
	return r
}

// The number of workers to generate 
func (r ApiConsumerCreateRequest) Workers(workers int32) ApiConsumerCreateRequest {
	r.workers = &workers
	return r
}

// Use SSL
func (r ApiConsumerCreateRequest) UseSSL(useSSL bool) ApiConsumerCreateRequest {
	r.useSSL = &useSSL
	return r
}

func (r ApiConsumerCreateRequest) Execute() (*QueueResponse, *http.Response, error) {
	return r.ApiService.ConsumerCreateExecute(r)
}

/*
ConsumerCreate Create Consumer

Create a connection to an existing amqp queue and register as a consumer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsumerCreateRequest
*/
func (a *AMQPAPIService) ConsumerCreate(ctx context.Context) ApiConsumerCreateRequest {
	return ApiConsumerCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueueResponse
func (a *AMQPAPIService) ConsumerCreateExecute(r ApiConsumerCreateRequest) (*QueueResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueueResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AMQPAPIService.ConsumerCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queue/consumer/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.hostname == nil {
		return localVarReturnValue, nil, reportError("hostname is required and must be specified")
	}
	if r.username == nil {
		return localVarReturnValue, nil, reportError("username is required and must be specified")
	}
	if r.password == nil {
		return localVarReturnValue, nil, reportError("password is required and must be specified")
	}
	if r.dataMapping == nil {
		return localVarReturnValue, nil, reportError("dataMapping is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "hostname", r.hostname, "form", "")
	if r.port != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port", r.port, "form", "")
	} else {
		var defaultValue int32 = 5672
		parameterAddToHeaderOrQuery(localVarQueryParams, "port", defaultValue, "form", "")
		r.port = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "password", r.password, "form", "")
	if r.virtualHost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "virtualHost", r.virtualHost, "form", "")
	}
	if r.exchanger != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchanger", r.exchanger, "form", "")
	}
	if r.exchangerType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchangerType", r.exchangerType, "form", "")
	}
	if r.workers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "workers", r.workers, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "workers", defaultValue, "form", "")
		r.workers = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "dataMapping", r.dataMapping, "form", "")
	if r.useSSL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useSSL", r.useSSL, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConsumerUpdateRequest struct {
	ctx context.Context
	ApiService *AMQPAPIService
	appKey *string
	queueId *int64
	dataMapping *string
	deviceId *string
	accountId *int64
	useSSL *bool
}

// The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
func (r ApiConsumerUpdateRequest) AppKey(appKey string) ApiConsumerUpdateRequest {
	r.appKey = &appKey
	return r
}

// The queue to update
func (r ApiConsumerUpdateRequest) QueueId(queueId int64) ApiConsumerUpdateRequest {
	r.queueId = &queueId
	return r
}

// The data mapping information in the format of AMQPRequest
func (r ApiConsumerUpdateRequest) DataMapping(dataMapping string) ApiConsumerUpdateRequest {
	r.dataMapping = &dataMapping
	return r
}

// The client deviceID
func (r ApiConsumerUpdateRequest) DeviceId(deviceId string) ApiConsumerUpdateRequest {
	r.deviceId = &deviceId
	return r
}

// The logged in user ID
func (r ApiConsumerUpdateRequest) AccountId(accountId int64) ApiConsumerUpdateRequest {
	r.accountId = &accountId
	return r
}

// Use SSL
func (r ApiConsumerUpdateRequest) UseSSL(useSSL bool) ApiConsumerUpdateRequest {
	r.useSSL = &useSSL
	return r
}

func (r ApiConsumerUpdateRequest) Execute() (*QueueResponse, *http.Response, error) {
	return r.ApiService.ConsumerUpdateExecute(r)
}

/*
ConsumerUpdate Update Consumer

Update an existing amqp queue's data mapping.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConsumerUpdateRequest
*/
func (a *AMQPAPIService) ConsumerUpdate(ctx context.Context) ApiConsumerUpdateRequest {
	return ApiConsumerUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueueResponse
func (a *AMQPAPIService) ConsumerUpdateExecute(r ApiConsumerUpdateRequest) (*QueueResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueueResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AMQPAPIService.ConsumerUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queue/consumer/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.queueId == nil {
		return localVarReturnValue, nil, reportError("queueId is required and must be specified")
	}
	if r.dataMapping == nil {
		return localVarReturnValue, nil, reportError("dataMapping is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "queueId", r.queueId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "dataMapping", r.dataMapping, "form", "")
	if r.useSSL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useSSL", r.useSSL, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueueCreateRequest struct {
	ctx context.Context
	ApiService *AMQPAPIService
	appKey *string
	name *string
	deviceId *string
	accountId *int64
	workers *int32
	analyticTags *string
	hostname *string
	port *int32
	username *string
	password *string
	virtualHost *string
	useSSL *bool
}

// The application key unique to each application.
func (r ApiQueueCreateRequest) AppKey(appKey string) ApiQueueCreateRequest {
	r.appKey = &appKey
	return r
}

// The name of the queue to create
func (r ApiQueueCreateRequest) Name(name string) ApiQueueCreateRequest {
	r.name = &name
	return r
}

// The client deviceID
func (r ApiQueueCreateRequest) DeviceId(deviceId string) ApiQueueCreateRequest {
	r.deviceId = &deviceId
	return r
}

// The logged in user ID
func (r ApiQueueCreateRequest) AccountId(accountId int64) ApiQueueCreateRequest {
	r.accountId = &accountId
	return r
}

// The number of workers to generate 
func (r ApiQueueCreateRequest) Workers(workers int32) ApiQueueCreateRequest {
	r.workers = &workers
	return r
}

// If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags
func (r ApiQueueCreateRequest) AnalyticTags(analyticTags string) ApiQueueCreateRequest {
	r.analyticTags = &analyticTags
	return r
}

// The hostname of the server the queue is hosted on
func (r ApiQueueCreateRequest) Hostname(hostname string) ApiQueueCreateRequest {
	r.hostname = &hostname
	return r
}

// The port of the server the queue is hosted on
func (r ApiQueueCreateRequest) Port(port int32) ApiQueueCreateRequest {
	r.port = &port
	return r
}

// The username to access the server that the queue is on
func (r ApiQueueCreateRequest) Username(username string) ApiQueueCreateRequest {
	r.username = &username
	return r
}

// The password to access the queue to connect to
func (r ApiQueueCreateRequest) Password(password string) ApiQueueCreateRequest {
	r.password = &password
	return r
}

// The virtual host defined on the server to queue
func (r ApiQueueCreateRequest) VirtualHost(virtualHost string) ApiQueueCreateRequest {
	r.virtualHost = &virtualHost
	return r
}

// Use SSL
func (r ApiQueueCreateRequest) UseSSL(useSSL bool) ApiQueueCreateRequest {
	r.useSSL = &useSSL
	return r
}

func (r ApiQueueCreateRequest) Execute() (*QueueResponse, *http.Response, error) {
	return r.ApiService.QueueCreateExecute(r)
}

/*
QueueCreate Create Queue

Create a basic AMQP queue. If the username and password and virtual host is not sepcified, the queue will be created on the virtual host assigned to the application.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueueCreateRequest
*/
func (a *AMQPAPIService) QueueCreate(ctx context.Context) ApiQueueCreateRequest {
	return ApiQueueCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueueResponse
func (a *AMQPAPIService) QueueCreateExecute(r ApiQueueCreateRequest) (*QueueResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueueResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AMQPAPIService.QueueCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queue/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	if r.workers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "workers", r.workers, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "workers", defaultValue, "form", "")
		r.workers = &defaultValue
	}
	if r.analyticTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyticTags", r.analyticTags, "form", "")
	}
	if r.hostname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hostname", r.hostname, "form", "")
	}
	if r.port != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port", r.port, "form", "")
	}
	if r.username != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "form", "")
	}
	if r.password != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "password", r.password, "form", "")
	}
	if r.virtualHost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "virtualHost", r.virtualHost, "form", "")
	}
	if r.useSSL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useSSL", r.useSSL, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueueDeleteRequest struct {
	ctx context.Context
	ApiService *AMQPAPIService
	queueId *int64
	deviceId *string
	accountId *int64
}

// The id of the queue to find
func (r ApiQueueDeleteRequest) QueueId(queueId int64) ApiQueueDeleteRequest {
	r.queueId = &queueId
	return r
}

// The client device ID
func (r ApiQueueDeleteRequest) DeviceId(deviceId string) ApiQueueDeleteRequest {
	r.deviceId = &deviceId
	return r
}

// The logged in user ID
func (r ApiQueueDeleteRequest) AccountId(accountId int64) ApiQueueDeleteRequest {
	r.accountId = &accountId
	return r
}

func (r ApiQueueDeleteRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.QueueDeleteExecute(r)
}

/*
QueueDelete Delete Queue

Delete the stored queue record and close any active connections to the AMQP servers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueueDeleteRequest
*/
func (a *AMQPAPIService) QueueDelete(ctx context.Context) ApiQueueDeleteRequest {
	return ApiQueueDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AMQPAPIService) QueueDeleteExecute(r ApiQueueDeleteRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AMQPAPIService.QueueDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queue/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queueId == nil {
		return localVarReturnValue, nil, reportError("queueId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "queueId", r.queueId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueueGetRequest struct {
	ctx context.Context
	ApiService *AMQPAPIService
	deviceId *string
	accountId *int64
	queueId *int64
	appKey *string
	name *string
	hostname *string
	virtualHost *string
}

// The client device ID
func (r ApiQueueGetRequest) DeviceId(deviceId string) ApiQueueGetRequest {
	r.deviceId = &deviceId
	return r
}

// The logged in user ID
func (r ApiQueueGetRequest) AccountId(accountId int64) ApiQueueGetRequest {
	r.accountId = &accountId
	return r
}

// The id of the queue to find
func (r ApiQueueGetRequest) QueueId(queueId int64) ApiQueueGetRequest {
	r.queueId = &queueId
	return r
}

// The application key the queue was assigned to
func (r ApiQueueGetRequest) AppKey(appKey string) ApiQueueGetRequest {
	r.appKey = &appKey
	return r
}

// The name of the queue to find
func (r ApiQueueGetRequest) Name(name string) ApiQueueGetRequest {
	r.name = &name
	return r
}

// The hostname of the queue to find
func (r ApiQueueGetRequest) Hostname(hostname string) ApiQueueGetRequest {
	r.hostname = &hostname
	return r
}

// The virtual host of the queue to find
func (r ApiQueueGetRequest) VirtualHost(virtualHost string) ApiQueueGetRequest {
	r.virtualHost = &virtualHost
	return r
}

func (r ApiQueueGetRequest) Execute() (*QueueResponse, *http.Response, error) {
	return r.ApiService.QueueGetExecute(r)
}

/*
QueueGet Get Queue

Get the stored queue record. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueueGetRequest
*/
func (a *AMQPAPIService) QueueGet(ctx context.Context) ApiQueueGetRequest {
	return ApiQueueGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueueResponse
func (a *AMQPAPIService) QueueGetExecute(r ApiQueueGetRequest) (*QueueResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueueResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AMQPAPIService.QueueGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queue/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.queueId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queueId", r.queueId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.hostname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hostname", r.hostname, "form", "")
	}
	if r.virtualHost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "virtualHost", r.virtualHost, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueuePublishRequest struct {
	ctx context.Context
	ApiService *AMQPAPIService
	message *string
	queueId *int64
	appKey *string
	name *string
	hostname *string
	virtualHost *string
}

// The payload to send to the queue
func (r ApiQueuePublishRequest) Message(message string) ApiQueuePublishRequest {
	r.message = &message
	return r
}

// The id of the queue to publish to
func (r ApiQueuePublishRequest) QueueId(queueId int64) ApiQueuePublishRequest {
	r.queueId = &queueId
	return r
}

// The application key the queue was assigned to
func (r ApiQueuePublishRequest) AppKey(appKey string) ApiQueuePublishRequest {
	r.appKey = &appKey
	return r
}

// The name of the queue to publish to or the analytic tag to handle if the analytic param is true
func (r ApiQueuePublishRequest) Name(name string) ApiQueuePublishRequest {
	r.name = &name
	return r
}

// The hostname of the server the queue is hosted on
func (r ApiQueuePublishRequest) Hostname(hostname string) ApiQueuePublishRequest {
	r.hostname = &hostname
	return r
}

// The virtual host defined on the server to queue
func (r ApiQueuePublishRequest) VirtualHost(virtualHost string) ApiQueuePublishRequest {
	r.virtualHost = &virtualHost
	return r
}

func (r ApiQueuePublishRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.QueuePublishExecute(r)
}

/*
QueuePublish Publish Queue

Publish a message to a stored queue. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueuePublishRequest
*/
func (a *AMQPAPIService) QueuePublish(ctx context.Context) ApiQueuePublishRequest {
	return ApiQueuePublishRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AMQPAPIService) QueuePublishExecute(r ApiQueuePublishRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AMQPAPIService.QueuePublish")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queue/publish"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.message == nil {
		return localVarReturnValue, nil, reportError("message is required and must be specified")
	}

	if r.queueId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queueId", r.queueId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.hostname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hostname", r.hostname, "form", "")
	}
	if r.virtualHost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "virtualHost", r.virtualHost, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "message", r.message, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueueSearchRequest struct {
	ctx context.Context
	ApiService *AMQPAPIService
	queueId *int64
	deviceId *string
	accountId *int64
	name *string
	start *int32
	limit *int32
}

// The id of the queue to find
func (r ApiQueueSearchRequest) QueueId(queueId int64) ApiQueueSearchRequest {
	r.queueId = &queueId
	return r
}

// The client device ID
func (r ApiQueueSearchRequest) DeviceId(deviceId string) ApiQueueSearchRequest {
	r.deviceId = &deviceId
	return r
}

// The logged in user ID
func (r ApiQueueSearchRequest) AccountId(accountId int64) ApiQueueSearchRequest {
	r.accountId = &accountId
	return r
}

// The name of the queue to find
func (r ApiQueueSearchRequest) Name(name string) ApiQueueSearchRequest {
	r.name = &name
	return r
}

// Start of the index
func (r ApiQueueSearchRequest) Start(start int32) ApiQueueSearchRequest {
	r.start = &start
	return r
}

// Limit of the index
func (r ApiQueueSearchRequest) Limit(limit int32) ApiQueueSearchRequest {
	r.limit = &limit
	return r
}

func (r ApiQueueSearchRequest) Execute() (*QueueResponse, *http.Response, error) {
	return r.ApiService.QueueSearchExecute(r)
}

/*
QueueSearch Search Queue

Get the queues setup for the BillableEntity's applications.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueueSearchRequest
*/
func (a *AMQPAPIService) QueueSearch(ctx context.Context) ApiQueueSearchRequest {
	return ApiQueueSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueueResponse
func (a *AMQPAPIService) QueueSearchExecute(r ApiQueueSearchRequest) (*QueueResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueueResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AMQPAPIService.QueueSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queue/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.queueId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queueId", r.queueId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 10
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueueUpdateRequest struct {
	ctx context.Context
	ApiService *AMQPAPIService
	queueId *int64
	deviceId *string
	accountId *int64
	appKey *string
	workers *int32
	analyticTags *string
	hostname *string
	port *int32
	username *string
	password *string
	virtualHost *string
	useSSL *bool
}

// The id of the queue to update
func (r ApiQueueUpdateRequest) QueueId(queueId int64) ApiQueueUpdateRequest {
	r.queueId = &queueId
	return r
}

// The client deviceID
func (r ApiQueueUpdateRequest) DeviceId(deviceId string) ApiQueueUpdateRequest {
	r.deviceId = &deviceId
	return r
}

// The logged in user ID
func (r ApiQueueUpdateRequest) AccountId(accountId int64) ApiQueueUpdateRequest {
	r.accountId = &accountId
	return r
}

// The application key unique to each application.
func (r ApiQueueUpdateRequest) AppKey(appKey string) ApiQueueUpdateRequest {
	r.appKey = &appKey
	return r
}

// The number of workers to generate
func (r ApiQueueUpdateRequest) Workers(workers int32) ApiQueueUpdateRequest {
	r.workers = &workers
	return r
}

// If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags
func (r ApiQueueUpdateRequest) AnalyticTags(analyticTags string) ApiQueueUpdateRequest {
	r.analyticTags = &analyticTags
	return r
}

// The hostname of the server the queue is hosted on
func (r ApiQueueUpdateRequest) Hostname(hostname string) ApiQueueUpdateRequest {
	r.hostname = &hostname
	return r
}

// The port of the server the queue is hosted on
func (r ApiQueueUpdateRequest) Port(port int32) ApiQueueUpdateRequest {
	r.port = &port
	return r
}

// The username to access the server that the queue is on
func (r ApiQueueUpdateRequest) Username(username string) ApiQueueUpdateRequest {
	r.username = &username
	return r
}

// The password to access the queue to connect to
func (r ApiQueueUpdateRequest) Password(password string) ApiQueueUpdateRequest {
	r.password = &password
	return r
}

// The virtual host defined on the server to queue
func (r ApiQueueUpdateRequest) VirtualHost(virtualHost string) ApiQueueUpdateRequest {
	r.virtualHost = &virtualHost
	return r
}

// the SSL to use
func (r ApiQueueUpdateRequest) UseSSL(useSSL bool) ApiQueueUpdateRequest {
	r.useSSL = &useSSL
	return r
}

func (r ApiQueueUpdateRequest) Execute() (*QueueResponse, *http.Response, error) {
	return r.ApiService.QueueUpdateExecute(r)
}

/*
QueueUpdate Update Queue

Update the basic AMQP queue.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueueUpdateRequest
*/
func (a *AMQPAPIService) QueueUpdate(ctx context.Context) ApiQueueUpdateRequest {
	return ApiQueueUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueueResponse
func (a *AMQPAPIService) QueueUpdateExecute(r ApiQueueUpdateRequest) (*QueueResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueueResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AMQPAPIService.QueueUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/queue/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queueId == nil {
		return localVarReturnValue, nil, reportError("queueId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "queueId", r.queueId, "form", "")
	if r.workers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "workers", r.workers, "form", "")
	}
	if r.analyticTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyticTags", r.analyticTags, "form", "")
	}
	if r.hostname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hostname", r.hostname, "form", "")
	}
	if r.port != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port", r.port, "form", "")
	}
	if r.username != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "form", "")
	}
	if r.password != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "password", r.password, "form", "")
	}
	if r.virtualHost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "virtualHost", r.virtualHost, "form", "")
	}
	if r.useSSL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useSSL", r.useSSL, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
