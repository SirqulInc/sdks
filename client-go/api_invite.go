/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// InviteAPIService InviteAPI service
type InviteAPIService service

type ApiAcceptInviteRequest struct {
	ctx context.Context
	ApiService *InviteAPIService
	version float32
	token *string
	accountId *int64
	albumId *int64
	missionId *int64
	albumContestId *int64
	offerId *int64
	offerLocationId *int64
	retailerLocationId *int64
	appKey *string
	autoFriend *bool
	autoAttendEvent *bool
	autoFavoriteOffer *bool
	autoFavoriteOfferLocation *bool
	autoFavoriteRetailerLocation *bool
}

// the invite token
func (r ApiAcceptInviteRequest) Token(token string) ApiAcceptInviteRequest {
	r.token = &token
	return r
}

// the accountId of the user who is accepting the invite
func (r ApiAcceptInviteRequest) AccountId(accountId int64) ApiAcceptInviteRequest {
	r.accountId = &accountId
	return r
}

// the album id associated with this invite (if applicable)
func (r ApiAcceptInviteRequest) AlbumId(albumId int64) ApiAcceptInviteRequest {
	r.albumId = &albumId
	return r
}

// the mission id associated with this invite (if applicable)
func (r ApiAcceptInviteRequest) MissionId(missionId int64) ApiAcceptInviteRequest {
	r.missionId = &missionId
	return r
}

// the album contest id associated with this invite (if applicable)
func (r ApiAcceptInviteRequest) AlbumContestId(albumContestId int64) ApiAcceptInviteRequest {
	r.albumContestId = &albumContestId
	return r
}

// the offer id associated with this invite (if applicable)
func (r ApiAcceptInviteRequest) OfferId(offerId int64) ApiAcceptInviteRequest {
	r.offerId = &offerId
	return r
}

// the offer location id associated with this invite (if applicable)
func (r ApiAcceptInviteRequest) OfferLocationId(offerLocationId int64) ApiAcceptInviteRequest {
	r.offerLocationId = &offerLocationId
	return r
}

// the retailer location id associated with this invite (if applicable)
func (r ApiAcceptInviteRequest) RetailerLocationId(retailerLocationId int64) ApiAcceptInviteRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// the application key
func (r ApiAcceptInviteRequest) AppKey(appKey string) ApiAcceptInviteRequest {
	r.appKey = &appKey
	return r
}

// whether to auto-friend the invite sender and receiver
func (r ApiAcceptInviteRequest) AutoFriend(autoFriend bool) ApiAcceptInviteRequest {
	r.autoFriend = &autoFriend
	return r
}

// whether to mark the event as attending automatically after invite is accepted
func (r ApiAcceptInviteRequest) AutoAttendEvent(autoAttendEvent bool) ApiAcceptInviteRequest {
	r.autoAttendEvent = &autoAttendEvent
	return r
}

// whether to mark the offer as favorited automatically after invite is accepted
func (r ApiAcceptInviteRequest) AutoFavoriteOffer(autoFavoriteOffer bool) ApiAcceptInviteRequest {
	r.autoFavoriteOffer = &autoFavoriteOffer
	return r
}

// whether to mark the offer location as favorited automatically after invite is accepted
func (r ApiAcceptInviteRequest) AutoFavoriteOfferLocation(autoFavoriteOfferLocation bool) ApiAcceptInviteRequest {
	r.autoFavoriteOfferLocation = &autoFavoriteOfferLocation
	return r
}

// whether to mark the retailer location as favorited automatically after invite is accepted
func (r ApiAcceptInviteRequest) AutoFavoriteRetailerLocation(autoFavoriteRetailerLocation bool) ApiAcceptInviteRequest {
	r.autoFavoriteRetailerLocation = &autoFavoriteRetailerLocation
	return r
}

func (r ApiAcceptInviteRequest) Execute() (*ConsumerInviteResponse, *http.Response, error) {
	return r.ApiService.AcceptInviteExecute(r)
}

/*
AcceptInvite Accept Invite

Allows a user to accept an invite. The user could also become the inviter's friend.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAcceptInviteRequest
*/
func (a *InviteAPIService) AcceptInvite(ctx context.Context, version float32) ApiAcceptInviteRequest {
	return ApiAcceptInviteRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ConsumerInviteResponse
func (a *InviteAPIService) AcceptInviteExecute(r ApiAcceptInviteRequest) (*ConsumerInviteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsumerInviteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InviteAPIService.AcceptInvite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/invite/accept"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.albumId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumId", r.albumId, "form", "")
	}
	if r.missionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	}
	if r.albumContestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumContestId", r.albumContestId, "form", "")
	}
	if r.offerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	}
	if r.offerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationId", r.offerLocationId, "form", "")
	}
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.autoFriend != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoFriend", r.autoFriend, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoFriend", defaultValue, "form", "")
		r.autoFriend = &defaultValue
	}
	if r.autoAttendEvent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoAttendEvent", r.autoAttendEvent, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoAttendEvent", defaultValue, "form", "")
		r.autoAttendEvent = &defaultValue
	}
	if r.autoFavoriteOffer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoFavoriteOffer", r.autoFavoriteOffer, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoFavoriteOffer", defaultValue, "form", "")
		r.autoFavoriteOffer = &defaultValue
	}
	if r.autoFavoriteOfferLocation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoFavoriteOfferLocation", r.autoFavoriteOfferLocation, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoFavoriteOfferLocation", defaultValue, "form", "")
		r.autoFavoriteOfferLocation = &defaultValue
	}
	if r.autoFavoriteRetailerLocation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoFavoriteRetailerLocation", r.autoFavoriteRetailerLocation, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoFavoriteRetailerLocation", defaultValue, "form", "")
		r.autoFavoriteRetailerLocation = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlbumContestInviteRequest struct {
	ctx context.Context
	ApiService *InviteAPIService
	version float32
	deviceId *string
	accountId *int64
	appId *int64
	appKey *string
	albumContestId *int64
	latitude *float64
	longitude *float64
}

// a unique ID given by the device (deviceId or accountId required)
func (r ApiAlbumContestInviteRequest) DeviceId(deviceId string) ApiAlbumContestInviteRequest {
	r.deviceId = &deviceId
	return r
}

// the account ID of the user (deviceId or accountId required)
func (r ApiAlbumContestInviteRequest) AccountId(accountId int64) ApiAlbumContestInviteRequest {
	r.accountId = &accountId
	return r
}

// This parameter is deprecated.
func (r ApiAlbumContestInviteRequest) AppId(appId int64) ApiAlbumContestInviteRequest {
	r.appId = &appId
	return r
}

// the application key
func (r ApiAlbumContestInviteRequest) AppKey(appKey string) ApiAlbumContestInviteRequest {
	r.appKey = &appKey
	return r
}

// the album contest to share
func (r ApiAlbumContestInviteRequest) AlbumContestId(albumContestId int64) ApiAlbumContestInviteRequest {
	r.albumContestId = &albumContestId
	return r
}

// the current latitude of the user
func (r ApiAlbumContestInviteRequest) Latitude(latitude float64) ApiAlbumContestInviteRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiAlbumContestInviteRequest) Longitude(longitude float64) ApiAlbumContestInviteRequest {
	r.longitude = &longitude
	return r
}

func (r ApiAlbumContestInviteRequest) Execute() (*InviteResponse, *http.Response, error) {
	return r.ApiService.AlbumContestInviteExecute(r)
}

/*
AlbumContestInvite Invite to Contest

Allows a user to invite people to gain access to a contest. This will generate an invite token, which when used, will give the invitee access to a contest (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAlbumContestInviteRequest
*/
func (a *InviteAPIService) AlbumContestInvite(ctx context.Context, version float32) ApiAlbumContestInviteRequest {
	return ApiAlbumContestInviteRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return InviteResponse
func (a *InviteAPIService) AlbumContestInviteExecute(r ApiAlbumContestInviteRequest) (*InviteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InviteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InviteAPIService.AlbumContestInvite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/invite/albumContest"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appId", r.appId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.albumContestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumContestId", r.albumContestId, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlbumInviteRequest struct {
	ctx context.Context
	ApiService *InviteAPIService
	version float32
	deviceId *string
	accountId *int64
	appId *int64
	appKey *string
	albumId *int64
	latitude *float64
	longitude *float64
}

// a unique ID given by the device (deviceId or accountId required)
func (r ApiAlbumInviteRequest) DeviceId(deviceId string) ApiAlbumInviteRequest {
	r.deviceId = &deviceId
	return r
}

// the account ID of the user (deviceId or accountId required)
func (r ApiAlbumInviteRequest) AccountId(accountId int64) ApiAlbumInviteRequest {
	r.accountId = &accountId
	return r
}

// This parameter is deprecated.
func (r ApiAlbumInviteRequest) AppId(appId int64) ApiAlbumInviteRequest {
	r.appId = &appId
	return r
}

// the application key
func (r ApiAlbumInviteRequest) AppKey(appKey string) ApiAlbumInviteRequest {
	r.appKey = &appKey
	return r
}

// the album to share
func (r ApiAlbumInviteRequest) AlbumId(albumId int64) ApiAlbumInviteRequest {
	r.albumId = &albumId
	return r
}

// the current latitude of the user
func (r ApiAlbumInviteRequest) Latitude(latitude float64) ApiAlbumInviteRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiAlbumInviteRequest) Longitude(longitude float64) ApiAlbumInviteRequest {
	r.longitude = &longitude
	return r
}

func (r ApiAlbumInviteRequest) Execute() (*InviteResponse, *http.Response, error) {
	return r.ApiService.AlbumInviteExecute(r)
}

/*
AlbumInvite Invite to Collection

Allows a user to invite people to gain access to a collection. This will generate an invite token, which when used, will give the invitee access to a collection (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAlbumInviteRequest
*/
func (a *InviteAPIService) AlbumInvite(ctx context.Context, version float32) ApiAlbumInviteRequest {
	return ApiAlbumInviteRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return InviteResponse
func (a *InviteAPIService) AlbumInviteExecute(r ApiAlbumInviteRequest) (*InviteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InviteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InviteAPIService.AlbumInvite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/invite/album"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appId", r.appId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.albumId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumId", r.albumId, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventInviteRequest struct {
	ctx context.Context
	ApiService *InviteAPIService
	version float32
	accountId *int64
	appKey *string
	listingId *int64
	receiverAccountIds *string
	retailerLocationId *int64
}

// the account ID of the user making the share
func (r ApiEventInviteRequest) AccountId(accountId int64) ApiEventInviteRequest {
	r.accountId = &accountId
	return r
}

// the application key
func (r ApiEventInviteRequest) AppKey(appKey string) ApiEventInviteRequest {
	r.appKey = &appKey
	return r
}

// The ID of the event listing
func (r ApiEventInviteRequest) ListingId(listingId int64) ApiEventInviteRequest {
	r.listingId = &listingId
	return r
}

// the account ID of a Sirqul user they would like to share an event with
func (r ApiEventInviteRequest) ReceiverAccountIds(receiverAccountIds string) ApiEventInviteRequest {
	r.receiverAccountIds = &receiverAccountIds
	return r
}

// The retailer location id of where the event will take place
func (r ApiEventInviteRequest) RetailerLocationId(retailerLocationId int64) ApiEventInviteRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

func (r ApiEventInviteRequest) Execute() (*InviteResponse, *http.Response, error) {
	return r.ApiService.EventInviteExecute(r)
}

/*
EventInvite Invite to Event

Allows a user to invite people to attend an event. This will generate an invite token, which when used, will allow the invitee to add the offer to their wallet.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiEventInviteRequest
*/
func (a *InviteAPIService) EventInvite(ctx context.Context, version float32) ApiEventInviteRequest {
	return ApiEventInviteRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return InviteResponse
func (a *InviteAPIService) EventInviteExecute(r ApiEventInviteRequest) (*InviteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InviteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InviteAPIService.EventInvite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/invite/event"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.listingId == nil {
		return localVarReturnValue, nil, reportError("listingId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.receiverAccountIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "receiverAccountIds", r.receiverAccountIds, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "listingId", r.listingId, "form", "")
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGameInviteRequest struct {
	ctx context.Context
	ApiService *InviteAPIService
	version float32
	deviceId *string
	accountId *int64
	appId *int64
	appKey *string
	gameLevelId *int64
	latitude *float64
	longitude *float64
}

// a unique ID given by the device (deviceId or accountId required)
func (r ApiGameInviteRequest) DeviceId(deviceId string) ApiGameInviteRequest {
	r.deviceId = &deviceId
	return r
}

// the account ID of the user (deviceId or accountId required)
func (r ApiGameInviteRequest) AccountId(accountId int64) ApiGameInviteRequest {
	r.accountId = &accountId
	return r
}

// This parameter is deprecated.
func (r ApiGameInviteRequest) AppId(appId int64) ApiGameInviteRequest {
	r.appId = &appId
	return r
}

// the application key
func (r ApiGameInviteRequest) AppKey(appKey string) ApiGameInviteRequest {
	r.appKey = &appKey
	return r
}

// the game level that the user owns and is giving access to
func (r ApiGameInviteRequest) GameLevelId(gameLevelId int64) ApiGameInviteRequest {
	r.gameLevelId = &gameLevelId
	return r
}

// the current latitude of the user
func (r ApiGameInviteRequest) Latitude(latitude float64) ApiGameInviteRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiGameInviteRequest) Longitude(longitude float64) ApiGameInviteRequest {
	r.longitude = &longitude
	return r
}

func (r ApiGameInviteRequest) Execute() (*InviteResponse, *http.Response, error) {
	return r.ApiService.GameInviteExecute(r)
}

/*
GameInvite Invite to Game Level

Allows a user to invite people to gain access to an album. This will generate an invite token, which when used, will give the invitee access to an album (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGameInviteRequest
*/
func (a *InviteAPIService) GameInvite(ctx context.Context, version float32) ApiGameInviteRequest {
	return ApiGameInviteRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return InviteResponse
func (a *InviteAPIService) GameInviteExecute(r ApiGameInviteRequest) (*InviteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InviteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InviteAPIService.GameInvite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/invite/gameLevel"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appId", r.appId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.gameLevelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gameLevelId", r.gameLevelId, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInviteRequest struct {
	ctx context.Context
	ApiService *InviteAPIService
	version float32
	accountId *int64
	token *string
	albumId *int64
	missionId *int64
	albumContestId *int64
	offerId *int64
	offerLocationId *int64
	retailerLocationId *int64
	appKey *string
}

// Account ID of the user if they are logged in
func (r ApiGetInviteRequest) AccountId(accountId int64) ApiGetInviteRequest {
	r.accountId = &accountId
	return r
}

// the invite token
func (r ApiGetInviteRequest) Token(token string) ApiGetInviteRequest {
	r.token = &token
	return r
}

// album id to match the invite against (if applicable)
func (r ApiGetInviteRequest) AlbumId(albumId int64) ApiGetInviteRequest {
	r.albumId = &albumId
	return r
}

// mission id to match the invite against (if applicable)
func (r ApiGetInviteRequest) MissionId(missionId int64) ApiGetInviteRequest {
	r.missionId = &missionId
	return r
}

// album contest id to match the invite against (if applicable)
func (r ApiGetInviteRequest) AlbumContestId(albumContestId int64) ApiGetInviteRequest {
	r.albumContestId = &albumContestId
	return r
}

// offer id to match the invite against (if applicable)
func (r ApiGetInviteRequest) OfferId(offerId int64) ApiGetInviteRequest {
	r.offerId = &offerId
	return r
}

// offer location id to match the invite against (if applicable)
func (r ApiGetInviteRequest) OfferLocationId(offerLocationId int64) ApiGetInviteRequest {
	r.offerLocationId = &offerLocationId
	return r
}

// retailer location id to match the invite against (if applicable)
func (r ApiGetInviteRequest) RetailerLocationId(retailerLocationId int64) ApiGetInviteRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// the application key
func (r ApiGetInviteRequest) AppKey(appKey string) ApiGetInviteRequest {
	r.appKey = &appKey
	return r
}

func (r ApiGetInviteRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.GetInviteExecute(r)
}

/*
GetInvite Get Invite

This is used to determine whether an invite token is valid. If the token is valid, this will also return information about who invited the user, and what they are invited to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetInviteRequest
*/
func (a *InviteAPIService) GetInvite(ctx context.Context, version float32) ApiGetInviteRequest {
	return ApiGetInviteRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *InviteAPIService) GetInviteExecute(r ApiGetInviteRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InviteAPIService.GetInvite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/invite/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	}
	if r.albumId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumId", r.albumId, "form", "")
	}
	if r.missionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	}
	if r.albumContestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumContestId", r.albumContestId, "form", "")
	}
	if r.offerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	}
	if r.offerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationId", r.offerLocationId, "form", "")
	}
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMissionInviteRequest struct {
	ctx context.Context
	ApiService *InviteAPIService
	version float32
	deviceId *string
	accountId *int64
	appId *int64
	appKey *string
	missionId *int64
	latitude *float64
	longitude *float64
}

// a unique ID given by the device (deviceId or accountId required)
func (r ApiMissionInviteRequest) DeviceId(deviceId string) ApiMissionInviteRequest {
	r.deviceId = &deviceId
	return r
}

// the account ID of the user (deviceId or accountId required)
func (r ApiMissionInviteRequest) AccountId(accountId int64) ApiMissionInviteRequest {
	r.accountId = &accountId
	return r
}

// This parameter is deprecated.
func (r ApiMissionInviteRequest) AppId(appId int64) ApiMissionInviteRequest {
	r.appId = &appId
	return r
}

// the application key
func (r ApiMissionInviteRequest) AppKey(appKey string) ApiMissionInviteRequest {
	r.appKey = &appKey
	return r
}

// the mission to share
func (r ApiMissionInviteRequest) MissionId(missionId int64) ApiMissionInviteRequest {
	r.missionId = &missionId
	return r
}

// the current latitude of the user
func (r ApiMissionInviteRequest) Latitude(latitude float64) ApiMissionInviteRequest {
	r.latitude = &latitude
	return r
}

// the current longitude of the user
func (r ApiMissionInviteRequest) Longitude(longitude float64) ApiMissionInviteRequest {
	r.longitude = &longitude
	return r
}

func (r ApiMissionInviteRequest) Execute() (*InviteResponse, *http.Response, error) {
	return r.ApiService.MissionInviteExecute(r)
}

/*
MissionInvite Invite to Mission

Allows a user to invite people to gain access to a mission. This will generate an invite token, which when used, will give the invitee access to a mission (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiMissionInviteRequest
*/
func (a *InviteAPIService) MissionInvite(ctx context.Context, version float32) ApiMissionInviteRequest {
	return ApiMissionInviteRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return InviteResponse
func (a *InviteAPIService) MissionInviteExecute(r ApiMissionInviteRequest) (*InviteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InviteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InviteAPIService.MissionInvite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/invite/mission"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.appId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appId", r.appId, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.missionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "missionId", r.missionId, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOfferInviteRequest struct {
	ctx context.Context
	ApiService *InviteAPIService
	version float32
	accountId *int64
	appKey *string
	offerId *int64
}

// the account ID of the user making the share
func (r ApiOfferInviteRequest) AccountId(accountId int64) ApiOfferInviteRequest {
	r.accountId = &accountId
	return r
}

// the application key
func (r ApiOfferInviteRequest) AppKey(appKey string) ApiOfferInviteRequest {
	r.appKey = &appKey
	return r
}

// the ID of the offer used to invite to favorite
func (r ApiOfferInviteRequest) OfferId(offerId int64) ApiOfferInviteRequest {
	r.offerId = &offerId
	return r
}

func (r ApiOfferInviteRequest) Execute() (*InviteResponse, *http.Response, error) {
	return r.ApiService.OfferInviteExecute(r)
}

/*
OfferInvite Invite to Offer

Allows a user to invite people to favorite an offer. This will generate an invite token, which when used, will give the invitee the offer in their favorite's list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiOfferInviteRequest
*/
func (a *InviteAPIService) OfferInvite(ctx context.Context, version float32) ApiOfferInviteRequest {
	return ApiOfferInviteRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return InviteResponse
func (a *InviteAPIService) OfferInviteExecute(r ApiOfferInviteRequest) (*InviteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InviteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InviteAPIService.OfferInvite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/invite/offer"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.offerId == nil {
		return localVarReturnValue, nil, reportError("offerId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOfferLocationInviteRequest struct {
	ctx context.Context
	ApiService *InviteAPIService
	version float32
	accountId *int64
	appKey *string
	offerLocationId *int64
}

// the account ID of the user making the share
func (r ApiOfferLocationInviteRequest) AccountId(accountId int64) ApiOfferLocationInviteRequest {
	r.accountId = &accountId
	return r
}

// the application key
func (r ApiOfferLocationInviteRequest) AppKey(appKey string) ApiOfferLocationInviteRequest {
	r.appKey = &appKey
	return r
}

// the id of the offer location to share
func (r ApiOfferLocationInviteRequest) OfferLocationId(offerLocationId int64) ApiOfferLocationInviteRequest {
	r.offerLocationId = &offerLocationId
	return r
}

func (r ApiOfferLocationInviteRequest) Execute() (*InviteResponse, *http.Response, error) {
	return r.ApiService.OfferLocationInviteExecute(r)
}

/*
OfferLocationInvite Invite to Offer Location

Allows a user to invite people to favorite an offer location. This will generate an invite token, which when used, will give the invitee the offer location in their favorite's list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiOfferLocationInviteRequest
*/
func (a *InviteAPIService) OfferLocationInvite(ctx context.Context, version float32) ApiOfferLocationInviteRequest {
	return ApiOfferLocationInviteRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return InviteResponse
func (a *InviteAPIService) OfferLocationInviteExecute(r ApiOfferLocationInviteRequest) (*InviteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InviteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InviteAPIService.OfferLocationInvite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/invite/offerLocation"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.offerLocationId == nil {
		return localVarReturnValue, nil, reportError("offerLocationId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "offerLocationId", r.offerLocationId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetailerLocationInviteRequest struct {
	ctx context.Context
	ApiService *InviteAPIService
	version float32
	accountId *int64
	appKey *string
	retailerLocationId *int64
	albumId *int64
}

// the account ID of the user making the share
func (r ApiRetailerLocationInviteRequest) AccountId(accountId int64) ApiRetailerLocationInviteRequest {
	r.accountId = &accountId
	return r
}

// the application key
func (r ApiRetailerLocationInviteRequest) AppKey(appKey string) ApiRetailerLocationInviteRequest {
	r.appKey = &appKey
	return r
}

// The retailer location id of where the event will take place
func (r ApiRetailerLocationInviteRequest) RetailerLocationId(retailerLocationId int64) ApiRetailerLocationInviteRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// Optional album id to link with the invite
func (r ApiRetailerLocationInviteRequest) AlbumId(albumId int64) ApiRetailerLocationInviteRequest {
	r.albumId = &albumId
	return r
}

func (r ApiRetailerLocationInviteRequest) Execute() (*InviteResponse, *http.Response, error) {
	return r.ApiService.RetailerLocationInviteExecute(r)
}

/*
RetailerLocationInvite Invite to Retailer Location

Allows a user to invite people to favorite a retailer location. This will generate an invite token, which when used, will give the invitee the retailer location in their favorite's list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiRetailerLocationInviteRequest
*/
func (a *InviteAPIService) RetailerLocationInvite(ctx context.Context, version float32) ApiRetailerLocationInviteRequest {
	return ApiRetailerLocationInviteRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return InviteResponse
func (a *InviteAPIService) RetailerLocationInviteExecute(r ApiRetailerLocationInviteRequest) (*InviteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InviteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InviteAPIService.RetailerLocationInvite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/invite/retailerLocation"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.retailerLocationId == nil {
		return localVarReturnValue, nil, reportError("retailerLocationId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	if r.albumId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumId", r.albumId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
