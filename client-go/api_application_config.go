/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ApplicationConfigAPIService ApplicationConfigAPI service
type ApplicationConfigAPIService service

type ApiCreateApplicationConfigRequest struct {
	ctx context.Context
	ApiService *ApplicationConfigAPIService
	version float32
	accountId *int64
	appKey *string
	configVersion *string
	assetId *int64
	retailerId *int64
	retailerLocationId *int64
	udid *string
}

// The account ID of the user
func (r ApiCreateApplicationConfigRequest) AccountId(accountId int64) ApiCreateApplicationConfigRequest {
	r.accountId = &accountId
	return r
}

// The application key that the newly created applicationConfig will be associated to
func (r ApiCreateApplicationConfigRequest) AppKey(appKey string) ApiCreateApplicationConfigRequest {
	r.appKey = &appKey
	return r
}

// The application configuration, has to be unique within the application
func (r ApiCreateApplicationConfigRequest) ConfigVersion(configVersion string) ApiCreateApplicationConfigRequest {
	r.configVersion = &configVersion
	return r
}

// The json assetId that stores the configuration detail.
func (r ApiCreateApplicationConfigRequest) AssetId(assetId int64) ApiCreateApplicationConfigRequest {
	r.assetId = &assetId
	return r
}

// The retailer id for retailer specific configurations
func (r ApiCreateApplicationConfigRequest) RetailerId(retailerId int64) ApiCreateApplicationConfigRequest {
	r.retailerId = &retailerId
	return r
}

// The retailer location id for retailer location specific configurations
func (r ApiCreateApplicationConfigRequest) RetailerLocationId(retailerLocationId int64) ApiCreateApplicationConfigRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// The device udid for device specific configurations
func (r ApiCreateApplicationConfigRequest) Udid(udid string) ApiCreateApplicationConfigRequest {
	r.udid = &udid
	return r
}

func (r ApiCreateApplicationConfigRequest) Execute() (*ApplicationConfigResponse, *http.Response, error) {
	return r.ApiService.CreateApplicationConfigExecute(r)
}

/*
CreateApplicationConfig Create AppConfig

Creates a new application configuration. If the configVersion provided already exists for the given app, an invalid response is returned and the application configuration won't be created.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateApplicationConfigRequest
*/
func (a *ApplicationConfigAPIService) CreateApplicationConfig(ctx context.Context, version float32) ApiCreateApplicationConfigRequest {
	return ApiCreateApplicationConfigRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ApplicationConfigResponse
func (a *ApplicationConfigAPIService) CreateApplicationConfigExecute(r ApiCreateApplicationConfigRequest) (*ApplicationConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationConfigResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationConfigAPIService.CreateApplicationConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/appconfig/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.configVersion == nil {
		return localVarReturnValue, nil, reportError("configVersion is required and must be specified")
	}
	if r.assetId == nil {
		return localVarReturnValue, nil, reportError("assetId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "configVersion", r.configVersion, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "form", "")
	if r.retailerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerId", r.retailerId, "form", "")
	}
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	if r.udid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udid", r.udid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteApplicationConfigRequest struct {
	ctx context.Context
	ApiService *ApplicationConfigAPIService
	version float32
	accountId *int64
	configId *int64
}

// The account ID of the user
func (r ApiDeleteApplicationConfigRequest) AccountId(accountId int64) ApiDeleteApplicationConfigRequest {
	r.accountId = &accountId
	return r
}

// The config ID of the application configuration to delete
func (r ApiDeleteApplicationConfigRequest) ConfigId(configId int64) ApiDeleteApplicationConfigRequest {
	r.configId = &configId
	return r
}

func (r ApiDeleteApplicationConfigRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteApplicationConfigExecute(r)
}

/*
DeleteApplicationConfig Delete AppConfig

Mark the application configuration for deletion.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteApplicationConfigRequest
*/
func (a *ApplicationConfigAPIService) DeleteApplicationConfig(ctx context.Context, version float32) ApiDeleteApplicationConfigRequest {
	return ApiDeleteApplicationConfigRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *ApplicationConfigAPIService) DeleteApplicationConfigExecute(r ApiDeleteApplicationConfigRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationConfigAPIService.DeleteApplicationConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/appconfig/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.configId == nil {
		return localVarReturnValue, nil, reportError("configId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "configId", r.configId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationConfigRequest struct {
	ctx context.Context
	ApiService *ApplicationConfigAPIService
	version float32
	accountId *int64
	configId *int64
}

// The account ID of the user
func (r ApiGetApplicationConfigRequest) AccountId(accountId int64) ApiGetApplicationConfigRequest {
	r.accountId = &accountId
	return r
}

// The config ID of the application configuration
func (r ApiGetApplicationConfigRequest) ConfigId(configId int64) ApiGetApplicationConfigRequest {
	r.configId = &configId
	return r
}

func (r ApiGetApplicationConfigRequest) Execute() (*ApplicationConfigResponse, *http.Response, error) {
	return r.ApiService.GetApplicationConfigExecute(r)
}

/*
GetApplicationConfig Get AppConfig

Gets the appConfig data by the given configId. If appConfig cannot be found, it returns an invalid response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetApplicationConfigRequest
*/
func (a *ApplicationConfigAPIService) GetApplicationConfig(ctx context.Context, version float32) ApiGetApplicationConfigRequest {
	return ApiGetApplicationConfigRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ApplicationConfigResponse
func (a *ApplicationConfigAPIService) GetApplicationConfigExecute(r ApiGetApplicationConfigRequest) (*ApplicationConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationConfigResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationConfigAPIService.GetApplicationConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/appconfig/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.configId == nil {
		return localVarReturnValue, nil, reportError("configId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "configId", r.configId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationConfigByConfigVersionRequest struct {
	ctx context.Context
	ApiService *ApplicationConfigAPIService
	version float32
	appKey *string
	configVersion *string
	retailerId *int64
	retailerLocationId *int64
	udid *string
	allowOlderVersions *bool
}

// The application key
func (r ApiGetApplicationConfigByConfigVersionRequest) AppKey(appKey string) ApiGetApplicationConfigByConfigVersionRequest {
	r.appKey = &appKey
	return r
}

// The version of the application configuration
func (r ApiGetApplicationConfigByConfigVersionRequest) ConfigVersion(configVersion string) ApiGetApplicationConfigByConfigVersionRequest {
	r.configVersion = &configVersion
	return r
}

// Only returns the config that matches the given retailer
func (r ApiGetApplicationConfigByConfigVersionRequest) RetailerId(retailerId int64) ApiGetApplicationConfigByConfigVersionRequest {
	r.retailerId = &retailerId
	return r
}

// Only returns the config that matches the given retailer location
func (r ApiGetApplicationConfigByConfigVersionRequest) RetailerLocationId(retailerLocationId int64) ApiGetApplicationConfigByConfigVersionRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// Only returns only returns the config that matches the given device udid
func (r ApiGetApplicationConfigByConfigVersionRequest) Udid(udid string) ApiGetApplicationConfigByConfigVersionRequest {
	r.udid = &udid
	return r
}

// Determines whether to return older config versions if the exact version is not found. If this happens, will try to return the latest version.
func (r ApiGetApplicationConfigByConfigVersionRequest) AllowOlderVersions(allowOlderVersions bool) ApiGetApplicationConfigByConfigVersionRequest {
	r.allowOlderVersions = &allowOlderVersions
	return r
}

func (r ApiGetApplicationConfigByConfigVersionRequest) Execute() (*ApplicationConfigResponse, *http.Response, error) {
	return r.ApiService.GetApplicationConfigByConfigVersionExecute(r)
}

/*
GetApplicationConfigByConfigVersion Get AppConfig by Version

Gets the appConfig data by the given appKey and app configVersion number.If the appKey is is invalid or appConfig is not found, it returns an invalid response. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetApplicationConfigByConfigVersionRequest
*/
func (a *ApplicationConfigAPIService) GetApplicationConfigByConfigVersion(ctx context.Context, version float32) ApiGetApplicationConfigByConfigVersionRequest {
	return ApiGetApplicationConfigByConfigVersionRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ApplicationConfigResponse
func (a *ApplicationConfigAPIService) GetApplicationConfigByConfigVersionExecute(r ApiGetApplicationConfigByConfigVersionRequest) (*ApplicationConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationConfigResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationConfigAPIService.GetApplicationConfigByConfigVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/appconfig/getbyversion"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appKey == nil {
		return localVarReturnValue, nil, reportError("appKey is required and must be specified")
	}
	if r.configVersion == nil {
		return localVarReturnValue, nil, reportError("configVersion is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "configVersion", r.configVersion, "form", "")
	if r.retailerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerId", r.retailerId, "form", "")
	}
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	if r.udid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udid", r.udid, "form", "")
	}
	if r.allowOlderVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowOlderVersions", r.allowOlderVersions, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowOlderVersions", defaultValue, "form", "")
		r.allowOlderVersions = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchApplicationConfigRequest struct {
	ctx context.Context
	ApiService *ApplicationConfigAPIService
	version float32
	accountId *int64
	appKey *string
	retailerId *int64
	retailerLocationId *int64
	udid *string
	configVersion *string
	sortField *string
	descending *bool
	start *int32
	limit *int32
}

// The account ID of the user
func (r ApiSearchApplicationConfigRequest) AccountId(accountId int64) ApiSearchApplicationConfigRequest {
	r.accountId = &accountId
	return r
}

// The application key to filter results by application Leaving this empty will return all application configurations for all applications (executive user only)
func (r ApiSearchApplicationConfigRequest) AppKey(appKey string) ApiSearchApplicationConfigRequest {
	r.appKey = &appKey
	return r
}

// Only returns the configs that matches the given retailer
func (r ApiSearchApplicationConfigRequest) RetailerId(retailerId int64) ApiSearchApplicationConfigRequest {
	r.retailerId = &retailerId
	return r
}

// Only returns the configs that matches the given retailer location
func (r ApiSearchApplicationConfigRequest) RetailerLocationId(retailerLocationId int64) ApiSearchApplicationConfigRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// Only returns only returns the configs that matches the given device udid
func (r ApiSearchApplicationConfigRequest) Udid(udid string) ApiSearchApplicationConfigRequest {
	r.udid = &udid
	return r
}

// Config Version
func (r ApiSearchApplicationConfigRequest) ConfigVersion(configVersion string) ApiSearchApplicationConfigRequest {
	r.configVersion = &configVersion
	return r
}

// Orders the results by: CREATED, UPDATED, ACTIVE, APPLICATION_ID,  APPLICATION_KEY, APPLICATION_NAME, RETAILER_NAME, RETAILER_ID, RETAILER_LOCATION_NAME,  RETAILER_LOCATION_ID, OFFER_TITLE, OFFER_ID, OFFER_LOCATION_ID, CONFIG_VERSION_MINOR,  CONFIG_VERSION_MAJOR, CONFIG_VERSION_INDEX 
func (r ApiSearchApplicationConfigRequest) SortField(sortField string) ApiSearchApplicationConfigRequest {
	r.sortField = &sortField
	return r
}

// Determines whether the results are in descending or ascending order
func (r ApiSearchApplicationConfigRequest) Descending(descending bool) ApiSearchApplicationConfigRequest {
	r.descending = &descending
	return r
}

// The start index for pagination
func (r ApiSearchApplicationConfigRequest) Start(start int32) ApiSearchApplicationConfigRequest {
	r.start = &start
	return r
}

// The limit for pagination (There is a hard limit of 100)
func (r ApiSearchApplicationConfigRequest) Limit(limit int32) ApiSearchApplicationConfigRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchApplicationConfigRequest) Execute() ([]ApplicationConfigResponse, *http.Response, error) {
	return r.ApiService.SearchApplicationConfigExecute(r)
}

/*
SearchApplicationConfig Search AppConfigs

Gets all versions of application configurations in a particular app by the given appKey.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchApplicationConfigRequest
*/
func (a *ApplicationConfigAPIService) SearchApplicationConfig(ctx context.Context, version float32) ApiSearchApplicationConfigRequest {
	return ApiSearchApplicationConfigRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []ApplicationConfigResponse
func (a *ApplicationConfigAPIService) SearchApplicationConfigExecute(r ApiSearchApplicationConfigRequest) ([]ApplicationConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApplicationConfigResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationConfigAPIService.SearchApplicationConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/appconfig/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.retailerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerId", r.retailerId, "form", "")
	}
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	if r.udid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udid", r.udid, "form", "")
	}
	if r.configVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configVersion", r.configVersion, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	} else {
		var defaultValue string = "CONFIG_VERSION_INDEX"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", defaultValue, "form", "")
		r.sortField = &defaultValue
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", defaultValue, "form", "")
		r.descending = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", defaultValue, "form", "")
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateApplicationConfigRequest struct {
	ctx context.Context
	ApiService *ApplicationConfigAPIService
	version float32
	accountId *int64
	configId *int64
	appKey *string
	configVersion *string
	assetId *int64
	retailerId *int64
	retailerLocationId *int64
	udid *string
}

// The account ID of the user
func (r ApiUpdateApplicationConfigRequest) AccountId(accountId int64) ApiUpdateApplicationConfigRequest {
	r.accountId = &accountId
	return r
}

// The config ID of the application configuration to update
func (r ApiUpdateApplicationConfigRequest) ConfigId(configId int64) ApiUpdateApplicationConfigRequest {
	r.configId = &configId
	return r
}

// The application key that the updated applicationConfig will be associated to
func (r ApiUpdateApplicationConfigRequest) AppKey(appKey string) ApiUpdateApplicationConfigRequest {
	r.appKey = &appKey
	return r
}

// The application configuration, has to be unique within the application
func (r ApiUpdateApplicationConfigRequest) ConfigVersion(configVersion string) ApiUpdateApplicationConfigRequest {
	r.configVersion = &configVersion
	return r
}

// The json assetId that stores the configuration detail.
func (r ApiUpdateApplicationConfigRequest) AssetId(assetId int64) ApiUpdateApplicationConfigRequest {
	r.assetId = &assetId
	return r
}

// The retailer id for retailer specific configurations
func (r ApiUpdateApplicationConfigRequest) RetailerId(retailerId int64) ApiUpdateApplicationConfigRequest {
	r.retailerId = &retailerId
	return r
}

// The retailer location id for retailer location specific configurations
func (r ApiUpdateApplicationConfigRequest) RetailerLocationId(retailerLocationId int64) ApiUpdateApplicationConfigRequest {
	r.retailerLocationId = &retailerLocationId
	return r
}

// The device udid for device specific configurations
func (r ApiUpdateApplicationConfigRequest) Udid(udid string) ApiUpdateApplicationConfigRequest {
	r.udid = &udid
	return r
}

func (r ApiUpdateApplicationConfigRequest) Execute() (*ApplicationConfigResponse, *http.Response, error) {
	return r.ApiService.UpdateApplicationConfigExecute(r)
}

/*
UpdateApplicationConfig Update AppConfig

pdates an existing application configuration. If the configVersion provided already exists for the given app the application configuration won't be updated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateApplicationConfigRequest
*/
func (a *ApplicationConfigAPIService) UpdateApplicationConfig(ctx context.Context, version float32) ApiUpdateApplicationConfigRequest {
	return ApiUpdateApplicationConfigRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return ApplicationConfigResponse
func (a *ApplicationConfigAPIService) UpdateApplicationConfigExecute(r ApiUpdateApplicationConfigRequest) (*ApplicationConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationConfigResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationConfigAPIService.UpdateApplicationConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/appconfig/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.configId == nil {
		return localVarReturnValue, nil, reportError("configId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "configId", r.configId, "form", "")
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.configVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "configVersion", r.configVersion, "form", "")
	}
	if r.assetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "form", "")
	}
	if r.retailerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerId", r.retailerId, "form", "")
	}
	if r.retailerLocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retailerLocationId", r.retailerLocationId, "form", "")
	}
	if r.udid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udid", r.udid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
