/*
Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

API version: 3.16
Contact: info@sirqul.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// AssetAPIService AssetAPI service
type AssetAPIService service

type ApiAssetDownloadRequest struct {
	ctx context.Context
	ApiService *AssetAPIService
	version float32
	filename string
}

func (r ApiAssetDownloadRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.AssetDownloadExecute(r)
}

/*
AssetDownload Download Asset

Downloads an asset from the server for assets that have been uploaded to the server.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @param filename the filename in the following formats: {assetId}-{suffix}.{extension} | {assetId}.{extension} | {assetId}
 @return ApiAssetDownloadRequest
*/
func (a *AssetAPIService) AssetDownload(ctx context.Context, version float32, filename string) ApiAssetDownloadRequest {
	return ApiAssetDownloadRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
		filename: filename,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AssetAPIService) AssetDownloadExecute(r ApiAssetDownloadRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.AssetDownload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/asset/download/{filename}"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"filename"+"}", url.PathEscape(parameterValueToString(r.filename, "filename")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssetMorphRequest struct {
	ctx context.Context
	ApiService *AssetAPIService
	version float32
	offerId *int64
	adSize *string
	creativeId *int64
	width *int32
	height *int32
	backgroundSize *string
	template *string
}

// offer id used for inserting offer text/flavor
func (r ApiAssetMorphRequest) OfferId(offerId int64) ApiAssetMorphRequest {
	r.offerId = &offerId
	return r
}

// the ad size used for selecting a format for the creative image
func (r ApiAssetMorphRequest) AdSize(adSize string) ApiAssetMorphRequest {
	r.adSize = &adSize
	return r
}

// used for inserting the newly created image into
func (r ApiAssetMorphRequest) CreativeId(creativeId int64) ApiAssetMorphRequest {
	r.creativeId = &creativeId
	return r
}

// total width of the creative image
func (r ApiAssetMorphRequest) Width(width int32) ApiAssetMorphRequest {
	r.width = &width
	return r
}

// total height of the creative image
func (r ApiAssetMorphRequest) Height(height int32) ApiAssetMorphRequest {
	r.height = &height
	return r
}

// the size of the background
func (r ApiAssetMorphRequest) BackgroundSize(backgroundSize string) ApiAssetMorphRequest {
	r.backgroundSize = &backgroundSize
	return r
}

// the template to use
func (r ApiAssetMorphRequest) Template(template string) ApiAssetMorphRequest {
	r.template = &template
	return r
}

func (r ApiAssetMorphRequest) Execute() (*AssetShortResponse, *http.Response, error) {
	return r.ApiService.AssetMorphExecute(r)
}

/*
AssetMorph Convert Offer to Creative

Converts an offer image + text into a creative image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiAssetMorphRequest
*/
func (a *AssetAPIService) AssetMorph(ctx context.Context, version float32) ApiAssetMorphRequest {
	return ApiAssetMorphRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return AssetShortResponse
func (a *AssetAPIService) AssetMorphExecute(r ApiAssetMorphRequest) (*AssetShortResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssetShortResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.AssetMorph")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/asset/morph"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.offerId == nil {
		return localVarReturnValue, nil, reportError("offerId is required and must be specified")
	}
	if r.adSize == nil {
		return localVarReturnValue, nil, reportError("adSize is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "offerId", r.offerId, "form", "")
	if r.creativeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creativeId", r.creativeId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "adSize", r.adSize, "form", "")
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.backgroundSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundSize", r.backgroundSize, "form", "")
	}
	if r.template != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "template", r.template, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssetRequest struct {
	ctx context.Context
	ApiService *AssetAPIService
	version float32
	returnNulls *bool
	deviceId *string
	accountId *int64
	albumId *int64
	collectionId *int64
	addToDefaultAlbum *string
	addToMediaLibrary *bool
	versionCode *int32
	versionName *string
	metaData *string
	caption *string
	assetType *string
	approvalStatus *string
	assignedAccountId *int64
	media *os.File
	mediaUrl *string
	mediaString *string
	mediaStringFileName *string
	mediaStringContentType *string
	mediaHeight *int32
	mediaWidth *int32
	attachedMedia *os.File
	attachedMediaUrl *string
	attachedMediaString *string
	attachedMediaStringFileName *string
	attachedMediaStringContentType *string
	attachedMediaHeight *int32
	attachedMediaWidth *int32
	locationDescription *string
	app *string
	appKey *string
	searchTags *string
	latitude *float64
	longitude *float64
}

// to return nulls
func (r ApiCreateAssetRequest) ReturnNulls(returnNulls bool) ApiCreateAssetRequest {
	r.returnNulls = &returnNulls
	return r
}

// a unique ID given by the device (deviceId or accountId required)
func (r ApiCreateAssetRequest) DeviceId(deviceId string) ApiCreateAssetRequest {
	r.deviceId = &deviceId
	return r
}

// the account ID of the user (deviceId or accountId required)
func (r ApiCreateAssetRequest) AccountId(accountId int64) ApiCreateAssetRequest {
	r.accountId = &accountId
	return r
}

// the album the asset will be added to (optional)
func (r ApiCreateAssetRequest) AlbumId(albumId int64) ApiCreateAssetRequest {
	r.albumId = &albumId
	return r
}

// Deprecated: use collections via the collection endpoints.
func (r ApiCreateAssetRequest) CollectionId(collectionId int64) ApiCreateAssetRequest {
	r.collectionId = &collectionId
	return r
}

// Whether to add to a default album
func (r ApiCreateAssetRequest) AddToDefaultAlbum(addToDefaultAlbum string) ApiCreateAssetRequest {
	r.addToDefaultAlbum = &addToDefaultAlbum
	return r
}

// Whether to add to the media library
func (r ApiCreateAssetRequest) AddToMediaLibrary(addToMediaLibrary bool) ApiCreateAssetRequest {
	r.addToMediaLibrary = &addToMediaLibrary
	return r
}

// the version code
func (r ApiCreateAssetRequest) VersionCode(versionCode int32) ApiCreateAssetRequest {
	r.versionCode = &versionCode
	return r
}

// the version name
func (r ApiCreateAssetRequest) VersionName(versionName string) ApiCreateAssetRequest {
	r.versionName = &versionName
	return r
}

// External custom client defined data
func (r ApiCreateAssetRequest) MetaData(metaData string) ApiCreateAssetRequest {
	r.metaData = &metaData
	return r
}

// the caption (optional)
func (r ApiCreateAssetRequest) Caption(caption string) ApiCreateAssetRequest {
	r.caption = &caption
	return r
}

// the asset type
func (r ApiCreateAssetRequest) AssetType(assetType string) ApiCreateAssetRequest {
	r.assetType = &assetType
	return r
}

// approval status for the asset
func (r ApiCreateAssetRequest) ApprovalStatus(approvalStatus string) ApiCreateAssetRequest {
	r.approvalStatus = &approvalStatus
	return r
}

// account id assigned to the asset
func (r ApiCreateAssetRequest) AssignedAccountId(assignedAccountId int64) ApiCreateAssetRequest {
	r.assignedAccountId = &assignedAccountId
	return r
}

// a MultipartFile containing the mimetype, etc
func (r ApiCreateAssetRequest) Media(media *os.File) ApiCreateAssetRequest {
	r.media = media
	return r
}

// this can be used if the \&quot;media\&quot; is a link (optional)
func (r ApiCreateAssetRequest) MediaUrl(mediaUrl string) ApiCreateAssetRequest {
	r.mediaUrl = &mediaUrl
	return r
}

// the media content as a string (optional)
func (r ApiCreateAssetRequest) MediaString(mediaString string) ApiCreateAssetRequest {
	r.mediaString = &mediaString
	return r
}

// file name for mediaString (optional)
func (r ApiCreateAssetRequest) MediaStringFileName(mediaStringFileName string) ApiCreateAssetRequest {
	r.mediaStringFileName = &mediaStringFileName
	return r
}

// content type for mediaString (optional)
func (r ApiCreateAssetRequest) MediaStringContentType(mediaStringContentType string) ApiCreateAssetRequest {
	r.mediaStringContentType = &mediaStringContentType
	return r
}

// the media height (optional)
func (r ApiCreateAssetRequest) MediaHeight(mediaHeight int32) ApiCreateAssetRequest {
	r.mediaHeight = &mediaHeight
	return r
}

// the media width (optional)
func (r ApiCreateAssetRequest) MediaWidth(mediaWidth int32) ApiCreateAssetRequest {
	r.mediaWidth = &mediaWidth
	return r
}

// a MultipartFile containing an asset that the \&quot;media\&quot; file references (optional). Example: to upload a video the \&quot;media\&quot; file should contain a screen capture and the \&quot;attachedMedia\&quot; should be the actual video.
func (r ApiCreateAssetRequest) AttachedMedia(attachedMedia *os.File) ApiCreateAssetRequest {
	r.attachedMedia = attachedMedia
	return r
}

// this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc) (optional)
func (r ApiCreateAssetRequest) AttachedMediaUrl(attachedMediaUrl string) ApiCreateAssetRequest {
	r.attachedMediaUrl = &attachedMediaUrl
	return r
}

// attached media content as a string (optional)
func (r ApiCreateAssetRequest) AttachedMediaString(attachedMediaString string) ApiCreateAssetRequest {
	r.attachedMediaString = &attachedMediaString
	return r
}

// file name for attachedMediaString (optional)
func (r ApiCreateAssetRequest) AttachedMediaStringFileName(attachedMediaStringFileName string) ApiCreateAssetRequest {
	r.attachedMediaStringFileName = &attachedMediaStringFileName
	return r
}

// content type for attachedMediaString (optional)
func (r ApiCreateAssetRequest) AttachedMediaStringContentType(attachedMediaStringContentType string) ApiCreateAssetRequest {
	r.attachedMediaStringContentType = &attachedMediaStringContentType
	return r
}

// the attached media height (optional)
func (r ApiCreateAssetRequest) AttachedMediaHeight(attachedMediaHeight int32) ApiCreateAssetRequest {
	r.attachedMediaHeight = &attachedMediaHeight
	return r
}

// the attached media width (optional)
func (r ApiCreateAssetRequest) AttachedMediaWidth(attachedMediaWidth int32) ApiCreateAssetRequest {
	r.attachedMediaWidth = &attachedMediaWidth
	return r
}

// the location description (optional)
func (r ApiCreateAssetRequest) LocationDescription(locationDescription string) ApiCreateAssetRequest {
	r.locationDescription = &locationDescription
	return r
}

// Deprecated: app parameter
func (r ApiCreateAssetRequest) App(app string) ApiCreateAssetRequest {
	r.app = &app
	return r
}

// the application key
func (r ApiCreateAssetRequest) AppKey(appKey string) ApiCreateAssetRequest {
	r.appKey = &appKey
	return r
}

// the search tags
func (r ApiCreateAssetRequest) SearchTags(searchTags string) ApiCreateAssetRequest {
	r.searchTags = &searchTags
	return r
}

// the latitude (optional)
func (r ApiCreateAssetRequest) Latitude(latitude float64) ApiCreateAssetRequest {
	r.latitude = &latitude
	return r
}

// the longitude (optional)
func (r ApiCreateAssetRequest) Longitude(longitude float64) ApiCreateAssetRequest {
	r.longitude = &longitude
	return r
}

func (r ApiCreateAssetRequest) Execute() (*AssetResponse, *http.Response, error) {
	return r.ApiService.CreateAssetExecute(r)
}

/*
CreateAsset Create Asset

Uploads an asset to server and returns an asset id which can be used to assign to various objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiCreateAssetRequest
*/
func (a *AssetAPIService) CreateAsset(ctx context.Context, version float32) ApiCreateAssetRequest {
	return ApiCreateAssetRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return AssetResponse
func (a *AssetAPIService) CreateAssetExecute(r ApiCreateAssetRequest) (*AssetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.CreateAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/asset/create"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnNulls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnNulls", r.returnNulls, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.albumId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumId", r.albumId, "form", "")
	}
	if r.collectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "collectionId", r.collectionId, "form", "")
	}
	if r.addToDefaultAlbum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addToDefaultAlbum", r.addToDefaultAlbum, "form", "")
	}
	if r.addToMediaLibrary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addToMediaLibrary", r.addToMediaLibrary, "form", "")
	}
	if r.versionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionCode", r.versionCode, "form", "")
	}
	if r.versionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionName", r.versionName, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caption", r.caption, "form", "")
	}
	if r.assetType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetType", r.assetType, "form", "")
	}
	if r.approvalStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalStatus", r.approvalStatus, "form", "")
	}
	if r.assignedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assignedAccountId", r.assignedAccountId, "form", "")
	}
	if r.media != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "media", r.media, "form", "")
	}
	if r.mediaUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaUrl", r.mediaUrl, "form", "")
	}
	if r.mediaString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaString", r.mediaString, "form", "")
	}
	if r.mediaStringFileName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaStringFileName", r.mediaStringFileName, "form", "")
	}
	if r.mediaStringContentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaStringContentType", r.mediaStringContentType, "form", "")
	}
	if r.mediaHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaHeight", r.mediaHeight, "form", "")
	}
	if r.mediaWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaWidth", r.mediaWidth, "form", "")
	}
	if r.attachedMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedMedia", r.attachedMedia, "form", "")
	}
	if r.attachedMediaUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedMediaUrl", r.attachedMediaUrl, "form", "")
	}
	if r.attachedMediaString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedMediaString", r.attachedMediaString, "form", "")
	}
	if r.attachedMediaStringFileName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedMediaStringFileName", r.attachedMediaStringFileName, "form", "")
	}
	if r.attachedMediaStringContentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedMediaStringContentType", r.attachedMediaStringContentType, "form", "")
	}
	if r.attachedMediaHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedMediaHeight", r.attachedMediaHeight, "form", "")
	}
	if r.attachedMediaWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedMediaWidth", r.attachedMediaWidth, "form", "")
	}
	if r.locationDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locationDescription", r.locationDescription, "form", "")
	}
	if r.app != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "app", r.app, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.searchTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchTags", r.searchTags, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAssetRequest struct {
	ctx context.Context
	ApiService *AssetAPIService
	version float32
	assetId *string
	deviceId *string
	accountId *int64
	latitude *float64
	longitude *float64
}

// the id of the asset to delete
func (r ApiDeleteAssetRequest) AssetId(assetId string) ApiDeleteAssetRequest {
	r.assetId = &assetId
	return r
}

// the device id (deviceId or accountId required)
func (r ApiDeleteAssetRequest) DeviceId(deviceId string) ApiDeleteAssetRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiDeleteAssetRequest) AccountId(accountId int64) ApiDeleteAssetRequest {
	r.accountId = &accountId
	return r
}

// latitude used to update the user&#39;s current location
func (r ApiDeleteAssetRequest) Latitude(latitude float64) ApiDeleteAssetRequest {
	r.latitude = &latitude
	return r
}

// longitude used to update the user&#39;s current location
func (r ApiDeleteAssetRequest) Longitude(longitude float64) ApiDeleteAssetRequest {
	r.longitude = &longitude
	return r
}

func (r ApiDeleteAssetRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.DeleteAssetExecute(r)
}

/*
DeleteAsset Delete Asset

Delete an asset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiDeleteAssetRequest
*/
func (a *AssetAPIService) DeleteAsset(ctx context.Context, version float32) ApiDeleteAssetRequest {
	return ApiDeleteAssetRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AssetAPIService) DeleteAssetExecute(r ApiDeleteAssetRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.DeleteAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/asset/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assetId == nil {
		return localVarReturnValue, nil, reportError("assetId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "form", "")
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetRequest struct {
	ctx context.Context
	ApiService *AssetAPIService
	version float32
	assetId *int64
	deviceId *string
	accountId *int64
	noteDescending *bool
}

// the asset ID
func (r ApiGetAssetRequest) AssetId(assetId int64) ApiGetAssetRequest {
	r.assetId = &assetId
	return r
}

// a unique ID given by the device (deviceId or accountId required)
func (r ApiGetAssetRequest) DeviceId(deviceId string) ApiGetAssetRequest {
	r.deviceId = &deviceId
	return r
}

// the account ID of the user (deviceId or accountId required)
func (r ApiGetAssetRequest) AccountId(accountId int64) ApiGetAssetRequest {
	r.accountId = &accountId
	return r
}

// determines whether the notes on the asset are in descending order
func (r ApiGetAssetRequest) NoteDescending(noteDescending bool) ApiGetAssetRequest {
	r.noteDescending = &noteDescending
	return r
}

func (r ApiGetAssetRequest) Execute() (*AssetFullResponse, *http.Response, error) {
	return r.ApiService.GetAssetExecute(r)
}

/*
GetAsset Get Asset

Gets the full asset response including attached likes and notes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiGetAssetRequest
*/
func (a *AssetAPIService) GetAsset(ctx context.Context, version float32) ApiGetAssetRequest {
	return ApiGetAssetRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return AssetFullResponse
func (a *AssetAPIService) GetAssetExecute(r ApiGetAssetRequest) (*AssetFullResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssetFullResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.GetAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/asset/get"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assetId == nil {
		return localVarReturnValue, nil, reportError("assetId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "form", "")
	if r.noteDescending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "noteDescending", r.noteDescending, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "noteDescending", defaultValue, "form", "")
		r.noteDescending = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveAssetRequest struct {
	ctx context.Context
	ApiService *AssetAPIService
	version float32
	assetId *string
	deviceId *string
	accountId *int64
	albumId *int64
	collectionId *int64
	removeFromDefaultAlbums *bool
	latitude *float64
	longitude *float64
}

// the id of the asset to remove
func (r ApiRemoveAssetRequest) AssetId(assetId string) ApiRemoveAssetRequest {
	r.assetId = &assetId
	return r
}

// the device id (deviceId or accountId required)
func (r ApiRemoveAssetRequest) DeviceId(deviceId string) ApiRemoveAssetRequest {
	r.deviceId = &deviceId
	return r
}

// the account id of the user (deviceId or accountId required)
func (r ApiRemoveAssetRequest) AccountId(accountId int64) ApiRemoveAssetRequest {
	r.accountId = &accountId
	return r
}

// the album id to remove the asset from
func (r ApiRemoveAssetRequest) AlbumId(albumId int64) ApiRemoveAssetRequest {
	r.albumId = &albumId
	return r
}

// the collection id to remove the asset from
func (r ApiRemoveAssetRequest) CollectionId(collectionId int64) ApiRemoveAssetRequest {
	r.collectionId = &collectionId
	return r
}

// remove from the user&#39;s profile album
func (r ApiRemoveAssetRequest) RemoveFromDefaultAlbums(removeFromDefaultAlbums bool) ApiRemoveAssetRequest {
	r.removeFromDefaultAlbums = &removeFromDefaultAlbums
	return r
}

// latitude used to update the user&#39;s current location
func (r ApiRemoveAssetRequest) Latitude(latitude float64) ApiRemoveAssetRequest {
	r.latitude = &latitude
	return r
}

// longitude used to update the user&#39;s current location
func (r ApiRemoveAssetRequest) Longitude(longitude float64) ApiRemoveAssetRequest {
	r.longitude = &longitude
	return r
}

func (r ApiRemoveAssetRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.RemoveAssetExecute(r)
}

/*
RemoveAsset Remove Asset from Collection

Remove assets from collections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiRemoveAssetRequest
*/
func (a *AssetAPIService) RemoveAsset(ctx context.Context, version float32) ApiRemoveAssetRequest {
	return ApiRemoveAssetRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AssetAPIService) RemoveAssetExecute(r ApiRemoveAssetRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.RemoveAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/asset/remove"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assetId == nil {
		return localVarReturnValue, nil, reportError("assetId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.albumId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumId", r.albumId, "form", "")
	}
	if r.collectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "collectionId", r.collectionId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "form", "")
	if r.removeFromDefaultAlbums != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "removeFromDefaultAlbums", r.removeFromDefaultAlbums, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchAssetsRequest struct {
	ctx context.Context
	ApiService *AssetAPIService
	version float32
	deviceId *string
	accountId *int64
	albumIds *string
	assetIds *string
	appKey *string
	mediaType *string
	mimeType *string
	keyword *string
	versionCode *int32
	versionName *string
	updatedSince *int64
	updatedBefore *int64
	sortField *string
	descending *bool
	searchMediaLibrary *bool
	filterByBillable *bool
	activeOnly *bool
	returnApp *bool
	start *int32
	limit *int32
	searchMode *string
	assetType *string
	approvalStatus *string
	assignedAccountId *int64
}

// a unique ID given by the device (deviceId or accountId required)
func (r ApiSearchAssetsRequest) DeviceId(deviceId string) ApiSearchAssetsRequest {
	r.deviceId = &deviceId
	return r
}

// the account ID of the user (deviceId or accountId required)
func (r ApiSearchAssetsRequest) AccountId(accountId int64) ApiSearchAssetsRequest {
	r.accountId = &accountId
	return r
}

// comma separated list of album ids to search on
func (r ApiSearchAssetsRequest) AlbumIds(albumIds string) ApiSearchAssetsRequest {
	r.albumIds = &albumIds
	return r
}

// comma separated list of asset ids to search on
func (r ApiSearchAssetsRequest) AssetIds(assetIds string) ApiSearchAssetsRequest {
	r.assetIds = &assetIds
	return r
}

// the application key to filter results by application.
func (r ApiSearchAssetsRequest) AppKey(appKey string) ApiSearchAssetsRequest {
	r.appKey = &appKey
	return r
}

// filter results by media type. Possible values include: APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, TEXT
func (r ApiSearchAssetsRequest) MediaType(mediaType string) ApiSearchAssetsRequest {
	r.mediaType = &mediaType
	return r
}

// filter results by mime type
func (r ApiSearchAssetsRequest) MimeType(mimeType string) ApiSearchAssetsRequest {
	r.mimeType = &mimeType
	return r
}

// keyword search string
func (r ApiSearchAssetsRequest) Keyword(keyword string) ApiSearchAssetsRequest {
	r.keyword = &keyword
	return r
}

// filter results by version code
func (r ApiSearchAssetsRequest) VersionCode(versionCode int32) ApiSearchAssetsRequest {
	r.versionCode = &versionCode
	return r
}

// filter results by version name
func (r ApiSearchAssetsRequest) VersionName(versionName string) ApiSearchAssetsRequest {
	r.versionName = &versionName
	return r
}

// return items that have been updated since this date (time-stamp in milliseconds)
func (r ApiSearchAssetsRequest) UpdatedSince(updatedSince int64) ApiSearchAssetsRequest {
	r.updatedSince = &updatedSince
	return r
}

// return items that have been updated before this date (time-stamp in milliseconds)
func (r ApiSearchAssetsRequest) UpdatedBefore(updatedBefore int64) ApiSearchAssetsRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// the field to sort by. See AssetApiMap
func (r ApiSearchAssetsRequest) SortField(sortField string) ApiSearchAssetsRequest {
	r.sortField = &sortField
	return r
}

// determines whether the sorted list is in descending or ascending order
func (r ApiSearchAssetsRequest) Descending(descending bool) ApiSearchAssetsRequest {
	r.descending = &descending
	return r
}

// determines whether to search on the media library album
func (r ApiSearchAssetsRequest) SearchMediaLibrary(searchMediaLibrary bool) ApiSearchAssetsRequest {
	r.searchMediaLibrary = &searchMediaLibrary
	return r
}

// filter results by billable entity
func (r ApiSearchAssetsRequest) FilterByBillable(filterByBillable bool) ApiSearchAssetsRequest {
	r.filterByBillable = &filterByBillable
	return r
}

// if only searching for active assets
func (r ApiSearchAssetsRequest) ActiveOnly(activeOnly bool) ApiSearchAssetsRequest {
	r.activeOnly = &activeOnly
	return r
}

// determines whether to include the application response as part of the asset response
func (r ApiSearchAssetsRequest) ReturnApp(returnApp bool) ApiSearchAssetsRequest {
	r.returnApp = &returnApp
	return r
}

// the start index for pagination
func (r ApiSearchAssetsRequest) Start(start int32) ApiSearchAssetsRequest {
	r.start = &start
	return r
}

// the limit for pagination (there is a hard limit of 200)
func (r ApiSearchAssetsRequest) Limit(limit int32) ApiSearchAssetsRequest {
	r.limit = &limit
	return r
}

// search mode for index (SearchIndexMode)
func (r ApiSearchAssetsRequest) SearchMode(searchMode string) ApiSearchAssetsRequest {
	r.searchMode = &searchMode
	return r
}

// filter by asset type
func (r ApiSearchAssetsRequest) AssetType(assetType string) ApiSearchAssetsRequest {
	r.assetType = &assetType
	return r
}

// filter by approval status
func (r ApiSearchAssetsRequest) ApprovalStatus(approvalStatus string) ApiSearchAssetsRequest {
	r.approvalStatus = &approvalStatus
	return r
}

// filter results by an assigned account id
func (r ApiSearchAssetsRequest) AssignedAccountId(assignedAccountId int64) ApiSearchAssetsRequest {
	r.assignedAccountId = &assignedAccountId
	return r
}

func (r ApiSearchAssetsRequest) Execute() ([]AssetResponse, *http.Response, error) {
	return r.ApiService.SearchAssetsExecute(r)
}

/*
SearchAssets Search Assets

Searches for assets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiSearchAssetsRequest
*/
func (a *AssetAPIService) SearchAssets(ctx context.Context, version float32) ApiSearchAssetsRequest {
	return ApiSearchAssetsRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return []AssetResponse
func (a *AssetAPIService) SearchAssetsExecute(r ApiSearchAssetsRequest) ([]AssetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AssetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.SearchAssets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/asset/search"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	if r.albumIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumIds", r.albumIds, "form", "")
	}
	if r.assetIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetIds", r.assetIds, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.mediaType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaType", r.mediaType, "form", "")
	}
	if r.mimeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mimeType", r.mimeType, "form", "")
	}
	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "form", "")
	}
	if r.versionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionCode", r.versionCode, "form", "")
	}
	if r.versionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionName", r.versionName, "form", "")
	}
	if r.updatedSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedSince", r.updatedSince, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "form", "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "form", "")
	}
	if r.searchMediaLibrary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchMediaLibrary", r.searchMediaLibrary, "form", "")
	}
	if r.filterByBillable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterByBillable", r.filterByBillable, "form", "")
	}
	if r.activeOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeOnly", r.activeOnly, "form", "")
	}
	if r.returnApp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnApp", r.returnApp, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.searchMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchMode", r.searchMode, "form", "")
	}
	if r.assetType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetType", r.assetType, "form", "")
	}
	if r.approvalStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalStatus", r.approvalStatus, "form", "")
	}
	if r.assignedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assignedAccountId", r.assignedAccountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAssetRequest struct {
	ctx context.Context
	ApiService *AssetAPIService
	version float32
	assetId *int64
	deviceId *string
	accountId *int64
	albumId *int64
	attachedAssetId *int64
	versionCode *int32
	versionName *string
	metaData *string
	caption *string
	assetType *string
	approvalStatus *string
	assignedAccountId *int64
	media *os.File
	mediaUrl *string
	mediaString *string
	mediaStringFileName *string
	mediaStringContentType *string
	mediaHeight *int32
	mediaWidth *int32
	attachedMedia *os.File
	attachedMediaUrl *string
	attachedMediaString *string
	attachedMediaStringFileName *string
	attachedMediaStringContentType *string
	attachedMediaHeight *int32
	attachedMediaWidth *int32
	locationDescription *string
	searchTags *string
	appKey *string
	latitude *float64
	longitude *float64
}

// the ID of the asset to update
func (r ApiUpdateAssetRequest) AssetId(assetId int64) ApiUpdateAssetRequest {
	r.assetId = &assetId
	return r
}

// a unique ID given by the device (deviceId or accountId required)
func (r ApiUpdateAssetRequest) DeviceId(deviceId string) ApiUpdateAssetRequest {
	r.deviceId = &deviceId
	return r
}

// the account ID of the user (deviceId or accountId required)
func (r ApiUpdateAssetRequest) AccountId(accountId int64) ApiUpdateAssetRequest {
	r.accountId = &accountId
	return r
}

// the ID of the album to check user permissions
func (r ApiUpdateAssetRequest) AlbumId(albumId int64) ApiUpdateAssetRequest {
	r.albumId = &albumId
	return r
}

// the ID of the attached asset
func (r ApiUpdateAssetRequest) AttachedAssetId(attachedAssetId int64) ApiUpdateAssetRequest {
	r.attachedAssetId = &attachedAssetId
	return r
}

// the version code
func (r ApiUpdateAssetRequest) VersionCode(versionCode int32) ApiUpdateAssetRequest {
	r.versionCode = &versionCode
	return r
}

// the version name
func (r ApiUpdateAssetRequest) VersionName(versionName string) ApiUpdateAssetRequest {
	r.versionName = &versionName
	return r
}

// External custom client defined data
func (r ApiUpdateAssetRequest) MetaData(metaData string) ApiUpdateAssetRequest {
	r.metaData = &metaData
	return r
}

// the caption
func (r ApiUpdateAssetRequest) Caption(caption string) ApiUpdateAssetRequest {
	r.caption = &caption
	return r
}

// the asset type
func (r ApiUpdateAssetRequest) AssetType(assetType string) ApiUpdateAssetRequest {
	r.assetType = &assetType
	return r
}

// approval status for the asset
func (r ApiUpdateAssetRequest) ApprovalStatus(approvalStatus string) ApiUpdateAssetRequest {
	r.approvalStatus = &approvalStatus
	return r
}

// account id assigned to the asset
func (r ApiUpdateAssetRequest) AssignedAccountId(assignedAccountId int64) ApiUpdateAssetRequest {
	r.assignedAccountId = &assignedAccountId
	return r
}

// a MultipartFile containing the mimetype, etc
func (r ApiUpdateAssetRequest) Media(media *os.File) ApiUpdateAssetRequest {
	r.media = media
	return r
}

// this can be used if the \&quot;media\&quot; is a link (optional)
func (r ApiUpdateAssetRequest) MediaUrl(mediaUrl string) ApiUpdateAssetRequest {
	r.mediaUrl = &mediaUrl
	return r
}

// the media content as a string (optional)
func (r ApiUpdateAssetRequest) MediaString(mediaString string) ApiUpdateAssetRequest {
	r.mediaString = &mediaString
	return r
}

// file name for mediaString (optional)
func (r ApiUpdateAssetRequest) MediaStringFileName(mediaStringFileName string) ApiUpdateAssetRequest {
	r.mediaStringFileName = &mediaStringFileName
	return r
}

// content type for mediaString (optional)
func (r ApiUpdateAssetRequest) MediaStringContentType(mediaStringContentType string) ApiUpdateAssetRequest {
	r.mediaStringContentType = &mediaStringContentType
	return r
}

// the media height (optional)
func (r ApiUpdateAssetRequest) MediaHeight(mediaHeight int32) ApiUpdateAssetRequest {
	r.mediaHeight = &mediaHeight
	return r
}

// the media width (optional)
func (r ApiUpdateAssetRequest) MediaWidth(mediaWidth int32) ApiUpdateAssetRequest {
	r.mediaWidth = &mediaWidth
	return r
}

// a MultipartFile containing an asset that the \&quot;media\&quot; file references (optional). Example: to upload a video the \&quot;media\&quot; file should contain a screen capture and the \&quot;attachedMedia\&quot; should be the actual video.
func (r ApiUpdateAssetRequest) AttachedMedia(attachedMedia *os.File) ApiUpdateAssetRequest {
	r.attachedMedia = attachedMedia
	return r
}

// this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc) (optional)
func (r ApiUpdateAssetRequest) AttachedMediaUrl(attachedMediaUrl string) ApiUpdateAssetRequest {
	r.attachedMediaUrl = &attachedMediaUrl
	return r
}

// attached media content as a string (optional)
func (r ApiUpdateAssetRequest) AttachedMediaString(attachedMediaString string) ApiUpdateAssetRequest {
	r.attachedMediaString = &attachedMediaString
	return r
}

// file name for attachedMediaString (optional)
func (r ApiUpdateAssetRequest) AttachedMediaStringFileName(attachedMediaStringFileName string) ApiUpdateAssetRequest {
	r.attachedMediaStringFileName = &attachedMediaStringFileName
	return r
}

// content type for attachedMediaString (optional)
func (r ApiUpdateAssetRequest) AttachedMediaStringContentType(attachedMediaStringContentType string) ApiUpdateAssetRequest {
	r.attachedMediaStringContentType = &attachedMediaStringContentType
	return r
}

// the attached media height (optional)
func (r ApiUpdateAssetRequest) AttachedMediaHeight(attachedMediaHeight int32) ApiUpdateAssetRequest {
	r.attachedMediaHeight = &attachedMediaHeight
	return r
}

// the attached media width (optional)
func (r ApiUpdateAssetRequest) AttachedMediaWidth(attachedMediaWidth int32) ApiUpdateAssetRequest {
	r.attachedMediaWidth = &attachedMediaWidth
	return r
}

// the location description
func (r ApiUpdateAssetRequest) LocationDescription(locationDescription string) ApiUpdateAssetRequest {
	r.locationDescription = &locationDescription
	return r
}

// search tags
func (r ApiUpdateAssetRequest) SearchTags(searchTags string) ApiUpdateAssetRequest {
	r.searchTags = &searchTags
	return r
}

// the application key
func (r ApiUpdateAssetRequest) AppKey(appKey string) ApiUpdateAssetRequest {
	r.appKey = &appKey
	return r
}

// latitude used to update the asset&#39;s location
func (r ApiUpdateAssetRequest) Latitude(latitude float64) ApiUpdateAssetRequest {
	r.latitude = &latitude
	return r
}

// longitude used to update the asset&#39;s location
func (r ApiUpdateAssetRequest) Longitude(longitude float64) ApiUpdateAssetRequest {
	r.longitude = &longitude
	return r
}

func (r ApiUpdateAssetRequest) Execute() (*SirqulResponse, *http.Response, error) {
	return r.ApiService.UpdateAssetExecute(r)
}

/*
UpdateAsset Update Asset

Updates an asset's meta data. If an album reference is passed in, the participants with write permissions are allowed to edit the asset. Otherwise, only the asset up-loader has permission to edit the data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param version
 @return ApiUpdateAssetRequest
*/
func (a *AssetAPIService) UpdateAsset(ctx context.Context, version float32) ApiUpdateAssetRequest {
	return ApiUpdateAssetRequest{
		ApiService: a,
		ctx: ctx,
		version: version,
	}
}

// Execute executes the request
//  @return SirqulResponse
func (a *AssetAPIService) UpdateAssetExecute(r ApiUpdateAssetRequest) (*SirqulResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SirqulResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.UpdateAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/{version}/asset/update"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assetId == nil {
		return localVarReturnValue, nil, reportError("assetId is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "assetId", r.assetId, "form", "")
	if r.albumId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "albumId", r.albumId, "form", "")
	}
	if r.attachedAssetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedAssetId", r.attachedAssetId, "form", "")
	}
	if r.versionCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionCode", r.versionCode, "form", "")
	}
	if r.versionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionName", r.versionName, "form", "")
	}
	if r.metaData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metaData", r.metaData, "form", "")
	}
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "caption", r.caption, "form", "")
	}
	if r.assetType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assetType", r.assetType, "form", "")
	}
	if r.approvalStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "approvalStatus", r.approvalStatus, "form", "")
	}
	if r.assignedAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assignedAccountId", r.assignedAccountId, "form", "")
	}
	if r.media != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "media", r.media, "form", "")
	}
	if r.mediaUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaUrl", r.mediaUrl, "form", "")
	}
	if r.mediaString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaString", r.mediaString, "form", "")
	}
	if r.mediaStringFileName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaStringFileName", r.mediaStringFileName, "form", "")
	}
	if r.mediaStringContentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaStringContentType", r.mediaStringContentType, "form", "")
	}
	if r.mediaHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaHeight", r.mediaHeight, "form", "")
	}
	if r.mediaWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaWidth", r.mediaWidth, "form", "")
	}
	if r.attachedMedia != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedMedia", r.attachedMedia, "form", "")
	}
	if r.attachedMediaUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedMediaUrl", r.attachedMediaUrl, "form", "")
	}
	if r.attachedMediaString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedMediaString", r.attachedMediaString, "form", "")
	}
	if r.attachedMediaStringFileName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedMediaStringFileName", r.attachedMediaStringFileName, "form", "")
	}
	if r.attachedMediaStringContentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedMediaStringContentType", r.attachedMediaStringContentType, "form", "")
	}
	if r.attachedMediaHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedMediaHeight", r.attachedMediaHeight, "form", "")
	}
	if r.attachedMediaWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedMediaWidth", r.attachedMediaWidth, "form", "")
	}
	if r.locationDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locationDescription", r.locationDescription, "form", "")
	}
	if r.searchTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchTags", r.searchTags, "form", "")
	}
	if r.appKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appKey", r.appKey, "form", "")
	}
	if r.latitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latitude", r.latitude, "form", "")
	}
	if r.longitude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "longitude", r.longitude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
