=begin comment

Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

The version of the OpenAPI document: 3.16
Contact: info@sirqul.com
Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package WWW::OpenAPIClient::TournamentApi;

require 5.6.0;
use strict;
use warnings;
use utf8;
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use WWW::OpenAPIClient::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'WWW::OpenAPIClient::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = WWW::OpenAPIClient::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# create_tournament
#
# Create Tournament
#
# @param int $account_id The logged in user. (required)
# @param string $app_key The appKey the tournament is created for. (required)
# @param string $title The title of the tournament (required)
# @param int $cost_to_play The number of tickets required to pay to enter the tournament (required)
# @param int $start_date The date/time to start the tournament (required)
# @param string $sub_type Custom string client apps can use for searching/filtering tournaments (optional)
# @param int $image_asset_id The asset ID to attach to the tournament (optional)
# @param int $seconds_between_levels The number of seconds in between the start of each tournament game/group (optional, default to 600)
# @param int $seconds_for_tie_breaker The number of seconds to extend the round end time in the case of a tie breaker (optional, default to 600)
# @param int $seconds_between_packs The number of seconds in between the start of each tournament round (optional, default to 86400)
# @param int $maximum_level_length The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional, default to 1800)
# @param string $cost_to_play_type The type of ticket required to pay (optional)
# @param int $minimum_to_play The minimum number of players required to sign up for the tournament to be played (optional, default to 1)
# @param int $starting_limit The starting number of players for a tournament (filled with AI&#39;s) (optional)
# @param int $available_limit The maximum number of players for a tournament (currently 128 but not enforced) (optional)
# @param string $description The description of the tournament (optional)
# @param string $meta_data External custom client defined data (optional)
# @param string $audience_ids The audiences associated with the tournament (optional)
# @param boolean $active Activate/deactivate the tournament (optional)
# @param boolean $enable_buy_back Determines whether to allow players to buy back into a tournament (optional, default to false)
# @param string $offer_ids The list of offers to give as a reward beyond the tickets (optional)
# @param int $offer_asset_id The artwork ID to attach to the reward tickets offers (optional)
# @param boolean $fixed_reward If set then do not update the ticket reward, auto set to true if offerIds provided (optional, default to false)
# @param string $split_reward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional, default to 'ALL')
# @param boolean $allocate_tickets Flag to indicate owner should receive tickets for completed missions (optional)
# @param string $tournament_data A text based string that will be passed into each tournament setup to populate the content (optional)
# @param string $mission_type The style of tournament to build, options are: TOURNAMENT, POOLPLAY (optional, default to 'MULTISTAGE')
# @param string $visibility Sets the visibility flag for the tournament (optional, default to 'PUBLIC')
# @param int $preliminary_groups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional, default to 1)
# @param string $preliminary_group_advancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional, default to '1')
# @param boolean $enable_multiple_entries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional, default to false)
# @param boolean $enable_multiple_votes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional, default to false)
# @param boolean $featured This determines whether the tournament is \&quot;featured\&quot; or not (optional, default to false)
# @param string $winner_tag This sets what analytic tag is used when a winner is determined (optional)
# @param string $tie_tag This sets what analytic tag is used when a tie has occurred (optional)
{
    my $params = {
    'account_id' => {
        data_type => 'int',
        description => 'The logged in user.',
        required => '1',
    },
    'app_key' => {
        data_type => 'string',
        description => 'The appKey the tournament is created for.',
        required => '1',
    },
    'title' => {
        data_type => 'string',
        description => 'The title of the tournament',
        required => '1',
    },
    'cost_to_play' => {
        data_type => 'int',
        description => 'The number of tickets required to pay to enter the tournament',
        required => '1',
    },
    'start_date' => {
        data_type => 'int',
        description => 'The date/time to start the tournament',
        required => '1',
    },
    'sub_type' => {
        data_type => 'string',
        description => 'Custom string client apps can use for searching/filtering tournaments',
        required => '0',
    },
    'image_asset_id' => {
        data_type => 'int',
        description => 'The asset ID to attach to the tournament',
        required => '0',
    },
    'seconds_between_levels' => {
        data_type => 'int',
        description => 'The number of seconds in between the start of each tournament game/group',
        required => '0',
    },
    'seconds_for_tie_breaker' => {
        data_type => 'int',
        description => 'The number of seconds to extend the round end time in the case of a tie breaker',
        required => '0',
    },
    'seconds_between_packs' => {
        data_type => 'int',
        description => 'The number of seconds in between the start of each tournament round',
        required => '0',
    },
    'maximum_level_length' => {
        data_type => 'int',
        description => 'The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity',
        required => '0',
    },
    'cost_to_play_type' => {
        data_type => 'string',
        description => 'The type of ticket required to pay',
        required => '0',
    },
    'minimum_to_play' => {
        data_type => 'int',
        description => 'The minimum number of players required to sign up for the tournament to be played',
        required => '0',
    },
    'starting_limit' => {
        data_type => 'int',
        description => 'The starting number of players for a tournament (filled with AI&#39;s)',
        required => '0',
    },
    'available_limit' => {
        data_type => 'int',
        description => 'The maximum number of players for a tournament (currently 128 but not enforced)',
        required => '0',
    },
    'description' => {
        data_type => 'string',
        description => 'The description of the tournament',
        required => '0',
    },
    'meta_data' => {
        data_type => 'string',
        description => 'External custom client defined data',
        required => '0',
    },
    'audience_ids' => {
        data_type => 'string',
        description => 'The audiences associated with the tournament',
        required => '0',
    },
    'active' => {
        data_type => 'boolean',
        description => 'Activate/deactivate the tournament',
        required => '0',
    },
    'enable_buy_back' => {
        data_type => 'boolean',
        description => 'Determines whether to allow players to buy back into a tournament',
        required => '0',
    },
    'offer_ids' => {
        data_type => 'string',
        description => 'The list of offers to give as a reward beyond the tickets',
        required => '0',
    },
    'offer_asset_id' => {
        data_type => 'int',
        description => 'The artwork ID to attach to the reward tickets offers',
        required => '0',
    },
    'fixed_reward' => {
        data_type => 'boolean',
        description => 'If set then do not update the ticket reward, auto set to true if offerIds provided',
        required => '0',
    },
    'split_reward' => {
        data_type => 'string',
        description => 'Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored',
        required => '0',
    },
    'allocate_tickets' => {
        data_type => 'boolean',
        description => 'Flag to indicate owner should receive tickets for completed missions',
        required => '0',
    },
    'tournament_data' => {
        data_type => 'string',
        description => 'A text based string that will be passed into each tournament setup to populate the content',
        required => '0',
    },
    'mission_type' => {
        data_type => 'string',
        description => 'The style of tournament to build, options are: TOURNAMENT, POOLPLAY',
        required => '0',
    },
    'visibility' => {
        data_type => 'string',
        description => 'Sets the visibility flag for the tournament',
        required => '0',
    },
    'preliminary_groups' => {
        data_type => 'int',
        description => 'The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)',
        required => '0',
    },
    'preliminary_group_advancements' => {
        data_type => 'string',
        description => 'This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)',
        required => '0',
    },
    'enable_multiple_entries' => {
        data_type => 'boolean',
        description => 'This determines if multiple submissions/entries are allowed in a multi-stage album tournament',
        required => '0',
    },
    'enable_multiple_votes' => {
        data_type => 'boolean',
        description => 'This determines if users are allowed to vote multiple times per group in a multi-stage album tournament',
        required => '0',
    },
    'featured' => {
        data_type => 'boolean',
        description => 'This determines whether the tournament is \&quot;featured\&quot; or not',
        required => '0',
    },
    'winner_tag' => {
        data_type => 'string',
        description => 'This sets what analytic tag is used when a winner is determined',
        required => '0',
    },
    'tie_tag' => {
        data_type => 'string',
        description => 'This sets what analytic tag is used when a tie has occurred',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_tournament' } = {
        summary => 'Create Tournament',
        params => $params,
        returns => 'TournamentResponse',
        };
}
# @return TournamentResponse
#
sub create_tournament {
    my ($self, %args) = @_;

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling create_tournament");
    }

    # verify the required parameter 'app_key' is set
    unless (exists $args{'app_key'}) {
      croak("Missing the required parameter 'app_key' when calling create_tournament");
    }

    # verify the required parameter 'title' is set
    unless (exists $args{'title'}) {
      croak("Missing the required parameter 'title' when calling create_tournament");
    }

    # verify the required parameter 'cost_to_play' is set
    unless (exists $args{'cost_to_play'}) {
      croak("Missing the required parameter 'cost_to_play' when calling create_tournament");
    }

    # verify the required parameter 'start_date' is set
    unless (exists $args{'start_date'}) {
      croak("Missing the required parameter 'start_date' when calling create_tournament");
    }

    # parse inputs
    my $_resource_path = '/tournament/create';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'app_key'}) {
        $query_params->{'appKey'} = $self->{api_client}->to_query_value($args{'app_key'});
    }

    # query params
    if ( exists $args{'title'}) {
        $query_params->{'title'} = $self->{api_client}->to_query_value($args{'title'});
    }

    # query params
    if ( exists $args{'sub_type'}) {
        $query_params->{'subType'} = $self->{api_client}->to_query_value($args{'sub_type'});
    }

    # query params
    if ( exists $args{'image_asset_id'}) {
        $query_params->{'imageAssetId'} = $self->{api_client}->to_query_value($args{'image_asset_id'});
    }

    # query params
    if ( exists $args{'seconds_between_levels'}) {
        $query_params->{'secondsBetweenLevels'} = $self->{api_client}->to_query_value($args{'seconds_between_levels'});
    }

    # query params
    if ( exists $args{'seconds_for_tie_breaker'}) {
        $query_params->{'secondsForTieBreaker'} = $self->{api_client}->to_query_value($args{'seconds_for_tie_breaker'});
    }

    # query params
    if ( exists $args{'seconds_between_packs'}) {
        $query_params->{'secondsBetweenPacks'} = $self->{api_client}->to_query_value($args{'seconds_between_packs'});
    }

    # query params
    if ( exists $args{'maximum_level_length'}) {
        $query_params->{'maximumLevelLength'} = $self->{api_client}->to_query_value($args{'maximum_level_length'});
    }

    # query params
    if ( exists $args{'cost_to_play'}) {
        $query_params->{'costToPlay'} = $self->{api_client}->to_query_value($args{'cost_to_play'});
    }

    # query params
    if ( exists $args{'cost_to_play_type'}) {
        $query_params->{'costToPlayType'} = $self->{api_client}->to_query_value($args{'cost_to_play_type'});
    }

    # query params
    if ( exists $args{'minimum_to_play'}) {
        $query_params->{'minimumToPlay'} = $self->{api_client}->to_query_value($args{'minimum_to_play'});
    }

    # query params
    if ( exists $args{'starting_limit'}) {
        $query_params->{'startingLimit'} = $self->{api_client}->to_query_value($args{'starting_limit'});
    }

    # query params
    if ( exists $args{'available_limit'}) {
        $query_params->{'availableLimit'} = $self->{api_client}->to_query_value($args{'available_limit'});
    }

    # query params
    if ( exists $args{'description'}) {
        $query_params->{'description'} = $self->{api_client}->to_query_value($args{'description'});
    }

    # query params
    if ( exists $args{'meta_data'}) {
        $query_params->{'metaData'} = $self->{api_client}->to_query_value($args{'meta_data'});
    }

    # query params
    if ( exists $args{'start_date'}) {
        $query_params->{'startDate'} = $self->{api_client}->to_query_value($args{'start_date'});
    }

    # query params
    if ( exists $args{'audience_ids'}) {
        $query_params->{'audienceIds'} = $self->{api_client}->to_query_value($args{'audience_ids'});
    }

    # query params
    if ( exists $args{'active'}) {
        $query_params->{'active'} = $self->{api_client}->to_query_value($args{'active'});
    }

    # query params
    if ( exists $args{'enable_buy_back'}) {
        $query_params->{'enableBuyBack'} = $self->{api_client}->to_query_value($args{'enable_buy_back'});
    }

    # query params
    if ( exists $args{'offer_ids'}) {
        $query_params->{'offerIds'} = $self->{api_client}->to_query_value($args{'offer_ids'});
    }

    # query params
    if ( exists $args{'offer_asset_id'}) {
        $query_params->{'offerAssetId'} = $self->{api_client}->to_query_value($args{'offer_asset_id'});
    }

    # query params
    if ( exists $args{'fixed_reward'}) {
        $query_params->{'fixedReward'} = $self->{api_client}->to_query_value($args{'fixed_reward'});
    }

    # query params
    if ( exists $args{'split_reward'}) {
        $query_params->{'splitReward'} = $self->{api_client}->to_query_value($args{'split_reward'});
    }

    # query params
    if ( exists $args{'allocate_tickets'}) {
        $query_params->{'allocateTickets'} = $self->{api_client}->to_query_value($args{'allocate_tickets'});
    }

    # query params
    if ( exists $args{'tournament_data'}) {
        $query_params->{'tournamentData'} = $self->{api_client}->to_query_value($args{'tournament_data'});
    }

    # query params
    if ( exists $args{'mission_type'}) {
        $query_params->{'missionType'} = $self->{api_client}->to_query_value($args{'mission_type'});
    }

    # query params
    if ( exists $args{'visibility'}) {
        $query_params->{'visibility'} = $self->{api_client}->to_query_value($args{'visibility'});
    }

    # query params
    if ( exists $args{'preliminary_groups'}) {
        $query_params->{'preliminaryGroups'} = $self->{api_client}->to_query_value($args{'preliminary_groups'});
    }

    # query params
    if ( exists $args{'preliminary_group_advancements'}) {
        $query_params->{'preliminaryGroupAdvancements'} = $self->{api_client}->to_query_value($args{'preliminary_group_advancements'});
    }

    # query params
    if ( exists $args{'enable_multiple_entries'}) {
        $query_params->{'enableMultipleEntries'} = $self->{api_client}->to_query_value($args{'enable_multiple_entries'});
    }

    # query params
    if ( exists $args{'enable_multiple_votes'}) {
        $query_params->{'enableMultipleVotes'} = $self->{api_client}->to_query_value($args{'enable_multiple_votes'});
    }

    # query params
    if ( exists $args{'featured'}) {
        $query_params->{'featured'} = $self->{api_client}->to_query_value($args{'featured'});
    }

    # query params
    if ( exists $args{'winner_tag'}) {
        $query_params->{'winnerTag'} = $self->{api_client}->to_query_value($args{'winner_tag'});
    }

    # query params
    if ( exists $args{'tie_tag'}) {
        $query_params->{'tieTag'} = $self->{api_client}->to_query_value($args{'tie_tag'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('TournamentResponse', $response);
    return $_response_object;
}

#
# delete_tournament
#
# Delete Tournament
#
# @param int $account_id the id of the logged in user (required)
# @param int $mission_id the id of the mission to delete (required)
{
    my $params = {
    'account_id' => {
        data_type => 'int',
        description => 'the id of the logged in user',
        required => '1',
    },
    'mission_id' => {
        data_type => 'int',
        description => 'the id of the mission to delete',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_tournament' } = {
        summary => 'Delete Tournament',
        params => $params,
        returns => 'SirqulResponse',
        };
}
# @return SirqulResponse
#
sub delete_tournament {
    my ($self, %args) = @_;

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling delete_tournament");
    }

    # verify the required parameter 'mission_id' is set
    unless (exists $args{'mission_id'}) {
      croak("Missing the required parameter 'mission_id' when calling delete_tournament");
    }

    # parse inputs
    my $_resource_path = '/tournament/delete';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'mission_id'}) {
        $query_params->{'missionId'} = $self->{api_client}->to_query_value($args{'mission_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('SirqulResponse', $response);
    return $_response_object;
}

#
# get_tournament
#
# Get Tournament
#
# @param int $account_id The id of the logged in user (required)
# @param int $mission_id The id of the mission to return (either missionId or joinCode is required) (optional)
# @param string $join_code Optional identifier for getting the tournament (either missionId or joinCode is required) (optional)
# @param string $include_scores Determines which type of scores are returned. Possible values include: ALL, MINE (optional)
# @param int $object_preview_size Determines the max number of game objects that will get returned for each game level response (optional, default to 50)
{
    my $params = {
    'account_id' => {
        data_type => 'int',
        description => 'The id of the logged in user',
        required => '1',
    },
    'mission_id' => {
        data_type => 'int',
        description => 'The id of the mission to return (either missionId or joinCode is required)',
        required => '0',
    },
    'join_code' => {
        data_type => 'string',
        description => 'Optional identifier for getting the tournament (either missionId or joinCode is required)',
        required => '0',
    },
    'include_scores' => {
        data_type => 'string',
        description => 'Determines which type of scores are returned. Possible values include: ALL, MINE',
        required => '0',
    },
    'object_preview_size' => {
        data_type => 'int',
        description => 'Determines the max number of game objects that will get returned for each game level response',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_tournament' } = {
        summary => 'Get Tournament',
        params => $params,
        returns => 'TournamentResponse',
        };
}
# @return TournamentResponse
#
sub get_tournament {
    my ($self, %args) = @_;

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling get_tournament");
    }

    # parse inputs
    my $_resource_path = '/tournament/get';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'mission_id'}) {
        $query_params->{'missionId'} = $self->{api_client}->to_query_value($args{'mission_id'});
    }

    # query params
    if ( exists $args{'join_code'}) {
        $query_params->{'joinCode'} = $self->{api_client}->to_query_value($args{'join_code'});
    }

    # query params
    if ( exists $args{'include_scores'}) {
        $query_params->{'includeScores'} = $self->{api_client}->to_query_value($args{'include_scores'});
    }

    # query params
    if ( exists $args{'object_preview_size'}) {
        $query_params->{'objectPreviewSize'} = $self->{api_client}->to_query_value($args{'object_preview_size'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('TournamentResponse', $response);
    return $_response_object;
}

#
# search_objects
#
# Search Tournament Objects
#
# @param int $account_id the account ID (required)
# @param int $game_level_id the game level id to filter results by (required)
# @param string $sort_field the field to sort by (optional, default to 'PLAYER_SCORE_COUNT')
# @param boolean $descending determines whether the sorted list is in descending or ascending order (optional, default to true)
# @param int $start the start index for pagination (optional, default to 0)
# @param int $limit the limit for pagination (optional, default to 20)
{
    my $params = {
    'account_id' => {
        data_type => 'int',
        description => 'the account ID',
        required => '1',
    },
    'game_level_id' => {
        data_type => 'int',
        description => 'the game level id to filter results by',
        required => '1',
    },
    'sort_field' => {
        data_type => 'string',
        description => 'the field to sort by',
        required => '0',
    },
    'descending' => {
        data_type => 'boolean',
        description => 'determines whether the sorted list is in descending or ascending order',
        required => '0',
    },
    'start' => {
        data_type => 'int',
        description => 'the start index for pagination',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'the limit for pagination',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'search_objects' } = {
        summary => 'Search Tournament Objects',
        params => $params,
        returns => 'SirqulResponse',
        };
}
# @return SirqulResponse
#
sub search_objects {
    my ($self, %args) = @_;

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling search_objects");
    }

    # verify the required parameter 'game_level_id' is set
    unless (exists $args{'game_level_id'}) {
      croak("Missing the required parameter 'game_level_id' when calling search_objects");
    }

    # parse inputs
    my $_resource_path = '/tournament/object/search';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'game_level_id'}) {
        $query_params->{'gameLevelId'} = $self->{api_client}->to_query_value($args{'game_level_id'});
    }

    # query params
    if ( exists $args{'sort_field'}) {
        $query_params->{'sortField'} = $self->{api_client}->to_query_value($args{'sort_field'});
    }

    # query params
    if ( exists $args{'descending'}) {
        $query_params->{'descending'} = $self->{api_client}->to_query_value($args{'descending'});
    }

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('SirqulResponse', $response);
    return $_response_object;
}

#
# search_rounds
#
# Search Tournament Rounds
#
# @param int $account_id the account ID (required)
# @param string $app_key the application key (required)
# @param string $status comma separated list of statuses to filter results by (optional, default to 'ACCEPTED,ACTIVE')
# @param string $mission_type The style of tournament to search for, options are: TOURNAMENT, POOLPLAY (optional)
# @param boolean $current_only search for games that are flagged current only (optional, default to true)
# @param string $visibilities Filter tournament rounds by the mission visibility flag (optional, default to 'PUBLIC')
# @param int $start the start index for pagination (optional, default to 0)
# @param int $limit the limit for pagination (optional, default to 20)
{
    my $params = {
    'account_id' => {
        data_type => 'int',
        description => 'the account ID',
        required => '1',
    },
    'app_key' => {
        data_type => 'string',
        description => 'the application key',
        required => '1',
    },
    'status' => {
        data_type => 'string',
        description => 'comma separated list of statuses to filter results by',
        required => '0',
    },
    'mission_type' => {
        data_type => 'string',
        description => 'The style of tournament to search for, options are: TOURNAMENT, POOLPLAY',
        required => '0',
    },
    'current_only' => {
        data_type => 'boolean',
        description => 'search for games that are flagged current only',
        required => '0',
    },
    'visibilities' => {
        data_type => 'string',
        description => 'Filter tournament rounds by the mission visibility flag',
        required => '0',
    },
    'start' => {
        data_type => 'int',
        description => 'the start index for pagination',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'the limit for pagination',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'search_rounds' } = {
        summary => 'Search Tournament Rounds',
        params => $params,
        returns => 'SirqulResponse',
        };
}
# @return SirqulResponse
#
sub search_rounds {
    my ($self, %args) = @_;

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling search_rounds");
    }

    # verify the required parameter 'app_key' is set
    unless (exists $args{'app_key'}) {
      croak("Missing the required parameter 'app_key' when calling search_rounds");
    }

    # parse inputs
    my $_resource_path = '/tournament/round/search';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'app_key'}) {
        $query_params->{'appKey'} = $self->{api_client}->to_query_value($args{'app_key'});
    }

    # query params
    if ( exists $args{'status'}) {
        $query_params->{'status'} = $self->{api_client}->to_query_value($args{'status'});
    }

    # query params
    if ( exists $args{'mission_type'}) {
        $query_params->{'missionType'} = $self->{api_client}->to_query_value($args{'mission_type'});
    }

    # query params
    if ( exists $args{'current_only'}) {
        $query_params->{'currentOnly'} = $self->{api_client}->to_query_value($args{'current_only'});
    }

    # query params
    if ( exists $args{'visibilities'}) {
        $query_params->{'visibilities'} = $self->{api_client}->to_query_value($args{'visibilities'});
    }

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('SirqulResponse', $response);
    return $_response_object;
}

#
# search_tournaments
#
# Search Tournaments
#
# @param int $account_id The logged in user. (required)
# @param string $app_key The application key (required)
# @param string $keyword the keyword to search tournament on (optional)
# @param string $sub_type filter results by subType (optional)
# @param boolean $include_inactive whether to include inactives in the search or not (optional, default to false)
# @param string $mission_types comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (optional, default to 'MULTISTAGE,TOURNAMENT,POOLPLAY')
# @param string $filter filter tournaments by the tournament&#39;s current state (optional, default to 'UPCOMING')
# @param string $sort_field which field to sort on (optional, default to 'START_DATE')
# @param boolean $descending Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false. (optional)
# @param string $visibility Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (optional, default to 'PUBLIC')
# @param int $start Start the result set at some index. (optional, default to 0)
# @param int $limit Limit the result to some number (optional, default to 20)
{
    my $params = {
    'account_id' => {
        data_type => 'int',
        description => 'The logged in user.',
        required => '1',
    },
    'app_key' => {
        data_type => 'string',
        description => 'The application key',
        required => '1',
    },
    'keyword' => {
        data_type => 'string',
        description => 'the keyword to search tournament on',
        required => '0',
    },
    'sub_type' => {
        data_type => 'string',
        description => 'filter results by subType',
        required => '0',
    },
    'include_inactive' => {
        data_type => 'boolean',
        description => 'whether to include inactives in the search or not',
        required => '0',
    },
    'mission_types' => {
        data_type => 'string',
        description => 'comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE',
        required => '0',
    },
    'filter' => {
        data_type => 'string',
        description => 'filter tournaments by the tournament&#39;s current state',
        required => '0',
    },
    'sort_field' => {
        data_type => 'string',
        description => 'which field to sort on',
        required => '0',
    },
    'descending' => {
        data_type => 'boolean',
        description => 'Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false.',
        required => '0',
    },
    'visibility' => {
        data_type => 'string',
        description => 'Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE',
        required => '0',
    },
    'start' => {
        data_type => 'int',
        description => 'Start the result set at some index.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'Limit the result to some number',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'search_tournaments' } = {
        summary => 'Search Tournaments',
        params => $params,
        returns => 'MissionShortResponse',
        };
}
# @return MissionShortResponse
#
sub search_tournaments {
    my ($self, %args) = @_;

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling search_tournaments");
    }

    # verify the required parameter 'app_key' is set
    unless (exists $args{'app_key'}) {
      croak("Missing the required parameter 'app_key' when calling search_tournaments");
    }

    # parse inputs
    my $_resource_path = '/tournament/search';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'app_key'}) {
        $query_params->{'appKey'} = $self->{api_client}->to_query_value($args{'app_key'});
    }

    # query params
    if ( exists $args{'keyword'}) {
        $query_params->{'keyword'} = $self->{api_client}->to_query_value($args{'keyword'});
    }

    # query params
    if ( exists $args{'sub_type'}) {
        $query_params->{'subType'} = $self->{api_client}->to_query_value($args{'sub_type'});
    }

    # query params
    if ( exists $args{'include_inactive'}) {
        $query_params->{'includeInactive'} = $self->{api_client}->to_query_value($args{'include_inactive'});
    }

    # query params
    if ( exists $args{'mission_types'}) {
        $query_params->{'missionTypes'} = $self->{api_client}->to_query_value($args{'mission_types'});
    }

    # query params
    if ( exists $args{'filter'}) {
        $query_params->{'filter'} = $self->{api_client}->to_query_value($args{'filter'});
    }

    # query params
    if ( exists $args{'sort_field'}) {
        $query_params->{'sortField'} = $self->{api_client}->to_query_value($args{'sort_field'});
    }

    # query params
    if ( exists $args{'descending'}) {
        $query_params->{'descending'} = $self->{api_client}->to_query_value($args{'descending'});
    }

    # query params
    if ( exists $args{'visibility'}) {
        $query_params->{'visibility'} = $self->{api_client}->to_query_value($args{'visibility'});
    }

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('MissionShortResponse', $response);
    return $_response_object;
}

#
# submit_tournament_score
#
# Submit Tournament Score
#
# @param int $account_id The logged in user account ID. (required)
# @param string $app_key The application key. (required)
# @param int $mission_id The missionId to score for (required)
# @param int $game_id The gameId to score for (required)
# @param int $pack_id The packId to score for (required)
# @param string $scores a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60;  (required)
# @param int $game_level_id The gameLevelId to score for (optional)
{
    my $params = {
    'account_id' => {
        data_type => 'int',
        description => 'The logged in user account ID.',
        required => '1',
    },
    'app_key' => {
        data_type => 'string',
        description => 'The application key.',
        required => '1',
    },
    'mission_id' => {
        data_type => 'int',
        description => 'The missionId to score for',
        required => '1',
    },
    'game_id' => {
        data_type => 'int',
        description => 'The gameId to score for',
        required => '1',
    },
    'pack_id' => {
        data_type => 'int',
        description => 'The packId to score for',
        required => '1',
    },
    'scores' => {
        data_type => 'string',
        description => 'a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60; ',
        required => '1',
    },
    'game_level_id' => {
        data_type => 'int',
        description => 'The gameLevelId to score for',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'submit_tournament_score' } = {
        summary => 'Submit Tournament Score',
        params => $params,
        returns => 'SirqulResponse',
        };
}
# @return SirqulResponse
#
sub submit_tournament_score {
    my ($self, %args) = @_;

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling submit_tournament_score");
    }

    # verify the required parameter 'app_key' is set
    unless (exists $args{'app_key'}) {
      croak("Missing the required parameter 'app_key' when calling submit_tournament_score");
    }

    # verify the required parameter 'mission_id' is set
    unless (exists $args{'mission_id'}) {
      croak("Missing the required parameter 'mission_id' when calling submit_tournament_score");
    }

    # verify the required parameter 'game_id' is set
    unless (exists $args{'game_id'}) {
      croak("Missing the required parameter 'game_id' when calling submit_tournament_score");
    }

    # verify the required parameter 'pack_id' is set
    unless (exists $args{'pack_id'}) {
      croak("Missing the required parameter 'pack_id' when calling submit_tournament_score");
    }

    # verify the required parameter 'scores' is set
    unless (exists $args{'scores'}) {
      croak("Missing the required parameter 'scores' when calling submit_tournament_score");
    }

    # parse inputs
    my $_resource_path = '/tournament/score';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'app_key'}) {
        $query_params->{'appKey'} = $self->{api_client}->to_query_value($args{'app_key'});
    }

    # query params
    if ( exists $args{'mission_id'}) {
        $query_params->{'missionId'} = $self->{api_client}->to_query_value($args{'mission_id'});
    }

    # query params
    if ( exists $args{'game_id'}) {
        $query_params->{'gameId'} = $self->{api_client}->to_query_value($args{'game_id'});
    }

    # query params
    if ( exists $args{'pack_id'}) {
        $query_params->{'packId'} = $self->{api_client}->to_query_value($args{'pack_id'});
    }

    # query params
    if ( exists $args{'game_level_id'}) {
        $query_params->{'gameLevelId'} = $self->{api_client}->to_query_value($args{'game_level_id'});
    }

    # query params
    if ( exists $args{'scores'}) {
        $query_params->{'scores'} = $self->{api_client}->to_query_value($args{'scores'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('SirqulResponse', $response);
    return $_response_object;
}

#
# submit_tournament_vote
#
# Submit a vote for a multi-stage album tournament.
#
# @param int $account_id The logged in user. (required)
# @param string $app_key The application to target (required)
# @param int $mission_id The tournament&#39;s primary id (required)
# @param int $game_object_id The tournament game object the user wants to vote on (required)
# @param string $device_id The unique id of the device making the request (optional) (optional)
# @param boolean $check_if_device_already_voted When true, check if the device already voted to prevent duplicate votes from the same device (optional, default to false)
{
    my $params = {
    'account_id' => {
        data_type => 'int',
        description => 'The logged in user.',
        required => '1',
    },
    'app_key' => {
        data_type => 'string',
        description => 'The application to target',
        required => '1',
    },
    'mission_id' => {
        data_type => 'int',
        description => 'The tournament&#39;s primary id',
        required => '1',
    },
    'game_object_id' => {
        data_type => 'int',
        description => 'The tournament game object the user wants to vote on',
        required => '1',
    },
    'device_id' => {
        data_type => 'string',
        description => 'The unique id of the device making the request (optional)',
        required => '0',
    },
    'check_if_device_already_voted' => {
        data_type => 'boolean',
        description => 'When true, check if the device already voted to prevent duplicate votes from the same device',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'submit_tournament_vote' } = {
        summary => 'Submit a vote for a multi-stage album tournament.',
        params => $params,
        returns => 'SirqulResponse',
        };
}
# @return SirqulResponse
#
sub submit_tournament_vote {
    my ($self, %args) = @_;

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling submit_tournament_vote");
    }

    # verify the required parameter 'app_key' is set
    unless (exists $args{'app_key'}) {
      croak("Missing the required parameter 'app_key' when calling submit_tournament_vote");
    }

    # verify the required parameter 'mission_id' is set
    unless (exists $args{'mission_id'}) {
      croak("Missing the required parameter 'mission_id' when calling submit_tournament_vote");
    }

    # verify the required parameter 'game_object_id' is set
    unless (exists $args{'game_object_id'}) {
      croak("Missing the required parameter 'game_object_id' when calling submit_tournament_vote");
    }

    # parse inputs
    my $_resource_path = '/tournament/vote';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'device_id'}) {
        $query_params->{'deviceId'} = $self->{api_client}->to_query_value($args{'device_id'});
    }

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'app_key'}) {
        $query_params->{'appKey'} = $self->{api_client}->to_query_value($args{'app_key'});
    }

    # query params
    if ( exists $args{'mission_id'}) {
        $query_params->{'missionId'} = $self->{api_client}->to_query_value($args{'mission_id'});
    }

    # query params
    if ( exists $args{'game_object_id'}) {
        $query_params->{'gameObjectId'} = $self->{api_client}->to_query_value($args{'game_object_id'});
    }

    # query params
    if ( exists $args{'check_if_device_already_voted'}) {
        $query_params->{'checkIfDeviceAlreadyVoted'} = $self->{api_client}->to_query_value($args{'check_if_device_already_voted'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('SirqulResponse', $response);
    return $_response_object;
}

#
# substitute_tournament_player
#
# Substitute Tournament Player
#
# @param int $account_id the id of the logged in user (required)
# @param int $mission_id the id of the mission (required)
# @param int $pack_id the id of the pack (required)
# @param int $game_level_id the id of the game level (required)
{
    my $params = {
    'account_id' => {
        data_type => 'int',
        description => 'the id of the logged in user',
        required => '1',
    },
    'mission_id' => {
        data_type => 'int',
        description => 'the id of the mission',
        required => '1',
    },
    'pack_id' => {
        data_type => 'int',
        description => 'the id of the pack',
        required => '1',
    },
    'game_level_id' => {
        data_type => 'int',
        description => 'the id of the game level',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'substitute_tournament_player' } = {
        summary => 'Substitute Tournament Player',
        params => $params,
        returns => 'SirqulResponse',
        };
}
# @return SirqulResponse
#
sub substitute_tournament_player {
    my ($self, %args) = @_;

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling substitute_tournament_player");
    }

    # verify the required parameter 'mission_id' is set
    unless (exists $args{'mission_id'}) {
      croak("Missing the required parameter 'mission_id' when calling substitute_tournament_player");
    }

    # verify the required parameter 'pack_id' is set
    unless (exists $args{'pack_id'}) {
      croak("Missing the required parameter 'pack_id' when calling substitute_tournament_player");
    }

    # verify the required parameter 'game_level_id' is set
    unless (exists $args{'game_level_id'}) {
      croak("Missing the required parameter 'game_level_id' when calling substitute_tournament_player");
    }

    # parse inputs
    my $_resource_path = '/tournament/substitute';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'mission_id'}) {
        $query_params->{'missionId'} = $self->{api_client}->to_query_value($args{'mission_id'});
    }

    # query params
    if ( exists $args{'pack_id'}) {
        $query_params->{'packId'} = $self->{api_client}->to_query_value($args{'pack_id'});
    }

    # query params
    if ( exists $args{'game_level_id'}) {
        $query_params->{'gameLevelId'} = $self->{api_client}->to_query_value($args{'game_level_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('SirqulResponse', $response);
    return $_response_object;
}

#
# update_tournament
#
# Update Tournament
#
# @param int $account_id The logged in user. (required)
# @param int $mission_id The mission/tournament to update (required)
# @param string $title The title of the tournament (optional)
# @param string $sub_type Custom string client apps can use for searching/filtering missions (optional)
# @param int $image_asset_id The asset ID to attach to the tournament (optional)
# @param int $seconds_between_levels The number of seconds in between the start of each tournament game (optional)
# @param int $seconds_for_tie_breaker The number of seconds to extend the round end time in the case of a tie breaker (optional)
# @param int $seconds_between_packs The number of seconds in between the start of each tournament round (optional)
# @param int $maximum_level_length The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional)
# @param int $cost_to_play The number of tickets required to pay to enter the tournament (optional)
# @param string $cost_to_play_type The type of ticket required to pay (optional)
# @param int $minimum_to_play The minimum number of players required to sign up for the tournament to be played (optional)
# @param int $starting_limit The starting number of players for a tournament (filled with AI&#39;s) (optional)
# @param int $available_limit The maximum number of players for a tournament (currently 128 but not enforced) (optional)
# @param string $description The description of the tournament (optional)
# @param string $meta_data External custom client defined data (optional)
# @param int $start_date The date/time to start the tournament (optional)
# @param string $audience_ids The audiences associated with the tournament (optional)
# @param boolean $active Activate/deactivate the mission (optional)
# @param boolean $enable_buy_back Determines whether to allow players to buy back into a tournament (optional)
# @param string $offer_ids The list of offers to give as a reward beyond the tickets (optional)
# @param int $offer_asset_id The artwork ID to attach to the reward offer (optional)
# @param boolean $fixed_reward If set then do not update the ticket reward, auto set to true if offerIds provided (optional)
# @param string $split_reward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional)
# @param boolean $allocate_tickets Flag to indicate owner should receive tickets for completed missions (optional)
# @param string $tournament_data A text based string that will be passed into each tournament setup to populate the content (optional)
# @param string $visibility Sets the visibility flag for the tournament (optional)
# @param int $preliminary_groups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional)
# @param string $preliminary_group_advancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional)
# @param boolean $enable_multiple_entries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional)
# @param boolean $enable_multiple_votes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional)
# @param boolean $featured This determines whether the tournament is \&quot;featured\&quot; or not (optional)
# @param string $winner_tag This sets what analytic tag is used when a winner is determined (optional)
# @param string $tie_tag This sets what analytic tag is used when a winner is determined (optional)
{
    my $params = {
    'account_id' => {
        data_type => 'int',
        description => 'The logged in user.',
        required => '1',
    },
    'mission_id' => {
        data_type => 'int',
        description => 'The mission/tournament to update',
        required => '1',
    },
    'title' => {
        data_type => 'string',
        description => 'The title of the tournament',
        required => '0',
    },
    'sub_type' => {
        data_type => 'string',
        description => 'Custom string client apps can use for searching/filtering missions',
        required => '0',
    },
    'image_asset_id' => {
        data_type => 'int',
        description => 'The asset ID to attach to the tournament',
        required => '0',
    },
    'seconds_between_levels' => {
        data_type => 'int',
        description => 'The number of seconds in between the start of each tournament game',
        required => '0',
    },
    'seconds_for_tie_breaker' => {
        data_type => 'int',
        description => 'The number of seconds to extend the round end time in the case of a tie breaker',
        required => '0',
    },
    'seconds_between_packs' => {
        data_type => 'int',
        description => 'The number of seconds in between the start of each tournament round',
        required => '0',
    },
    'maximum_level_length' => {
        data_type => 'int',
        description => 'The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity',
        required => '0',
    },
    'cost_to_play' => {
        data_type => 'int',
        description => 'The number of tickets required to pay to enter the tournament',
        required => '0',
    },
    'cost_to_play_type' => {
        data_type => 'string',
        description => 'The type of ticket required to pay',
        required => '0',
    },
    'minimum_to_play' => {
        data_type => 'int',
        description => 'The minimum number of players required to sign up for the tournament to be played',
        required => '0',
    },
    'starting_limit' => {
        data_type => 'int',
        description => 'The starting number of players for a tournament (filled with AI&#39;s)',
        required => '0',
    },
    'available_limit' => {
        data_type => 'int',
        description => 'The maximum number of players for a tournament (currently 128 but not enforced)',
        required => '0',
    },
    'description' => {
        data_type => 'string',
        description => 'The description of the tournament',
        required => '0',
    },
    'meta_data' => {
        data_type => 'string',
        description => 'External custom client defined data',
        required => '0',
    },
    'start_date' => {
        data_type => 'int',
        description => 'The date/time to start the tournament',
        required => '0',
    },
    'audience_ids' => {
        data_type => 'string',
        description => 'The audiences associated with the tournament',
        required => '0',
    },
    'active' => {
        data_type => 'boolean',
        description => 'Activate/deactivate the mission',
        required => '0',
    },
    'enable_buy_back' => {
        data_type => 'boolean',
        description => 'Determines whether to allow players to buy back into a tournament',
        required => '0',
    },
    'offer_ids' => {
        data_type => 'string',
        description => 'The list of offers to give as a reward beyond the tickets',
        required => '0',
    },
    'offer_asset_id' => {
        data_type => 'int',
        description => 'The artwork ID to attach to the reward offer',
        required => '0',
    },
    'fixed_reward' => {
        data_type => 'boolean',
        description => 'If set then do not update the ticket reward, auto set to true if offerIds provided',
        required => '0',
    },
    'split_reward' => {
        data_type => 'string',
        description => 'Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored',
        required => '0',
    },
    'allocate_tickets' => {
        data_type => 'boolean',
        description => 'Flag to indicate owner should receive tickets for completed missions',
        required => '0',
    },
    'tournament_data' => {
        data_type => 'string',
        description => 'A text based string that will be passed into each tournament setup to populate the content',
        required => '0',
    },
    'visibility' => {
        data_type => 'string',
        description => 'Sets the visibility flag for the tournament',
        required => '0',
    },
    'preliminary_groups' => {
        data_type => 'int',
        description => 'The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)',
        required => '0',
    },
    'preliminary_group_advancements' => {
        data_type => 'string',
        description => 'This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)',
        required => '0',
    },
    'enable_multiple_entries' => {
        data_type => 'boolean',
        description => 'This determines if multiple submissions/entries are allowed in a multi-stage album tournament',
        required => '0',
    },
    'enable_multiple_votes' => {
        data_type => 'boolean',
        description => 'This determines if users are allowed to vote multiple times per group in a multi-stage album tournament',
        required => '0',
    },
    'featured' => {
        data_type => 'boolean',
        description => 'This determines whether the tournament is \&quot;featured\&quot; or not',
        required => '0',
    },
    'winner_tag' => {
        data_type => 'string',
        description => 'This sets what analytic tag is used when a winner is determined',
        required => '0',
    },
    'tie_tag' => {
        data_type => 'string',
        description => 'This sets what analytic tag is used when a winner is determined',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'update_tournament' } = {
        summary => 'Update Tournament',
        params => $params,
        returns => 'TournamentResponse',
        };
}
# @return TournamentResponse
#
sub update_tournament {
    my ($self, %args) = @_;

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling update_tournament");
    }

    # verify the required parameter 'mission_id' is set
    unless (exists $args{'mission_id'}) {
      croak("Missing the required parameter 'mission_id' when calling update_tournament");
    }

    # parse inputs
    my $_resource_path = '/tournament/update';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'mission_id'}) {
        $query_params->{'missionId'} = $self->{api_client}->to_query_value($args{'mission_id'});
    }

    # query params
    if ( exists $args{'title'}) {
        $query_params->{'title'} = $self->{api_client}->to_query_value($args{'title'});
    }

    # query params
    if ( exists $args{'sub_type'}) {
        $query_params->{'subType'} = $self->{api_client}->to_query_value($args{'sub_type'});
    }

    # query params
    if ( exists $args{'image_asset_id'}) {
        $query_params->{'imageAssetId'} = $self->{api_client}->to_query_value($args{'image_asset_id'});
    }

    # query params
    if ( exists $args{'seconds_between_levels'}) {
        $query_params->{'secondsBetweenLevels'} = $self->{api_client}->to_query_value($args{'seconds_between_levels'});
    }

    # query params
    if ( exists $args{'seconds_for_tie_breaker'}) {
        $query_params->{'secondsForTieBreaker'} = $self->{api_client}->to_query_value($args{'seconds_for_tie_breaker'});
    }

    # query params
    if ( exists $args{'seconds_between_packs'}) {
        $query_params->{'secondsBetweenPacks'} = $self->{api_client}->to_query_value($args{'seconds_between_packs'});
    }

    # query params
    if ( exists $args{'maximum_level_length'}) {
        $query_params->{'maximumLevelLength'} = $self->{api_client}->to_query_value($args{'maximum_level_length'});
    }

    # query params
    if ( exists $args{'cost_to_play'}) {
        $query_params->{'costToPlay'} = $self->{api_client}->to_query_value($args{'cost_to_play'});
    }

    # query params
    if ( exists $args{'cost_to_play_type'}) {
        $query_params->{'costToPlayType'} = $self->{api_client}->to_query_value($args{'cost_to_play_type'});
    }

    # query params
    if ( exists $args{'minimum_to_play'}) {
        $query_params->{'minimumToPlay'} = $self->{api_client}->to_query_value($args{'minimum_to_play'});
    }

    # query params
    if ( exists $args{'starting_limit'}) {
        $query_params->{'startingLimit'} = $self->{api_client}->to_query_value($args{'starting_limit'});
    }

    # query params
    if ( exists $args{'available_limit'}) {
        $query_params->{'availableLimit'} = $self->{api_client}->to_query_value($args{'available_limit'});
    }

    # query params
    if ( exists $args{'description'}) {
        $query_params->{'description'} = $self->{api_client}->to_query_value($args{'description'});
    }

    # query params
    if ( exists $args{'meta_data'}) {
        $query_params->{'metaData'} = $self->{api_client}->to_query_value($args{'meta_data'});
    }

    # query params
    if ( exists $args{'start_date'}) {
        $query_params->{'startDate'} = $self->{api_client}->to_query_value($args{'start_date'});
    }

    # query params
    if ( exists $args{'audience_ids'}) {
        $query_params->{'audienceIds'} = $self->{api_client}->to_query_value($args{'audience_ids'});
    }

    # query params
    if ( exists $args{'active'}) {
        $query_params->{'active'} = $self->{api_client}->to_query_value($args{'active'});
    }

    # query params
    if ( exists $args{'enable_buy_back'}) {
        $query_params->{'enableBuyBack'} = $self->{api_client}->to_query_value($args{'enable_buy_back'});
    }

    # query params
    if ( exists $args{'offer_ids'}) {
        $query_params->{'offerIds'} = $self->{api_client}->to_query_value($args{'offer_ids'});
    }

    # query params
    if ( exists $args{'offer_asset_id'}) {
        $query_params->{'offerAssetId'} = $self->{api_client}->to_query_value($args{'offer_asset_id'});
    }

    # query params
    if ( exists $args{'fixed_reward'}) {
        $query_params->{'fixedReward'} = $self->{api_client}->to_query_value($args{'fixed_reward'});
    }

    # query params
    if ( exists $args{'split_reward'}) {
        $query_params->{'splitReward'} = $self->{api_client}->to_query_value($args{'split_reward'});
    }

    # query params
    if ( exists $args{'allocate_tickets'}) {
        $query_params->{'allocateTickets'} = $self->{api_client}->to_query_value($args{'allocate_tickets'});
    }

    # query params
    if ( exists $args{'tournament_data'}) {
        $query_params->{'tournamentData'} = $self->{api_client}->to_query_value($args{'tournament_data'});
    }

    # query params
    if ( exists $args{'visibility'}) {
        $query_params->{'visibility'} = $self->{api_client}->to_query_value($args{'visibility'});
    }

    # query params
    if ( exists $args{'preliminary_groups'}) {
        $query_params->{'preliminaryGroups'} = $self->{api_client}->to_query_value($args{'preliminary_groups'});
    }

    # query params
    if ( exists $args{'preliminary_group_advancements'}) {
        $query_params->{'preliminaryGroupAdvancements'} = $self->{api_client}->to_query_value($args{'preliminary_group_advancements'});
    }

    # query params
    if ( exists $args{'enable_multiple_entries'}) {
        $query_params->{'enableMultipleEntries'} = $self->{api_client}->to_query_value($args{'enable_multiple_entries'});
    }

    # query params
    if ( exists $args{'enable_multiple_votes'}) {
        $query_params->{'enableMultipleVotes'} = $self->{api_client}->to_query_value($args{'enable_multiple_votes'});
    }

    # query params
    if ( exists $args{'featured'}) {
        $query_params->{'featured'} = $self->{api_client}->to_query_value($args{'featured'});
    }

    # query params
    if ( exists $args{'winner_tag'}) {
        $query_params->{'winnerTag'} = $self->{api_client}->to_query_value($args{'winner_tag'});
    }

    # query params
    if ( exists $args{'tie_tag'}) {
        $query_params->{'tieTag'} = $self->{api_client}->to_query_value($args{'tie_tag'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('TournamentResponse', $response);
    return $_response_object;
}

1;
