=begin comment

Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

The version of the OpenAPI document: 3.16
Contact: info@sirqul.com
Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package WWW::OpenAPIClient::TrackingApi;

require 5.6.0;
use strict;
use warnings;
use utf8;
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use WWW::OpenAPIClient::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'WWW::OpenAPIClient::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = WWW::OpenAPIClient::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# batch_save_tracking
#
# Create Batch Tracking
#
# @param string $data JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60;  (required)
# @param string $device_id the device id (deviceId or accountId required) (optional)
# @param int $account_id the account id of the user (deviceId or accountId required) (optional)
# @param boolean $generate_accounts Whether to generate accounts for tracking entries when the owner does not exist (optional)
# @param boolean $update_account_locations Whether to update the account&#39;s current location from the incoming tracking data (optional)
# @param string $default_tag The default tag to apply to incoming legs when no tag is provided (optional, default to 'PASSIVE')
# @param string $slave_uid  (optional)
{
    my $params = {
    'data' => {
        data_type => 'string',
        description => 'JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60; ',
        required => '1',
    },
    'device_id' => {
        data_type => 'string',
        description => 'the device id (deviceId or accountId required)',
        required => '0',
    },
    'account_id' => {
        data_type => 'int',
        description => 'the account id of the user (deviceId or accountId required)',
        required => '0',
    },
    'generate_accounts' => {
        data_type => 'boolean',
        description => 'Whether to generate accounts for tracking entries when the owner does not exist',
        required => '0',
    },
    'update_account_locations' => {
        data_type => 'boolean',
        description => 'Whether to update the account&#39;s current location from the incoming tracking data',
        required => '0',
    },
    'default_tag' => {
        data_type => 'string',
        description => 'The default tag to apply to incoming legs when no tag is provided',
        required => '0',
    },
    'slave_uid' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'batch_save_tracking' } = {
        summary => 'Create Batch Tracking',
        params => $params,
        returns => 'ARRAY[Leg]',
        };
}
# @return ARRAY[Leg]
#
sub batch_save_tracking {
    my ($self, %args) = @_;

    # verify the required parameter 'data' is set
    unless (exists $args{'data'}) {
      croak("Missing the required parameter 'data' when calling batch_save_tracking");
    }

    # parse inputs
    my $_resource_path = '/tracking/batch/create';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'device_id'}) {
        $query_params->{'deviceId'} = $self->{api_client}->to_query_value($args{'device_id'});
    }

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'data'}) {
        $query_params->{'data'} = $self->{api_client}->to_query_value($args{'data'});
    }

    # query params
    if ( exists $args{'generate_accounts'}) {
        $query_params->{'generateAccounts'} = $self->{api_client}->to_query_value($args{'generate_accounts'});
    }

    # query params
    if ( exists $args{'update_account_locations'}) {
        $query_params->{'updateAccountLocations'} = $self->{api_client}->to_query_value($args{'update_account_locations'});
    }

    # query params
    if ( exists $args{'default_tag'}) {
        $query_params->{'defaultTag'} = $self->{api_client}->to_query_value($args{'default_tag'});
    }

    # query params
    if ( exists $args{'slave_uid'}) {
        $query_params->{'slaveUID'} = $self->{api_client}->to_query_value($args{'slave_uid'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[Leg]', $response);
    return $_response_object;
}

#
# get_predicted_locations
#
# Get Predicted Locations
#
# @param int $account_id The account id of the customer (required)
# @param double $latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
# @param double $longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
# @param int $date_check Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)
# @param string $hour_check Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
# @param int $threshold The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1)
# @param string $distance_unit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to 'MILES')
# @param double $search_range Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
# @param string $sort_order The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to 'MATCHES')
{
    my $params = {
    'account_id' => {
        data_type => 'int',
        description => 'The account id of the customer',
        required => '1',
    },
    'latitude' => {
        data_type => 'double',
        description => 'latitude to return a more likely result set based on the user&#39;s current location',
        required => '0',
    },
    'longitude' => {
        data_type => 'double',
        description => 'longitude to return a more likely result set based on the user&#39;s current location',
        required => '0',
    },
    'date_check' => {
        data_type => 'int',
        description => 'Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used.',
        required => '0',
    },
    'hour_check' => {
        data_type => 'string',
        description => 'Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;.',
        required => '0',
    },
    'threshold' => {
        data_type => 'int',
        description => 'The minimum number matches in 1 hour to be considered a likely location.',
        required => '0',
    },
    'distance_unit' => {
        data_type => 'string',
        description => 'Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}',
        required => '0',
    },
    'search_range' => {
        data_type => 'double',
        description => 'Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction.',
        required => '0',
    },
    'sort_order' => {
        data_type => 'string',
        description => 'The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED}',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_predicted_locations' } = {
        summary => 'Get Predicted Locations',
        params => $params,
        returns => 'PredictedLocationResponse',
        };
}
# @return PredictedLocationResponse
#
sub get_predicted_locations {
    my ($self, %args) = @_;

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling get_predicted_locations");
    }

    # parse inputs
    my $_resource_path = '/tracking/predicted/get';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'latitude'}) {
        $query_params->{'latitude'} = $self->{api_client}->to_query_value($args{'latitude'});
    }

    # query params
    if ( exists $args{'longitude'}) {
        $query_params->{'longitude'} = $self->{api_client}->to_query_value($args{'longitude'});
    }

    # query params
    if ( exists $args{'date_check'}) {
        $query_params->{'dateCheck'} = $self->{api_client}->to_query_value($args{'date_check'});
    }

    # query params
    if ( exists $args{'hour_check'}) {
        $query_params->{'hourCheck'} = $self->{api_client}->to_query_value($args{'hour_check'});
    }

    # query params
    if ( exists $args{'threshold'}) {
        $query_params->{'threshold'} = $self->{api_client}->to_query_value($args{'threshold'});
    }

    # query params
    if ( exists $args{'distance_unit'}) {
        $query_params->{'distanceUnit'} = $self->{api_client}->to_query_value($args{'distance_unit'});
    }

    # query params
    if ( exists $args{'search_range'}) {
        $query_params->{'searchRange'} = $self->{api_client}->to_query_value($args{'search_range'});
    }

    # query params
    if ( exists $args{'sort_order'}) {
        $query_params->{'sortOrder'} = $self->{api_client}->to_query_value($args{'sort_order'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PredictedLocationResponse', $response);
    return $_response_object;
}

#
# get_predicted_path
#
# Get Tracking Path
#
# @param int $account_id The account id of the customer (required)
# @param int $start_step_id The stepId to begin from (required)
# @param int $end_step_id The stepId to end with (required)
{
    my $params = {
    'account_id' => {
        data_type => 'int',
        description => 'The account id of the customer',
        required => '1',
    },
    'start_step_id' => {
        data_type => 'int',
        description => 'The stepId to begin from',
        required => '1',
    },
    'end_step_id' => {
        data_type => 'int',
        description => 'The stepId to end with',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_predicted_path' } = {
        summary => 'Get Tracking Path',
        params => $params,
        returns => 'ARRAY[StepResponse]',
        };
}
# @return ARRAY[StepResponse]
#
sub get_predicted_path {
    my ($self, %args) = @_;

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling get_predicted_path");
    }

    # verify the required parameter 'start_step_id' is set
    unless (exists $args{'start_step_id'}) {
      croak("Missing the required parameter 'start_step_id' when calling get_predicted_path");
    }

    # verify the required parameter 'end_step_id' is set
    unless (exists $args{'end_step_id'}) {
      croak("Missing the required parameter 'end_step_id' when calling get_predicted_path");
    }

    # parse inputs
    my $_resource_path = '/tracking/path/get';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'start_step_id'}) {
        $query_params->{'startStepId'} = $self->{api_client}->to_query_value($args{'start_step_id'});
    }

    # query params
    if ( exists $args{'end_step_id'}) {
        $query_params->{'endStepId'} = $self->{api_client}->to_query_value($args{'end_step_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[StepResponse]', $response);
    return $_response_object;
}

#
# get_preferred_locations
#
# Search Preferred Locations
#
# @param int $account_id The account id of the customer (required)
# @param double $latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
# @param double $longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
# @param int $date_check Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)
# @param string $hour_check Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
# @param string $sort_field Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to 'PREFERRED_DATE')
# @param boolean $descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
# @param int $start The start index for pagination (optional, default to 0)
# @param int $limit The limit for pagination (optional, default to 20)
# @param double $search_range Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
# @param string $distance_unit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to 'MILES')
{
    my $params = {
    'account_id' => {
        data_type => 'int',
        description => 'The account id of the customer',
        required => '1',
    },
    'latitude' => {
        data_type => 'double',
        description => 'latitude to return a more likely result set based on the user&#39;s current location',
        required => '0',
    },
    'longitude' => {
        data_type => 'double',
        description => 'longitude to return a more likely result set based on the user&#39;s current location',
        required => '0',
    },
    'date_check' => {
        data_type => 'int',
        description => 'Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.',
        required => '0',
    },
    'hour_check' => {
        data_type => 'string',
        description => 'Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;.',
        required => '0',
    },
    'sort_field' => {
        data_type => 'string',
        description => 'Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location',
        required => '0',
    },
    'descending' => {
        data_type => 'boolean',
        description => 'Determines whether the sorted list is in descending or ascending order',
        required => '0',
    },
    'start' => {
        data_type => 'int',
        description => 'The start index for pagination',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'The limit for pagination',
        required => '0',
    },
    'search_range' => {
        data_type => 'double',
        description => 'Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction.',
        required => '0',
    },
    'distance_unit' => {
        data_type => 'string',
        description => 'Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_preferred_locations' } = {
        summary => 'Search Preferred Locations',
        params => $params,
        returns => 'ARRAY[PreferredLocationResponse]',
        };
}
# @return ARRAY[PreferredLocationResponse]
#
sub get_preferred_locations {
    my ($self, %args) = @_;

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling get_preferred_locations");
    }

    # parse inputs
    my $_resource_path = '/tracking/preferred/search';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'latitude'}) {
        $query_params->{'latitude'} = $self->{api_client}->to_query_value($args{'latitude'});
    }

    # query params
    if ( exists $args{'longitude'}) {
        $query_params->{'longitude'} = $self->{api_client}->to_query_value($args{'longitude'});
    }

    # query params
    if ( exists $args{'date_check'}) {
        $query_params->{'dateCheck'} = $self->{api_client}->to_query_value($args{'date_check'});
    }

    # query params
    if ( exists $args{'hour_check'}) {
        $query_params->{'hourCheck'} = $self->{api_client}->to_query_value($args{'hour_check'});
    }

    # query params
    if ( exists $args{'sort_field'}) {
        $query_params->{'sortField'} = $self->{api_client}->to_query_value($args{'sort_field'});
    }

    # query params
    if ( exists $args{'descending'}) {
        $query_params->{'descending'} = $self->{api_client}->to_query_value($args{'descending'});
    }

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'search_range'}) {
        $query_params->{'searchRange'} = $self->{api_client}->to_query_value($args{'search_range'});
    }

    # query params
    if ( exists $args{'distance_unit'}) {
        $query_params->{'distanceUnit'} = $self->{api_client}->to_query_value($args{'distance_unit'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[PreferredLocationResponse]', $response);
    return $_response_object;
}

#
# get_tracking_legs
#
# Search Tracking
#
# @param string $device_id the device id (deviceId or accountId required) (optional)
# @param int $account_id the account id of the user (deviceId or accountId required) (optional)
# @param int $owner_id the account id of the person the user wants to tracking data for (optional)
# @param string $tracking_device_id the id of the tracking device (optional)
# @param int $start_date the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)
# @param int $end_date the end date in (UTC milliseconds) to filter the tracking results (optional)
# @param string $tags filter results by tag (optional)
# @param boolean $get_last_point gets the last known location of the user (optional, default to false)
{
    my $params = {
    'device_id' => {
        data_type => 'string',
        description => 'the device id (deviceId or accountId required)',
        required => '0',
    },
    'account_id' => {
        data_type => 'int',
        description => 'the account id of the user (deviceId or accountId required)',
        required => '0',
    },
    'owner_id' => {
        data_type => 'int',
        description => 'the account id of the person the user wants to tracking data for',
        required => '0',
    },
    'tracking_device_id' => {
        data_type => 'string',
        description => 'the id of the tracking device',
        required => '0',
    },
    'start_date' => {
        data_type => 'int',
        description => 'the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.',
        required => '0',
    },
    'end_date' => {
        data_type => 'int',
        description => 'the end date in (UTC milliseconds) to filter the tracking results',
        required => '0',
    },
    'tags' => {
        data_type => 'string',
        description => 'filter results by tag',
        required => '0',
    },
    'get_last_point' => {
        data_type => 'boolean',
        description => 'gets the last known location of the user',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_tracking_legs' } = {
        summary => 'Search Tracking',
        params => $params,
        returns => 'ARRAY[LegResponse]',
        };
}
# @return ARRAY[LegResponse]
#
sub get_tracking_legs {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/tracking/search';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'device_id'}) {
        $query_params->{'deviceId'} = $self->{api_client}->to_query_value($args{'device_id'});
    }

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'owner_id'}) {
        $query_params->{'ownerId'} = $self->{api_client}->to_query_value($args{'owner_id'});
    }

    # query params
    if ( exists $args{'tracking_device_id'}) {
        $query_params->{'trackingDeviceId'} = $self->{api_client}->to_query_value($args{'tracking_device_id'});
    }

    # query params
    if ( exists $args{'start_date'}) {
        $query_params->{'startDate'} = $self->{api_client}->to_query_value($args{'start_date'});
    }

    # query params
    if ( exists $args{'end_date'}) {
        $query_params->{'endDate'} = $self->{api_client}->to_query_value($args{'end_date'});
    }

    # query params
    if ( exists $args{'tags'}) {
        $query_params->{'tags'} = $self->{api_client}->to_query_value($args{'tags'});
    }

    # query params
    if ( exists $args{'get_last_point'}) {
        $query_params->{'getLastPoint'} = $self->{api_client}->to_query_value($args{'get_last_point'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[LegResponse]', $response);
    return $_response_object;
}

#
# save_tracking_leg
#
# Create Tracking Leg
#
# @param double $start_lat the latitude of the first point (required)
# @param double $start_lng the longitude of the first point (required)
# @param int $start_date the start date (in UTC milliseconds) of the first point (required)
# @param double $end_lat the latitude of the last point (required)
# @param double $end_lng the longitude of the last point (required)
# @param int $end_date the end date (in UTC milliseconds) of the last point (required)
# @param string $device_id the device id (deviceId or accountId required) (optional)
# @param int $account_id the account id of the user (deviceId or accountId required) (optional)
# @param double $distance the total distance (optional)
# @param int $duration the total duration (optional)
# @param string $steps JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60;  (optional)
# @param string $tags name the leg for searching (optional)
{
    my $params = {
    'start_lat' => {
        data_type => 'double',
        description => 'the latitude of the first point',
        required => '1',
    },
    'start_lng' => {
        data_type => 'double',
        description => 'the longitude of the first point',
        required => '1',
    },
    'start_date' => {
        data_type => 'int',
        description => 'the start date (in UTC milliseconds) of the first point',
        required => '1',
    },
    'end_lat' => {
        data_type => 'double',
        description => 'the latitude of the last point',
        required => '1',
    },
    'end_lng' => {
        data_type => 'double',
        description => 'the longitude of the last point',
        required => '1',
    },
    'end_date' => {
        data_type => 'int',
        description => 'the end date (in UTC milliseconds) of the last point',
        required => '1',
    },
    'device_id' => {
        data_type => 'string',
        description => 'the device id (deviceId or accountId required)',
        required => '0',
    },
    'account_id' => {
        data_type => 'int',
        description => 'the account id of the user (deviceId or accountId required)',
        required => '0',
    },
    'distance' => {
        data_type => 'double',
        description => 'the total distance',
        required => '0',
    },
    'duration' => {
        data_type => 'int',
        description => 'the total duration',
        required => '0',
    },
    'steps' => {
        data_type => 'string',
        description => 'JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60; ',
        required => '0',
    },
    'tags' => {
        data_type => 'string',
        description => 'name the leg for searching',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'save_tracking_leg' } = {
        summary => 'Create Tracking Leg',
        params => $params,
        returns => 'SirqulResponse',
        };
}
# @return SirqulResponse
#
sub save_tracking_leg {
    my ($self, %args) = @_;

    # verify the required parameter 'start_lat' is set
    unless (exists $args{'start_lat'}) {
      croak("Missing the required parameter 'start_lat' when calling save_tracking_leg");
    }

    # verify the required parameter 'start_lng' is set
    unless (exists $args{'start_lng'}) {
      croak("Missing the required parameter 'start_lng' when calling save_tracking_leg");
    }

    # verify the required parameter 'start_date' is set
    unless (exists $args{'start_date'}) {
      croak("Missing the required parameter 'start_date' when calling save_tracking_leg");
    }

    # verify the required parameter 'end_lat' is set
    unless (exists $args{'end_lat'}) {
      croak("Missing the required parameter 'end_lat' when calling save_tracking_leg");
    }

    # verify the required parameter 'end_lng' is set
    unless (exists $args{'end_lng'}) {
      croak("Missing the required parameter 'end_lng' when calling save_tracking_leg");
    }

    # verify the required parameter 'end_date' is set
    unless (exists $args{'end_date'}) {
      croak("Missing the required parameter 'end_date' when calling save_tracking_leg");
    }

    # parse inputs
    my $_resource_path = '/tracking/leg/create';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'device_id'}) {
        $query_params->{'deviceId'} = $self->{api_client}->to_query_value($args{'device_id'});
    }

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'distance'}) {
        $query_params->{'distance'} = $self->{api_client}->to_query_value($args{'distance'});
    }

    # query params
    if ( exists $args{'duration'}) {
        $query_params->{'duration'} = $self->{api_client}->to_query_value($args{'duration'});
    }

    # query params
    if ( exists $args{'start_lat'}) {
        $query_params->{'startLat'} = $self->{api_client}->to_query_value($args{'start_lat'});
    }

    # query params
    if ( exists $args{'start_lng'}) {
        $query_params->{'startLng'} = $self->{api_client}->to_query_value($args{'start_lng'});
    }

    # query params
    if ( exists $args{'start_date'}) {
        $query_params->{'startDate'} = $self->{api_client}->to_query_value($args{'start_date'});
    }

    # query params
    if ( exists $args{'end_lat'}) {
        $query_params->{'endLat'} = $self->{api_client}->to_query_value($args{'end_lat'});
    }

    # query params
    if ( exists $args{'end_lng'}) {
        $query_params->{'endLng'} = $self->{api_client}->to_query_value($args{'end_lng'});
    }

    # query params
    if ( exists $args{'end_date'}) {
        $query_params->{'endDate'} = $self->{api_client}->to_query_value($args{'end_date'});
    }

    # query params
    if ( exists $args{'steps'}) {
        $query_params->{'steps'} = $self->{api_client}->to_query_value($args{'steps'});
    }

    # query params
    if ( exists $args{'tags'}) {
        $query_params->{'tags'} = $self->{api_client}->to_query_value($args{'tags'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('SirqulResponse', $response);
    return $_response_object;
}

#
# save_tracking_step
#
# Create Tracking Step
#
# @param int $leg_id the leg to add the step to (required)
# @param double $start_lat the latitude of the first point (required)
# @param double $start_lng the longitude of the first point (required)
# @param int $start_date the start date (in UTC milliseconds) of the first point (required)
# @param double $end_lat the latitude of the last point (required)
# @param double $end_lng the longitude of the last point (required)
# @param int $end_date the end date (in UTC milliseconds) of the last point (required)
# @param string $device_id the device id (deviceId or accountId required) (optional)
# @param int $account_id the account id of the user (deviceId or accountId required) (optional)
# @param double $distance the total distance (optional)
# @param int $duration the total duration (optional)
{
    my $params = {
    'leg_id' => {
        data_type => 'int',
        description => 'the leg to add the step to',
        required => '1',
    },
    'start_lat' => {
        data_type => 'double',
        description => 'the latitude of the first point',
        required => '1',
    },
    'start_lng' => {
        data_type => 'double',
        description => 'the longitude of the first point',
        required => '1',
    },
    'start_date' => {
        data_type => 'int',
        description => 'the start date (in UTC milliseconds) of the first point',
        required => '1',
    },
    'end_lat' => {
        data_type => 'double',
        description => 'the latitude of the last point',
        required => '1',
    },
    'end_lng' => {
        data_type => 'double',
        description => 'the longitude of the last point',
        required => '1',
    },
    'end_date' => {
        data_type => 'int',
        description => 'the end date (in UTC milliseconds) of the last point',
        required => '1',
    },
    'device_id' => {
        data_type => 'string',
        description => 'the device id (deviceId or accountId required)',
        required => '0',
    },
    'account_id' => {
        data_type => 'int',
        description => 'the account id of the user (deviceId or accountId required)',
        required => '0',
    },
    'distance' => {
        data_type => 'double',
        description => 'the total distance',
        required => '0',
    },
    'duration' => {
        data_type => 'int',
        description => 'the total duration',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'save_tracking_step' } = {
        summary => 'Create Tracking Step',
        params => $params,
        returns => 'SirqulResponse',
        };
}
# @return SirqulResponse
#
sub save_tracking_step {
    my ($self, %args) = @_;

    # verify the required parameter 'leg_id' is set
    unless (exists $args{'leg_id'}) {
      croak("Missing the required parameter 'leg_id' when calling save_tracking_step");
    }

    # verify the required parameter 'start_lat' is set
    unless (exists $args{'start_lat'}) {
      croak("Missing the required parameter 'start_lat' when calling save_tracking_step");
    }

    # verify the required parameter 'start_lng' is set
    unless (exists $args{'start_lng'}) {
      croak("Missing the required parameter 'start_lng' when calling save_tracking_step");
    }

    # verify the required parameter 'start_date' is set
    unless (exists $args{'start_date'}) {
      croak("Missing the required parameter 'start_date' when calling save_tracking_step");
    }

    # verify the required parameter 'end_lat' is set
    unless (exists $args{'end_lat'}) {
      croak("Missing the required parameter 'end_lat' when calling save_tracking_step");
    }

    # verify the required parameter 'end_lng' is set
    unless (exists $args{'end_lng'}) {
      croak("Missing the required parameter 'end_lng' when calling save_tracking_step");
    }

    # verify the required parameter 'end_date' is set
    unless (exists $args{'end_date'}) {
      croak("Missing the required parameter 'end_date' when calling save_tracking_step");
    }

    # parse inputs
    my $_resource_path = '/tracking/step/create';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'device_id'}) {
        $query_params->{'deviceId'} = $self->{api_client}->to_query_value($args{'device_id'});
    }

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'leg_id'}) {
        $query_params->{'legId'} = $self->{api_client}->to_query_value($args{'leg_id'});
    }

    # query params
    if ( exists $args{'distance'}) {
        $query_params->{'distance'} = $self->{api_client}->to_query_value($args{'distance'});
    }

    # query params
    if ( exists $args{'duration'}) {
        $query_params->{'duration'} = $self->{api_client}->to_query_value($args{'duration'});
    }

    # query params
    if ( exists $args{'start_lat'}) {
        $query_params->{'startLat'} = $self->{api_client}->to_query_value($args{'start_lat'});
    }

    # query params
    if ( exists $args{'start_lng'}) {
        $query_params->{'startLng'} = $self->{api_client}->to_query_value($args{'start_lng'});
    }

    # query params
    if ( exists $args{'start_date'}) {
        $query_params->{'startDate'} = $self->{api_client}->to_query_value($args{'start_date'});
    }

    # query params
    if ( exists $args{'end_lat'}) {
        $query_params->{'endLat'} = $self->{api_client}->to_query_value($args{'end_lat'});
    }

    # query params
    if ( exists $args{'end_lng'}) {
        $query_params->{'endLng'} = $self->{api_client}->to_query_value($args{'end_lng'});
    }

    # query params
    if ( exists $args{'end_date'}) {
        $query_params->{'endDate'} = $self->{api_client}->to_query_value($args{'end_date'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('SirqulResponse', $response);
    return $_response_object;
}

#
# search_accounts_with_tracking_legs
#
# List Tracking
#
# @param int $account_id The account id of the user (required)
# @param string $keyword Used for LIKE search of first or last name on the acocunt (optional)
# @param int $start_date Range to begin in UTC milliseconds (optional)
# @param int $end_date Range to end in UTC milliseconds (optional)
# @param string $tags Exact match on tag field of Legs&#39;s searchTag (optional)
# @param string $audience_ids  (optional)
# @param double $latitude Origin latitude to perform searching constraints with given range (optional)
# @param double $longitude Origin longitude to perform searching constraints with given range (optional)
# @param double $range The radius, in miles, to perform the search for (optional, default to 5)
# @param string $sort_field The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to 'LEG_START_DATE')
# @param boolean $descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)
# @param int $start The index into the record set to start with. Default is 0. (optional, default to 0)
# @param int $limit The total number of records to return. Default is 20. (optional, default to 20)
# @param boolean $active_only Determines whether to return only active results. Default is false. (optional, default to false)
{
    my $params = {
    'account_id' => {
        data_type => 'int',
        description => 'The account id of the user',
        required => '1',
    },
    'keyword' => {
        data_type => 'string',
        description => 'Used for LIKE search of first or last name on the acocunt',
        required => '0',
    },
    'start_date' => {
        data_type => 'int',
        description => 'Range to begin in UTC milliseconds',
        required => '0',
    },
    'end_date' => {
        data_type => 'int',
        description => 'Range to end in UTC milliseconds',
        required => '0',
    },
    'tags' => {
        data_type => 'string',
        description => 'Exact match on tag field of Legs&#39;s searchTag',
        required => '0',
    },
    'audience_ids' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'latitude' => {
        data_type => 'double',
        description => 'Origin latitude to perform searching constraints with given range',
        required => '0',
    },
    'longitude' => {
        data_type => 'double',
        description => 'Origin longitude to perform searching constraints with given range',
        required => '0',
    },
    'range' => {
        data_type => 'double',
        description => 'The radius, in miles, to perform the search for',
        required => '0',
    },
    'sort_field' => {
        data_type => 'string',
        description => 'The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY}',
        required => '0',
    },
    'descending' => {
        data_type => 'boolean',
        description => 'The order to return the results. Default is false, which will return the results in ascending order.',
        required => '0',
    },
    'start' => {
        data_type => 'int',
        description => 'The index into the record set to start with. Default is 0.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'The total number of records to return. Default is 20.',
        required => '0',
    },
    'active_only' => {
        data_type => 'boolean',
        description => 'Determines whether to return only active results. Default is false.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'search_accounts_with_tracking_legs' } = {
        summary => 'List Tracking',
        params => $params,
        returns => 'ARRAY[AccountMiniResponse]',
        };
}
# @return ARRAY[AccountMiniResponse]
#
sub search_accounts_with_tracking_legs {
    my ($self, %args) = @_;

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling search_accounts_with_tracking_legs");
    }

    # parse inputs
    my $_resource_path = '/tracking/list';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'keyword'}) {
        $query_params->{'keyword'} = $self->{api_client}->to_query_value($args{'keyword'});
    }

    # query params
    if ( exists $args{'start_date'}) {
        $query_params->{'startDate'} = $self->{api_client}->to_query_value($args{'start_date'});
    }

    # query params
    if ( exists $args{'end_date'}) {
        $query_params->{'endDate'} = $self->{api_client}->to_query_value($args{'end_date'});
    }

    # query params
    if ( exists $args{'tags'}) {
        $query_params->{'tags'} = $self->{api_client}->to_query_value($args{'tags'});
    }

    # query params
    if ( exists $args{'audience_ids'}) {
        $query_params->{'audienceIds'} = $self->{api_client}->to_query_value($args{'audience_ids'});
    }

    # query params
    if ( exists $args{'latitude'}) {
        $query_params->{'latitude'} = $self->{api_client}->to_query_value($args{'latitude'});
    }

    # query params
    if ( exists $args{'longitude'}) {
        $query_params->{'longitude'} = $self->{api_client}->to_query_value($args{'longitude'});
    }

    # query params
    if ( exists $args{'range'}) {
        $query_params->{'range'} = $self->{api_client}->to_query_value($args{'range'});
    }

    # query params
    if ( exists $args{'sort_field'}) {
        $query_params->{'sortField'} = $self->{api_client}->to_query_value($args{'sort_field'});
    }

    # query params
    if ( exists $args{'descending'}) {
        $query_params->{'descending'} = $self->{api_client}->to_query_value($args{'descending'});
    }

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'active_only'}) {
        $query_params->{'activeOnly'} = $self->{api_client}->to_query_value($args{'active_only'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[AccountMiniResponse]', $response);
    return $_response_object;
}

#
# search_tracking_legs
#
# Search Tracking (Billable)
#
# @param int $account_id The account id to search tracking for (required)
# @param string $app_key The application key (required)
# @param string $tracking_device_id The id of the tracking device (optional)
# @param int $start_date The start date in (UTC milliseconds) to filter the tracking results (optional)
# @param int $end_date The end date in (UTC milliseconds) to filter the tracking results (optional)
# @param string $tags Filter results by tag (optional)
# @param int $start The start index for pagination (optional, default to 0)
# @param int $limit The limit for pagination (optional, default to 100)
{
    my $params = {
    'account_id' => {
        data_type => 'int',
        description => 'The account id to search tracking for',
        required => '1',
    },
    'app_key' => {
        data_type => 'string',
        description => 'The application key',
        required => '1',
    },
    'tracking_device_id' => {
        data_type => 'string',
        description => 'The id of the tracking device',
        required => '0',
    },
    'start_date' => {
        data_type => 'int',
        description => 'The start date in (UTC milliseconds) to filter the tracking results',
        required => '0',
    },
    'end_date' => {
        data_type => 'int',
        description => 'The end date in (UTC milliseconds) to filter the tracking results',
        required => '0',
    },
    'tags' => {
        data_type => 'string',
        description => 'Filter results by tag',
        required => '0',
    },
    'start' => {
        data_type => 'int',
        description => 'The start index for pagination',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'The limit for pagination',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'search_tracking_legs' } = {
        summary => 'Search Tracking (Billable)',
        params => $params,
        returns => 'ARRAY[LegResponse]',
        };
}
# @return ARRAY[LegResponse]
#
sub search_tracking_legs {
    my ($self, %args) = @_;

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling search_tracking_legs");
    }

    # verify the required parameter 'app_key' is set
    unless (exists $args{'app_key'}) {
      croak("Missing the required parameter 'app_key' when calling search_tracking_legs");
    }

    # parse inputs
    my $_resource_path = '/tracking/searchByBillable';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'app_key'}) {
        $query_params->{'appKey'} = $self->{api_client}->to_query_value($args{'app_key'});
    }

    # query params
    if ( exists $args{'tracking_device_id'}) {
        $query_params->{'trackingDeviceId'} = $self->{api_client}->to_query_value($args{'tracking_device_id'});
    }

    # query params
    if ( exists $args{'start_date'}) {
        $query_params->{'startDate'} = $self->{api_client}->to_query_value($args{'start_date'});
    }

    # query params
    if ( exists $args{'end_date'}) {
        $query_params->{'endDate'} = $self->{api_client}->to_query_value($args{'end_date'});
    }

    # query params
    if ( exists $args{'tags'}) {
        $query_params->{'tags'} = $self->{api_client}->to_query_value($args{'tags'});
    }

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[LegResponse]', $response);
    return $_response_object;
}

1;
