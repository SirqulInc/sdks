=begin comment

Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

The version of the OpenAPI document: 3.16
Contact: info@sirqul.com
Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package WWW::OpenAPIClient::RankingApi;

require 5.6.0;
use strict;
use warnings;
use utf8;
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use WWW::OpenAPIClient::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'WWW::OpenAPIClient::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = WWW::OpenAPIClient::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# get_historical_rankings
#
# Search Historical Rankings
#
# @param double $version  (required)
# @param string $app_key the application key for filtering results by application (required)
# @param string $rank_type the rank type to return (required)
# @param int $start_date timestamp in milliseconds to filter results with (required)
# @param int $end_date timestamp in milliseconds to filter results with (required)
# @param string $device_id a unique id given by the device (deviceId or accountId required) (optional)
# @param int $account_id the account id of the user (optional)
# @param string $sort_field determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST (optional, default to 'TOTAL')
# @param boolean $descending determines whether to return results in ascending or descending order (optional, default to true)
# @param int $start the start index for pagination (optional, default to 0)
# @param int $limit the limit for pagination (optional, default to 100)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'app_key' => {
        data_type => 'string',
        description => 'the application key for filtering results by application',
        required => '1',
    },
    'rank_type' => {
        data_type => 'string',
        description => 'the rank type to return',
        required => '1',
    },
    'start_date' => {
        data_type => 'int',
        description => 'timestamp in milliseconds to filter results with',
        required => '1',
    },
    'end_date' => {
        data_type => 'int',
        description => 'timestamp in milliseconds to filter results with',
        required => '1',
    },
    'device_id' => {
        data_type => 'string',
        description => 'a unique id given by the device (deviceId or accountId required)',
        required => '0',
    },
    'account_id' => {
        data_type => 'int',
        description => 'the account id of the user',
        required => '0',
    },
    'sort_field' => {
        data_type => 'string',
        description => 'determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST',
        required => '0',
    },
    'descending' => {
        data_type => 'boolean',
        description => 'determines whether to return results in ascending or descending order',
        required => '0',
    },
    'start' => {
        data_type => 'int',
        description => 'the start index for pagination',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'the limit for pagination',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_historical_rankings' } = {
        summary => 'Search Historical Rankings',
        params => $params,
        returns => 'RankFullResponse',
        };
}
# @return RankFullResponse
#
sub get_historical_rankings {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling get_historical_rankings");
    }

    # verify the required parameter 'app_key' is set
    unless (exists $args{'app_key'}) {
      croak("Missing the required parameter 'app_key' when calling get_historical_rankings");
    }

    # verify the required parameter 'rank_type' is set
    unless (exists $args{'rank_type'}) {
      croak("Missing the required parameter 'rank_type' when calling get_historical_rankings");
    }

    # verify the required parameter 'start_date' is set
    unless (exists $args{'start_date'}) {
      croak("Missing the required parameter 'start_date' when calling get_historical_rankings");
    }

    # verify the required parameter 'end_date' is set
    unless (exists $args{'end_date'}) {
      croak("Missing the required parameter 'end_date' when calling get_historical_rankings");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/ranking/historical/search';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'device_id'}) {
        $query_params->{'deviceId'} = $self->{api_client}->to_query_value($args{'device_id'});
    }

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'app_key'}) {
        $query_params->{'appKey'} = $self->{api_client}->to_query_value($args{'app_key'});
    }

    # query params
    if ( exists $args{'rank_type'}) {
        $query_params->{'rankType'} = $self->{api_client}->to_query_value($args{'rank_type'});
    }

    # query params
    if ( exists $args{'start_date'}) {
        $query_params->{'startDate'} = $self->{api_client}->to_query_value($args{'start_date'});
    }

    # query params
    if ( exists $args{'end_date'}) {
        $query_params->{'endDate'} = $self->{api_client}->to_query_value($args{'end_date'});
    }

    # query params
    if ( exists $args{'sort_field'}) {
        $query_params->{'sortField'} = $self->{api_client}->to_query_value($args{'sort_field'});
    }

    # query params
    if ( exists $args{'descending'}) {
        $query_params->{'descending'} = $self->{api_client}->to_query_value($args{'descending'});
    }

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('RankFullResponse', $response);
    return $_response_object;
}

#
# get_rankings
#
# Search Rankings
#
# @param double $version  (required)
# @param string $device_id a unique id given by the device (deviceId or accountId required) (optional)
# @param int $account_id the account id of the user (deviceId or accountId required) (optional)
# @param string $game_type This parameter is deprecated. (optional)
# @param string $app_key the application key for filtering results by application (required for non-EXECUTIVE users) (optional)
# @param string $q This parameter is deprecated. (optional)
# @param string $keyword keyword to search for (optional)
# @param string $rank_type a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS (optional, default to 'POINTS,DOWNLOADS,INVITATIONS')
# @param string $leaderboard_mode the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId (optional, default to 'GLOBAL')
# @param string $within_account_ids comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts. (optional)
# @param boolean $return_user_rank determines whether to return the user&#39;s current rank in the response. This can be turned off for sequential paginated requests. (optional, default to true)
# @param int $album_id album id to use when performing CUSTOM filters (optional)
# @param int $audience_id audience id to use when performing CUSTOM filters (optional)
# @param string $sort_field determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score (optional, default to 'TOTAL')
# @param boolean $descending determines whether to return results in ascending or descending order (optional, default to true)
# @param int $_i This parameter is deprecated. (optional)
# @param int $start the start index for pagination (optional, default to 0)
# @param int $_l This parameter is deprecated. (optional)
# @param int $limit the limit for pagination (optional, default to 100)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'device_id' => {
        data_type => 'string',
        description => 'a unique id given by the device (deviceId or accountId required)',
        required => '0',
    },
    'account_id' => {
        data_type => 'int',
        description => 'the account id of the user (deviceId or accountId required)',
        required => '0',
    },
    'game_type' => {
        data_type => 'string',
        description => 'This parameter is deprecated.',
        required => '0',
    },
    'app_key' => {
        data_type => 'string',
        description => 'the application key for filtering results by application (required for non-EXECUTIVE users)',
        required => '0',
    },
    'q' => {
        data_type => 'string',
        description => 'This parameter is deprecated.',
        required => '0',
    },
    'keyword' => {
        data_type => 'string',
        description => 'keyword to search for',
        required => '0',
    },
    'rank_type' => {
        data_type => 'string',
        description => 'a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS',
        required => '0',
    },
    'leaderboard_mode' => {
        data_type => 'string',
        description => 'the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId',
        required => '0',
    },
    'within_account_ids' => {
        data_type => 'string',
        description => 'comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts.',
        required => '0',
    },
    'return_user_rank' => {
        data_type => 'boolean',
        description => 'determines whether to return the user&#39;s current rank in the response. This can be turned off for sequential paginated requests.',
        required => '0',
    },
    'album_id' => {
        data_type => 'int',
        description => 'album id to use when performing CUSTOM filters',
        required => '0',
    },
    'audience_id' => {
        data_type => 'int',
        description => 'audience id to use when performing CUSTOM filters',
        required => '0',
    },
    'sort_field' => {
        data_type => 'string',
        description => 'determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score',
        required => '0',
    },
    'descending' => {
        data_type => 'boolean',
        description => 'determines whether to return results in ascending or descending order',
        required => '0',
    },
    '_i' => {
        data_type => 'int',
        description => 'This parameter is deprecated.',
        required => '0',
    },
    'start' => {
        data_type => 'int',
        description => 'the start index for pagination',
        required => '0',
    },
    '_l' => {
        data_type => 'int',
        description => 'This parameter is deprecated.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'the limit for pagination',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_rankings' } = {
        summary => 'Search Rankings',
        params => $params,
        returns => 'RankFullResponse',
        };
}
# @return RankFullResponse
#
sub get_rankings {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling get_rankings");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/ranking/search';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'device_id'}) {
        $query_params->{'deviceId'} = $self->{api_client}->to_query_value($args{'device_id'});
    }

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'game_type'}) {
        $query_params->{'gameType'} = $self->{api_client}->to_query_value($args{'game_type'});
    }

    # query params
    if ( exists $args{'app_key'}) {
        $query_params->{'appKey'} = $self->{api_client}->to_query_value($args{'app_key'});
    }

    # query params
    if ( exists $args{'q'}) {
        $query_params->{'q'} = $self->{api_client}->to_query_value($args{'q'});
    }

    # query params
    if ( exists $args{'keyword'}) {
        $query_params->{'keyword'} = $self->{api_client}->to_query_value($args{'keyword'});
    }

    # query params
    if ( exists $args{'rank_type'}) {
        $query_params->{'rankType'} = $self->{api_client}->to_query_value($args{'rank_type'});
    }

    # query params
    if ( exists $args{'leaderboard_mode'}) {
        $query_params->{'leaderboardMode'} = $self->{api_client}->to_query_value($args{'leaderboard_mode'});
    }

    # query params
    if ( exists $args{'within_account_ids'}) {
        $query_params->{'withinAccountIds'} = $self->{api_client}->to_query_value($args{'within_account_ids'});
    }

    # query params
    if ( exists $args{'return_user_rank'}) {
        $query_params->{'returnUserRank'} = $self->{api_client}->to_query_value($args{'return_user_rank'});
    }

    # query params
    if ( exists $args{'album_id'}) {
        $query_params->{'albumId'} = $self->{api_client}->to_query_value($args{'album_id'});
    }

    # query params
    if ( exists $args{'audience_id'}) {
        $query_params->{'audienceId'} = $self->{api_client}->to_query_value($args{'audience_id'});
    }

    # query params
    if ( exists $args{'sort_field'}) {
        $query_params->{'sortField'} = $self->{api_client}->to_query_value($args{'sort_field'});
    }

    # query params
    if ( exists $args{'descending'}) {
        $query_params->{'descending'} = $self->{api_client}->to_query_value($args{'descending'});
    }

    # query params
    if ( exists $args{'_i'}) {
        $query_params->{'_i'} = $self->{api_client}->to_query_value($args{'_i'});
    }

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'_l'}) {
        $query_params->{'_l'} = $self->{api_client}->to_query_value($args{'_l'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('RankFullResponse', $response);
    return $_response_object;
}

#
# get_user_rank
#
# Get Personal Rankings
#
# @param double $version  (required)
# @param string $device_id a unique id given by the device (deviceId or accountId required) (optional)
# @param int $account_id the account id of the user (optional)
# @param string $app_key the application key for filtering results by application (required) (optional)
# @param string $rank_type pass in all rankTypes and children rankTypes (optional)
# @param boolean $return_user_rank determines whether to return the user&#39;s current rank in the response, for each rankType (optional, default to false)
# @param string $leaderboard_mode the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM (optional, default to 'GLOBAL')
# @param string $sort_field determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST (optional, default to 'TOTAL')
# @param string $keyword keyword to search for (on rankType) (optional)
# @param boolean $descending determines whether to return results in descending order (optional, default to true)
# @param int $start the start index for pagination (optional, default to 0)
# @param int $limit the limit for pagination (optional, default to 100)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'device_id' => {
        data_type => 'string',
        description => 'a unique id given by the device (deviceId or accountId required)',
        required => '0',
    },
    'account_id' => {
        data_type => 'int',
        description => 'the account id of the user',
        required => '0',
    },
    'app_key' => {
        data_type => 'string',
        description => 'the application key for filtering results by application (required)',
        required => '0',
    },
    'rank_type' => {
        data_type => 'string',
        description => 'pass in all rankTypes and children rankTypes',
        required => '0',
    },
    'return_user_rank' => {
        data_type => 'boolean',
        description => 'determines whether to return the user&#39;s current rank in the response, for each rankType',
        required => '0',
    },
    'leaderboard_mode' => {
        data_type => 'string',
        description => 'the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM',
        required => '0',
    },
    'sort_field' => {
        data_type => 'string',
        description => 'determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST',
        required => '0',
    },
    'keyword' => {
        data_type => 'string',
        description => 'keyword to search for (on rankType)',
        required => '0',
    },
    'descending' => {
        data_type => 'boolean',
        description => 'determines whether to return results in descending order',
        required => '0',
    },
    'start' => {
        data_type => 'int',
        description => 'the start index for pagination',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'the limit for pagination',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_user_rank' } = {
        summary => 'Get Personal Rankings',
        params => $params,
        returns => 'object',
        };
}
# @return object
#
sub get_user_rank {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling get_user_rank");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/ranking/personal/ranks';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'device_id'}) {
        $query_params->{'deviceId'} = $self->{api_client}->to_query_value($args{'device_id'});
    }

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'app_key'}) {
        $query_params->{'appKey'} = $self->{api_client}->to_query_value($args{'app_key'});
    }

    # query params
    if ( exists $args{'rank_type'}) {
        $query_params->{'rankType'} = $self->{api_client}->to_query_value($args{'rank_type'});
    }

    # query params
    if ( exists $args{'return_user_rank'}) {
        $query_params->{'returnUserRank'} = $self->{api_client}->to_query_value($args{'return_user_rank'});
    }

    # query params
    if ( exists $args{'leaderboard_mode'}) {
        $query_params->{'leaderboardMode'} = $self->{api_client}->to_query_value($args{'leaderboard_mode'});
    }

    # query params
    if ( exists $args{'sort_field'}) {
        $query_params->{'sortField'} = $self->{api_client}->to_query_value($args{'sort_field'});
    }

    # query params
    if ( exists $args{'keyword'}) {
        $query_params->{'keyword'} = $self->{api_client}->to_query_value($args{'keyword'});
    }

    # query params
    if ( exists $args{'descending'}) {
        $query_params->{'descending'} = $self->{api_client}->to_query_value($args{'descending'});
    }

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('object', $response);
    return $_response_object;
}

#
# override_user_rank
#
# Override User Rank
#
# @param double $version  (required)
# @param int $account_id the logged in user&#39;s account id (must have permissions to manage data for the application) (required)
# @param int $owner_account_id the end user&#39;s account id to override (required)
# @param string $app_key the application key the leaderboard is for (required)
# @param string $rank_type the rankType of the leaderboard (required)
# @param int $total_score the total score to update (optional)
# @param int $total_count the total count to update (optional)
# @param int $total_time the total time to update (optional)
# @param int $daily_score the daily score to update (optional)
# @param int $daily_count the daily count to update (optional)
# @param int $daily_time the daily time to update (optional)
# @param int $weekly_score the weekly score to update (optional)
# @param int $weekly_count the weekly count to update (optional)
# @param int $weekly_time the weekly time to update (optional)
# @param int $monthly_score the monthly score to update (optional)
# @param int $monthly_count the monthly count to update (optional)
# @param int $monthly_time the monthly time to update (optional)
# @param int $top_score the top score to update (optional)
# @param int $lowest_score the lowest score to update (optional)
# @param int $streak_count the streak count to update (optional)
# @param int $streak_best_count the best streak count to update (optional)
# @param int $start_date the start date to update (optional)
# @param int $end_date the end date to update (optional)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'account_id' => {
        data_type => 'int',
        description => 'the logged in user&#39;s account id (must have permissions to manage data for the application)',
        required => '1',
    },
    'owner_account_id' => {
        data_type => 'int',
        description => 'the end user&#39;s account id to override',
        required => '1',
    },
    'app_key' => {
        data_type => 'string',
        description => 'the application key the leaderboard is for',
        required => '1',
    },
    'rank_type' => {
        data_type => 'string',
        description => 'the rankType of the leaderboard',
        required => '1',
    },
    'total_score' => {
        data_type => 'int',
        description => 'the total score to update',
        required => '0',
    },
    'total_count' => {
        data_type => 'int',
        description => 'the total count to update',
        required => '0',
    },
    'total_time' => {
        data_type => 'int',
        description => 'the total time to update',
        required => '0',
    },
    'daily_score' => {
        data_type => 'int',
        description => 'the daily score to update',
        required => '0',
    },
    'daily_count' => {
        data_type => 'int',
        description => 'the daily count to update',
        required => '0',
    },
    'daily_time' => {
        data_type => 'int',
        description => 'the daily time to update',
        required => '0',
    },
    'weekly_score' => {
        data_type => 'int',
        description => 'the weekly score to update',
        required => '0',
    },
    'weekly_count' => {
        data_type => 'int',
        description => 'the weekly count to update',
        required => '0',
    },
    'weekly_time' => {
        data_type => 'int',
        description => 'the weekly time to update',
        required => '0',
    },
    'monthly_score' => {
        data_type => 'int',
        description => 'the monthly score to update',
        required => '0',
    },
    'monthly_count' => {
        data_type => 'int',
        description => 'the monthly count to update',
        required => '0',
    },
    'monthly_time' => {
        data_type => 'int',
        description => 'the monthly time to update',
        required => '0',
    },
    'top_score' => {
        data_type => 'int',
        description => 'the top score to update',
        required => '0',
    },
    'lowest_score' => {
        data_type => 'int',
        description => 'the lowest score to update',
        required => '0',
    },
    'streak_count' => {
        data_type => 'int',
        description => 'the streak count to update',
        required => '0',
    },
    'streak_best_count' => {
        data_type => 'int',
        description => 'the best streak count to update',
        required => '0',
    },
    'start_date' => {
        data_type => 'int',
        description => 'the start date to update',
        required => '0',
    },
    'end_date' => {
        data_type => 'int',
        description => 'the end date to update',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'override_user_rank' } = {
        summary => 'Override User Rank',
        params => $params,
        returns => 'SirqulResponse',
        };
}
# @return SirqulResponse
#
sub override_user_rank {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling override_user_rank");
    }

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling override_user_rank");
    }

    # verify the required parameter 'owner_account_id' is set
    unless (exists $args{'owner_account_id'}) {
      croak("Missing the required parameter 'owner_account_id' when calling override_user_rank");
    }

    # verify the required parameter 'app_key' is set
    unless (exists $args{'app_key'}) {
      croak("Missing the required parameter 'app_key' when calling override_user_rank");
    }

    # verify the required parameter 'rank_type' is set
    unless (exists $args{'rank_type'}) {
      croak("Missing the required parameter 'rank_type' when calling override_user_rank");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/ranking/override';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'owner_account_id'}) {
        $query_params->{'ownerAccountId'} = $self->{api_client}->to_query_value($args{'owner_account_id'});
    }

    # query params
    if ( exists $args{'app_key'}) {
        $query_params->{'appKey'} = $self->{api_client}->to_query_value($args{'app_key'});
    }

    # query params
    if ( exists $args{'rank_type'}) {
        $query_params->{'rankType'} = $self->{api_client}->to_query_value($args{'rank_type'});
    }

    # query params
    if ( exists $args{'total_score'}) {
        $query_params->{'totalScore'} = $self->{api_client}->to_query_value($args{'total_score'});
    }

    # query params
    if ( exists $args{'total_count'}) {
        $query_params->{'totalCount'} = $self->{api_client}->to_query_value($args{'total_count'});
    }

    # query params
    if ( exists $args{'total_time'}) {
        $query_params->{'totalTime'} = $self->{api_client}->to_query_value($args{'total_time'});
    }

    # query params
    if ( exists $args{'daily_score'}) {
        $query_params->{'dailyScore'} = $self->{api_client}->to_query_value($args{'daily_score'});
    }

    # query params
    if ( exists $args{'daily_count'}) {
        $query_params->{'dailyCount'} = $self->{api_client}->to_query_value($args{'daily_count'});
    }

    # query params
    if ( exists $args{'daily_time'}) {
        $query_params->{'dailyTime'} = $self->{api_client}->to_query_value($args{'daily_time'});
    }

    # query params
    if ( exists $args{'weekly_score'}) {
        $query_params->{'weeklyScore'} = $self->{api_client}->to_query_value($args{'weekly_score'});
    }

    # query params
    if ( exists $args{'weekly_count'}) {
        $query_params->{'weeklyCount'} = $self->{api_client}->to_query_value($args{'weekly_count'});
    }

    # query params
    if ( exists $args{'weekly_time'}) {
        $query_params->{'weeklyTime'} = $self->{api_client}->to_query_value($args{'weekly_time'});
    }

    # query params
    if ( exists $args{'monthly_score'}) {
        $query_params->{'monthlyScore'} = $self->{api_client}->to_query_value($args{'monthly_score'});
    }

    # query params
    if ( exists $args{'monthly_count'}) {
        $query_params->{'monthlyCount'} = $self->{api_client}->to_query_value($args{'monthly_count'});
    }

    # query params
    if ( exists $args{'monthly_time'}) {
        $query_params->{'monthlyTime'} = $self->{api_client}->to_query_value($args{'monthly_time'});
    }

    # query params
    if ( exists $args{'top_score'}) {
        $query_params->{'topScore'} = $self->{api_client}->to_query_value($args{'top_score'});
    }

    # query params
    if ( exists $args{'lowest_score'}) {
        $query_params->{'lowestScore'} = $self->{api_client}->to_query_value($args{'lowest_score'});
    }

    # query params
    if ( exists $args{'streak_count'}) {
        $query_params->{'streakCount'} = $self->{api_client}->to_query_value($args{'streak_count'});
    }

    # query params
    if ( exists $args{'streak_best_count'}) {
        $query_params->{'streakBestCount'} = $self->{api_client}->to_query_value($args{'streak_best_count'});
    }

    # query params
    if ( exists $args{'start_date'}) {
        $query_params->{'startDate'} = $self->{api_client}->to_query_value($args{'start_date'});
    }

    # query params
    if ( exists $args{'end_date'}) {
        $query_params->{'endDate'} = $self->{api_client}->to_query_value($args{'end_date'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('SirqulResponse', $response);
    return $_response_object;
}

#
# update_rankings
#
# Update Ranking
#
# @param double $version  (required)
# @param int $account_id the account id of the user (required)
# @param string $app_key the application key for filtering results by application (required)
# @param string $rank_type a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS (required)
# @param int $increment the value to increment (optional, default to 1)
# @param int $time_increment the time value to increment (optional)
# @param string $tag the analytic tag for this achievement (used to validate scores) (optional)
# @param int $start_date custom date you can save along with the score for the user (optional)
# @param int $end_date custom date you can save along with the score for the user (optional)
# @param boolean $update_global update the global rankings if true, default is false (optional)
# @param boolean $create_leaderboard create the leaderboard if it does not exist (default false) (optional, default to false)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'account_id' => {
        data_type => 'int',
        description => 'the account id of the user',
        required => '1',
    },
    'app_key' => {
        data_type => 'string',
        description => 'the application key for filtering results by application',
        required => '1',
    },
    'rank_type' => {
        data_type => 'string',
        description => 'a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS',
        required => '1',
    },
    'increment' => {
        data_type => 'int',
        description => 'the value to increment',
        required => '0',
    },
    'time_increment' => {
        data_type => 'int',
        description => 'the time value to increment',
        required => '0',
    },
    'tag' => {
        data_type => 'string',
        description => 'the analytic tag for this achievement (used to validate scores)',
        required => '0',
    },
    'start_date' => {
        data_type => 'int',
        description => 'custom date you can save along with the score for the user',
        required => '0',
    },
    'end_date' => {
        data_type => 'int',
        description => 'custom date you can save along with the score for the user',
        required => '0',
    },
    'update_global' => {
        data_type => 'boolean',
        description => 'update the global rankings if true, default is false',
        required => '0',
    },
    'create_leaderboard' => {
        data_type => 'boolean',
        description => 'create the leaderboard if it does not exist (default false)',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'update_rankings' } = {
        summary => 'Update Ranking',
        params => $params,
        returns => 'SirqulResponse',
        };
}
# @return SirqulResponse
#
sub update_rankings {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling update_rankings");
    }

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling update_rankings");
    }

    # verify the required parameter 'app_key' is set
    unless (exists $args{'app_key'}) {
      croak("Missing the required parameter 'app_key' when calling update_rankings");
    }

    # verify the required parameter 'rank_type' is set
    unless (exists $args{'rank_type'}) {
      croak("Missing the required parameter 'rank_type' when calling update_rankings");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/ranking/update';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'app_key'}) {
        $query_params->{'appKey'} = $self->{api_client}->to_query_value($args{'app_key'});
    }

    # query params
    if ( exists $args{'rank_type'}) {
        $query_params->{'rankType'} = $self->{api_client}->to_query_value($args{'rank_type'});
    }

    # query params
    if ( exists $args{'increment'}) {
        $query_params->{'increment'} = $self->{api_client}->to_query_value($args{'increment'});
    }

    # query params
    if ( exists $args{'time_increment'}) {
        $query_params->{'timeIncrement'} = $self->{api_client}->to_query_value($args{'time_increment'});
    }

    # query params
    if ( exists $args{'tag'}) {
        $query_params->{'tag'} = $self->{api_client}->to_query_value($args{'tag'});
    }

    # query params
    if ( exists $args{'start_date'}) {
        $query_params->{'startDate'} = $self->{api_client}->to_query_value($args{'start_date'});
    }

    # query params
    if ( exists $args{'end_date'}) {
        $query_params->{'endDate'} = $self->{api_client}->to_query_value($args{'end_date'});
    }

    # query params
    if ( exists $args{'update_global'}) {
        $query_params->{'updateGlobal'} = $self->{api_client}->to_query_value($args{'update_global'});
    }

    # query params
    if ( exists $args{'create_leaderboard'}) {
        $query_params->{'createLeaderboard'} = $self->{api_client}->to_query_value($args{'create_leaderboard'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('SirqulResponse', $response);
    return $_response_object;
}

1;
