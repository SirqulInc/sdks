=begin comment

Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

The version of the OpenAPI document: 3.16
Contact: info@sirqul.com
Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package WWW::OpenAPIClient::AudienceApi;

require 5.6.0;
use strict;
use warnings;
use utf8;
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use WWW::OpenAPIClient::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'WWW::OpenAPIClient::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = WWW::OpenAPIClient::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# create_audience
#
# Create Audience
#
# @param double $version  (required)
# @param int $account_id The logged in user. (required)
# @param string $name The name of the audience (required)
# @param string $description The description of the audience (optional)
# @param string $search_tags The search tags (optional)
# @param string $gender The gender; possible values are: MALE, FEMALE, ANY (optional)
# @param string $age_groups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
# @param string $category_ids The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
# @param string $application_ids The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
# @param string $game_experience_level The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
# @param string $devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
# @param string $device_ids The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
# @param string $device_versions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
# @param string $locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
# @param string $radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
# @param int $start_time_offset Seconds from the start time of an event (optional)
# @param int $end_time_offset Seconds from the end time of an event (optional)
# @param boolean $send_suggestion If true, then notify matching users when they are inside the radius (optional, default to true)
# @param string $associate_description The description of the associated object (optional)
# @param string $associate_type The type of the object to center the audience geofence (optional)
# @param int $associate_id The ID of the object to center the audience geofence (optional)
# @param string $grouping_id Optional grouping id for the audience (optional)
# @param string $meta_data External custom client defined data (optional)
# @param string $visibility Visibility of the audience (optional)
# @param string $audience_type Type of audience (optional)
# @param boolean $use_order Use order for cohort (optional)
# @param string $cohort_regions_data Cohort data for \&quot;cohort\&quot; audience type (optional)
# @param string $app_key Filter results by application key (optional)
# @param string $trilateration_types Trilateration types (optional)
# @param boolean $unique_name If true, makes sure the audience name is unique (optional)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'account_id' => {
        data_type => 'int',
        description => 'The logged in user.',
        required => '1',
    },
    'name' => {
        data_type => 'string',
        description => 'The name of the audience',
        required => '1',
    },
    'description' => {
        data_type => 'string',
        description => 'The description of the audience',
        required => '0',
    },
    'search_tags' => {
        data_type => 'string',
        description => 'The search tags',
        required => '0',
    },
    'gender' => {
        data_type => 'string',
        description => 'The gender; possible values are: MALE, FEMALE, ANY',
        required => '0',
    },
    'age_groups' => {
        data_type => 'string',
        description => 'The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)',
        required => '0',
    },
    'category_ids' => {
        data_type => 'string',
        description => 'The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)',
        required => '0',
    },
    'application_ids' => {
        data_type => 'string',
        description => 'The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)',
        required => '0',
    },
    'game_experience_level' => {
        data_type => 'string',
        description => 'The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT',
        required => '0',
    },
    'devices' => {
        data_type => 'string',
        description => '(Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)',
        required => '0',
    },
    'device_ids' => {
        data_type => 'string',
        description => 'The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)',
        required => '0',
    },
    'device_versions' => {
        data_type => 'string',
        description => 'The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)',
        required => '0',
    },
    'locations' => {
        data_type => 'string',
        description => 'The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)',
        required => '0',
    },
    'radius' => {
        data_type => 'string',
        description => 'The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.',
        required => '0',
    },
    'start_time_offset' => {
        data_type => 'int',
        description => 'Seconds from the start time of an event',
        required => '0',
    },
    'end_time_offset' => {
        data_type => 'int',
        description => 'Seconds from the end time of an event',
        required => '0',
    },
    'send_suggestion' => {
        data_type => 'boolean',
        description => 'If true, then notify matching users when they are inside the radius',
        required => '0',
    },
    'associate_description' => {
        data_type => 'string',
        description => 'The description of the associated object',
        required => '0',
    },
    'associate_type' => {
        data_type => 'string',
        description => 'The type of the object to center the audience geofence',
        required => '0',
    },
    'associate_id' => {
        data_type => 'int',
        description => 'The ID of the object to center the audience geofence',
        required => '0',
    },
    'grouping_id' => {
        data_type => 'string',
        description => 'Optional grouping id for the audience',
        required => '0',
    },
    'meta_data' => {
        data_type => 'string',
        description => 'External custom client defined data',
        required => '0',
    },
    'visibility' => {
        data_type => 'string',
        description => 'Visibility of the audience',
        required => '0',
    },
    'audience_type' => {
        data_type => 'string',
        description => 'Type of audience',
        required => '0',
    },
    'use_order' => {
        data_type => 'boolean',
        description => 'Use order for cohort',
        required => '0',
    },
    'cohort_regions_data' => {
        data_type => 'string',
        description => 'Cohort data for \&quot;cohort\&quot; audience type',
        required => '0',
    },
    'app_key' => {
        data_type => 'string',
        description => 'Filter results by application key',
        required => '0',
    },
    'trilateration_types' => {
        data_type => 'string',
        description => 'Trilateration types',
        required => '0',
    },
    'unique_name' => {
        data_type => 'boolean',
        description => 'If true, makes sure the audience name is unique',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_audience' } = {
        summary => 'Create Audience',
        params => $params,
        returns => 'AudienceResponse',
        };
}
# @return AudienceResponse
#
sub create_audience {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling create_audience");
    }

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling create_audience");
    }

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling create_audience");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/audience/create';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'name'}) {
        $query_params->{'name'} = $self->{api_client}->to_query_value($args{'name'});
    }

    # query params
    if ( exists $args{'description'}) {
        $query_params->{'description'} = $self->{api_client}->to_query_value($args{'description'});
    }

    # query params
    if ( exists $args{'search_tags'}) {
        $query_params->{'searchTags'} = $self->{api_client}->to_query_value($args{'search_tags'});
    }

    # query params
    if ( exists $args{'gender'}) {
        $query_params->{'gender'} = $self->{api_client}->to_query_value($args{'gender'});
    }

    # query params
    if ( exists $args{'age_groups'}) {
        $query_params->{'ageGroups'} = $self->{api_client}->to_query_value($args{'age_groups'});
    }

    # query params
    if ( exists $args{'category_ids'}) {
        $query_params->{'categoryIds'} = $self->{api_client}->to_query_value($args{'category_ids'});
    }

    # query params
    if ( exists $args{'application_ids'}) {
        $query_params->{'applicationIds'} = $self->{api_client}->to_query_value($args{'application_ids'});
    }

    # query params
    if ( exists $args{'game_experience_level'}) {
        $query_params->{'gameExperienceLevel'} = $self->{api_client}->to_query_value($args{'game_experience_level'});
    }

    # query params
    if ( exists $args{'devices'}) {
        $query_params->{'devices'} = $self->{api_client}->to_query_value($args{'devices'});
    }

    # query params
    if ( exists $args{'device_ids'}) {
        $query_params->{'deviceIds'} = $self->{api_client}->to_query_value($args{'device_ids'});
    }

    # query params
    if ( exists $args{'device_versions'}) {
        $query_params->{'deviceVersions'} = $self->{api_client}->to_query_value($args{'device_versions'});
    }

    # query params
    if ( exists $args{'locations'}) {
        $query_params->{'locations'} = $self->{api_client}->to_query_value($args{'locations'});
    }

    # query params
    if ( exists $args{'radius'}) {
        $query_params->{'radius'} = $self->{api_client}->to_query_value($args{'radius'});
    }

    # query params
    if ( exists $args{'start_time_offset'}) {
        $query_params->{'startTimeOffset'} = $self->{api_client}->to_query_value($args{'start_time_offset'});
    }

    # query params
    if ( exists $args{'end_time_offset'}) {
        $query_params->{'endTimeOffset'} = $self->{api_client}->to_query_value($args{'end_time_offset'});
    }

    # query params
    if ( exists $args{'send_suggestion'}) {
        $query_params->{'sendSuggestion'} = $self->{api_client}->to_query_value($args{'send_suggestion'});
    }

    # query params
    if ( exists $args{'associate_description'}) {
        $query_params->{'associateDescription'} = $self->{api_client}->to_query_value($args{'associate_description'});
    }

    # query params
    if ( exists $args{'associate_type'}) {
        $query_params->{'associateType'} = $self->{api_client}->to_query_value($args{'associate_type'});
    }

    # query params
    if ( exists $args{'associate_id'}) {
        $query_params->{'associateId'} = $self->{api_client}->to_query_value($args{'associate_id'});
    }

    # query params
    if ( exists $args{'grouping_id'}) {
        $query_params->{'groupingId'} = $self->{api_client}->to_query_value($args{'grouping_id'});
    }

    # query params
    if ( exists $args{'meta_data'}) {
        $query_params->{'metaData'} = $self->{api_client}->to_query_value($args{'meta_data'});
    }

    # query params
    if ( exists $args{'visibility'}) {
        $query_params->{'visibility'} = $self->{api_client}->to_query_value($args{'visibility'});
    }

    # query params
    if ( exists $args{'audience_type'}) {
        $query_params->{'audienceType'} = $self->{api_client}->to_query_value($args{'audience_type'});
    }

    # query params
    if ( exists $args{'use_order'}) {
        $query_params->{'useOrder'} = $self->{api_client}->to_query_value($args{'use_order'});
    }

    # query params
    if ( exists $args{'cohort_regions_data'}) {
        $query_params->{'cohortRegionsData'} = $self->{api_client}->to_query_value($args{'cohort_regions_data'});
    }

    # query params
    if ( exists $args{'app_key'}) {
        $query_params->{'appKey'} = $self->{api_client}->to_query_value($args{'app_key'});
    }

    # query params
    if ( exists $args{'trilateration_types'}) {
        $query_params->{'trilaterationTypes'} = $self->{api_client}->to_query_value($args{'trilateration_types'});
    }

    # query params
    if ( exists $args{'unique_name'}) {
        $query_params->{'uniqueName'} = $self->{api_client}->to_query_value($args{'unique_name'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AudienceResponse', $response);
    return $_response_object;
}

#
# delete_audience
#
# Delete Audience
#
# @param double $version  (required)
# @param int $account_id The logged in user. (required)
# @param int $audience_id The id of the audience to delete. (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'account_id' => {
        data_type => 'int',
        description => 'The logged in user.',
        required => '1',
    },
    'audience_id' => {
        data_type => 'int',
        description => 'The id of the audience to delete.',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_audience' } = {
        summary => 'Delete Audience',
        params => $params,
        returns => 'SirqulResponse',
        };
}
# @return SirqulResponse
#
sub delete_audience {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling delete_audience");
    }

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling delete_audience");
    }

    # verify the required parameter 'audience_id' is set
    unless (exists $args{'audience_id'}) {
      croak("Missing the required parameter 'audience_id' when calling delete_audience");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/audience/delete';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'audience_id'}) {
        $query_params->{'audienceId'} = $self->{api_client}->to_query_value($args{'audience_id'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('SirqulResponse', $response);
    return $_response_object;
}

#
# get_age_groups
#
# Get Age Groups
#
# @param double $version  (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_age_groups' } = {
        summary => 'Get Age Groups',
        params => $params,
        returns => 'ARRAY[AgeGroupResponse]',
        };
}
# @return ARRAY[AgeGroupResponse]
#
sub get_age_groups {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling get_age_groups");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/audience/ageGroups';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[AgeGroupResponse]', $response);
    return $_response_object;
}

#
# get_audience
#
# Get Audience
#
# @param double $version  (required)
# @param int $account_id The logged in user. (required)
# @param int $audience_id The id of the audience to return. (required)
# @param string $app_key The application key (optional). If provided, results may be scoped to this application. (optional)
# @param boolean $return_account_count (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
# @param boolean $return_album_count (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
# @param string $album_types_for_count (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'account_id' => {
        data_type => 'int',
        description => 'The logged in user.',
        required => '1',
    },
    'audience_id' => {
        data_type => 'int',
        description => 'The id of the audience to return.',
        required => '1',
    },
    'app_key' => {
        data_type => 'string',
        description => 'The application key (optional). If provided, results may be scoped to this application.',
        required => '0',
    },
    'return_account_count' => {
        data_type => 'boolean',
        description => '(boolean) set to true to include the accountCount associated with current audience of the current app',
        required => '0',
    },
    'return_album_count' => {
        data_type => 'boolean',
        description => '(boolean) set to true to include the albumCount associated with current audience of the current app',
        required => '0',
    },
    'album_types_for_count' => {
        data_type => 'string',
        description => '(String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_audience' } = {
        summary => 'Get Audience',
        params => $params,
        returns => 'AudienceResponse',
        };
}
# @return AudienceResponse
#
sub get_audience {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling get_audience");
    }

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling get_audience");
    }

    # verify the required parameter 'audience_id' is set
    unless (exists $args{'audience_id'}) {
      croak("Missing the required parameter 'audience_id' when calling get_audience");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/audience/get';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'audience_id'}) {
        $query_params->{'audienceId'} = $self->{api_client}->to_query_value($args{'audience_id'});
    }

    # query params
    if ( exists $args{'app_key'}) {
        $query_params->{'appKey'} = $self->{api_client}->to_query_value($args{'app_key'});
    }

    # query params
    if ( exists $args{'return_account_count'}) {
        $query_params->{'returnAccountCount'} = $self->{api_client}->to_query_value($args{'return_account_count'});
    }

    # query params
    if ( exists $args{'return_album_count'}) {
        $query_params->{'returnAlbumCount'} = $self->{api_client}->to_query_value($args{'return_album_count'});
    }

    # query params
    if ( exists $args{'album_types_for_count'}) {
        $query_params->{'albumTypesForCount'} = $self->{api_client}->to_query_value($args{'album_types_for_count'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AudienceResponse', $response);
    return $_response_object;
}

#
# get_audience_list
#
# Search Audiences
#
# @param double $version  (required)
# @param int $account_id The logged in user. (optional)
# @param string $album_ids Comma separated list of album IDs to filter results with (optional)
# @param string $keyword The keyword used to search (optional)
# @param string $keyword_fields Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY (optional, default to 'SEARCH_TAGS,NAME,DESCRIPTION')
# @param string $sort_field The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER} (optional, default to 'NAME')
# @param boolean $descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to false)
# @param int $start The index into the record set to start with. (optional, default to 0)
# @param int $limit The total number of record to return (there is a hard limit of 100). (optional, default to 20)
# @param boolean $send_suggestion Filter results based on whether or not the audience is set to send suggestions (optional)
# @param boolean $active_only Determines whether to return only active results. Default is false. (optional)
# @param boolean $group_by_grouping_id Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal) (optional)
# @param string $app_key Filter results by application key (optional)
# @param boolean $return_global If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well (optional)
# @param boolean $exact_keyword If true, match keyword exactly (optional)
# @param string $audience_type (Deprecated) Filter results by audience type (optional)
# @param string $audience_types comma separated string with the different audience types you want to filter for (optional)
# @param boolean $return_account_count (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
# @param boolean $return_album_count (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
# @param string $album_types_for_count (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'account_id' => {
        data_type => 'int',
        description => 'The logged in user.',
        required => '0',
    },
    'album_ids' => {
        data_type => 'string',
        description => 'Comma separated list of album IDs to filter results with',
        required => '0',
    },
    'keyword' => {
        data_type => 'string',
        description => 'The keyword used to search',
        required => '0',
    },
    'keyword_fields' => {
        data_type => 'string',
        description => 'Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY',
        required => '0',
    },
    'sort_field' => {
        data_type => 'string',
        description => 'The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}',
        required => '0',
    },
    'descending' => {
        data_type => 'boolean',
        description => 'The order to return the results. Default is false, which will return the results in ascending order.',
        required => '0',
    },
    'start' => {
        data_type => 'int',
        description => 'The index into the record set to start with.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'The total number of record to return (there is a hard limit of 100).',
        required => '0',
    },
    'send_suggestion' => {
        data_type => 'boolean',
        description => 'Filter results based on whether or not the audience is set to send suggestions',
        required => '0',
    },
    'active_only' => {
        data_type => 'boolean',
        description => 'Determines whether to return only active results. Default is false.',
        required => '0',
    },
    'group_by_grouping_id' => {
        data_type => 'boolean',
        description => 'Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)',
        required => '0',
    },
    'app_key' => {
        data_type => 'string',
        description => 'Filter results by application key',
        required => '0',
    },
    'return_global' => {
        data_type => 'boolean',
        description => 'If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well',
        required => '0',
    },
    'exact_keyword' => {
        data_type => 'boolean',
        description => 'If true, match keyword exactly',
        required => '0',
    },
    'audience_type' => {
        data_type => 'string',
        description => '(Deprecated) Filter results by audience type',
        required => '0',
    },
    'audience_types' => {
        data_type => 'string',
        description => 'comma separated string with the different audience types you want to filter for',
        required => '0',
    },
    'return_account_count' => {
        data_type => 'boolean',
        description => '(boolean) set to true to include the accountCount associated with current audience of the current app',
        required => '0',
    },
    'return_album_count' => {
        data_type => 'boolean',
        description => '(boolean) set to true to include the albumCount associated with current audience of the current app',
        required => '0',
    },
    'album_types_for_count' => {
        data_type => 'string',
        description => '(String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_audience_list' } = {
        summary => 'Search Audiences',
        params => $params,
        returns => 'ARRAY[SearchResponse]',
        };
}
# @return ARRAY[SearchResponse]
#
sub get_audience_list {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling get_audience_list");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/audience/search';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'album_ids'}) {
        $query_params->{'albumIds'} = $self->{api_client}->to_query_value($args{'album_ids'});
    }

    # query params
    if ( exists $args{'keyword'}) {
        $query_params->{'keyword'} = $self->{api_client}->to_query_value($args{'keyword'});
    }

    # query params
    if ( exists $args{'keyword_fields'}) {
        $query_params->{'keywordFields'} = $self->{api_client}->to_query_value($args{'keyword_fields'});
    }

    # query params
    if ( exists $args{'sort_field'}) {
        $query_params->{'sortField'} = $self->{api_client}->to_query_value($args{'sort_field'});
    }

    # query params
    if ( exists $args{'descending'}) {
        $query_params->{'descending'} = $self->{api_client}->to_query_value($args{'descending'});
    }

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'send_suggestion'}) {
        $query_params->{'sendSuggestion'} = $self->{api_client}->to_query_value($args{'send_suggestion'});
    }

    # query params
    if ( exists $args{'active_only'}) {
        $query_params->{'activeOnly'} = $self->{api_client}->to_query_value($args{'active_only'});
    }

    # query params
    if ( exists $args{'group_by_grouping_id'}) {
        $query_params->{'groupByGroupingId'} = $self->{api_client}->to_query_value($args{'group_by_grouping_id'});
    }

    # query params
    if ( exists $args{'app_key'}) {
        $query_params->{'appKey'} = $self->{api_client}->to_query_value($args{'app_key'});
    }

    # query params
    if ( exists $args{'return_global'}) {
        $query_params->{'returnGlobal'} = $self->{api_client}->to_query_value($args{'return_global'});
    }

    # query params
    if ( exists $args{'exact_keyword'}) {
        $query_params->{'exactKeyword'} = $self->{api_client}->to_query_value($args{'exact_keyword'});
    }

    # query params
    if ( exists $args{'audience_type'}) {
        $query_params->{'audienceType'} = $self->{api_client}->to_query_value($args{'audience_type'});
    }

    # query params
    if ( exists $args{'audience_types'}) {
        $query_params->{'audienceTypes'} = $self->{api_client}->to_query_value($args{'audience_types'});
    }

    # query params
    if ( exists $args{'return_account_count'}) {
        $query_params->{'returnAccountCount'} = $self->{api_client}->to_query_value($args{'return_account_count'});
    }

    # query params
    if ( exists $args{'return_album_count'}) {
        $query_params->{'returnAlbumCount'} = $self->{api_client}->to_query_value($args{'return_album_count'});
    }

    # query params
    if ( exists $args{'album_types_for_count'}) {
        $query_params->{'albumTypesForCount'} = $self->{api_client}->to_query_value($args{'album_types_for_count'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[SearchResponse]', $response);
    return $_response_object;
}

#
# get_devices
#
# Get Devices
#
# @param double $version  (required)
# @param boolean $include_inactive If true return inactive record as well. default is false. (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'include_inactive' => {
        data_type => 'boolean',
        description => 'If true return inactive record as well. default is false.',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_devices' } = {
        summary => 'Get Devices',
        params => $params,
        returns => 'ARRAY[AudienceDeviceResponse]',
        };
}
# @return ARRAY[AudienceDeviceResponse]
#
sub get_devices {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling get_devices");
    }

    # verify the required parameter 'include_inactive' is set
    unless (exists $args{'include_inactive'}) {
      croak("Missing the required parameter 'include_inactive' when calling get_devices");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/audience/devices';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'include_inactive'}) {
        $query_params->{'includeInactive'} = $self->{api_client}->to_query_value($args{'include_inactive'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[AudienceDeviceResponse]', $response);
    return $_response_object;
}

#
# get_experiences
#
# Get Experiences
#
# @param double $version  (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_experiences' } = {
        summary => 'Get Experiences',
        params => $params,
        returns => 'SirqulResponse',
        };
}
# @return SirqulResponse
#
sub get_experiences {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling get_experiences");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/audience/experiences';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('SirqulResponse', $response);
    return $_response_object;
}

#
# get_grouped_audiences
#
# Get GroupedAudiences
#
# @param double $version  (required)
# @param int $account_id The logged in user. (required)
# @param string $audience_grouping_id The audience grouping id to return. (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'account_id' => {
        data_type => 'int',
        description => 'The logged in user.',
        required => '1',
    },
    'audience_grouping_id' => {
        data_type => 'string',
        description => 'The audience grouping id to return.',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_grouped_audiences' } = {
        summary => 'Get GroupedAudiences',
        params => $params,
        returns => 'AudienceResponse',
        };
}
# @return AudienceResponse
#
sub get_grouped_audiences {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling get_grouped_audiences");
    }

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling get_grouped_audiences");
    }

    # verify the required parameter 'audience_grouping_id' is set
    unless (exists $args{'audience_grouping_id'}) {
      croak("Missing the required parameter 'audience_grouping_id' when calling get_grouped_audiences");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/audience/grouped/get';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'audience_grouping_id'}) {
        $query_params->{'audienceGroupingId'} = $self->{api_client}->to_query_value($args{'audience_grouping_id'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AudienceResponse', $response);
    return $_response_object;
}

#
# list_by_account
#
# List Suggestions by Audience
#
# @param double $version  (required)
# @param int $account_id The account to match offers for. (required)
# @param int $limit the limit of the index (required)
# @param string $suggestion_type the type of suggestion (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'account_id' => {
        data_type => 'int',
        description => 'The account to match offers for.',
        required => '1',
    },
    'limit' => {
        data_type => 'int',
        description => 'the limit of the index',
        required => '1',
    },
    'suggestion_type' => {
        data_type => 'string',
        description => 'the type of suggestion',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_by_account' } = {
        summary => 'List Suggestions by Audience',
        params => $params,
        returns => 'OfferListResponse',
        };
}
# @return OfferListResponse
#
sub list_by_account {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling list_by_account");
    }

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling list_by_account");
    }

    # verify the required parameter 'limit' is set
    unless (exists $args{'limit'}) {
      croak("Missing the required parameter 'limit' when calling list_by_account");
    }

    # verify the required parameter 'suggestion_type' is set
    unless (exists $args{'suggestion_type'}) {
      croak("Missing the required parameter 'suggestion_type' when calling list_by_account");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/audience/suggestion/list';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'suggestion_type'}) {
        $query_params->{'suggestionType'} = $self->{api_client}->to_query_value($args{'suggestion_type'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('OfferListResponse', $response);
    return $_response_object;
}

#
# list_by_audience
#
# List Offers by Audience
#
# @param double $version  (required)
# @param int $limit this is the limit of the index (required)
# @param string $gender this is the gender to list offers by (optional)
# @param int $age this is the age to list offers by (optional)
# @param string $category_ids this is the category IDs to list offers by (optional)
# @param double $latitude this is the latitude to list offers by (optional)
# @param double $longitude this is the longitude to list offers by (optional)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'limit' => {
        data_type => 'int',
        description => 'this is the limit of the index',
        required => '1',
    },
    'gender' => {
        data_type => 'string',
        description => 'this is the gender to list offers by',
        required => '0',
    },
    'age' => {
        data_type => 'int',
        description => 'this is the age to list offers by',
        required => '0',
    },
    'category_ids' => {
        data_type => 'string',
        description => 'this is the category IDs to list offers by',
        required => '0',
    },
    'latitude' => {
        data_type => 'double',
        description => 'this is the latitude to list offers by',
        required => '0',
    },
    'longitude' => {
        data_type => 'double',
        description => 'this is the longitude to list offers by',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_by_audience' } = {
        summary => 'List Offers by Audience',
        params => $params,
        returns => 'OfferListResponse',
        };
}
# @return OfferListResponse
#
sub list_by_audience {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling list_by_audience");
    }

    # verify the required parameter 'limit' is set
    unless (exists $args{'limit'}) {
      croak("Missing the required parameter 'limit' when calling list_by_audience");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/audience/suggestion/offersByAudience';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'gender'}) {
        $query_params->{'gender'} = $self->{api_client}->to_query_value($args{'gender'});
    }

    # query params
    if ( exists $args{'age'}) {
        $query_params->{'age'} = $self->{api_client}->to_query_value($args{'age'});
    }

    # query params
    if ( exists $args{'category_ids'}) {
        $query_params->{'categoryIds'} = $self->{api_client}->to_query_value($args{'category_ids'});
    }

    # query params
    if ( exists $args{'latitude'}) {
        $query_params->{'latitude'} = $self->{api_client}->to_query_value($args{'latitude'});
    }

    # query params
    if ( exists $args{'longitude'}) {
        $query_params->{'longitude'} = $self->{api_client}->to_query_value($args{'longitude'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('OfferListResponse', $response);
    return $_response_object;
}

#
# list_lastest_by_account
#
# List Sent Suggestions 
#
# @param double $version  (required)
# @param int $account_id The account to match offers for. (required)
# @param int $timeframe The timeframe in seconds of the latest suggestions (required)
# @param string $suggestion_type The type of trigger suggestions to return (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'account_id' => {
        data_type => 'int',
        description => 'The account to match offers for.',
        required => '1',
    },
    'timeframe' => {
        data_type => 'int',
        description => 'The timeframe in seconds of the latest suggestions',
        required => '1',
    },
    'suggestion_type' => {
        data_type => 'string',
        description => 'The type of trigger suggestions to return',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_lastest_by_account' } = {
        summary => 'List Sent Suggestions ',
        params => $params,
        returns => 'OfferListResponse',
        };
}
# @return OfferListResponse
#
sub list_lastest_by_account {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling list_lastest_by_account");
    }

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling list_lastest_by_account");
    }

    # verify the required parameter 'timeframe' is set
    unless (exists $args{'timeframe'}) {
      croak("Missing the required parameter 'timeframe' when calling list_lastest_by_account");
    }

    # verify the required parameter 'suggestion_type' is set
    unless (exists $args{'suggestion_type'}) {
      croak("Missing the required parameter 'suggestion_type' when calling list_lastest_by_account");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/audience/suggestion/latest';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'timeframe'}) {
        $query_params->{'timeframe'} = $self->{api_client}->to_query_value($args{'timeframe'});
    }

    # query params
    if ( exists $args{'suggestion_type'}) {
        $query_params->{'suggestionType'} = $self->{api_client}->to_query_value($args{'suggestion_type'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('OfferListResponse', $response);
    return $_response_object;
}

#
# send_by_account
#
# Send Suggestions
#
# @param double $version  (required)
# @param int $account_id The account to match offers for. (required)
# @param double $latitude the latitude (required)
# @param double $longitude the longitude (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'account_id' => {
        data_type => 'int',
        description => 'The account to match offers for.',
        required => '1',
    },
    'latitude' => {
        data_type => 'double',
        description => 'the latitude',
        required => '1',
    },
    'longitude' => {
        data_type => 'double',
        description => 'the longitude',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'send_by_account' } = {
        summary => 'Send Suggestions',
        params => $params,
        returns => 'SirqulResponse',
        };
}
# @return SirqulResponse
#
sub send_by_account {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling send_by_account");
    }

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling send_by_account");
    }

    # verify the required parameter 'latitude' is set
    unless (exists $args{'latitude'}) {
      croak("Missing the required parameter 'latitude' when calling send_by_account");
    }

    # verify the required parameter 'longitude' is set
    unless (exists $args{'longitude'}) {
      croak("Missing the required parameter 'longitude' when calling send_by_account");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/audience/suggestion/send';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'latitude'}) {
        $query_params->{'latitude'} = $self->{api_client}->to_query_value($args{'latitude'});
    }

    # query params
    if ( exists $args{'longitude'}) {
        $query_params->{'longitude'} = $self->{api_client}->to_query_value($args{'longitude'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('SirqulResponse', $response);
    return $_response_object;
}

#
# update_audience
#
# Update Audience
#
# @param double $version  (required)
# @param int $account_id The logged in user. (required)
# @param int $audience_id The id of the audience to update. (required)
# @param string $name The name of the audience (optional)
# @param string $description The description of the audience (optional)
# @param string $search_tags The search tags (optional)
# @param string $gender The gender; possible values are: MALE, FEMALE, ANY (optional)
# @param string $age_groups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
# @param string $category_ids The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
# @param string $application_ids The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
# @param string $game_experience_level The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
# @param string $devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
# @param string $device_ids The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
# @param string $device_versions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
# @param string $locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
# @param string $radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
# @param boolean $active if audience is active (optional)
# @param boolean $send_suggestion If true, then notify matching users when they are inside the radius (optional)
# @param int $start_time_offset Seconds from the start time of an event (optional)
# @param int $end_time_offset Seconds from the end time of an event (optional)
# @param string $associate_description the associate description (optional)
# @param string $associate_type The type of the object to center the audience geofence (optional)
# @param int $associate_id The ID of the object to center the audience geofence (optional)
# @param string $grouping_id Optional grouping id for the audience (optional)
# @param string $meta_data External custom client defined data (optional)
# @param string $visibility Visibility of the audience (optional)
# @param string $audience_type Type of audience (optional)
# @param boolean $use_order Use order for cohort (optional)
# @param string $cohort_regions_data Cohort data for \&quot;cohort\&quot; audience type (optional)
# @param string $app_key Filter results by application key (optional)
# @param string $trilateration_types Trilateration types (optional)
# @param boolean $unique_name If true, makes sure the audience name is unique (optional)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'account_id' => {
        data_type => 'int',
        description => 'The logged in user.',
        required => '1',
    },
    'audience_id' => {
        data_type => 'int',
        description => 'The id of the audience to update.',
        required => '1',
    },
    'name' => {
        data_type => 'string',
        description => 'The name of the audience',
        required => '0',
    },
    'description' => {
        data_type => 'string',
        description => 'The description of the audience',
        required => '0',
    },
    'search_tags' => {
        data_type => 'string',
        description => 'The search tags',
        required => '0',
    },
    'gender' => {
        data_type => 'string',
        description => 'The gender; possible values are: MALE, FEMALE, ANY',
        required => '0',
    },
    'age_groups' => {
        data_type => 'string',
        description => 'The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)',
        required => '0',
    },
    'category_ids' => {
        data_type => 'string',
        description => 'The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)',
        required => '0',
    },
    'application_ids' => {
        data_type => 'string',
        description => 'The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)',
        required => '0',
    },
    'game_experience_level' => {
        data_type => 'string',
        description => 'The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT',
        required => '0',
    },
    'devices' => {
        data_type => 'string',
        description => '(Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)',
        required => '0',
    },
    'device_ids' => {
        data_type => 'string',
        description => 'The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)',
        required => '0',
    },
    'device_versions' => {
        data_type => 'string',
        description => 'The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)',
        required => '0',
    },
    'locations' => {
        data_type => 'string',
        description => 'The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)',
        required => '0',
    },
    'radius' => {
        data_type => 'string',
        description => 'The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.',
        required => '0',
    },
    'active' => {
        data_type => 'boolean',
        description => 'if audience is active',
        required => '0',
    },
    'send_suggestion' => {
        data_type => 'boolean',
        description => 'If true, then notify matching users when they are inside the radius',
        required => '0',
    },
    'start_time_offset' => {
        data_type => 'int',
        description => 'Seconds from the start time of an event',
        required => '0',
    },
    'end_time_offset' => {
        data_type => 'int',
        description => 'Seconds from the end time of an event',
        required => '0',
    },
    'associate_description' => {
        data_type => 'string',
        description => 'the associate description',
        required => '0',
    },
    'associate_type' => {
        data_type => 'string',
        description => 'The type of the object to center the audience geofence',
        required => '0',
    },
    'associate_id' => {
        data_type => 'int',
        description => 'The ID of the object to center the audience geofence',
        required => '0',
    },
    'grouping_id' => {
        data_type => 'string',
        description => 'Optional grouping id for the audience',
        required => '0',
    },
    'meta_data' => {
        data_type => 'string',
        description => 'External custom client defined data',
        required => '0',
    },
    'visibility' => {
        data_type => 'string',
        description => 'Visibility of the audience',
        required => '0',
    },
    'audience_type' => {
        data_type => 'string',
        description => 'Type of audience',
        required => '0',
    },
    'use_order' => {
        data_type => 'boolean',
        description => 'Use order for cohort',
        required => '0',
    },
    'cohort_regions_data' => {
        data_type => 'string',
        description => 'Cohort data for \&quot;cohort\&quot; audience type',
        required => '0',
    },
    'app_key' => {
        data_type => 'string',
        description => 'Filter results by application key',
        required => '0',
    },
    'trilateration_types' => {
        data_type => 'string',
        description => 'Trilateration types',
        required => '0',
    },
    'unique_name' => {
        data_type => 'boolean',
        description => 'If true, makes sure the audience name is unique',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'update_audience' } = {
        summary => 'Update Audience',
        params => $params,
        returns => 'AudienceResponse',
        };
}
# @return AudienceResponse
#
sub update_audience {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling update_audience");
    }

    # verify the required parameter 'account_id' is set
    unless (exists $args{'account_id'}) {
      croak("Missing the required parameter 'account_id' when calling update_audience");
    }

    # verify the required parameter 'audience_id' is set
    unless (exists $args{'audience_id'}) {
      croak("Missing the required parameter 'audience_id' when calling update_audience");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/audience/update';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'account_id'}) {
        $query_params->{'accountId'} = $self->{api_client}->to_query_value($args{'account_id'});
    }

    # query params
    if ( exists $args{'audience_id'}) {
        $query_params->{'audienceId'} = $self->{api_client}->to_query_value($args{'audience_id'});
    }

    # query params
    if ( exists $args{'name'}) {
        $query_params->{'name'} = $self->{api_client}->to_query_value($args{'name'});
    }

    # query params
    if ( exists $args{'description'}) {
        $query_params->{'description'} = $self->{api_client}->to_query_value($args{'description'});
    }

    # query params
    if ( exists $args{'search_tags'}) {
        $query_params->{'searchTags'} = $self->{api_client}->to_query_value($args{'search_tags'});
    }

    # query params
    if ( exists $args{'gender'}) {
        $query_params->{'gender'} = $self->{api_client}->to_query_value($args{'gender'});
    }

    # query params
    if ( exists $args{'age_groups'}) {
        $query_params->{'ageGroups'} = $self->{api_client}->to_query_value($args{'age_groups'});
    }

    # query params
    if ( exists $args{'category_ids'}) {
        $query_params->{'categoryIds'} = $self->{api_client}->to_query_value($args{'category_ids'});
    }

    # query params
    if ( exists $args{'application_ids'}) {
        $query_params->{'applicationIds'} = $self->{api_client}->to_query_value($args{'application_ids'});
    }

    # query params
    if ( exists $args{'game_experience_level'}) {
        $query_params->{'gameExperienceLevel'} = $self->{api_client}->to_query_value($args{'game_experience_level'});
    }

    # query params
    if ( exists $args{'devices'}) {
        $query_params->{'devices'} = $self->{api_client}->to_query_value($args{'devices'});
    }

    # query params
    if ( exists $args{'device_ids'}) {
        $query_params->{'deviceIds'} = $self->{api_client}->to_query_value($args{'device_ids'});
    }

    # query params
    if ( exists $args{'device_versions'}) {
        $query_params->{'deviceVersions'} = $self->{api_client}->to_query_value($args{'device_versions'});
    }

    # query params
    if ( exists $args{'locations'}) {
        $query_params->{'locations'} = $self->{api_client}->to_query_value($args{'locations'});
    }

    # query params
    if ( exists $args{'radius'}) {
        $query_params->{'radius'} = $self->{api_client}->to_query_value($args{'radius'});
    }

    # query params
    if ( exists $args{'active'}) {
        $query_params->{'active'} = $self->{api_client}->to_query_value($args{'active'});
    }

    # query params
    if ( exists $args{'send_suggestion'}) {
        $query_params->{'sendSuggestion'} = $self->{api_client}->to_query_value($args{'send_suggestion'});
    }

    # query params
    if ( exists $args{'start_time_offset'}) {
        $query_params->{'startTimeOffset'} = $self->{api_client}->to_query_value($args{'start_time_offset'});
    }

    # query params
    if ( exists $args{'end_time_offset'}) {
        $query_params->{'endTimeOffset'} = $self->{api_client}->to_query_value($args{'end_time_offset'});
    }

    # query params
    if ( exists $args{'associate_description'}) {
        $query_params->{'associateDescription'} = $self->{api_client}->to_query_value($args{'associate_description'});
    }

    # query params
    if ( exists $args{'associate_type'}) {
        $query_params->{'associateType'} = $self->{api_client}->to_query_value($args{'associate_type'});
    }

    # query params
    if ( exists $args{'associate_id'}) {
        $query_params->{'associateId'} = $self->{api_client}->to_query_value($args{'associate_id'});
    }

    # query params
    if ( exists $args{'grouping_id'}) {
        $query_params->{'groupingId'} = $self->{api_client}->to_query_value($args{'grouping_id'});
    }

    # query params
    if ( exists $args{'meta_data'}) {
        $query_params->{'metaData'} = $self->{api_client}->to_query_value($args{'meta_data'});
    }

    # query params
    if ( exists $args{'visibility'}) {
        $query_params->{'visibility'} = $self->{api_client}->to_query_value($args{'visibility'});
    }

    # query params
    if ( exists $args{'audience_type'}) {
        $query_params->{'audienceType'} = $self->{api_client}->to_query_value($args{'audience_type'});
    }

    # query params
    if ( exists $args{'use_order'}) {
        $query_params->{'useOrder'} = $self->{api_client}->to_query_value($args{'use_order'});
    }

    # query params
    if ( exists $args{'cohort_regions_data'}) {
        $query_params->{'cohortRegionsData'} = $self->{api_client}->to_query_value($args{'cohort_regions_data'});
    }

    # query params
    if ( exists $args{'app_key'}) {
        $query_params->{'appKey'} = $self->{api_client}->to_query_value($args{'app_key'});
    }

    # query params
    if ( exists $args{'trilateration_types'}) {
        $query_params->{'trilaterationTypes'} = $self->{api_client}->to_query_value($args{'trilateration_types'});
    }

    # query params
    if ( exists $args{'unique_name'}) {
        $query_params->{'uniqueName'} = $self->{api_client}->to_query_value($args{'unique_name'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AudienceResponse', $response);
    return $_response_object;
}

1;
