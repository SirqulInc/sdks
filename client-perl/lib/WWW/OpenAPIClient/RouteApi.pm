=begin comment

Sirqul IoT Platform

Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

The version of the OpenAPI document: 3.16
Contact: info@sirqul.com
Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package WWW::OpenAPIClient::RouteApi;

require 5.6.0;
use strict;
use warnings;
use utf8;
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use WWW::OpenAPIClient::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'WWW::OpenAPIClient::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = WWW::OpenAPIClient::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# approve_route
#
# Approve Route
#
# @param double $version  (required)
# @param int $route_id the id of the route to approve (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'route_id' => {
        data_type => 'int',
        description => 'the id of the route to approve',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'approve_route' } = {
        summary => 'Approve Route',
        params => $params,
        returns => 'Route',
        };
}
# @return Route
#
sub approve_route {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling approve_route");
    }

    # verify the required parameter 'route_id' is set
    unless (exists $args{'route_id'}) {
      croak("Missing the required parameter 'route_id' when calling approve_route");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{routeId}/approve';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'route_id'}) {
        my $_base_variable = "{" . "routeId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'route_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('Route', $response);
    return $_response_object;
}

#
# copy_route
#
# Copy Route
#
# @param double $version  (required)
# @param int $route_id the id of the route to duplicate (required)
# @param Route $body  (optional)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'route_id' => {
        data_type => 'int',
        description => 'the id of the route to duplicate',
        required => '1',
    },
    'body' => {
        data_type => 'Route',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'copy_route' } = {
        summary => 'Copy Route',
        params => $params,
        returns => 'Route',
        };
}
# @return Route
#
sub copy_route {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling copy_route");
    }

    # verify the required parameter 'route_id' is set
    unless (exists $args{'route_id'}) {
      croak("Missing the required parameter 'route_id' when calling copy_route");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{routeId}/copy';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'route_id'}) {
        my $_base_variable = "{" . "routeId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'route_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('Route', $response);
    return $_response_object;
}

#
# create_route
#
# Create Route
#
# @param double $version  (required)
# @param Route $body  (optional)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'body' => {
        data_type => 'Route',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_route' } = {
        summary => 'Create Route',
        params => $params,
        returns => 'Route',
        };
}
# @return Route
#
sub create_route {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling create_route");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('Route', $response);
    return $_response_object;
}

#
# create_route_directions
#
# Update Route Directions
#
# @param double $version  (required)
# @param int $route_id the id of the route to update directions for (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'route_id' => {
        data_type => 'int',
        description => 'the id of the route to update directions for',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_route_directions' } = {
        summary => 'Update Route Directions',
        params => $params,
        returns => 'ARRAY[Direction]',
        };
}
# @return ARRAY[Direction]
#
sub create_route_directions {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling create_route_directions");
    }

    # verify the required parameter 'route_id' is set
    unless (exists $args{'route_id'}) {
      croak("Missing the required parameter 'route_id' when calling create_route_directions");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{routeId}/directions';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'route_id'}) {
        my $_base_variable = "{" . "routeId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'route_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[Direction]', $response);
    return $_response_object;
}

#
# create_route_polyline
#
# Create Route Polyline
#
# @param double $version  (required)
# @param int $route_id the id of the route to create a polyline for (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'route_id' => {
        data_type => 'int',
        description => 'the id of the route to create a polyline for',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_route_polyline' } = {
        summary => 'Create Route Polyline',
        params => $params,
        returns => 'Route',
        };
}
# @return Route
#
sub create_route_polyline {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling create_route_polyline");
    }

    # verify the required parameter 'route_id' is set
    unless (exists $args{'route_id'}) {
      croak("Missing the required parameter 'route_id' when calling create_route_polyline");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{routeId}/polyline';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'route_id'}) {
        my $_base_variable = "{" . "routeId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'route_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('Route', $response);
    return $_response_object;
}

#
# delete_route
#
# Delete Route
#
# @param double $version  (required)
# @param int $route_id the id of the route (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'route_id' => {
        data_type => 'int',
        description => 'the id of the route',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_route' } = {
        summary => 'Delete Route',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub delete_route {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling delete_route");
    }

    # verify the required parameter 'route_id' is set
    unless (exists $args{'route_id'}) {
      croak("Missing the required parameter 'route_id' when calling delete_route");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{routeId}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'route_id'}) {
        my $_base_variable = "{" . "routeId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'route_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# disapprove_route
#
# Disapprove Route
#
# @param double $version  (required)
# @param int $route_id the id of the route to reject (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'route_id' => {
        data_type => 'int',
        description => 'the id of the route to reject',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'disapprove_route' } = {
        summary => 'Disapprove Route',
        params => $params,
        returns => 'Route',
        };
}
# @return Route
#
sub disapprove_route {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling disapprove_route");
    }

    # verify the required parameter 'route_id' is set
    unless (exists $args{'route_id'}) {
      croak("Missing the required parameter 'route_id' when calling disapprove_route");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{routeId}/disapprove';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'route_id'}) {
        my $_base_variable = "{" . "routeId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'route_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('Route', $response);
    return $_response_object;
}

#
# get_route
#
# Get Route
#
# @param double $version  (required)
# @param int $route_id the id of the route to get (required)
# @param boolean $show_inherited_properties return inherited properties from parent or not (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'route_id' => {
        data_type => 'int',
        description => 'the id of the route to get',
        required => '1',
    },
    'show_inherited_properties' => {
        data_type => 'boolean',
        description => 'return inherited properties from parent or not',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_route' } = {
        summary => 'Get Route',
        params => $params,
        returns => 'Route',
        };
}
# @return Route
#
sub get_route {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling get_route");
    }

    # verify the required parameter 'route_id' is set
    unless (exists $args{'route_id'}) {
      croak("Missing the required parameter 'route_id' when calling get_route");
    }

    # verify the required parameter 'show_inherited_properties' is set
    unless (exists $args{'show_inherited_properties'}) {
      croak("Missing the required parameter 'show_inherited_properties' when calling get_route");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{routeId}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'show_inherited_properties'}) {
        $query_params->{'showInheritedProperties'} = $self->{api_client}->to_query_value($args{'show_inherited_properties'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'route_id'}) {
        my $_base_variable = "{" . "routeId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'route_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('Route', $response);
    return $_response_object;
}

#
# get_route_directions
#
# Get Route Directions
#
# @param double $version  (required)
# @param int $route_id the id of the route to get directions for (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'route_id' => {
        data_type => 'int',
        description => 'the id of the route to get directions for',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_route_directions' } = {
        summary => 'Get Route Directions',
        params => $params,
        returns => 'ARRAY[Direction]',
        };
}
# @return ARRAY[Direction]
#
sub get_route_directions {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling get_route_directions");
    }

    # verify the required parameter 'route_id' is set
    unless (exists $args{'route_id'}) {
      croak("Missing the required parameter 'route_id' when calling get_route_directions");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{routeId}/directions';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'route_id'}) {
        my $_base_variable = "{" . "routeId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'route_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[Direction]', $response);
    return $_response_object;
}

#
# get_route_shipments
#
# Get Route Shipments
#
# @param double $version  (required)
# @param int $route_id the id of the route to get shipments for (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'route_id' => {
        data_type => 'int',
        description => 'the id of the route to get shipments for',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_route_shipments' } = {
        summary => 'Get Route Shipments',
        params => $params,
        returns => 'ARRAY[Shipment]',
        };
}
# @return ARRAY[Shipment]
#
sub get_route_shipments {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling get_route_shipments");
    }

    # verify the required parameter 'route_id' is set
    unless (exists $args{'route_id'}) {
      croak("Missing the required parameter 'route_id' when calling get_route_shipments");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{routeId}/shipments';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'route_id'}) {
        my $_base_variable = "{" . "routeId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'route_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[Shipment]', $response);
    return $_response_object;
}

#
# get_route_stop
#
# Get Route Stop
#
# @param double $version  (required)
# @param int $route_id the id of the route to get stops for (required)
# @param int $stop_id the id of the specific stop on the route (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'route_id' => {
        data_type => 'int',
        description => 'the id of the route to get stops for',
        required => '1',
    },
    'stop_id' => {
        data_type => 'int',
        description => 'the id of the specific stop on the route',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_route_stop' } = {
        summary => 'Get Route Stop',
        params => $params,
        returns => 'Stop',
        };
}
# @return Stop
#
sub get_route_stop {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling get_route_stop");
    }

    # verify the required parameter 'route_id' is set
    unless (exists $args{'route_id'}) {
      croak("Missing the required parameter 'route_id' when calling get_route_stop");
    }

    # verify the required parameter 'stop_id' is set
    unless (exists $args{'stop_id'}) {
      croak("Missing the required parameter 'stop_id' when calling get_route_stop");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{routeId}/stop/{stopId}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'route_id'}) {
        my $_base_variable = "{" . "routeId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'route_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'stop_id'}) {
        my $_base_variable = "{" . "stopId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'stop_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('Stop', $response);
    return $_response_object;
}

#
# get_route_stops
#
# Get Route Stops
#
# @param double $version  (required)
# @param int $route_id the id of the route (required)
# @param boolean $confirmed_only only get stops that have been confirmed or not (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'route_id' => {
        data_type => 'int',
        description => 'the id of the route',
        required => '1',
    },
    'confirmed_only' => {
        data_type => 'boolean',
        description => 'only get stops that have been confirmed or not',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_route_stops' } = {
        summary => 'Get Route Stops',
        params => $params,
        returns => 'ARRAY[Stop]',
        };
}
# @return ARRAY[Stop]
#
sub get_route_stops {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling get_route_stops");
    }

    # verify the required parameter 'route_id' is set
    unless (exists $args{'route_id'}) {
      croak("Missing the required parameter 'route_id' when calling get_route_stops");
    }

    # verify the required parameter 'confirmed_only' is set
    unless (exists $args{'confirmed_only'}) {
      croak("Missing the required parameter 'confirmed_only' when calling get_route_stops");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{routeId}/stops';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'confirmed_only'}) {
        $query_params->{'confirmedOnly'} = $self->{api_client}->to_query_value($args{'confirmed_only'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'route_id'}) {
        my $_base_variable = "{" . "routeId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'route_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[Stop]', $response);
    return $_response_object;
}

#
# get_shipments_at_stop
#
# Get Shipments At Stop
#
# @param double $version  (required)
# @param int $route_id the id of the route (required)
# @param int $stop_id the id of the stop to get shipments on (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'route_id' => {
        data_type => 'int',
        description => 'the id of the route',
        required => '1',
    },
    'stop_id' => {
        data_type => 'int',
        description => 'the id of the stop to get shipments on',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_shipments_at_stop' } = {
        summary => 'Get Shipments At Stop',
        params => $params,
        returns => 'ARRAY[Shipment]',
        };
}
# @return ARRAY[Shipment]
#
sub get_shipments_at_stop {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling get_shipments_at_stop");
    }

    # verify the required parameter 'route_id' is set
    unless (exists $args{'route_id'}) {
      croak("Missing the required parameter 'route_id' when calling get_shipments_at_stop");
    }

    # verify the required parameter 'stop_id' is set
    unless (exists $args{'stop_id'}) {
      croak("Missing the required parameter 'stop_id' when calling get_shipments_at_stop");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{routeId}/stop/{stopId}/shipments';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'route_id'}) {
        my $_base_variable = "{" . "routeId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'route_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'stop_id'}) {
        my $_base_variable = "{" . "stopId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'stop_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[Shipment]', $response);
    return $_response_object;
}

#
# optimize_route
#
# Optimize Route
#
# @param double $version  (required)
# @param int $route_id the id of the route to optimize (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'route_id' => {
        data_type => 'int',
        description => 'the id of the route to optimize',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'optimize_route' } = {
        summary => 'Optimize Route',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub optimize_route {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling optimize_route");
    }

    # verify the required parameter 'route_id' is set
    unless (exists $args{'route_id'}) {
      croak("Missing the required parameter 'route_id' when calling optimize_route");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{routeId}/optimize';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'route_id'}) {
        my $_base_variable = "{" . "routeId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'route_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# remove_stop
#
# Delete Stop
#
# @param double $version  (required)
# @param int $route_id the id of the route (required)
# @param int $stop_id the id of the specific stop to delete on the route (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'route_id' => {
        data_type => 'int',
        description => 'the id of the route',
        required => '1',
    },
    'stop_id' => {
        data_type => 'int',
        description => 'the id of the specific stop to delete on the route',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'remove_stop' } = {
        summary => 'Delete Stop',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub remove_stop {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling remove_stop");
    }

    # verify the required parameter 'route_id' is set
    unless (exists $args{'route_id'}) {
      croak("Missing the required parameter 'route_id' when calling remove_stop");
    }

    # verify the required parameter 'stop_id' is set
    unless (exists $args{'stop_id'}) {
      croak("Missing the required parameter 'stop_id' when calling remove_stop");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{routeId}/stop/{stopId}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'route_id'}) {
        my $_base_variable = "{" . "routeId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'route_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'stop_id'}) {
        my $_base_variable = "{" . "stopId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'stop_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# reorder_route_stops_patch
#
# Reorder Route Stops
#
# @param double $version  (required)
# @param int $route_id the id of the route (required)
# @param ARRAY[Stop] $body  (optional)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'route_id' => {
        data_type => 'int',
        description => 'the id of the route',
        required => '1',
    },
    'body' => {
        data_type => 'ARRAY[Stop]',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'reorder_route_stops_patch' } = {
        summary => 'Reorder Route Stops',
        params => $params,
        returns => 'ARRAY[Stop]',
        };
}
# @return ARRAY[Stop]
#
sub reorder_route_stops_patch {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling reorder_route_stops_patch");
    }

    # verify the required parameter 'route_id' is set
    unless (exists $args{'route_id'}) {
      croak("Missing the required parameter 'route_id' when calling reorder_route_stops_patch");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{routeId}/stops/reorder';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'route_id'}) {
        my $_base_variable = "{" . "routeId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'route_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[Stop]', $response);
    return $_response_object;
}

#
# reorder_route_stops_post
#
# Reorder Route Stops
#
# @param double $version  (required)
# @param int $route_id the id of the route (required)
# @param ARRAY[Stop] $body  (optional)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'route_id' => {
        data_type => 'int',
        description => 'the id of the route',
        required => '1',
    },
    'body' => {
        data_type => 'ARRAY[Stop]',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'reorder_route_stops_post' } = {
        summary => 'Reorder Route Stops',
        params => $params,
        returns => 'ARRAY[Stop]',
        };
}
# @return ARRAY[Stop]
#
sub reorder_route_stops_post {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling reorder_route_stops_post");
    }

    # verify the required parameter 'route_id' is set
    unless (exists $args{'route_id'}) {
      croak("Missing the required parameter 'route_id' when calling reorder_route_stops_post");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{routeId}/stops/reorder';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'route_id'}) {
        my $_base_variable = "{" . "routeId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'route_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[Stop]', $response);
    return $_response_object;
}

#
# search_routes
#
# Search Routes
#
# @param double $version  (required)
# @param string $sort_field The field to sort by (required)
# @param boolean $descending Determines whether the sorted list is in descending or ascending order (required)
# @param int $start The start index for pagination (required)
# @param int $limit The limit for pagination (required)
# @param boolean $active_only Return only active results (required)
# @param boolean $includes_empty Include empty routes or not (required)
# @param boolean $root_only Only return root instance routes (required)
# @param boolean $show_inherited_properties Display root route properties (required)
# @param int $hub_id Filter results by service hub (optional)
# @param int $program_id Filter results by program (optional)
# @param int $scheduled_start The start date to filter the results by (optional)
# @param int $scheduled_end The end date to filter the results by (optional)
# @param int $updated_start The lower bound of updated date (optional)
# @param int $updated_end The upper bound of updated date (optional)
# @param boolean $featured The route is featured or not (optional)
# @param int $seat_count Has at least this many seat available (optional)
# @param boolean $approved Has been approved or not (optional)
# @param boolean $started Has started or not (optional)
# @param boolean $completed Has completed or not (optional)
# @param boolean $valid Is valid or not (optional)
# @param int $parent_id If it is a recurring route based on the parent route (optional)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'sort_field' => {
        data_type => 'string',
        description => 'The field to sort by',
        required => '1',
    },
    'descending' => {
        data_type => 'boolean',
        description => 'Determines whether the sorted list is in descending or ascending order',
        required => '1',
    },
    'start' => {
        data_type => 'int',
        description => 'The start index for pagination',
        required => '1',
    },
    'limit' => {
        data_type => 'int',
        description => 'The limit for pagination',
        required => '1',
    },
    'active_only' => {
        data_type => 'boolean',
        description => 'Return only active results',
        required => '1',
    },
    'includes_empty' => {
        data_type => 'boolean',
        description => 'Include empty routes or not',
        required => '1',
    },
    'root_only' => {
        data_type => 'boolean',
        description => 'Only return root instance routes',
        required => '1',
    },
    'show_inherited_properties' => {
        data_type => 'boolean',
        description => 'Display root route properties',
        required => '1',
    },
    'hub_id' => {
        data_type => 'int',
        description => 'Filter results by service hub',
        required => '0',
    },
    'program_id' => {
        data_type => 'int',
        description => 'Filter results by program',
        required => '0',
    },
    'scheduled_start' => {
        data_type => 'int',
        description => 'The start date to filter the results by',
        required => '0',
    },
    'scheduled_end' => {
        data_type => 'int',
        description => 'The end date to filter the results by',
        required => '0',
    },
    'updated_start' => {
        data_type => 'int',
        description => 'The lower bound of updated date',
        required => '0',
    },
    'updated_end' => {
        data_type => 'int',
        description => 'The upper bound of updated date',
        required => '0',
    },
    'featured' => {
        data_type => 'boolean',
        description => 'The route is featured or not',
        required => '0',
    },
    'seat_count' => {
        data_type => 'int',
        description => 'Has at least this many seat available',
        required => '0',
    },
    'approved' => {
        data_type => 'boolean',
        description => 'Has been approved or not',
        required => '0',
    },
    'started' => {
        data_type => 'boolean',
        description => 'Has started or not',
        required => '0',
    },
    'completed' => {
        data_type => 'boolean',
        description => 'Has completed or not',
        required => '0',
    },
    'valid' => {
        data_type => 'boolean',
        description => 'Is valid or not',
        required => '0',
    },
    'parent_id' => {
        data_type => 'int',
        description => 'If it is a recurring route based on the parent route',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'search_routes' } = {
        summary => 'Search Routes',
        params => $params,
        returns => 'ARRAY[Route]',
        };
}
# @return ARRAY[Route]
#
sub search_routes {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling search_routes");
    }

    # verify the required parameter 'sort_field' is set
    unless (exists $args{'sort_field'}) {
      croak("Missing the required parameter 'sort_field' when calling search_routes");
    }

    # verify the required parameter 'descending' is set
    unless (exists $args{'descending'}) {
      croak("Missing the required parameter 'descending' when calling search_routes");
    }

    # verify the required parameter 'start' is set
    unless (exists $args{'start'}) {
      croak("Missing the required parameter 'start' when calling search_routes");
    }

    # verify the required parameter 'limit' is set
    unless (exists $args{'limit'}) {
      croak("Missing the required parameter 'limit' when calling search_routes");
    }

    # verify the required parameter 'active_only' is set
    unless (exists $args{'active_only'}) {
      croak("Missing the required parameter 'active_only' when calling search_routes");
    }

    # verify the required parameter 'includes_empty' is set
    unless (exists $args{'includes_empty'}) {
      croak("Missing the required parameter 'includes_empty' when calling search_routes");
    }

    # verify the required parameter 'root_only' is set
    unless (exists $args{'root_only'}) {
      croak("Missing the required parameter 'root_only' when calling search_routes");
    }

    # verify the required parameter 'show_inherited_properties' is set
    unless (exists $args{'show_inherited_properties'}) {
      croak("Missing the required parameter 'show_inherited_properties' when calling search_routes");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'hub_id'}) {
        $query_params->{'hubId'} = $self->{api_client}->to_query_value($args{'hub_id'});
    }

    # query params
    if ( exists $args{'program_id'}) {
        $query_params->{'programId'} = $self->{api_client}->to_query_value($args{'program_id'});
    }

    # query params
    if ( exists $args{'scheduled_start'}) {
        $query_params->{'scheduledStart'} = $self->{api_client}->to_query_value($args{'scheduled_start'});
    }

    # query params
    if ( exists $args{'scheduled_end'}) {
        $query_params->{'scheduledEnd'} = $self->{api_client}->to_query_value($args{'scheduled_end'});
    }

    # query params
    if ( exists $args{'updated_start'}) {
        $query_params->{'updatedStart'} = $self->{api_client}->to_query_value($args{'updated_start'});
    }

    # query params
    if ( exists $args{'updated_end'}) {
        $query_params->{'updatedEnd'} = $self->{api_client}->to_query_value($args{'updated_end'});
    }

    # query params
    if ( exists $args{'featured'}) {
        $query_params->{'featured'} = $self->{api_client}->to_query_value($args{'featured'});
    }

    # query params
    if ( exists $args{'seat_count'}) {
        $query_params->{'seatCount'} = $self->{api_client}->to_query_value($args{'seat_count'});
    }

    # query params
    if ( exists $args{'approved'}) {
        $query_params->{'approved'} = $self->{api_client}->to_query_value($args{'approved'});
    }

    # query params
    if ( exists $args{'started'}) {
        $query_params->{'started'} = $self->{api_client}->to_query_value($args{'started'});
    }

    # query params
    if ( exists $args{'completed'}) {
        $query_params->{'completed'} = $self->{api_client}->to_query_value($args{'completed'});
    }

    # query params
    if ( exists $args{'valid'}) {
        $query_params->{'valid'} = $self->{api_client}->to_query_value($args{'valid'});
    }

    # query params
    if ( exists $args{'parent_id'}) {
        $query_params->{'parentId'} = $self->{api_client}->to_query_value($args{'parent_id'});
    }

    # query params
    if ( exists $args{'sort_field'}) {
        $query_params->{'sortField'} = $self->{api_client}->to_query_value($args{'sort_field'});
    }

    # query params
    if ( exists $args{'descending'}) {
        $query_params->{'descending'} = $self->{api_client}->to_query_value($args{'descending'});
    }

    # query params
    if ( exists $args{'start'}) {
        $query_params->{'start'} = $self->{api_client}->to_query_value($args{'start'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'active_only'}) {
        $query_params->{'activeOnly'} = $self->{api_client}->to_query_value($args{'active_only'});
    }

    # query params
    if ( exists $args{'includes_empty'}) {
        $query_params->{'includesEmpty'} = $self->{api_client}->to_query_value($args{'includes_empty'});
    }

    # query params
    if ( exists $args{'root_only'}) {
        $query_params->{'rootOnly'} = $self->{api_client}->to_query_value($args{'root_only'});
    }

    # query params
    if ( exists $args{'show_inherited_properties'}) {
        $query_params->{'showInheritedProperties'} = $self->{api_client}->to_query_value($args{'show_inherited_properties'});
    }

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[Route]', $response);
    return $_response_object;
}

#
# set_driver
#
# Set Driver
#
# @param double $version  (required)
# @param int $id the id of the route (required)
# @param int $driver_id the id of the driver (required)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'id' => {
        data_type => 'int',
        description => 'the id of the route',
        required => '1',
    },
    'driver_id' => {
        data_type => 'int',
        description => 'the id of the driver',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'set_driver' } = {
        summary => 'Set Driver',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub set_driver {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling set_driver");
    }

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling set_driver");
    }

    # verify the required parameter 'driver_id' is set
    unless (exists $args{'driver_id'}) {
      croak("Missing the required parameter 'driver_id' when calling set_driver");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{id}/driver/{driverId}';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'id'}) {
        my $_base_variable = "{" . "id" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'driver_id'}) {
        my $_base_variable = "{" . "driverId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'driver_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# update_route
#
# Update Route
#
# @param double $version  (required)
# @param int $route_id the id of the route (required)
# @param Route $body  (optional)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'route_id' => {
        data_type => 'int',
        description => 'the id of the route',
        required => '1',
    },
    'body' => {
        data_type => 'Route',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'update_route' } = {
        summary => 'Update Route',
        params => $params,
        returns => 'Route',
        };
}
# @return Route
#
sub update_route {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling update_route");
    }

    # verify the required parameter 'route_id' is set
    unless (exists $args{'route_id'}) {
      croak("Missing the required parameter 'route_id' when calling update_route");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{routeId}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'route_id'}) {
        my $_base_variable = "{" . "routeId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'route_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('Route', $response);
    return $_response_object;
}

#
# update_route_stop
#
# Update Route Stop
#
# @param double $version  (required)
# @param int $route_id the id of the route to update stops for (required)
# @param int $stop_id the id of the specific stop to update on the route (required)
# @param Stop $body  (optional)
{
    my $params = {
    'version' => {
        data_type => 'double',
        description => '',
        required => '1',
    },
    'route_id' => {
        data_type => 'int',
        description => 'the id of the route to update stops for',
        required => '1',
    },
    'stop_id' => {
        data_type => 'int',
        description => 'the id of the specific stop to update on the route',
        required => '1',
    },
    'body' => {
        data_type => 'Stop',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'update_route_stop' } = {
        summary => 'Update Route Stop',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub update_route_stop {
    my ($self, %args) = @_;

    # verify the required parameter 'version' is set
    unless (exists $args{'version'}) {
      croak("Missing the required parameter 'version' when calling update_route_stop");
    }

    # verify the required parameter 'route_id' is set
    unless (exists $args{'route_id'}) {
      croak("Missing the required parameter 'route_id' when calling update_route_stop");
    }

    # verify the required parameter 'stop_id' is set
    unless (exists $args{'stop_id'}) {
      croak("Missing the required parameter 'stop_id' when calling update_route_stop");
    }

    # parse inputs
    my $_resource_path = '/api/{version}/route/{routeId}/stop/{stopId}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'version'}) {
        my $_base_variable = "{" . "version" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'version'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'route_id'}) {
        my $_base_variable = "{" . "routeId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'route_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'stop_id'}) {
        my $_base_variable = "{" . "stopId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'stop_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

1;
