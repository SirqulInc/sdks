// <auto-generated>
/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Net;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IConnectionApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ConnectionApiEvents Events { get; }

        /// <summary>
        /// Add Connection
        /// </summary>
        /// <remarks>
        /// Adds a connection to a group.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the group id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionId">the connection id (optional)</param>
        /// <param name="connectionAccountId">the connection account id (optional)</param>
        /// <param name="pendingId">the pending id (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddConnectionToGroupApiResponse"/>&gt;</returns>
        Task<IAddConnectionToGroupApiResponse> AddConnectionToGroupAsync(bool returnNulls, long groupId, Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionId = default, Option<long> connectionAccountId = default, Option<long> pendingId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Add Connection
        /// </summary>
        /// <remarks>
        /// Adds a connection to a group.
        /// </remarks>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the group id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionId">the connection id (optional)</param>
        /// <param name="connectionAccountId">the connection account id (optional)</param>
        /// <param name="pendingId">the pending id (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddConnectionToGroupApiResponse"/>?&gt;</returns>
        Task<IAddConnectionToGroupApiResponse?> AddConnectionToGroupOrDefaultAsync(bool returnNulls, long groupId, Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionId = default, Option<long> connectionAccountId = default, Option<long> pendingId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Add Connections
        /// </summary>
        /// <remarks>
        /// Adds a list of connections to a group.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectionGroupId">the connection group ID</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionIds">comma separated list of connection ids (optional)</param>
        /// <param name="connectionAccountIds">comma separated list of connection account ids (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddConnectionsToGroupApiResponse"/>&gt;</returns>
        Task<IAddConnectionsToGroupApiResponse> AddConnectionsToGroupAsync(long connectionGroupId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> connectionIds = default, Option<string> connectionAccountIds = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Add Connections
        /// </summary>
        /// <remarks>
        /// Adds a list of connections to a group.
        /// </remarks>
        /// <param name="connectionGroupId">the connection group ID</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionIds">comma separated list of connection ids (optional)</param>
        /// <param name="connectionAccountIds">comma separated list of connection account ids (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddConnectionsToGroupApiResponse"/>?&gt;</returns>
        Task<IAddConnectionsToGroupApiResponse?> AddConnectionsToGroupOrDefaultAsync(long connectionGroupId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> connectionIds = default, Option<string> connectionAccountIds = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Add Connection Groups
        /// </summary>
        /// <remarks>
        /// Add sub groups to a group.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the parent group id</param>
        /// <param name="subGroupIds">comma separated list of group IDs to add to the parent group</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddSubGroupsApiResponse"/>&gt;</returns>
        Task<IAddSubGroupsApiResponse> AddSubGroupsAsync(bool returnNulls, long groupId, string subGroupIds, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Add Connection Groups
        /// </summary>
        /// <remarks>
        /// Add sub groups to a group.
        /// </remarks>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the parent group id</param>
        /// <param name="subGroupIds">comma separated list of group IDs to add to the parent group</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddSubGroupsApiResponse"/>?&gt;</returns>
        Task<IAddSubGroupsApiResponse?> AddSubGroupsOrDefaultAsync(bool returnNulls, long groupId, string subGroupIds, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create or Update Connection
        /// </summary>
        /// <remarks>
        /// Creates or updates the connection of the user and another account. Allows a user to follow, block, mark as trusted, and/or add someone to a group.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionId">the connection id for editing (optional)</param>
        /// <param name="connectionAccountId">the connection account id (i.e. the account id of another user) (optional)</param>
        /// <param name="pendingId">the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps) (optional)</param>
        /// <param name="groupId">optional group id if the user wants to add this person into a group (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="isTrusted">determines whether the user is trusting this account (optional)</param>
        /// <param name="ignoreFriendRequest">determines whether the user has set to ignore the user&#39;s friend request (optional)</param>
        /// <param name="isContact">determines whether the user is a contact of this account (optional)</param>
        /// <param name="isBlocked">determines whether the user is blocking this account (optional)</param>
        /// <param name="isFollowing">determines whether the user is following this account (optional)</param>
        /// <param name="connectionResponse">whether to return the connection response or not (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateOrUpdateConnectionApiResponse"/>&gt;</returns>
        Task<ICreateOrUpdateConnectionApiResponse> CreateOrUpdateConnectionAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionId = default, Option<long> connectionAccountId = default, Option<long> pendingId = default, Option<long> groupId = default, Option<string> gameType = default, Option<string> appKey = default, Option<bool> isTrusted = default, Option<bool> ignoreFriendRequest = default, Option<bool> isContact = default, Option<bool> isBlocked = default, Option<bool> isFollowing = default, Option<bool> connectionResponse = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create or Update Connection
        /// </summary>
        /// <remarks>
        /// Creates or updates the connection of the user and another account. Allows a user to follow, block, mark as trusted, and/or add someone to a group.
        /// </remarks>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionId">the connection id for editing (optional)</param>
        /// <param name="connectionAccountId">the connection account id (i.e. the account id of another user) (optional)</param>
        /// <param name="pendingId">the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps) (optional)</param>
        /// <param name="groupId">optional group id if the user wants to add this person into a group (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="isTrusted">determines whether the user is trusting this account (optional)</param>
        /// <param name="ignoreFriendRequest">determines whether the user has set to ignore the user&#39;s friend request (optional)</param>
        /// <param name="isContact">determines whether the user is a contact of this account (optional)</param>
        /// <param name="isBlocked">determines whether the user is blocking this account (optional)</param>
        /// <param name="isFollowing">determines whether the user is following this account (optional)</param>
        /// <param name="connectionResponse">whether to return the connection response or not (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateOrUpdateConnectionApiResponse"/>?&gt;</returns>
        Task<ICreateOrUpdateConnectionApiResponse?> CreateOrUpdateConnectionOrDefaultAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionId = default, Option<long> connectionAccountId = default, Option<long> pendingId = default, Option<long> groupId = default, Option<string> gameType = default, Option<string> appKey = default, Option<bool> isTrusted = default, Option<bool> ignoreFriendRequest = default, Option<bool> isContact = default, Option<bool> isBlocked = default, Option<bool> isFollowing = default, Option<bool> connectionResponse = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create or Update Connection Group
        /// </summary>
        /// <remarks>
        /// Creates a new private group.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="name">the name of the group (optional)</param>
        /// <param name="groupId">the group id to update a group (don&#39;t pass anything in if you want to create a new group) (optional)</param>
        /// <param name="assetId">the asset to attach to the group (optional)</param>
        /// <param name="connections">comma separated list of connection IDs (optional)</param>
        /// <param name="description">the description of the group (optional)</param>
        /// <param name="canViewProfileInfo">determines whether the connections in the group can see the user&#39;s profile info (optional)</param>
        /// <param name="canViewGameInfo">determines whether the connections in the group can see the user&#39;s game info (optional)</param>
        /// <param name="canViewFriendInfo">determines whether the connections in the group can see the user&#39;s friends/connections (optional)</param>
        /// <param name="active">Sets whether the connection group is active or inactive (optional)</param>
        /// <param name="latitude">the latitude of the group (optional)</param>
        /// <param name="longitude">the longitude of the group (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateOrUpdateGroupApiResponse"/>&gt;</returns>
        Task<ICreateOrUpdateGroupApiResponse> CreateOrUpdateGroupAsync(bool returnNulls, Option<string> deviceId = default, Option<long> accountId = default, Option<string> name = default, Option<long> groupId = default, Option<long> assetId = default, Option<string> connections = default, Option<string> description = default, Option<bool> canViewProfileInfo = default, Option<bool> canViewGameInfo = default, Option<bool> canViewFriendInfo = default, Option<bool> active = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create or Update Connection Group
        /// </summary>
        /// <remarks>
        /// Creates a new private group.
        /// </remarks>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="name">the name of the group (optional)</param>
        /// <param name="groupId">the group id to update a group (don&#39;t pass anything in if you want to create a new group) (optional)</param>
        /// <param name="assetId">the asset to attach to the group (optional)</param>
        /// <param name="connections">comma separated list of connection IDs (optional)</param>
        /// <param name="description">the description of the group (optional)</param>
        /// <param name="canViewProfileInfo">determines whether the connections in the group can see the user&#39;s profile info (optional)</param>
        /// <param name="canViewGameInfo">determines whether the connections in the group can see the user&#39;s game info (optional)</param>
        /// <param name="canViewFriendInfo">determines whether the connections in the group can see the user&#39;s friends/connections (optional)</param>
        /// <param name="active">Sets whether the connection group is active or inactive (optional)</param>
        /// <param name="latitude">the latitude of the group (optional)</param>
        /// <param name="longitude">the longitude of the group (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateOrUpdateGroupApiResponse"/>?&gt;</returns>
        Task<ICreateOrUpdateGroupApiResponse?> CreateOrUpdateGroupOrDefaultAsync(bool returnNulls, Option<string> deviceId = default, Option<long> accountId = default, Option<string> name = default, Option<long> groupId = default, Option<long> assetId = default, Option<string> connections = default, Option<string> description = default, Option<bool> canViewProfileInfo = default, Option<bool> canViewGameInfo = default, Option<bool> canViewFriendInfo = default, Option<bool> active = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Accept Follow Request
        /// </summary>
        /// <remarks>
        /// Accept someone&#39;s follow request.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="connectionAccountId">the account ID of the user who initiated the follow</param>
        /// <param name="appKey">the application key for sending notifications</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFollowAcceptApiResponse"/>&gt;</returns>
        Task<IFollowAcceptApiResponse> FollowAcceptAsync(long accountId, long connectionAccountId, string appKey, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Accept Follow Request
        /// </summary>
        /// <remarks>
        /// Accept someone&#39;s follow request.
        /// </remarks>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="connectionAccountId">the account ID of the user who initiated the follow</param>
        /// <param name="appKey">the application key for sending notifications</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFollowAcceptApiResponse"/>?&gt;</returns>
        Task<IFollowAcceptApiResponse?> FollowAcceptOrDefaultAsync(long accountId, long connectionAccountId, string appKey, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Reject Follow Request
        /// </summary>
        /// <remarks>
        /// Reject someone&#39;s follow request or remove them as a follower.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="connectionAccountId">the account ID of the user who initiated the follow</param>
        /// <param name="appKey">the application key for sending notifications</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFollowRejectApiResponse"/>&gt;</returns>
        Task<IFollowRejectApiResponse> FollowRejectAsync(long accountId, long connectionAccountId, string appKey, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Reject Follow Request
        /// </summary>
        /// <remarks>
        /// Reject someone&#39;s follow request or remove them as a follower.
        /// </remarks>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="connectionAccountId">the account ID of the user who initiated the follow</param>
        /// <param name="appKey">the application key for sending notifications</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFollowRejectApiResponse"/>?&gt;</returns>
        Task<IFollowRejectApiResponse?> FollowRejectOrDefaultAsync(long accountId, long connectionAccountId, string appKey, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Remove Follower / Unfollow
        /// </summary>
        /// <remarks>
        /// Unfollow someone you are following or remove them as a follower.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="connectionAccountId">the account ID of the user who you want to unfollow</param>
        /// <param name="appKey">the application key for sending notifications</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFollowRemoveApiResponse"/>&gt;</returns>
        Task<IFollowRemoveApiResponse> FollowRemoveAsync(long accountId, long connectionAccountId, string appKey, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Remove Follower / Unfollow
        /// </summary>
        /// <remarks>
        /// Unfollow someone you are following or remove them as a follower.
        /// </remarks>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="connectionAccountId">the account ID of the user who you want to unfollow</param>
        /// <param name="appKey">the application key for sending notifications</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFollowRemoveApiResponse"/>?&gt;</returns>
        Task<IFollowRemoveApiResponse?> FollowRemoveOrDefaultAsync(long accountId, long connectionAccountId, string appKey, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send Follow Request
        /// </summary>
        /// <remarks>
        /// Send a request to follow someone.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="connectionAccountId">the account ID of the user who you want to follow</param>
        /// <param name="appKey">the application key for sending notifications</param>
        /// <param name="approvalNeeded">determines if the other user needs to confirm the follow request (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFollowRequestApiResponse"/>&gt;</returns>
        Task<IFollowRequestApiResponse> FollowRequestAsync(long accountId, long connectionAccountId, string appKey, Option<bool> approvalNeeded = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send Follow Request
        /// </summary>
        /// <remarks>
        /// Send a request to follow someone.
        /// </remarks>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="connectionAccountId">the account ID of the user who you want to follow</param>
        /// <param name="appKey">the application key for sending notifications</param>
        /// <param name="approvalNeeded">determines if the other user needs to confirm the follow request (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFollowRequestApiResponse"/>?&gt;</returns>
        Task<IFollowRequestApiResponse?> FollowRequestOrDefaultAsync(long accountId, long connectionAccountId, string appKey, Option<bool> approvalNeeded = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Accept Friend
        /// </summary>
        /// <remarks>
        /// Accept a friend request and optionally sends a notification.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendAccountId">the friend&#39;s account id</param>
        /// <param name="notifyFriend">determines whether to send a notification to the afflicting party</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="notificationMessage">optional message to send in a notification (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFriendAcceptApiResponse"/>&gt;</returns>
        Task<IFriendAcceptApiResponse> FriendAcceptAsync(long friendAccountId, bool notifyFriend, Option<string> deviceId = default, Option<long> accountId = default, Option<string> gameType = default, Option<string> appKey = default, Option<string> notificationMessage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Accept Friend
        /// </summary>
        /// <remarks>
        /// Accept a friend request and optionally sends a notification.
        /// </remarks>
        /// <param name="friendAccountId">the friend&#39;s account id</param>
        /// <param name="notifyFriend">determines whether to send a notification to the afflicting party</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="notificationMessage">optional message to send in a notification (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFriendAcceptApiResponse"/>?&gt;</returns>
        Task<IFriendAcceptApiResponse?> FriendAcceptOrDefaultAsync(long friendAccountId, bool notifyFriend, Option<string> deviceId = default, Option<long> accountId = default, Option<string> gameType = default, Option<string> appKey = default, Option<string> notificationMessage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Decline Friend
        /// </summary>
        /// <remarks>
        /// Request a friend request and optionally sends a notification.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendAccountId">the friend&#39;s account id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="notifyFriend">determines whether to send a notification to the afflicting party (optional)</param>
        /// <param name="notificationMessage">optional message to send in a notification (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFriendRejectApiResponse"/>&gt;</returns>
        Task<IFriendRejectApiResponse> FriendRejectAsync(long friendAccountId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> gameType = default, Option<string> appKey = default, Option<bool> notifyFriend = default, Option<string> notificationMessage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Decline Friend
        /// </summary>
        /// <remarks>
        /// Request a friend request and optionally sends a notification.
        /// </remarks>
        /// <param name="friendAccountId">the friend&#39;s account id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="notifyFriend">determines whether to send a notification to the afflicting party (optional)</param>
        /// <param name="notificationMessage">optional message to send in a notification (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFriendRejectApiResponse"/>?&gt;</returns>
        Task<IFriendRejectApiResponse?> FriendRejectOrDefaultAsync(long friendAccountId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> gameType = default, Option<string> appKey = default, Option<bool> notifyFriend = default, Option<string> notificationMessage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Friend
        /// </summary>
        /// <remarks>
        /// Removes a friend from the user&#39;s friends list.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendAccountId">the account ID of the friend to remove</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="notifyFriend">optionally notifies the connection that they have been removed as a friend (optional)</param>
        /// <param name="removeFromGroups">optionally removes the connection from the user&#39;s groups (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFriendRemoveApiResponse"/>&gt;</returns>
        Task<IFriendRemoveApiResponse> FriendRemoveAsync(long friendAccountId, Option<string> deviceId = default, Option<long> accountId = default, Option<bool> notifyFriend = default, Option<bool> removeFromGroups = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Friend
        /// </summary>
        /// <remarks>
        /// Removes a friend from the user&#39;s friends list.
        /// </remarks>
        /// <param name="friendAccountId">the account ID of the friend to remove</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="notifyFriend">optionally notifies the connection that they have been removed as a friend (optional)</param>
        /// <param name="removeFromGroups">optionally removes the connection from the user&#39;s groups (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFriendRemoveApiResponse"/>?&gt;</returns>
        Task<IFriendRemoveApiResponse?> FriendRemoveOrDefaultAsync(long friendAccountId, Option<string> deviceId = default, Option<long> accountId = default, Option<bool> notifyFriend = default, Option<bool> removeFromGroups = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Request Friend
        /// </summary>
        /// <remarks>
        /// Sends a friend request notification to another user.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendAccountId">the friend&#39;s account id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="notificationMessage">optional message to send in a notification (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFriendRequestApiResponse"/>&gt;</returns>
        Task<IFriendRequestApiResponse> FriendRequestAsync(long friendAccountId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> gameType = default, Option<string> appKey = default, Option<string> notificationMessage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Request Friend
        /// </summary>
        /// <remarks>
        /// Sends a friend request notification to another user.
        /// </remarks>
        /// <param name="friendAccountId">the friend&#39;s account id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="notificationMessage">optional message to send in a notification (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFriendRequestApiResponse"/>?&gt;</returns>
        Task<IFriendRequestApiResponse?> FriendRequestOrDefaultAsync(long friendAccountId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> gameType = default, Option<string> appKey = default, Option<string> notificationMessage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Sent Friend Requests
        /// </summary>
        /// <remarks>
        /// Gets the connection sent friend requests.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="deviceId">the ID of the device (optional)</param>
        /// <param name="accountId">the id of the account (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetConnectionSentFriendRequestsApiResponse"/>&gt;</returns>
        Task<IGetConnectionSentFriendRequestsApiResponse> GetConnectionSentFriendRequestsAsync(Option<string> deviceId = default, Option<long> accountId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Sent Friend Requests
        /// </summary>
        /// <remarks>
        /// Gets the connection sent friend requests.
        /// </remarks>
        /// <param name="deviceId">the ID of the device (optional)</param>
        /// <param name="accountId">the id of the account (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetConnectionSentFriendRequestsApiResponse"/>?&gt;</returns>
        Task<IGetConnectionSentFriendRequestsApiResponse?> GetConnectionSentFriendRequestsOrDefaultAsync(Option<string> deviceId = default, Option<long> accountId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Connections
        /// </summary>
        /// <remarks>
        /// Gets the connections.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="filter">a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)</param>
        /// <param name="sortField">sorts the response list by ConnectionApiMap</param>
        /// <param name="descending">sorts the response list by descending order if true</param>
        /// <param name="start">start index of the pagination</param>
        /// <param name="limit">limit of the pagination</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id (deviceId or accountId required) (optional)</param>
        /// <param name="connectionAccountId">optional parameter to search on other account&#39;s connections (optional)</param>
        /// <param name="q">This parameter is deprecated. (optional)</param>
        /// <param name="keyword">an optional keyword to search on, this parameter is ignored if empty (optional)</param>
        /// <param name="i">This parameter is deprecated. (optional)</param>
        /// <param name="l">This parameter is deprecated. (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetConnectionsApiResponse"/>&gt;</returns>
        Task<IGetConnectionsApiResponse> GetConnectionsAsync(bool returnNulls, string filter, string sortField, bool descending, int start, int limit, Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionAccountId = default, Option<string> q = default, Option<string> keyword = default, Option<int> i = default, Option<int> l = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Connections
        /// </summary>
        /// <remarks>
        /// Gets the connections.
        /// </remarks>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="filter">a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)</param>
        /// <param name="sortField">sorts the response list by ConnectionApiMap</param>
        /// <param name="descending">sorts the response list by descending order if true</param>
        /// <param name="start">start index of the pagination</param>
        /// <param name="limit">limit of the pagination</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id (deviceId or accountId required) (optional)</param>
        /// <param name="connectionAccountId">optional parameter to search on other account&#39;s connections (optional)</param>
        /// <param name="q">This parameter is deprecated. (optional)</param>
        /// <param name="keyword">an optional keyword to search on, this parameter is ignored if empty (optional)</param>
        /// <param name="i">This parameter is deprecated. (optional)</param>
        /// <param name="l">This parameter is deprecated. (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetConnectionsApiResponse"/>?&gt;</returns>
        Task<IGetConnectionsApiResponse?> GetConnectionsOrDefaultAsync(bool returnNulls, string filter, string sortField, bool descending, int start, int limit, Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionAccountId = default, Option<string> q = default, Option<string> keyword = default, Option<int> i = default, Option<int> l = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Connection Group
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="combineConnections">whether to combine connections or not</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="groupId">the group id (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGroupDetailsApiResponse"/>&gt;</returns>
        Task<IGetGroupDetailsApiResponse> GetGroupDetailsAsync(bool combineConnections, Option<string> deviceId = default, Option<long> accountId = default, Option<long> groupId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Connection Group
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="combineConnections">whether to combine connections or not</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="groupId">the group id (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGroupDetailsApiResponse"/>?&gt;</returns>
        Task<IGetGroupDetailsApiResponse?> GetGroupDetailsOrDefaultAsync(bool combineConnections, Option<string> deviceId = default, Option<long> accountId = default, Option<long> groupId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Connection Groups
        /// </summary>
        /// <remarks>
        /// Gets a user&#39;s private groups and default groups.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortField">the field to sort by</param>
        /// <param name="descending">whether to return results in descending or ascending order</param>
        /// <param name="activeOnly">to search on active only or not</param>
        /// <param name="start">The start of the pagination</param>
        /// <param name="limit">the limit of the pagination</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="keyword">keyword search string (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGroupSearchApiResponse"/>&gt;</returns>
        Task<IGroupSearchApiResponse> GroupSearchAsync(string sortField, bool descending, bool activeOnly, int start, int limit, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> keyword = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Connection Groups
        /// </summary>
        /// <remarks>
        /// Gets a user&#39;s private groups and default groups.
        /// </remarks>
        /// <param name="sortField">the field to sort by</param>
        /// <param name="descending">whether to return results in descending or ascending order</param>
        /// <param name="activeOnly">to search on active only or not</param>
        /// <param name="start">The start of the pagination</param>
        /// <param name="limit">the limit of the pagination</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="keyword">keyword search string (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGroupSearchApiResponse"/>?&gt;</returns>
        Task<IGroupSearchApiResponse?> GroupSearchOrDefaultAsync(string sortField, bool descending, bool activeOnly, int start, int limit, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> keyword = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Connection
        /// </summary>
        /// <remarks>
        /// Removes the connection from group.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the group id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionId">the connection id (optional)</param>
        /// <param name="connectionAccountId">the connection account id (optional)</param>
        /// <param name="pendingId">the pending id (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveConnectionFromGroupApiResponse"/>&gt;</returns>
        Task<IRemoveConnectionFromGroupApiResponse> RemoveConnectionFromGroupAsync(bool returnNulls, long groupId, Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionId = default, Option<long> connectionAccountId = default, Option<long> pendingId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Connection
        /// </summary>
        /// <remarks>
        /// Removes the connection from group.
        /// </remarks>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the group id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionId">the connection id (optional)</param>
        /// <param name="connectionAccountId">the connection account id (optional)</param>
        /// <param name="pendingId">the pending id (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveConnectionFromGroupApiResponse"/>?&gt;</returns>
        Task<IRemoveConnectionFromGroupApiResponse?> RemoveConnectionFromGroupOrDefaultAsync(bool returnNulls, long groupId, Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionId = default, Option<long> connectionAccountId = default, Option<long> pendingId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Remove Connections
        /// </summary>
        /// <remarks>
        /// Remove a list of connections from a group.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectionGroupId">connection group id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionIds">comma separated list of connection ids (optional)</param>
        /// <param name="connectionAccountIds">comma separated list of connection account ids (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveConnectionsFromGroupApiResponse"/>&gt;</returns>
        Task<IRemoveConnectionsFromGroupApiResponse> RemoveConnectionsFromGroupAsync(long connectionGroupId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> connectionIds = default, Option<string> connectionAccountIds = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Remove Connections
        /// </summary>
        /// <remarks>
        /// Remove a list of connections from a group.
        /// </remarks>
        /// <param name="connectionGroupId">connection group id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionIds">comma separated list of connection ids (optional)</param>
        /// <param name="connectionAccountIds">comma separated list of connection account ids (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveConnectionsFromGroupApiResponse"/>?&gt;</returns>
        Task<IRemoveConnectionsFromGroupApiResponse?> RemoveConnectionsFromGroupOrDefaultAsync(long connectionGroupId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> connectionIds = default, Option<string> connectionAccountIds = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Connection Group
        /// </summary>
        /// <remarks>
        /// Remove a user&#39;s group.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the group id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveGroupApiResponse"/>&gt;</returns>
        Task<IRemoveGroupApiResponse> RemoveGroupAsync(bool returnNulls, long groupId, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Connection Group
        /// </summary>
        /// <remarks>
        /// Remove a user&#39;s group.
        /// </remarks>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the group id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveGroupApiResponse"/>?&gt;</returns>
        Task<IRemoveGroupApiResponse?> RemoveGroupOrDefaultAsync(bool returnNulls, long groupId, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Remove Connection Groups
        /// </summary>
        /// <remarks>
        /// Remove sub groups from a group
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the parent group id</param>
        /// <param name="subGroupIds">comma separated list of group IDs to remove from the parent group</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveSubGroupsApiResponse"/>&gt;</returns>
        Task<IRemoveSubGroupsApiResponse> RemoveSubGroupsAsync(bool returnNulls, long groupId, string subGroupIds, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Remove Connection Groups
        /// </summary>
        /// <remarks>
        /// Remove sub groups from a group
        /// </remarks>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the parent group id</param>
        /// <param name="subGroupIds">comma separated list of group IDs to remove from the parent group</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveSubGroupsApiResponse"/>?&gt;</returns>
        Task<IRemoveSubGroupsApiResponse?> RemoveSubGroupsOrDefaultAsync(bool returnNulls, long groupId, string subGroupIds, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Possible Connections
        /// </summary>
        /// <remarks>
        /// Search for accounts that the user may not have a connection with.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnNulls">return all json attributes if true. defualt is true.</param>
        /// <param name="start">start index of the pagination</param>
        /// <param name="limit">limit of the pagination</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id (deviceId or accountId required) (optional)</param>
        /// <param name="q">This parameter is deprecated. (optional)</param>
        /// <param name="keyword">keyword to search on, optional and this parameter is ignored if empt (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the public application key, if provided only looks for users of that application (optional)</param>
        /// <param name="i">This parameter is deprecated. (optional)</param>
        /// <param name="l">This parameter is deprecated. (optional)</param>
        /// <param name="sortField">the field to sort on (optional)</param>
        /// <param name="hasLocation">whether the search has location or not (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchConnectionsApiResponse"/>&gt;</returns>
        Task<ISearchConnectionsApiResponse> SearchConnectionsAsync(bool returnNulls, int start, int limit, Option<string> deviceId = default, Option<long> accountId = default, Option<string> q = default, Option<string> keyword = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> gameType = default, Option<string> appKey = default, Option<int> i = default, Option<int> l = default, Option<string> sortField = default, Option<bool> hasLocation = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Possible Connections
        /// </summary>
        /// <remarks>
        /// Search for accounts that the user may not have a connection with.
        /// </remarks>
        /// <param name="returnNulls">return all json attributes if true. defualt is true.</param>
        /// <param name="start">start index of the pagination</param>
        /// <param name="limit">limit of the pagination</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id (deviceId or accountId required) (optional)</param>
        /// <param name="q">This parameter is deprecated. (optional)</param>
        /// <param name="keyword">keyword to search on, optional and this parameter is ignored if empt (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the public application key, if provided only looks for users of that application (optional)</param>
        /// <param name="i">This parameter is deprecated. (optional)</param>
        /// <param name="l">This parameter is deprecated. (optional)</param>
        /// <param name="sortField">the field to sort on (optional)</param>
        /// <param name="hasLocation">whether the search has location or not (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchConnectionsApiResponse"/>?&gt;</returns>
        Task<ISearchConnectionsApiResponse?> SearchConnectionsOrDefaultAsync(bool returnNulls, int start, int limit, Option<string> deviceId = default, Option<long> accountId = default, Option<string> q = default, Option<string> keyword = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> gameType = default, Option<string> appKey = default, Option<int> i = default, Option<int> l = default, Option<string> sortField = default, Option<bool> hasLocation = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IAddConnectionToGroupApiResponse"/>
    /// </summary>
    public interface IAddConnectionToGroupApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IAddConnectionsToGroupApiResponse"/>
    /// </summary>
    public interface IAddConnectionsToGroupApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IAddSubGroupsApiResponse"/>
    /// </summary>
    public interface IAddSubGroupsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ConnectionGroupResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICreateOrUpdateConnectionApiResponse"/>
    /// </summary>
    public interface ICreateOrUpdateConnectionApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ConnectionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICreateOrUpdateGroupApiResponse"/>
    /// </summary>
    public interface ICreateOrUpdateGroupApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IFollowAcceptApiResponse"/>
    /// </summary>
    public interface IFollowAcceptApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IFollowRejectApiResponse"/>
    /// </summary>
    public interface IFollowRejectApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IFollowRemoveApiResponse"/>
    /// </summary>
    public interface IFollowRemoveApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IFollowRequestApiResponse"/>
    /// </summary>
    public interface IFollowRequestApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IFriendAcceptApiResponse"/>
    /// </summary>
    public interface IFriendAcceptApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IFriendRejectApiResponse"/>
    /// </summary>
    public interface IFriendRejectApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IFriendRemoveApiResponse"/>
    /// </summary>
    public interface IFriendRemoveApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IFriendRequestApiResponse"/>
    /// </summary>
    public interface IFriendRequestApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetConnectionSentFriendRequestsApiResponse"/>
    /// </summary>
    public interface IGetConnectionSentFriendRequestsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ConnectionListResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetConnectionsApiResponse"/>
    /// </summary>
    public interface IGetConnectionsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ConnectionListResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetGroupDetailsApiResponse"/>
    /// </summary>
    public interface IGetGroupDetailsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ConnectionGroupResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGroupSearchApiResponse"/>
    /// </summary>
    public interface IGroupSearchApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<ConnectionInfoResponse>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IRemoveConnectionFromGroupApiResponse"/>
    /// </summary>
    public interface IRemoveConnectionFromGroupApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IRemoveConnectionsFromGroupApiResponse"/>
    /// </summary>
    public interface IRemoveConnectionsFromGroupApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IRemoveGroupApiResponse"/>
    /// </summary>
    public interface IRemoveGroupApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IRemoveSubGroupsApiResponse"/>
    /// </summary>
    public interface IRemoveSubGroupsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchConnectionsApiResponse"/>
    /// </summary>
    public interface ISearchConnectionsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ConnectionListResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ConnectionApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddConnectionToGroup;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddConnectionToGroup;

        internal void ExecuteOnAddConnectionToGroup(ConnectionApi.AddConnectionToGroupApiResponse apiResponse)
        {
            OnAddConnectionToGroup?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddConnectionToGroup(Exception exception)
        {
            OnErrorAddConnectionToGroup?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddConnectionsToGroup;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddConnectionsToGroup;

        internal void ExecuteOnAddConnectionsToGroup(ConnectionApi.AddConnectionsToGroupApiResponse apiResponse)
        {
            OnAddConnectionsToGroup?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddConnectionsToGroup(Exception exception)
        {
            OnErrorAddConnectionsToGroup?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddSubGroups;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddSubGroups;

        internal void ExecuteOnAddSubGroups(ConnectionApi.AddSubGroupsApiResponse apiResponse)
        {
            OnAddSubGroups?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddSubGroups(Exception exception)
        {
            OnErrorAddSubGroups?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateOrUpdateConnection;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateOrUpdateConnection;

        internal void ExecuteOnCreateOrUpdateConnection(ConnectionApi.CreateOrUpdateConnectionApiResponse apiResponse)
        {
            OnCreateOrUpdateConnection?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateOrUpdateConnection(Exception exception)
        {
            OnErrorCreateOrUpdateConnection?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateOrUpdateGroup;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateOrUpdateGroup;

        internal void ExecuteOnCreateOrUpdateGroup(ConnectionApi.CreateOrUpdateGroupApiResponse apiResponse)
        {
            OnCreateOrUpdateGroup?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateOrUpdateGroup(Exception exception)
        {
            OnErrorCreateOrUpdateGroup?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnFollowAccept;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorFollowAccept;

        internal void ExecuteOnFollowAccept(ConnectionApi.FollowAcceptApiResponse apiResponse)
        {
            OnFollowAccept?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFollowAccept(Exception exception)
        {
            OnErrorFollowAccept?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnFollowReject;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorFollowReject;

        internal void ExecuteOnFollowReject(ConnectionApi.FollowRejectApiResponse apiResponse)
        {
            OnFollowReject?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFollowReject(Exception exception)
        {
            OnErrorFollowReject?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnFollowRemove;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorFollowRemove;

        internal void ExecuteOnFollowRemove(ConnectionApi.FollowRemoveApiResponse apiResponse)
        {
            OnFollowRemove?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFollowRemove(Exception exception)
        {
            OnErrorFollowRemove?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnFollowRequest;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorFollowRequest;

        internal void ExecuteOnFollowRequest(ConnectionApi.FollowRequestApiResponse apiResponse)
        {
            OnFollowRequest?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFollowRequest(Exception exception)
        {
            OnErrorFollowRequest?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnFriendAccept;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorFriendAccept;

        internal void ExecuteOnFriendAccept(ConnectionApi.FriendAcceptApiResponse apiResponse)
        {
            OnFriendAccept?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFriendAccept(Exception exception)
        {
            OnErrorFriendAccept?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnFriendReject;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorFriendReject;

        internal void ExecuteOnFriendReject(ConnectionApi.FriendRejectApiResponse apiResponse)
        {
            OnFriendReject?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFriendReject(Exception exception)
        {
            OnErrorFriendReject?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnFriendRemove;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorFriendRemove;

        internal void ExecuteOnFriendRemove(ConnectionApi.FriendRemoveApiResponse apiResponse)
        {
            OnFriendRemove?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFriendRemove(Exception exception)
        {
            OnErrorFriendRemove?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnFriendRequest;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorFriendRequest;

        internal void ExecuteOnFriendRequest(ConnectionApi.FriendRequestApiResponse apiResponse)
        {
            OnFriendRequest?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFriendRequest(Exception exception)
        {
            OnErrorFriendRequest?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetConnectionSentFriendRequests;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetConnectionSentFriendRequests;

        internal void ExecuteOnGetConnectionSentFriendRequests(ConnectionApi.GetConnectionSentFriendRequestsApiResponse apiResponse)
        {
            OnGetConnectionSentFriendRequests?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetConnectionSentFriendRequests(Exception exception)
        {
            OnErrorGetConnectionSentFriendRequests?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetConnections;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetConnections;

        internal void ExecuteOnGetConnections(ConnectionApi.GetConnectionsApiResponse apiResponse)
        {
            OnGetConnections?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetConnections(Exception exception)
        {
            OnErrorGetConnections?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetGroupDetails;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetGroupDetails;

        internal void ExecuteOnGetGroupDetails(ConnectionApi.GetGroupDetailsApiResponse apiResponse)
        {
            OnGetGroupDetails?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetGroupDetails(Exception exception)
        {
            OnErrorGetGroupDetails?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGroupSearch;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGroupSearch;

        internal void ExecuteOnGroupSearch(ConnectionApi.GroupSearchApiResponse apiResponse)
        {
            OnGroupSearch?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGroupSearch(Exception exception)
        {
            OnErrorGroupSearch?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRemoveConnectionFromGroup;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRemoveConnectionFromGroup;

        internal void ExecuteOnRemoveConnectionFromGroup(ConnectionApi.RemoveConnectionFromGroupApiResponse apiResponse)
        {
            OnRemoveConnectionFromGroup?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRemoveConnectionFromGroup(Exception exception)
        {
            OnErrorRemoveConnectionFromGroup?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRemoveConnectionsFromGroup;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRemoveConnectionsFromGroup;

        internal void ExecuteOnRemoveConnectionsFromGroup(ConnectionApi.RemoveConnectionsFromGroupApiResponse apiResponse)
        {
            OnRemoveConnectionsFromGroup?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRemoveConnectionsFromGroup(Exception exception)
        {
            OnErrorRemoveConnectionsFromGroup?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRemoveGroup;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRemoveGroup;

        internal void ExecuteOnRemoveGroup(ConnectionApi.RemoveGroupApiResponse apiResponse)
        {
            OnRemoveGroup?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRemoveGroup(Exception exception)
        {
            OnErrorRemoveGroup?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRemoveSubGroups;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRemoveSubGroups;

        internal void ExecuteOnRemoveSubGroups(ConnectionApi.RemoveSubGroupsApiResponse apiResponse)
        {
            OnRemoveSubGroups?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRemoveSubGroups(Exception exception)
        {
            OnErrorRemoveSubGroups?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchConnections;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchConnections;

        internal void ExecuteOnSearchConnections(ConnectionApi.SearchConnectionsApiResponse apiResponse)
        {
            OnSearchConnections?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchConnections(Exception exception)
        {
            OnErrorSearchConnections?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ConnectionApi : IConnectionApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ConnectionApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ConnectionApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectionApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ConnectionApi(ILogger<ConnectionApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ConnectionApiEvents connectionApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ConnectionApi>();
            HttpClient = httpClient;
            Events = connectionApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatAddConnectionToGroup(ref bool returnNulls, ref long groupId, ref Option<string> deviceId, ref Option<long> accountId, ref Option<long> connectionId, ref Option<long> connectionAccountId, ref Option<long> pendingId, ref Option<double> latitude, ref Option<double> longitude);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <returns></returns>
        private void ValidateAddConnectionToGroup(Option<string> deviceId)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="pendingId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void AfterAddConnectionToGroupDefaultImplementation(IAddConnectionToGroupApiResponse apiResponseLocalVar, bool returnNulls, long groupId, Option<string> deviceId, Option<long> accountId, Option<long> connectionId, Option<long> connectionAccountId, Option<long> pendingId, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLog = false;
            AfterAddConnectionToGroup(ref suppressDefaultLog, apiResponseLocalVar, returnNulls, groupId, deviceId, accountId, connectionId, connectionAccountId, pendingId, latitude, longitude);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="pendingId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void AfterAddConnectionToGroup(ref bool suppressDefaultLog, IAddConnectionToGroupApiResponse apiResponseLocalVar, bool returnNulls, long groupId, Option<string> deviceId, Option<long> accountId, Option<long> connectionId, Option<long> connectionAccountId, Option<long> pendingId, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="pendingId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void OnErrorAddConnectionToGroupDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, bool returnNulls, long groupId, Option<string> deviceId, Option<long> accountId, Option<long> connectionId, Option<long> connectionAccountId, Option<long> pendingId, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAddConnectionToGroup(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, returnNulls, groupId, deviceId, accountId, connectionId, connectionAccountId, pendingId, latitude, longitude);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="pendingId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void OnErrorAddConnectionToGroup(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, bool returnNulls, long groupId, Option<string> deviceId, Option<long> accountId, Option<long> connectionId, Option<long> connectionAccountId, Option<long> pendingId, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Add Connection Adds a connection to a group.
        /// </summary>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the group id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionId">the connection id (optional)</param>
        /// <param name="connectionAccountId">the connection account id (optional)</param>
        /// <param name="pendingId">the pending id (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddConnectionToGroupApiResponse"/>&gt;</returns>
        public async Task<IAddConnectionToGroupApiResponse?> AddConnectionToGroupOrDefaultAsync(bool returnNulls, long groupId, Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionId = default, Option<long> connectionAccountId = default, Option<long> pendingId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddConnectionToGroupAsync(returnNulls, groupId, deviceId, accountId, connectionId, connectionAccountId, pendingId, latitude, longitude, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Add Connection Adds a connection to a group.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the group id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionId">the connection id (optional)</param>
        /// <param name="connectionAccountId">the connection account id (optional)</param>
        /// <param name="pendingId">the pending id (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddConnectionToGroupApiResponse"/>&gt;</returns>
        public async Task<IAddConnectionToGroupApiResponse> AddConnectionToGroupAsync(bool returnNulls, long groupId, Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionId = default, Option<long> connectionAccountId = default, Option<long> pendingId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddConnectionToGroup(deviceId);

                FormatAddConnectionToGroup(ref returnNulls, ref groupId, ref deviceId, ref accountId, ref connectionId, ref connectionAccountId, ref pendingId, ref latitude, ref longitude);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/connection/group/addConnection"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/connection/group/addConnection");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["returnNulls"] = ClientUtils.ParameterToString(returnNulls);
                    parseQueryStringLocalVar["groupId"] = ClientUtils.ParameterToString(groupId);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (connectionId.IsSet)
                        parseQueryStringLocalVar["connectionId"] = ClientUtils.ParameterToString(connectionId.Value);

                    if (connectionAccountId.IsSet)
                        parseQueryStringLocalVar["connectionAccountId"] = ClientUtils.ParameterToString(connectionAccountId.Value);

                    if (pendingId.IsSet)
                        parseQueryStringLocalVar["pendingId"] = ClientUtils.ParameterToString(pendingId.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<AddConnectionToGroupApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddConnectionToGroupApiResponse>();
                        AddConnectionToGroupApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/connection/group/addConnection", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterAddConnectionToGroupDefaultImplementation(apiResponseLocalVar, returnNulls, groupId, deviceId, accountId, connectionId, connectionAccountId, pendingId, latitude, longitude);

                        Events.ExecuteOnAddConnectionToGroup(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddConnectionToGroupDefaultImplementation(e, "/consumer/connection/group/addConnection", uriBuilderLocalVar.Path, returnNulls, groupId, deviceId, accountId, connectionId, connectionAccountId, pendingId, latitude, longitude);
                Events.ExecuteOnErrorAddConnectionToGroup(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddConnectionToGroupApiResponse"/>
        /// </summary>
        public partial class AddConnectionToGroupApiResponse : Org.OpenAPITools.Client.ApiResponse, IAddConnectionToGroupApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddConnectionToGroupApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddConnectionToGroupApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddConnectionToGroupApiResponse(ILogger<AddConnectionToGroupApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="AddConnectionToGroupApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddConnectionToGroupApiResponse(ILogger<AddConnectionToGroupApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatAddConnectionsToGroup(ref long connectionGroupId, ref Option<string> deviceId, ref Option<long> accountId, ref Option<string> connectionIds, ref Option<string> connectionAccountIds, ref Option<double> latitude, ref Option<double> longitude);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <returns></returns>
        private void ValidateAddConnectionsToGroup(Option<string> deviceId, Option<string> connectionIds, Option<string> connectionAccountIds)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (connectionIds.IsSet && connectionIds.Value == null)
                throw new ArgumentNullException(nameof(connectionIds));

            if (connectionAccountIds.IsSet && connectionAccountIds.Value == null)
                throw new ArgumentNullException(nameof(connectionAccountIds));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="connectionGroupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void AfterAddConnectionsToGroupDefaultImplementation(IAddConnectionsToGroupApiResponse apiResponseLocalVar, long connectionGroupId, Option<string> deviceId, Option<long> accountId, Option<string> connectionIds, Option<string> connectionAccountIds, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLog = false;
            AfterAddConnectionsToGroup(ref suppressDefaultLog, apiResponseLocalVar, connectionGroupId, deviceId, accountId, connectionIds, connectionAccountIds, latitude, longitude);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="connectionGroupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void AfterAddConnectionsToGroup(ref bool suppressDefaultLog, IAddConnectionsToGroupApiResponse apiResponseLocalVar, long connectionGroupId, Option<string> deviceId, Option<long> accountId, Option<string> connectionIds, Option<string> connectionAccountIds, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="connectionGroupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void OnErrorAddConnectionsToGroupDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long connectionGroupId, Option<string> deviceId, Option<long> accountId, Option<string> connectionIds, Option<string> connectionAccountIds, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAddConnectionsToGroup(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, connectionGroupId, deviceId, accountId, connectionIds, connectionAccountIds, latitude, longitude);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="connectionGroupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void OnErrorAddConnectionsToGroup(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long connectionGroupId, Option<string> deviceId, Option<long> accountId, Option<string> connectionIds, Option<string> connectionAccountIds, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Add Connections Adds a list of connections to a group.
        /// </summary>
        /// <param name="connectionGroupId">the connection group ID</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionIds">comma separated list of connection ids (optional)</param>
        /// <param name="connectionAccountIds">comma separated list of connection account ids (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddConnectionsToGroupApiResponse"/>&gt;</returns>
        public async Task<IAddConnectionsToGroupApiResponse?> AddConnectionsToGroupOrDefaultAsync(long connectionGroupId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> connectionIds = default, Option<string> connectionAccountIds = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddConnectionsToGroupAsync(connectionGroupId, deviceId, accountId, connectionIds, connectionAccountIds, latitude, longitude, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Add Connections Adds a list of connections to a group.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectionGroupId">the connection group ID</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionIds">comma separated list of connection ids (optional)</param>
        /// <param name="connectionAccountIds">comma separated list of connection account ids (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddConnectionsToGroupApiResponse"/>&gt;</returns>
        public async Task<IAddConnectionsToGroupApiResponse> AddConnectionsToGroupAsync(long connectionGroupId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> connectionIds = default, Option<string> connectionAccountIds = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddConnectionsToGroup(deviceId, connectionIds, connectionAccountIds);

                FormatAddConnectionsToGroup(ref connectionGroupId, ref deviceId, ref accountId, ref connectionIds, ref connectionAccountIds, ref latitude, ref longitude);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/connection/group/addConnections"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/connection/group/addConnections");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["connectionGroupId"] = ClientUtils.ParameterToString(connectionGroupId);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (connectionIds.IsSet)
                        parseQueryStringLocalVar["connectionIds"] = ClientUtils.ParameterToString(connectionIds.Value);

                    if (connectionAccountIds.IsSet)
                        parseQueryStringLocalVar["connectionAccountIds"] = ClientUtils.ParameterToString(connectionAccountIds.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<AddConnectionsToGroupApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddConnectionsToGroupApiResponse>();
                        AddConnectionsToGroupApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/connection/group/addConnections", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterAddConnectionsToGroupDefaultImplementation(apiResponseLocalVar, connectionGroupId, deviceId, accountId, connectionIds, connectionAccountIds, latitude, longitude);

                        Events.ExecuteOnAddConnectionsToGroup(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddConnectionsToGroupDefaultImplementation(e, "/connection/group/addConnections", uriBuilderLocalVar.Path, connectionGroupId, deviceId, accountId, connectionIds, connectionAccountIds, latitude, longitude);
                Events.ExecuteOnErrorAddConnectionsToGroup(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddConnectionsToGroupApiResponse"/>
        /// </summary>
        public partial class AddConnectionsToGroupApiResponse : Org.OpenAPITools.Client.ApiResponse, IAddConnectionsToGroupApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddConnectionsToGroupApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddConnectionsToGroupApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddConnectionsToGroupApiResponse(ILogger<AddConnectionsToGroupApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="AddConnectionsToGroupApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddConnectionsToGroupApiResponse(ILogger<AddConnectionsToGroupApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatAddSubGroups(ref bool returnNulls, ref long groupId, ref string subGroupIds, ref Option<string> deviceId, ref Option<long> accountId, ref Option<double> latitude, ref Option<double> longitude);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="subGroupIds"></param>
        /// <param name="deviceId"></param>
        /// <returns></returns>
        private void ValidateAddSubGroups(string subGroupIds, Option<string> deviceId)
        {
            if (subGroupIds == null)
                throw new ArgumentNullException(nameof(subGroupIds));

            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="subGroupIds"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void AfterAddSubGroupsDefaultImplementation(IAddSubGroupsApiResponse apiResponseLocalVar, bool returnNulls, long groupId, string subGroupIds, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLog = false;
            AfterAddSubGroups(ref suppressDefaultLog, apiResponseLocalVar, returnNulls, groupId, subGroupIds, deviceId, accountId, latitude, longitude);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="subGroupIds"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void AfterAddSubGroups(ref bool suppressDefaultLog, IAddSubGroupsApiResponse apiResponseLocalVar, bool returnNulls, long groupId, string subGroupIds, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="subGroupIds"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void OnErrorAddSubGroupsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, bool returnNulls, long groupId, string subGroupIds, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAddSubGroups(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, returnNulls, groupId, subGroupIds, deviceId, accountId, latitude, longitude);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="subGroupIds"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void OnErrorAddSubGroups(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, bool returnNulls, long groupId, string subGroupIds, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Add Connection Groups Add sub groups to a group.
        /// </summary>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the parent group id</param>
        /// <param name="subGroupIds">comma separated list of group IDs to add to the parent group</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddSubGroupsApiResponse"/>&gt;</returns>
        public async Task<IAddSubGroupsApiResponse?> AddSubGroupsOrDefaultAsync(bool returnNulls, long groupId, string subGroupIds, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddSubGroupsAsync(returnNulls, groupId, subGroupIds, deviceId, accountId, latitude, longitude, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Add Connection Groups Add sub groups to a group.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the parent group id</param>
        /// <param name="subGroupIds">comma separated list of group IDs to add to the parent group</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddSubGroupsApiResponse"/>&gt;</returns>
        public async Task<IAddSubGroupsApiResponse> AddSubGroupsAsync(bool returnNulls, long groupId, string subGroupIds, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddSubGroups(subGroupIds, deviceId);

                FormatAddSubGroups(ref returnNulls, ref groupId, ref subGroupIds, ref deviceId, ref accountId, ref latitude, ref longitude);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/connection/group/addSubGroup"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/connection/group/addSubGroup");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["returnNulls"] = ClientUtils.ParameterToString(returnNulls);
                    parseQueryStringLocalVar["groupId"] = ClientUtils.ParameterToString(groupId);
                    parseQueryStringLocalVar["subGroupIds"] = ClientUtils.ParameterToString(subGroupIds);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<AddSubGroupsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddSubGroupsApiResponse>();
                        AddSubGroupsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/connection/group/addSubGroup", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterAddSubGroupsDefaultImplementation(apiResponseLocalVar, returnNulls, groupId, subGroupIds, deviceId, accountId, latitude, longitude);

                        Events.ExecuteOnAddSubGroups(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddSubGroupsDefaultImplementation(e, "/consumer/connection/group/addSubGroup", uriBuilderLocalVar.Path, returnNulls, groupId, subGroupIds, deviceId, accountId, latitude, longitude);
                Events.ExecuteOnErrorAddSubGroups(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddSubGroupsApiResponse"/>
        /// </summary>
        public partial class AddSubGroupsApiResponse : Org.OpenAPITools.Client.ApiResponse, IAddSubGroupsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddSubGroupsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddSubGroupsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddSubGroupsApiResponse(ILogger<AddSubGroupsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="AddSubGroupsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddSubGroupsApiResponse(ILogger<AddSubGroupsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ConnectionGroupResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ConnectionGroupResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ConnectionGroupResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateOrUpdateConnection(ref Option<string> deviceId, ref Option<long> accountId, ref Option<long> connectionId, ref Option<long> connectionAccountId, ref Option<long> pendingId, ref Option<long> groupId, ref Option<string> gameType, ref Option<string> appKey, ref Option<bool> isTrusted, ref Option<bool> ignoreFriendRequest, ref Option<bool> isContact, ref Option<bool> isBlocked, ref Option<bool> isFollowing, ref Option<bool> connectionResponse);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <returns></returns>
        private void ValidateCreateOrUpdateConnection(Option<string> deviceId, Option<string> gameType, Option<string> appKey)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (gameType.IsSet && gameType.Value == null)
                throw new ArgumentNullException(nameof(gameType));

            if (appKey.IsSet && appKey.Value == null)
                throw new ArgumentNullException(nameof(appKey));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="pendingId"></param>
        /// <param name="groupId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="isTrusted"></param>
        /// <param name="ignoreFriendRequest"></param>
        /// <param name="isContact"></param>
        /// <param name="isBlocked"></param>
        /// <param name="isFollowing"></param>
        /// <param name="connectionResponse"></param>
        private void AfterCreateOrUpdateConnectionDefaultImplementation(ICreateOrUpdateConnectionApiResponse apiResponseLocalVar, Option<string> deviceId, Option<long> accountId, Option<long> connectionId, Option<long> connectionAccountId, Option<long> pendingId, Option<long> groupId, Option<string> gameType, Option<string> appKey, Option<bool> isTrusted, Option<bool> ignoreFriendRequest, Option<bool> isContact, Option<bool> isBlocked, Option<bool> isFollowing, Option<bool> connectionResponse)
        {
            bool suppressDefaultLog = false;
            AfterCreateOrUpdateConnection(ref suppressDefaultLog, apiResponseLocalVar, deviceId, accountId, connectionId, connectionAccountId, pendingId, groupId, gameType, appKey, isTrusted, ignoreFriendRequest, isContact, isBlocked, isFollowing, connectionResponse);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="pendingId"></param>
        /// <param name="groupId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="isTrusted"></param>
        /// <param name="ignoreFriendRequest"></param>
        /// <param name="isContact"></param>
        /// <param name="isBlocked"></param>
        /// <param name="isFollowing"></param>
        /// <param name="connectionResponse"></param>
        partial void AfterCreateOrUpdateConnection(ref bool suppressDefaultLog, ICreateOrUpdateConnectionApiResponse apiResponseLocalVar, Option<string> deviceId, Option<long> accountId, Option<long> connectionId, Option<long> connectionAccountId, Option<long> pendingId, Option<long> groupId, Option<string> gameType, Option<string> appKey, Option<bool> isTrusted, Option<bool> ignoreFriendRequest, Option<bool> isContact, Option<bool> isBlocked, Option<bool> isFollowing, Option<bool> connectionResponse);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="pendingId"></param>
        /// <param name="groupId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="isTrusted"></param>
        /// <param name="ignoreFriendRequest"></param>
        /// <param name="isContact"></param>
        /// <param name="isBlocked"></param>
        /// <param name="isFollowing"></param>
        /// <param name="connectionResponse"></param>
        private void OnErrorCreateOrUpdateConnectionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> deviceId, Option<long> accountId, Option<long> connectionId, Option<long> connectionAccountId, Option<long> pendingId, Option<long> groupId, Option<string> gameType, Option<string> appKey, Option<bool> isTrusted, Option<bool> ignoreFriendRequest, Option<bool> isContact, Option<bool> isBlocked, Option<bool> isFollowing, Option<bool> connectionResponse)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateOrUpdateConnection(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, deviceId, accountId, connectionId, connectionAccountId, pendingId, groupId, gameType, appKey, isTrusted, ignoreFriendRequest, isContact, isBlocked, isFollowing, connectionResponse);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="pendingId"></param>
        /// <param name="groupId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="isTrusted"></param>
        /// <param name="ignoreFriendRequest"></param>
        /// <param name="isContact"></param>
        /// <param name="isBlocked"></param>
        /// <param name="isFollowing"></param>
        /// <param name="connectionResponse"></param>
        partial void OnErrorCreateOrUpdateConnection(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> deviceId, Option<long> accountId, Option<long> connectionId, Option<long> connectionAccountId, Option<long> pendingId, Option<long> groupId, Option<string> gameType, Option<string> appKey, Option<bool> isTrusted, Option<bool> ignoreFriendRequest, Option<bool> isContact, Option<bool> isBlocked, Option<bool> isFollowing, Option<bool> connectionResponse);

        /// <summary>
        /// Create or Update Connection Creates or updates the connection of the user and another account. Allows a user to follow, block, mark as trusted, and/or add someone to a group.
        /// </summary>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionId">the connection id for editing (optional)</param>
        /// <param name="connectionAccountId">the connection account id (i.e. the account id of another user) (optional)</param>
        /// <param name="pendingId">the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps) (optional)</param>
        /// <param name="groupId">optional group id if the user wants to add this person into a group (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="isTrusted">determines whether the user is trusting this account (optional)</param>
        /// <param name="ignoreFriendRequest">determines whether the user has set to ignore the user&#39;s friend request (optional)</param>
        /// <param name="isContact">determines whether the user is a contact of this account (optional)</param>
        /// <param name="isBlocked">determines whether the user is blocking this account (optional)</param>
        /// <param name="isFollowing">determines whether the user is following this account (optional)</param>
        /// <param name="connectionResponse">whether to return the connection response or not (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateOrUpdateConnectionApiResponse"/>&gt;</returns>
        public async Task<ICreateOrUpdateConnectionApiResponse?> CreateOrUpdateConnectionOrDefaultAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionId = default, Option<long> connectionAccountId = default, Option<long> pendingId = default, Option<long> groupId = default, Option<string> gameType = default, Option<string> appKey = default, Option<bool> isTrusted = default, Option<bool> ignoreFriendRequest = default, Option<bool> isContact = default, Option<bool> isBlocked = default, Option<bool> isFollowing = default, Option<bool> connectionResponse = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateOrUpdateConnectionAsync(deviceId, accountId, connectionId, connectionAccountId, pendingId, groupId, gameType, appKey, isTrusted, ignoreFriendRequest, isContact, isBlocked, isFollowing, connectionResponse, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create or Update Connection Creates or updates the connection of the user and another account. Allows a user to follow, block, mark as trusted, and/or add someone to a group.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionId">the connection id for editing (optional)</param>
        /// <param name="connectionAccountId">the connection account id (i.e. the account id of another user) (optional)</param>
        /// <param name="pendingId">the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps) (optional)</param>
        /// <param name="groupId">optional group id if the user wants to add this person into a group (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="isTrusted">determines whether the user is trusting this account (optional)</param>
        /// <param name="ignoreFriendRequest">determines whether the user has set to ignore the user&#39;s friend request (optional)</param>
        /// <param name="isContact">determines whether the user is a contact of this account (optional)</param>
        /// <param name="isBlocked">determines whether the user is blocking this account (optional)</param>
        /// <param name="isFollowing">determines whether the user is following this account (optional)</param>
        /// <param name="connectionResponse">whether to return the connection response or not (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateOrUpdateConnectionApiResponse"/>&gt;</returns>
        public async Task<ICreateOrUpdateConnectionApiResponse> CreateOrUpdateConnectionAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionId = default, Option<long> connectionAccountId = default, Option<long> pendingId = default, Option<long> groupId = default, Option<string> gameType = default, Option<string> appKey = default, Option<bool> isTrusted = default, Option<bool> ignoreFriendRequest = default, Option<bool> isContact = default, Option<bool> isBlocked = default, Option<bool> isFollowing = default, Option<bool> connectionResponse = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateOrUpdateConnection(deviceId, gameType, appKey);

                FormatCreateOrUpdateConnection(ref deviceId, ref accountId, ref connectionId, ref connectionAccountId, ref pendingId, ref groupId, ref gameType, ref appKey, ref isTrusted, ref ignoreFriendRequest, ref isContact, ref isBlocked, ref isFollowing, ref connectionResponse);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/connection/add"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/connection/add");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (connectionId.IsSet)
                        parseQueryStringLocalVar["connectionId"] = ClientUtils.ParameterToString(connectionId.Value);

                    if (connectionAccountId.IsSet)
                        parseQueryStringLocalVar["connectionAccountId"] = ClientUtils.ParameterToString(connectionAccountId.Value);

                    if (pendingId.IsSet)
                        parseQueryStringLocalVar["pendingId"] = ClientUtils.ParameterToString(pendingId.Value);

                    if (groupId.IsSet)
                        parseQueryStringLocalVar["groupId"] = ClientUtils.ParameterToString(groupId.Value);

                    if (gameType.IsSet)
                        parseQueryStringLocalVar["gameType"] = ClientUtils.ParameterToString(gameType.Value);

                    if (appKey.IsSet)
                        parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey.Value);

                    if (isTrusted.IsSet)
                        parseQueryStringLocalVar["isTrusted"] = ClientUtils.ParameterToString(isTrusted.Value);

                    if (ignoreFriendRequest.IsSet)
                        parseQueryStringLocalVar["ignoreFriendRequest"] = ClientUtils.ParameterToString(ignoreFriendRequest.Value);

                    if (isContact.IsSet)
                        parseQueryStringLocalVar["isContact"] = ClientUtils.ParameterToString(isContact.Value);

                    if (isBlocked.IsSet)
                        parseQueryStringLocalVar["isBlocked"] = ClientUtils.ParameterToString(isBlocked.Value);

                    if (isFollowing.IsSet)
                        parseQueryStringLocalVar["isFollowing"] = ClientUtils.ParameterToString(isFollowing.Value);

                    if (connectionResponse.IsSet)
                        parseQueryStringLocalVar["connectionResponse"] = ClientUtils.ParameterToString(connectionResponse.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateOrUpdateConnectionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateOrUpdateConnectionApiResponse>();
                        CreateOrUpdateConnectionApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/connection/add", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateOrUpdateConnectionDefaultImplementation(apiResponseLocalVar, deviceId, accountId, connectionId, connectionAccountId, pendingId, groupId, gameType, appKey, isTrusted, ignoreFriendRequest, isContact, isBlocked, isFollowing, connectionResponse);

                        Events.ExecuteOnCreateOrUpdateConnection(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateOrUpdateConnectionDefaultImplementation(e, "/consumer/connection/add", uriBuilderLocalVar.Path, deviceId, accountId, connectionId, connectionAccountId, pendingId, groupId, gameType, appKey, isTrusted, ignoreFriendRequest, isContact, isBlocked, isFollowing, connectionResponse);
                Events.ExecuteOnErrorCreateOrUpdateConnection(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateOrUpdateConnectionApiResponse"/>
        /// </summary>
        public partial class CreateOrUpdateConnectionApiResponse : Org.OpenAPITools.Client.ApiResponse, ICreateOrUpdateConnectionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateOrUpdateConnectionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateOrUpdateConnectionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateOrUpdateConnectionApiResponse(ILogger<CreateOrUpdateConnectionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateOrUpdateConnectionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateOrUpdateConnectionApiResponse(ILogger<CreateOrUpdateConnectionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ConnectionResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ConnectionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ConnectionResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateOrUpdateGroup(ref bool returnNulls, ref Option<string> deviceId, ref Option<long> accountId, ref Option<string> name, ref Option<long> groupId, ref Option<long> assetId, ref Option<string> connections, ref Option<string> description, ref Option<bool> canViewProfileInfo, ref Option<bool> canViewGameInfo, ref Option<bool> canViewFriendInfo, ref Option<bool> active, ref Option<double> latitude, ref Option<double> longitude);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <param name="name"></param>
        /// <param name="connections"></param>
        /// <param name="description"></param>
        /// <returns></returns>
        private void ValidateCreateOrUpdateGroup(Option<string> deviceId, Option<string> name, Option<string> connections, Option<string> description)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (name.IsSet && name.Value == null)
                throw new ArgumentNullException(nameof(name));

            if (connections.IsSet && connections.Value == null)
                throw new ArgumentNullException(nameof(connections));

            if (description.IsSet && description.Value == null)
                throw new ArgumentNullException(nameof(description));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="name"></param>
        /// <param name="groupId"></param>
        /// <param name="assetId"></param>
        /// <param name="connections"></param>
        /// <param name="description"></param>
        /// <param name="canViewProfileInfo"></param>
        /// <param name="canViewGameInfo"></param>
        /// <param name="canViewFriendInfo"></param>
        /// <param name="active"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void AfterCreateOrUpdateGroupDefaultImplementation(ICreateOrUpdateGroupApiResponse apiResponseLocalVar, bool returnNulls, Option<string> deviceId, Option<long> accountId, Option<string> name, Option<long> groupId, Option<long> assetId, Option<string> connections, Option<string> description, Option<bool> canViewProfileInfo, Option<bool> canViewGameInfo, Option<bool> canViewFriendInfo, Option<bool> active, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLog = false;
            AfterCreateOrUpdateGroup(ref suppressDefaultLog, apiResponseLocalVar, returnNulls, deviceId, accountId, name, groupId, assetId, connections, description, canViewProfileInfo, canViewGameInfo, canViewFriendInfo, active, latitude, longitude);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="name"></param>
        /// <param name="groupId"></param>
        /// <param name="assetId"></param>
        /// <param name="connections"></param>
        /// <param name="description"></param>
        /// <param name="canViewProfileInfo"></param>
        /// <param name="canViewGameInfo"></param>
        /// <param name="canViewFriendInfo"></param>
        /// <param name="active"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void AfterCreateOrUpdateGroup(ref bool suppressDefaultLog, ICreateOrUpdateGroupApiResponse apiResponseLocalVar, bool returnNulls, Option<string> deviceId, Option<long> accountId, Option<string> name, Option<long> groupId, Option<long> assetId, Option<string> connections, Option<string> description, Option<bool> canViewProfileInfo, Option<bool> canViewGameInfo, Option<bool> canViewFriendInfo, Option<bool> active, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="name"></param>
        /// <param name="groupId"></param>
        /// <param name="assetId"></param>
        /// <param name="connections"></param>
        /// <param name="description"></param>
        /// <param name="canViewProfileInfo"></param>
        /// <param name="canViewGameInfo"></param>
        /// <param name="canViewFriendInfo"></param>
        /// <param name="active"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void OnErrorCreateOrUpdateGroupDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, bool returnNulls, Option<string> deviceId, Option<long> accountId, Option<string> name, Option<long> groupId, Option<long> assetId, Option<string> connections, Option<string> description, Option<bool> canViewProfileInfo, Option<bool> canViewGameInfo, Option<bool> canViewFriendInfo, Option<bool> active, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateOrUpdateGroup(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, returnNulls, deviceId, accountId, name, groupId, assetId, connections, description, canViewProfileInfo, canViewGameInfo, canViewFriendInfo, active, latitude, longitude);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="name"></param>
        /// <param name="groupId"></param>
        /// <param name="assetId"></param>
        /// <param name="connections"></param>
        /// <param name="description"></param>
        /// <param name="canViewProfileInfo"></param>
        /// <param name="canViewGameInfo"></param>
        /// <param name="canViewFriendInfo"></param>
        /// <param name="active"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void OnErrorCreateOrUpdateGroup(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, bool returnNulls, Option<string> deviceId, Option<long> accountId, Option<string> name, Option<long> groupId, Option<long> assetId, Option<string> connections, Option<string> description, Option<bool> canViewProfileInfo, Option<bool> canViewGameInfo, Option<bool> canViewFriendInfo, Option<bool> active, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Create or Update Connection Group Creates a new private group.
        /// </summary>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="name">the name of the group (optional)</param>
        /// <param name="groupId">the group id to update a group (don&#39;t pass anything in if you want to create a new group) (optional)</param>
        /// <param name="assetId">the asset to attach to the group (optional)</param>
        /// <param name="connections">comma separated list of connection IDs (optional)</param>
        /// <param name="description">the description of the group (optional)</param>
        /// <param name="canViewProfileInfo">determines whether the connections in the group can see the user&#39;s profile info (optional)</param>
        /// <param name="canViewGameInfo">determines whether the connections in the group can see the user&#39;s game info (optional)</param>
        /// <param name="canViewFriendInfo">determines whether the connections in the group can see the user&#39;s friends/connections (optional)</param>
        /// <param name="active">Sets whether the connection group is active or inactive (optional)</param>
        /// <param name="latitude">the latitude of the group (optional)</param>
        /// <param name="longitude">the longitude of the group (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateOrUpdateGroupApiResponse"/>&gt;</returns>
        public async Task<ICreateOrUpdateGroupApiResponse?> CreateOrUpdateGroupOrDefaultAsync(bool returnNulls, Option<string> deviceId = default, Option<long> accountId = default, Option<string> name = default, Option<long> groupId = default, Option<long> assetId = default, Option<string> connections = default, Option<string> description = default, Option<bool> canViewProfileInfo = default, Option<bool> canViewGameInfo = default, Option<bool> canViewFriendInfo = default, Option<bool> active = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateOrUpdateGroupAsync(returnNulls, deviceId, accountId, name, groupId, assetId, connections, description, canViewProfileInfo, canViewGameInfo, canViewFriendInfo, active, latitude, longitude, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create or Update Connection Group Creates a new private group.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="name">the name of the group (optional)</param>
        /// <param name="groupId">the group id to update a group (don&#39;t pass anything in if you want to create a new group) (optional)</param>
        /// <param name="assetId">the asset to attach to the group (optional)</param>
        /// <param name="connections">comma separated list of connection IDs (optional)</param>
        /// <param name="description">the description of the group (optional)</param>
        /// <param name="canViewProfileInfo">determines whether the connections in the group can see the user&#39;s profile info (optional)</param>
        /// <param name="canViewGameInfo">determines whether the connections in the group can see the user&#39;s game info (optional)</param>
        /// <param name="canViewFriendInfo">determines whether the connections in the group can see the user&#39;s friends/connections (optional)</param>
        /// <param name="active">Sets whether the connection group is active or inactive (optional)</param>
        /// <param name="latitude">the latitude of the group (optional)</param>
        /// <param name="longitude">the longitude of the group (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateOrUpdateGroupApiResponse"/>&gt;</returns>
        public async Task<ICreateOrUpdateGroupApiResponse> CreateOrUpdateGroupAsync(bool returnNulls, Option<string> deviceId = default, Option<long> accountId = default, Option<string> name = default, Option<long> groupId = default, Option<long> assetId = default, Option<string> connections = default, Option<string> description = default, Option<bool> canViewProfileInfo = default, Option<bool> canViewGameInfo = default, Option<bool> canViewFriendInfo = default, Option<bool> active = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateOrUpdateGroup(deviceId, name, connections, description);

                FormatCreateOrUpdateGroup(ref returnNulls, ref deviceId, ref accountId, ref name, ref groupId, ref assetId, ref connections, ref description, ref canViewProfileInfo, ref canViewGameInfo, ref canViewFriendInfo, ref active, ref latitude, ref longitude);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/connection/group"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/connection/group");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["returnNulls"] = ClientUtils.ParameterToString(returnNulls);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (name.IsSet)
                        parseQueryStringLocalVar["name"] = ClientUtils.ParameterToString(name.Value);

                    if (groupId.IsSet)
                        parseQueryStringLocalVar["groupId"] = ClientUtils.ParameterToString(groupId.Value);

                    if (assetId.IsSet)
                        parseQueryStringLocalVar["assetId"] = ClientUtils.ParameterToString(assetId.Value);

                    if (connections.IsSet)
                        parseQueryStringLocalVar["connections"] = ClientUtils.ParameterToString(connections.Value);

                    if (description.IsSet)
                        parseQueryStringLocalVar["description"] = ClientUtils.ParameterToString(description.Value);

                    if (canViewProfileInfo.IsSet)
                        parseQueryStringLocalVar["canViewProfileInfo"] = ClientUtils.ParameterToString(canViewProfileInfo.Value);

                    if (canViewGameInfo.IsSet)
                        parseQueryStringLocalVar["canViewGameInfo"] = ClientUtils.ParameterToString(canViewGameInfo.Value);

                    if (canViewFriendInfo.IsSet)
                        parseQueryStringLocalVar["canViewFriendInfo"] = ClientUtils.ParameterToString(canViewFriendInfo.Value);

                    if (active.IsSet)
                        parseQueryStringLocalVar["active"] = ClientUtils.ParameterToString(active.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateOrUpdateGroupApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateOrUpdateGroupApiResponse>();
                        CreateOrUpdateGroupApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/connection/group", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateOrUpdateGroupDefaultImplementation(apiResponseLocalVar, returnNulls, deviceId, accountId, name, groupId, assetId, connections, description, canViewProfileInfo, canViewGameInfo, canViewFriendInfo, active, latitude, longitude);

                        Events.ExecuteOnCreateOrUpdateGroup(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateOrUpdateGroupDefaultImplementation(e, "/consumer/connection/group", uriBuilderLocalVar.Path, returnNulls, deviceId, accountId, name, groupId, assetId, connections, description, canViewProfileInfo, canViewGameInfo, canViewFriendInfo, active, latitude, longitude);
                Events.ExecuteOnErrorCreateOrUpdateGroup(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateOrUpdateGroupApiResponse"/>
        /// </summary>
        public partial class CreateOrUpdateGroupApiResponse : Org.OpenAPITools.Client.ApiResponse, ICreateOrUpdateGroupApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateOrUpdateGroupApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateOrUpdateGroupApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateOrUpdateGroupApiResponse(ILogger<CreateOrUpdateGroupApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateOrUpdateGroupApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateOrUpdateGroupApiResponse(ILogger<CreateOrUpdateGroupApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFollowAccept(ref long accountId, ref long connectionAccountId, ref string appKey);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="appKey"></param>
        /// <returns></returns>
        private void ValidateFollowAccept(string appKey)
        {
            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        private void AfterFollowAcceptDefaultImplementation(IFollowAcceptApiResponse apiResponseLocalVar, long accountId, long connectionAccountId, string appKey)
        {
            bool suppressDefaultLog = false;
            AfterFollowAccept(ref suppressDefaultLog, apiResponseLocalVar, accountId, connectionAccountId, appKey);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        partial void AfterFollowAccept(ref bool suppressDefaultLog, IFollowAcceptApiResponse apiResponseLocalVar, long accountId, long connectionAccountId, string appKey);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        private void OnErrorFollowAcceptDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long connectionAccountId, string appKey)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorFollowAccept(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, connectionAccountId, appKey);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        partial void OnErrorFollowAccept(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long connectionAccountId, string appKey);

        /// <summary>
        /// Accept Follow Request Accept someone&#39;s follow request.
        /// </summary>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="connectionAccountId">the account ID of the user who initiated the follow</param>
        /// <param name="appKey">the application key for sending notifications</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFollowAcceptApiResponse"/>&gt;</returns>
        public async Task<IFollowAcceptApiResponse?> FollowAcceptOrDefaultAsync(long accountId, long connectionAccountId, string appKey, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FollowAcceptAsync(accountId, connectionAccountId, appKey, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Accept Follow Request Accept someone&#39;s follow request.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="connectionAccountId">the account ID of the user who initiated the follow</param>
        /// <param name="appKey">the application key for sending notifications</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFollowAcceptApiResponse"/>&gt;</returns>
        public async Task<IFollowAcceptApiResponse> FollowAcceptAsync(long accountId, long connectionAccountId, string appKey, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateFollowAccept(appKey);

                FormatFollowAccept(ref accountId, ref connectionAccountId, ref appKey);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/follow/accept"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/follow/accept");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["connectionAccountId"] = ClientUtils.ParameterToString(connectionAccountId);
                    parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<FollowAcceptApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FollowAcceptApiResponse>();
                        FollowAcceptApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/follow/accept", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterFollowAcceptDefaultImplementation(apiResponseLocalVar, accountId, connectionAccountId, appKey);

                        Events.ExecuteOnFollowAccept(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFollowAcceptDefaultImplementation(e, "/consumer/follow/accept", uriBuilderLocalVar.Path, accountId, connectionAccountId, appKey);
                Events.ExecuteOnErrorFollowAccept(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FollowAcceptApiResponse"/>
        /// </summary>
        public partial class FollowAcceptApiResponse : Org.OpenAPITools.Client.ApiResponse, IFollowAcceptApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FollowAcceptApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FollowAcceptApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FollowAcceptApiResponse(ILogger<FollowAcceptApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="FollowAcceptApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FollowAcceptApiResponse(ILogger<FollowAcceptApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFollowReject(ref long accountId, ref long connectionAccountId, ref string appKey);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="appKey"></param>
        /// <returns></returns>
        private void ValidateFollowReject(string appKey)
        {
            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        private void AfterFollowRejectDefaultImplementation(IFollowRejectApiResponse apiResponseLocalVar, long accountId, long connectionAccountId, string appKey)
        {
            bool suppressDefaultLog = false;
            AfterFollowReject(ref suppressDefaultLog, apiResponseLocalVar, accountId, connectionAccountId, appKey);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        partial void AfterFollowReject(ref bool suppressDefaultLog, IFollowRejectApiResponse apiResponseLocalVar, long accountId, long connectionAccountId, string appKey);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        private void OnErrorFollowRejectDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long connectionAccountId, string appKey)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorFollowReject(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, connectionAccountId, appKey);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        partial void OnErrorFollowReject(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long connectionAccountId, string appKey);

        /// <summary>
        /// Reject Follow Request Reject someone&#39;s follow request or remove them as a follower.
        /// </summary>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="connectionAccountId">the account ID of the user who initiated the follow</param>
        /// <param name="appKey">the application key for sending notifications</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFollowRejectApiResponse"/>&gt;</returns>
        public async Task<IFollowRejectApiResponse?> FollowRejectOrDefaultAsync(long accountId, long connectionAccountId, string appKey, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FollowRejectAsync(accountId, connectionAccountId, appKey, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Reject Follow Request Reject someone&#39;s follow request or remove them as a follower.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="connectionAccountId">the account ID of the user who initiated the follow</param>
        /// <param name="appKey">the application key for sending notifications</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFollowRejectApiResponse"/>&gt;</returns>
        public async Task<IFollowRejectApiResponse> FollowRejectAsync(long accountId, long connectionAccountId, string appKey, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateFollowReject(appKey);

                FormatFollowReject(ref accountId, ref connectionAccountId, ref appKey);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/follow/reject"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/follow/reject");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["connectionAccountId"] = ClientUtils.ParameterToString(connectionAccountId);
                    parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<FollowRejectApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FollowRejectApiResponse>();
                        FollowRejectApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/follow/reject", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterFollowRejectDefaultImplementation(apiResponseLocalVar, accountId, connectionAccountId, appKey);

                        Events.ExecuteOnFollowReject(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFollowRejectDefaultImplementation(e, "/consumer/follow/reject", uriBuilderLocalVar.Path, accountId, connectionAccountId, appKey);
                Events.ExecuteOnErrorFollowReject(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FollowRejectApiResponse"/>
        /// </summary>
        public partial class FollowRejectApiResponse : Org.OpenAPITools.Client.ApiResponse, IFollowRejectApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FollowRejectApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FollowRejectApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FollowRejectApiResponse(ILogger<FollowRejectApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="FollowRejectApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FollowRejectApiResponse(ILogger<FollowRejectApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFollowRemove(ref long accountId, ref long connectionAccountId, ref string appKey);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="appKey"></param>
        /// <returns></returns>
        private void ValidateFollowRemove(string appKey)
        {
            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        private void AfterFollowRemoveDefaultImplementation(IFollowRemoveApiResponse apiResponseLocalVar, long accountId, long connectionAccountId, string appKey)
        {
            bool suppressDefaultLog = false;
            AfterFollowRemove(ref suppressDefaultLog, apiResponseLocalVar, accountId, connectionAccountId, appKey);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        partial void AfterFollowRemove(ref bool suppressDefaultLog, IFollowRemoveApiResponse apiResponseLocalVar, long accountId, long connectionAccountId, string appKey);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        private void OnErrorFollowRemoveDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long connectionAccountId, string appKey)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorFollowRemove(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, connectionAccountId, appKey);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        partial void OnErrorFollowRemove(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long connectionAccountId, string appKey);

        /// <summary>
        /// Remove Follower / Unfollow Unfollow someone you are following or remove them as a follower.
        /// </summary>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="connectionAccountId">the account ID of the user who you want to unfollow</param>
        /// <param name="appKey">the application key for sending notifications</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFollowRemoveApiResponse"/>&gt;</returns>
        public async Task<IFollowRemoveApiResponse?> FollowRemoveOrDefaultAsync(long accountId, long connectionAccountId, string appKey, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FollowRemoveAsync(accountId, connectionAccountId, appKey, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Remove Follower / Unfollow Unfollow someone you are following or remove them as a follower.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="connectionAccountId">the account ID of the user who you want to unfollow</param>
        /// <param name="appKey">the application key for sending notifications</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFollowRemoveApiResponse"/>&gt;</returns>
        public async Task<IFollowRemoveApiResponse> FollowRemoveAsync(long accountId, long connectionAccountId, string appKey, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateFollowRemove(appKey);

                FormatFollowRemove(ref accountId, ref connectionAccountId, ref appKey);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/follow/remove"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/follow/remove");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["connectionAccountId"] = ClientUtils.ParameterToString(connectionAccountId);
                    parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<FollowRemoveApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FollowRemoveApiResponse>();
                        FollowRemoveApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/follow/remove", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterFollowRemoveDefaultImplementation(apiResponseLocalVar, accountId, connectionAccountId, appKey);

                        Events.ExecuteOnFollowRemove(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFollowRemoveDefaultImplementation(e, "/consumer/follow/remove", uriBuilderLocalVar.Path, accountId, connectionAccountId, appKey);
                Events.ExecuteOnErrorFollowRemove(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FollowRemoveApiResponse"/>
        /// </summary>
        public partial class FollowRemoveApiResponse : Org.OpenAPITools.Client.ApiResponse, IFollowRemoveApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FollowRemoveApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FollowRemoveApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FollowRemoveApiResponse(ILogger<FollowRemoveApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="FollowRemoveApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FollowRemoveApiResponse(ILogger<FollowRemoveApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFollowRequest(ref long accountId, ref long connectionAccountId, ref string appKey, ref Option<bool> approvalNeeded);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="appKey"></param>
        /// <returns></returns>
        private void ValidateFollowRequest(string appKey)
        {
            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        /// <param name="approvalNeeded"></param>
        private void AfterFollowRequestDefaultImplementation(IFollowRequestApiResponse apiResponseLocalVar, long accountId, long connectionAccountId, string appKey, Option<bool> approvalNeeded)
        {
            bool suppressDefaultLog = false;
            AfterFollowRequest(ref suppressDefaultLog, apiResponseLocalVar, accountId, connectionAccountId, appKey, approvalNeeded);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        /// <param name="approvalNeeded"></param>
        partial void AfterFollowRequest(ref bool suppressDefaultLog, IFollowRequestApiResponse apiResponseLocalVar, long accountId, long connectionAccountId, string appKey, Option<bool> approvalNeeded);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        /// <param name="approvalNeeded"></param>
        private void OnErrorFollowRequestDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long connectionAccountId, string appKey, Option<bool> approvalNeeded)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorFollowRequest(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, connectionAccountId, appKey, approvalNeeded);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        /// <param name="approvalNeeded"></param>
        partial void OnErrorFollowRequest(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long connectionAccountId, string appKey, Option<bool> approvalNeeded);

        /// <summary>
        /// Send Follow Request Send a request to follow someone.
        /// </summary>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="connectionAccountId">the account ID of the user who you want to follow</param>
        /// <param name="appKey">the application key for sending notifications</param>
        /// <param name="approvalNeeded">determines if the other user needs to confirm the follow request (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFollowRequestApiResponse"/>&gt;</returns>
        public async Task<IFollowRequestApiResponse?> FollowRequestOrDefaultAsync(long accountId, long connectionAccountId, string appKey, Option<bool> approvalNeeded = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FollowRequestAsync(accountId, connectionAccountId, appKey, approvalNeeded, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Send Follow Request Send a request to follow someone.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="connectionAccountId">the account ID of the user who you want to follow</param>
        /// <param name="appKey">the application key for sending notifications</param>
        /// <param name="approvalNeeded">determines if the other user needs to confirm the follow request (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFollowRequestApiResponse"/>&gt;</returns>
        public async Task<IFollowRequestApiResponse> FollowRequestAsync(long accountId, long connectionAccountId, string appKey, Option<bool> approvalNeeded = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateFollowRequest(appKey);

                FormatFollowRequest(ref accountId, ref connectionAccountId, ref appKey, ref approvalNeeded);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/follow/request"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/follow/request");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["connectionAccountId"] = ClientUtils.ParameterToString(connectionAccountId);
                    parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey);

                    if (approvalNeeded.IsSet)
                        parseQueryStringLocalVar["approvalNeeded"] = ClientUtils.ParameterToString(approvalNeeded.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<FollowRequestApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FollowRequestApiResponse>();
                        FollowRequestApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/follow/request", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterFollowRequestDefaultImplementation(apiResponseLocalVar, accountId, connectionAccountId, appKey, approvalNeeded);

                        Events.ExecuteOnFollowRequest(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFollowRequestDefaultImplementation(e, "/consumer/follow/request", uriBuilderLocalVar.Path, accountId, connectionAccountId, appKey, approvalNeeded);
                Events.ExecuteOnErrorFollowRequest(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FollowRequestApiResponse"/>
        /// </summary>
        public partial class FollowRequestApiResponse : Org.OpenAPITools.Client.ApiResponse, IFollowRequestApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FollowRequestApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FollowRequestApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FollowRequestApiResponse(ILogger<FollowRequestApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="FollowRequestApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FollowRequestApiResponse(ILogger<FollowRequestApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFriendAccept(ref long friendAccountId, ref bool notifyFriend, ref Option<string> deviceId, ref Option<long> accountId, ref Option<string> gameType, ref Option<string> appKey, ref Option<string> notificationMessage);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="notificationMessage"></param>
        /// <returns></returns>
        private void ValidateFriendAccept(Option<string> deviceId, Option<string> gameType, Option<string> appKey, Option<string> notificationMessage)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (gameType.IsSet && gameType.Value == null)
                throw new ArgumentNullException(nameof(gameType));

            if (appKey.IsSet && appKey.Value == null)
                throw new ArgumentNullException(nameof(appKey));

            if (notificationMessage.IsSet && notificationMessage.Value == null)
                throw new ArgumentNullException(nameof(notificationMessage));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="friendAccountId"></param>
        /// <param name="notifyFriend"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="notificationMessage"></param>
        private void AfterFriendAcceptDefaultImplementation(IFriendAcceptApiResponse apiResponseLocalVar, long friendAccountId, bool notifyFriend, Option<string> deviceId, Option<long> accountId, Option<string> gameType, Option<string> appKey, Option<string> notificationMessage)
        {
            bool suppressDefaultLog = false;
            AfterFriendAccept(ref suppressDefaultLog, apiResponseLocalVar, friendAccountId, notifyFriend, deviceId, accountId, gameType, appKey, notificationMessage);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="friendAccountId"></param>
        /// <param name="notifyFriend"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="notificationMessage"></param>
        partial void AfterFriendAccept(ref bool suppressDefaultLog, IFriendAcceptApiResponse apiResponseLocalVar, long friendAccountId, bool notifyFriend, Option<string> deviceId, Option<long> accountId, Option<string> gameType, Option<string> appKey, Option<string> notificationMessage);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="friendAccountId"></param>
        /// <param name="notifyFriend"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="notificationMessage"></param>
        private void OnErrorFriendAcceptDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long friendAccountId, bool notifyFriend, Option<string> deviceId, Option<long> accountId, Option<string> gameType, Option<string> appKey, Option<string> notificationMessage)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorFriendAccept(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, friendAccountId, notifyFriend, deviceId, accountId, gameType, appKey, notificationMessage);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="friendAccountId"></param>
        /// <param name="notifyFriend"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="notificationMessage"></param>
        partial void OnErrorFriendAccept(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long friendAccountId, bool notifyFriend, Option<string> deviceId, Option<long> accountId, Option<string> gameType, Option<string> appKey, Option<string> notificationMessage);

        /// <summary>
        /// Accept Friend Accept a friend request and optionally sends a notification.
        /// </summary>
        /// <param name="friendAccountId">the friend&#39;s account id</param>
        /// <param name="notifyFriend">determines whether to send a notification to the afflicting party</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="notificationMessage">optional message to send in a notification (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFriendAcceptApiResponse"/>&gt;</returns>
        public async Task<IFriendAcceptApiResponse?> FriendAcceptOrDefaultAsync(long friendAccountId, bool notifyFriend, Option<string> deviceId = default, Option<long> accountId = default, Option<string> gameType = default, Option<string> appKey = default, Option<string> notificationMessage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FriendAcceptAsync(friendAccountId, notifyFriend, deviceId, accountId, gameType, appKey, notificationMessage, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Accept Friend Accept a friend request and optionally sends a notification.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendAccountId">the friend&#39;s account id</param>
        /// <param name="notifyFriend">determines whether to send a notification to the afflicting party</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="notificationMessage">optional message to send in a notification (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFriendAcceptApiResponse"/>&gt;</returns>
        public async Task<IFriendAcceptApiResponse> FriendAcceptAsync(long friendAccountId, bool notifyFriend, Option<string> deviceId = default, Option<long> accountId = default, Option<string> gameType = default, Option<string> appKey = default, Option<string> notificationMessage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateFriendAccept(deviceId, gameType, appKey, notificationMessage);

                FormatFriendAccept(ref friendAccountId, ref notifyFriend, ref deviceId, ref accountId, ref gameType, ref appKey, ref notificationMessage);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/friend/accept"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/friend/accept");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["friendAccountId"] = ClientUtils.ParameterToString(friendAccountId);
                    parseQueryStringLocalVar["notifyFriend"] = ClientUtils.ParameterToString(notifyFriend);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (gameType.IsSet)
                        parseQueryStringLocalVar["gameType"] = ClientUtils.ParameterToString(gameType.Value);

                    if (appKey.IsSet)
                        parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey.Value);

                    if (notificationMessage.IsSet)
                        parseQueryStringLocalVar["notificationMessage"] = ClientUtils.ParameterToString(notificationMessage.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<FriendAcceptApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FriendAcceptApiResponse>();
                        FriendAcceptApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/friend/accept", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterFriendAcceptDefaultImplementation(apiResponseLocalVar, friendAccountId, notifyFriend, deviceId, accountId, gameType, appKey, notificationMessage);

                        Events.ExecuteOnFriendAccept(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFriendAcceptDefaultImplementation(e, "/consumer/friend/accept", uriBuilderLocalVar.Path, friendAccountId, notifyFriend, deviceId, accountId, gameType, appKey, notificationMessage);
                Events.ExecuteOnErrorFriendAccept(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FriendAcceptApiResponse"/>
        /// </summary>
        public partial class FriendAcceptApiResponse : Org.OpenAPITools.Client.ApiResponse, IFriendAcceptApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FriendAcceptApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FriendAcceptApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FriendAcceptApiResponse(ILogger<FriendAcceptApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="FriendAcceptApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FriendAcceptApiResponse(ILogger<FriendAcceptApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFriendReject(ref long friendAccountId, ref Option<string> deviceId, ref Option<long> accountId, ref Option<string> gameType, ref Option<string> appKey, ref Option<bool> notifyFriend, ref Option<string> notificationMessage);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="notificationMessage"></param>
        /// <returns></returns>
        private void ValidateFriendReject(Option<string> deviceId, Option<string> gameType, Option<string> appKey, Option<string> notificationMessage)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (gameType.IsSet && gameType.Value == null)
                throw new ArgumentNullException(nameof(gameType));

            if (appKey.IsSet && appKey.Value == null)
                throw new ArgumentNullException(nameof(appKey));

            if (notificationMessage.IsSet && notificationMessage.Value == null)
                throw new ArgumentNullException(nameof(notificationMessage));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="friendAccountId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="notifyFriend"></param>
        /// <param name="notificationMessage"></param>
        private void AfterFriendRejectDefaultImplementation(IFriendRejectApiResponse apiResponseLocalVar, long friendAccountId, Option<string> deviceId, Option<long> accountId, Option<string> gameType, Option<string> appKey, Option<bool> notifyFriend, Option<string> notificationMessage)
        {
            bool suppressDefaultLog = false;
            AfterFriendReject(ref suppressDefaultLog, apiResponseLocalVar, friendAccountId, deviceId, accountId, gameType, appKey, notifyFriend, notificationMessage);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="friendAccountId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="notifyFriend"></param>
        /// <param name="notificationMessage"></param>
        partial void AfterFriendReject(ref bool suppressDefaultLog, IFriendRejectApiResponse apiResponseLocalVar, long friendAccountId, Option<string> deviceId, Option<long> accountId, Option<string> gameType, Option<string> appKey, Option<bool> notifyFriend, Option<string> notificationMessage);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="friendAccountId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="notifyFriend"></param>
        /// <param name="notificationMessage"></param>
        private void OnErrorFriendRejectDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long friendAccountId, Option<string> deviceId, Option<long> accountId, Option<string> gameType, Option<string> appKey, Option<bool> notifyFriend, Option<string> notificationMessage)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorFriendReject(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, friendAccountId, deviceId, accountId, gameType, appKey, notifyFriend, notificationMessage);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="friendAccountId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="notifyFriend"></param>
        /// <param name="notificationMessage"></param>
        partial void OnErrorFriendReject(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long friendAccountId, Option<string> deviceId, Option<long> accountId, Option<string> gameType, Option<string> appKey, Option<bool> notifyFriend, Option<string> notificationMessage);

        /// <summary>
        /// Decline Friend Request a friend request and optionally sends a notification.
        /// </summary>
        /// <param name="friendAccountId">the friend&#39;s account id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="notifyFriend">determines whether to send a notification to the afflicting party (optional)</param>
        /// <param name="notificationMessage">optional message to send in a notification (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFriendRejectApiResponse"/>&gt;</returns>
        public async Task<IFriendRejectApiResponse?> FriendRejectOrDefaultAsync(long friendAccountId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> gameType = default, Option<string> appKey = default, Option<bool> notifyFriend = default, Option<string> notificationMessage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FriendRejectAsync(friendAccountId, deviceId, accountId, gameType, appKey, notifyFriend, notificationMessage, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Decline Friend Request a friend request and optionally sends a notification.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendAccountId">the friend&#39;s account id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="notifyFriend">determines whether to send a notification to the afflicting party (optional)</param>
        /// <param name="notificationMessage">optional message to send in a notification (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFriendRejectApiResponse"/>&gt;</returns>
        public async Task<IFriendRejectApiResponse> FriendRejectAsync(long friendAccountId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> gameType = default, Option<string> appKey = default, Option<bool> notifyFriend = default, Option<string> notificationMessage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateFriendReject(deviceId, gameType, appKey, notificationMessage);

                FormatFriendReject(ref friendAccountId, ref deviceId, ref accountId, ref gameType, ref appKey, ref notifyFriend, ref notificationMessage);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/friend/reject"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/friend/reject");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["friendAccountId"] = ClientUtils.ParameterToString(friendAccountId);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (gameType.IsSet)
                        parseQueryStringLocalVar["gameType"] = ClientUtils.ParameterToString(gameType.Value);

                    if (appKey.IsSet)
                        parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey.Value);

                    if (notifyFriend.IsSet)
                        parseQueryStringLocalVar["notifyFriend"] = ClientUtils.ParameterToString(notifyFriend.Value);

                    if (notificationMessage.IsSet)
                        parseQueryStringLocalVar["notificationMessage"] = ClientUtils.ParameterToString(notificationMessage.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<FriendRejectApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FriendRejectApiResponse>();
                        FriendRejectApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/friend/reject", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterFriendRejectDefaultImplementation(apiResponseLocalVar, friendAccountId, deviceId, accountId, gameType, appKey, notifyFriend, notificationMessage);

                        Events.ExecuteOnFriendReject(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFriendRejectDefaultImplementation(e, "/consumer/friend/reject", uriBuilderLocalVar.Path, friendAccountId, deviceId, accountId, gameType, appKey, notifyFriend, notificationMessage);
                Events.ExecuteOnErrorFriendReject(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FriendRejectApiResponse"/>
        /// </summary>
        public partial class FriendRejectApiResponse : Org.OpenAPITools.Client.ApiResponse, IFriendRejectApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FriendRejectApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FriendRejectApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FriendRejectApiResponse(ILogger<FriendRejectApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="FriendRejectApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FriendRejectApiResponse(ILogger<FriendRejectApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFriendRemove(ref long friendAccountId, ref Option<string> deviceId, ref Option<long> accountId, ref Option<bool> notifyFriend, ref Option<bool> removeFromGroups);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <returns></returns>
        private void ValidateFriendRemove(Option<string> deviceId)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="friendAccountId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="notifyFriend"></param>
        /// <param name="removeFromGroups"></param>
        private void AfterFriendRemoveDefaultImplementation(IFriendRemoveApiResponse apiResponseLocalVar, long friendAccountId, Option<string> deviceId, Option<long> accountId, Option<bool> notifyFriend, Option<bool> removeFromGroups)
        {
            bool suppressDefaultLog = false;
            AfterFriendRemove(ref suppressDefaultLog, apiResponseLocalVar, friendAccountId, deviceId, accountId, notifyFriend, removeFromGroups);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="friendAccountId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="notifyFriend"></param>
        /// <param name="removeFromGroups"></param>
        partial void AfterFriendRemove(ref bool suppressDefaultLog, IFriendRemoveApiResponse apiResponseLocalVar, long friendAccountId, Option<string> deviceId, Option<long> accountId, Option<bool> notifyFriend, Option<bool> removeFromGroups);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="friendAccountId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="notifyFriend"></param>
        /// <param name="removeFromGroups"></param>
        private void OnErrorFriendRemoveDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long friendAccountId, Option<string> deviceId, Option<long> accountId, Option<bool> notifyFriend, Option<bool> removeFromGroups)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorFriendRemove(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, friendAccountId, deviceId, accountId, notifyFriend, removeFromGroups);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="friendAccountId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="notifyFriend"></param>
        /// <param name="removeFromGroups"></param>
        partial void OnErrorFriendRemove(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long friendAccountId, Option<string> deviceId, Option<long> accountId, Option<bool> notifyFriend, Option<bool> removeFromGroups);

        /// <summary>
        /// Delete Friend Removes a friend from the user&#39;s friends list.
        /// </summary>
        /// <param name="friendAccountId">the account ID of the friend to remove</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="notifyFriend">optionally notifies the connection that they have been removed as a friend (optional)</param>
        /// <param name="removeFromGroups">optionally removes the connection from the user&#39;s groups (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFriendRemoveApiResponse"/>&gt;</returns>
        public async Task<IFriendRemoveApiResponse?> FriendRemoveOrDefaultAsync(long friendAccountId, Option<string> deviceId = default, Option<long> accountId = default, Option<bool> notifyFriend = default, Option<bool> removeFromGroups = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FriendRemoveAsync(friendAccountId, deviceId, accountId, notifyFriend, removeFromGroups, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete Friend Removes a friend from the user&#39;s friends list.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendAccountId">the account ID of the friend to remove</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="notifyFriend">optionally notifies the connection that they have been removed as a friend (optional)</param>
        /// <param name="removeFromGroups">optionally removes the connection from the user&#39;s groups (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFriendRemoveApiResponse"/>&gt;</returns>
        public async Task<IFriendRemoveApiResponse> FriendRemoveAsync(long friendAccountId, Option<string> deviceId = default, Option<long> accountId = default, Option<bool> notifyFriend = default, Option<bool> removeFromGroups = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateFriendRemove(deviceId);

                FormatFriendRemove(ref friendAccountId, ref deviceId, ref accountId, ref notifyFriend, ref removeFromGroups);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/friend/remove"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/friend/remove");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["friendAccountId"] = ClientUtils.ParameterToString(friendAccountId);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (notifyFriend.IsSet)
                        parseQueryStringLocalVar["notifyFriend"] = ClientUtils.ParameterToString(notifyFriend.Value);

                    if (removeFromGroups.IsSet)
                        parseQueryStringLocalVar["removeFromGroups"] = ClientUtils.ParameterToString(removeFromGroups.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<FriendRemoveApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FriendRemoveApiResponse>();
                        FriendRemoveApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/friend/remove", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterFriendRemoveDefaultImplementation(apiResponseLocalVar, friendAccountId, deviceId, accountId, notifyFriend, removeFromGroups);

                        Events.ExecuteOnFriendRemove(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFriendRemoveDefaultImplementation(e, "/consumer/friend/remove", uriBuilderLocalVar.Path, friendAccountId, deviceId, accountId, notifyFriend, removeFromGroups);
                Events.ExecuteOnErrorFriendRemove(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FriendRemoveApiResponse"/>
        /// </summary>
        public partial class FriendRemoveApiResponse : Org.OpenAPITools.Client.ApiResponse, IFriendRemoveApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FriendRemoveApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FriendRemoveApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FriendRemoveApiResponse(ILogger<FriendRemoveApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="FriendRemoveApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FriendRemoveApiResponse(ILogger<FriendRemoveApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFriendRequest(ref long friendAccountId, ref Option<string> deviceId, ref Option<long> accountId, ref Option<string> gameType, ref Option<string> appKey, ref Option<string> notificationMessage);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="notificationMessage"></param>
        /// <returns></returns>
        private void ValidateFriendRequest(Option<string> deviceId, Option<string> gameType, Option<string> appKey, Option<string> notificationMessage)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (gameType.IsSet && gameType.Value == null)
                throw new ArgumentNullException(nameof(gameType));

            if (appKey.IsSet && appKey.Value == null)
                throw new ArgumentNullException(nameof(appKey));

            if (notificationMessage.IsSet && notificationMessage.Value == null)
                throw new ArgumentNullException(nameof(notificationMessage));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="friendAccountId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="notificationMessage"></param>
        private void AfterFriendRequestDefaultImplementation(IFriendRequestApiResponse apiResponseLocalVar, long friendAccountId, Option<string> deviceId, Option<long> accountId, Option<string> gameType, Option<string> appKey, Option<string> notificationMessage)
        {
            bool suppressDefaultLog = false;
            AfterFriendRequest(ref suppressDefaultLog, apiResponseLocalVar, friendAccountId, deviceId, accountId, gameType, appKey, notificationMessage);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="friendAccountId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="notificationMessage"></param>
        partial void AfterFriendRequest(ref bool suppressDefaultLog, IFriendRequestApiResponse apiResponseLocalVar, long friendAccountId, Option<string> deviceId, Option<long> accountId, Option<string> gameType, Option<string> appKey, Option<string> notificationMessage);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="friendAccountId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="notificationMessage"></param>
        private void OnErrorFriendRequestDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long friendAccountId, Option<string> deviceId, Option<long> accountId, Option<string> gameType, Option<string> appKey, Option<string> notificationMessage)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorFriendRequest(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, friendAccountId, deviceId, accountId, gameType, appKey, notificationMessage);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="friendAccountId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="notificationMessage"></param>
        partial void OnErrorFriendRequest(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long friendAccountId, Option<string> deviceId, Option<long> accountId, Option<string> gameType, Option<string> appKey, Option<string> notificationMessage);

        /// <summary>
        /// Request Friend Sends a friend request notification to another user.
        /// </summary>
        /// <param name="friendAccountId">the friend&#39;s account id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="notificationMessage">optional message to send in a notification (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFriendRequestApiResponse"/>&gt;</returns>
        public async Task<IFriendRequestApiResponse?> FriendRequestOrDefaultAsync(long friendAccountId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> gameType = default, Option<string> appKey = default, Option<string> notificationMessage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FriendRequestAsync(friendAccountId, deviceId, accountId, gameType, appKey, notificationMessage, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Request Friend Sends a friend request notification to another user.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="friendAccountId">the friend&#39;s account id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="notificationMessage">optional message to send in a notification (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFriendRequestApiResponse"/>&gt;</returns>
        public async Task<IFriendRequestApiResponse> FriendRequestAsync(long friendAccountId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> gameType = default, Option<string> appKey = default, Option<string> notificationMessage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateFriendRequest(deviceId, gameType, appKey, notificationMessage);

                FormatFriendRequest(ref friendAccountId, ref deviceId, ref accountId, ref gameType, ref appKey, ref notificationMessage);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/friend/request"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/friend/request");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["friendAccountId"] = ClientUtils.ParameterToString(friendAccountId);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (gameType.IsSet)
                        parseQueryStringLocalVar["gameType"] = ClientUtils.ParameterToString(gameType.Value);

                    if (appKey.IsSet)
                        parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey.Value);

                    if (notificationMessage.IsSet)
                        parseQueryStringLocalVar["notificationMessage"] = ClientUtils.ParameterToString(notificationMessage.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<FriendRequestApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FriendRequestApiResponse>();
                        FriendRequestApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/friend/request", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterFriendRequestDefaultImplementation(apiResponseLocalVar, friendAccountId, deviceId, accountId, gameType, appKey, notificationMessage);

                        Events.ExecuteOnFriendRequest(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFriendRequestDefaultImplementation(e, "/consumer/friend/request", uriBuilderLocalVar.Path, friendAccountId, deviceId, accountId, gameType, appKey, notificationMessage);
                Events.ExecuteOnErrorFriendRequest(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FriendRequestApiResponse"/>
        /// </summary>
        public partial class FriendRequestApiResponse : Org.OpenAPITools.Client.ApiResponse, IFriendRequestApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FriendRequestApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FriendRequestApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FriendRequestApiResponse(ILogger<FriendRequestApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="FriendRequestApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FriendRequestApiResponse(ILogger<FriendRequestApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetConnectionSentFriendRequests(ref Option<string> deviceId, ref Option<long> accountId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <returns></returns>
        private void ValidateGetConnectionSentFriendRequests(Option<string> deviceId)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        private void AfterGetConnectionSentFriendRequestsDefaultImplementation(IGetConnectionSentFriendRequestsApiResponse apiResponseLocalVar, Option<string> deviceId, Option<long> accountId)
        {
            bool suppressDefaultLog = false;
            AfterGetConnectionSentFriendRequests(ref suppressDefaultLog, apiResponseLocalVar, deviceId, accountId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        partial void AfterGetConnectionSentFriendRequests(ref bool suppressDefaultLog, IGetConnectionSentFriendRequestsApiResponse apiResponseLocalVar, Option<string> deviceId, Option<long> accountId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        private void OnErrorGetConnectionSentFriendRequestsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> deviceId, Option<long> accountId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetConnectionSentFriendRequests(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, deviceId, accountId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        partial void OnErrorGetConnectionSentFriendRequests(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> deviceId, Option<long> accountId);

        /// <summary>
        /// Get Sent Friend Requests Gets the connection sent friend requests.
        /// </summary>
        /// <param name="deviceId">the ID of the device (optional)</param>
        /// <param name="accountId">the id of the account (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetConnectionSentFriendRequestsApiResponse"/>&gt;</returns>
        public async Task<IGetConnectionSentFriendRequestsApiResponse?> GetConnectionSentFriendRequestsOrDefaultAsync(Option<string> deviceId = default, Option<long> accountId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetConnectionSentFriendRequestsAsync(deviceId, accountId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Sent Friend Requests Gets the connection sent friend requests.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="deviceId">the ID of the device (optional)</param>
        /// <param name="accountId">the id of the account (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetConnectionSentFriendRequestsApiResponse"/>&gt;</returns>
        public async Task<IGetConnectionSentFriendRequestsApiResponse> GetConnectionSentFriendRequestsAsync(Option<string> deviceId = default, Option<long> accountId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetConnectionSentFriendRequests(deviceId);

                FormatGetConnectionSentFriendRequests(ref deviceId, ref accountId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/connection/getRequested"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/connection/getRequested");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetConnectionSentFriendRequestsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetConnectionSentFriendRequestsApiResponse>();
                        GetConnectionSentFriendRequestsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/connection/getRequested", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetConnectionSentFriendRequestsDefaultImplementation(apiResponseLocalVar, deviceId, accountId);

                        Events.ExecuteOnGetConnectionSentFriendRequests(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetConnectionSentFriendRequestsDefaultImplementation(e, "/consumer/connection/getRequested", uriBuilderLocalVar.Path, deviceId, accountId);
                Events.ExecuteOnErrorGetConnectionSentFriendRequests(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetConnectionSentFriendRequestsApiResponse"/>
        /// </summary>
        public partial class GetConnectionSentFriendRequestsApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetConnectionSentFriendRequestsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetConnectionSentFriendRequestsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetConnectionSentFriendRequestsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetConnectionSentFriendRequestsApiResponse(ILogger<GetConnectionSentFriendRequestsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetConnectionSentFriendRequestsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetConnectionSentFriendRequestsApiResponse(ILogger<GetConnectionSentFriendRequestsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ConnectionListResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ConnectionListResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ConnectionListResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetConnections(ref bool returnNulls, ref string filter, ref string sortField, ref bool descending, ref int start, ref int limit, ref Option<string> deviceId, ref Option<long> accountId, ref Option<long> connectionAccountId, ref Option<string> q, ref Option<string> keyword, ref Option<int> i, ref Option<int> l, ref Option<double> latitude, ref Option<double> longitude);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="filter"></param>
        /// <param name="sortField"></param>
        /// <param name="deviceId"></param>
        /// <param name="q"></param>
        /// <param name="keyword"></param>
        /// <returns></returns>
        private void ValidateGetConnections(string filter, string sortField, Option<string> deviceId, Option<string> q, Option<string> keyword)
        {
            if (filter == null)
                throw new ArgumentNullException(nameof(filter));

            if (sortField == null)
                throw new ArgumentNullException(nameof(sortField));

            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (q.IsSet && q.Value == null)
                throw new ArgumentNullException(nameof(q));

            if (keyword.IsSet && keyword.Value == null)
                throw new ArgumentNullException(nameof(keyword));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="filter"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="q"></param>
        /// <param name="keyword"></param>
        /// <param name="i"></param>
        /// <param name="l"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void AfterGetConnectionsDefaultImplementation(IGetConnectionsApiResponse apiResponseLocalVar, bool returnNulls, string filter, string sortField, bool descending, int start, int limit, Option<string> deviceId, Option<long> accountId, Option<long> connectionAccountId, Option<string> q, Option<string> keyword, Option<int> i, Option<int> l, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLog = false;
            AfterGetConnections(ref suppressDefaultLog, apiResponseLocalVar, returnNulls, filter, sortField, descending, start, limit, deviceId, accountId, connectionAccountId, q, keyword, i, l, latitude, longitude);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="filter"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="q"></param>
        /// <param name="keyword"></param>
        /// <param name="i"></param>
        /// <param name="l"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void AfterGetConnections(ref bool suppressDefaultLog, IGetConnectionsApiResponse apiResponseLocalVar, bool returnNulls, string filter, string sortField, bool descending, int start, int limit, Option<string> deviceId, Option<long> accountId, Option<long> connectionAccountId, Option<string> q, Option<string> keyword, Option<int> i, Option<int> l, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="filter"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="q"></param>
        /// <param name="keyword"></param>
        /// <param name="i"></param>
        /// <param name="l"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void OnErrorGetConnectionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, bool returnNulls, string filter, string sortField, bool descending, int start, int limit, Option<string> deviceId, Option<long> accountId, Option<long> connectionAccountId, Option<string> q, Option<string> keyword, Option<int> i, Option<int> l, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetConnections(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, returnNulls, filter, sortField, descending, start, limit, deviceId, accountId, connectionAccountId, q, keyword, i, l, latitude, longitude);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="filter"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="q"></param>
        /// <param name="keyword"></param>
        /// <param name="i"></param>
        /// <param name="l"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void OnErrorGetConnections(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, bool returnNulls, string filter, string sortField, bool descending, int start, int limit, Option<string> deviceId, Option<long> accountId, Option<long> connectionAccountId, Option<string> q, Option<string> keyword, Option<int> i, Option<int> l, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Search Connections Gets the connections.
        /// </summary>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="filter">a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)</param>
        /// <param name="sortField">sorts the response list by ConnectionApiMap</param>
        /// <param name="descending">sorts the response list by descending order if true</param>
        /// <param name="start">start index of the pagination</param>
        /// <param name="limit">limit of the pagination</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id (deviceId or accountId required) (optional)</param>
        /// <param name="connectionAccountId">optional parameter to search on other account&#39;s connections (optional)</param>
        /// <param name="q">This parameter is deprecated. (optional)</param>
        /// <param name="keyword">an optional keyword to search on, this parameter is ignored if empty (optional)</param>
        /// <param name="i">This parameter is deprecated. (optional)</param>
        /// <param name="l">This parameter is deprecated. (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetConnectionsApiResponse"/>&gt;</returns>
        public async Task<IGetConnectionsApiResponse?> GetConnectionsOrDefaultAsync(bool returnNulls, string filter, string sortField, bool descending, int start, int limit, Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionAccountId = default, Option<string> q = default, Option<string> keyword = default, Option<int> i = default, Option<int> l = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetConnectionsAsync(returnNulls, filter, sortField, descending, start, limit, deviceId, accountId, connectionAccountId, q, keyword, i, l, latitude, longitude, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Connections Gets the connections.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="filter">a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)</param>
        /// <param name="sortField">sorts the response list by ConnectionApiMap</param>
        /// <param name="descending">sorts the response list by descending order if true</param>
        /// <param name="start">start index of the pagination</param>
        /// <param name="limit">limit of the pagination</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id (deviceId or accountId required) (optional)</param>
        /// <param name="connectionAccountId">optional parameter to search on other account&#39;s connections (optional)</param>
        /// <param name="q">This parameter is deprecated. (optional)</param>
        /// <param name="keyword">an optional keyword to search on, this parameter is ignored if empty (optional)</param>
        /// <param name="i">This parameter is deprecated. (optional)</param>
        /// <param name="l">This parameter is deprecated. (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetConnectionsApiResponse"/>&gt;</returns>
        public async Task<IGetConnectionsApiResponse> GetConnectionsAsync(bool returnNulls, string filter, string sortField, bool descending, int start, int limit, Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionAccountId = default, Option<string> q = default, Option<string> keyword = default, Option<int> i = default, Option<int> l = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetConnections(filter, sortField, deviceId, q, keyword);

                FormatGetConnections(ref returnNulls, ref filter, ref sortField, ref descending, ref start, ref limit, ref deviceId, ref accountId, ref connectionAccountId, ref q, ref keyword, ref i, ref l, ref latitude, ref longitude);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/connection/get"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/connection/get");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["returnNulls"] = ClientUtils.ParameterToString(returnNulls);
                    parseQueryStringLocalVar["filter"] = ClientUtils.ParameterToString(filter);
                    parseQueryStringLocalVar["sortField"] = ClientUtils.ParameterToString(sortField);
                    parseQueryStringLocalVar["descending"] = ClientUtils.ParameterToString(descending);
                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (connectionAccountId.IsSet)
                        parseQueryStringLocalVar["connectionAccountId"] = ClientUtils.ParameterToString(connectionAccountId.Value);

                    if (q.IsSet)
                        parseQueryStringLocalVar["q"] = ClientUtils.ParameterToString(q.Value);

                    if (keyword.IsSet)
                        parseQueryStringLocalVar["keyword"] = ClientUtils.ParameterToString(keyword.Value);

                    if (i.IsSet)
                        parseQueryStringLocalVar["_i"] = ClientUtils.ParameterToString(i.Value);

                    if (l.IsSet)
                        parseQueryStringLocalVar["_l"] = ClientUtils.ParameterToString(l.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetConnectionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetConnectionsApiResponse>();
                        GetConnectionsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/connection/get", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetConnectionsDefaultImplementation(apiResponseLocalVar, returnNulls, filter, sortField, descending, start, limit, deviceId, accountId, connectionAccountId, q, keyword, i, l, latitude, longitude);

                        Events.ExecuteOnGetConnections(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetConnectionsDefaultImplementation(e, "/consumer/connection/get", uriBuilderLocalVar.Path, returnNulls, filter, sortField, descending, start, limit, deviceId, accountId, connectionAccountId, q, keyword, i, l, latitude, longitude);
                Events.ExecuteOnErrorGetConnections(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetConnectionsApiResponse"/>
        /// </summary>
        public partial class GetConnectionsApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetConnectionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetConnectionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetConnectionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetConnectionsApiResponse(ILogger<GetConnectionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetConnectionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetConnectionsApiResponse(ILogger<GetConnectionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ConnectionListResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ConnectionListResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ConnectionListResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetGroupDetails(ref bool combineConnections, ref Option<string> deviceId, ref Option<long> accountId, ref Option<long> groupId, ref Option<double> latitude, ref Option<double> longitude);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <returns></returns>
        private void ValidateGetGroupDetails(Option<string> deviceId)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="combineConnections"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="groupId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void AfterGetGroupDetailsDefaultImplementation(IGetGroupDetailsApiResponse apiResponseLocalVar, bool combineConnections, Option<string> deviceId, Option<long> accountId, Option<long> groupId, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLog = false;
            AfterGetGroupDetails(ref suppressDefaultLog, apiResponseLocalVar, combineConnections, deviceId, accountId, groupId, latitude, longitude);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="combineConnections"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="groupId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void AfterGetGroupDetails(ref bool suppressDefaultLog, IGetGroupDetailsApiResponse apiResponseLocalVar, bool combineConnections, Option<string> deviceId, Option<long> accountId, Option<long> groupId, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="combineConnections"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="groupId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void OnErrorGetGroupDetailsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, bool combineConnections, Option<string> deviceId, Option<long> accountId, Option<long> groupId, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetGroupDetails(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, combineConnections, deviceId, accountId, groupId, latitude, longitude);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="combineConnections"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="groupId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void OnErrorGetGroupDetails(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, bool combineConnections, Option<string> deviceId, Option<long> accountId, Option<long> groupId, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Get Connection Group 
        /// </summary>
        /// <param name="combineConnections">whether to combine connections or not</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="groupId">the group id (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGroupDetailsApiResponse"/>&gt;</returns>
        public async Task<IGetGroupDetailsApiResponse?> GetGroupDetailsOrDefaultAsync(bool combineConnections, Option<string> deviceId = default, Option<long> accountId = default, Option<long> groupId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetGroupDetailsAsync(combineConnections, deviceId, accountId, groupId, latitude, longitude, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Connection Group 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="combineConnections">whether to combine connections or not</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="groupId">the group id (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGroupDetailsApiResponse"/>&gt;</returns>
        public async Task<IGetGroupDetailsApiResponse> GetGroupDetailsAsync(bool combineConnections, Option<string> deviceId = default, Option<long> accountId = default, Option<long> groupId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetGroupDetails(deviceId);

                FormatGetGroupDetails(ref combineConnections, ref deviceId, ref accountId, ref groupId, ref latitude, ref longitude);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/connection/group/details/get"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/connection/group/details/get");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["combineConnections"] = ClientUtils.ParameterToString(combineConnections);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (groupId.IsSet)
                        parseQueryStringLocalVar["groupId"] = ClientUtils.ParameterToString(groupId.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetGroupDetailsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetGroupDetailsApiResponse>();
                        GetGroupDetailsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/connection/group/details/get", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetGroupDetailsDefaultImplementation(apiResponseLocalVar, combineConnections, deviceId, accountId, groupId, latitude, longitude);

                        Events.ExecuteOnGetGroupDetails(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetGroupDetailsDefaultImplementation(e, "/consumer/connection/group/details/get", uriBuilderLocalVar.Path, combineConnections, deviceId, accountId, groupId, latitude, longitude);
                Events.ExecuteOnErrorGetGroupDetails(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetGroupDetailsApiResponse"/>
        /// </summary>
        public partial class GetGroupDetailsApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetGroupDetailsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetGroupDetailsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetGroupDetailsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetGroupDetailsApiResponse(ILogger<GetGroupDetailsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetGroupDetailsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetGroupDetailsApiResponse(ILogger<GetGroupDetailsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ConnectionGroupResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ConnectionGroupResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ConnectionGroupResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGroupSearch(ref string sortField, ref bool descending, ref bool activeOnly, ref int start, ref int limit, ref Option<string> deviceId, ref Option<long> accountId, ref Option<double> latitude, ref Option<double> longitude, ref Option<string> keyword);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sortField"></param>
        /// <param name="deviceId"></param>
        /// <param name="keyword"></param>
        /// <returns></returns>
        private void ValidateGroupSearch(string sortField, Option<string> deviceId, Option<string> keyword)
        {
            if (sortField == null)
                throw new ArgumentNullException(nameof(sortField));

            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (keyword.IsSet && keyword.Value == null)
                throw new ArgumentNullException(nameof(keyword));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="activeOnly"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="keyword"></param>
        private void AfterGroupSearchDefaultImplementation(IGroupSearchApiResponse apiResponseLocalVar, string sortField, bool descending, bool activeOnly, int start, int limit, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude, Option<string> keyword)
        {
            bool suppressDefaultLog = false;
            AfterGroupSearch(ref suppressDefaultLog, apiResponseLocalVar, sortField, descending, activeOnly, start, limit, deviceId, accountId, latitude, longitude, keyword);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="activeOnly"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="keyword"></param>
        partial void AfterGroupSearch(ref bool suppressDefaultLog, IGroupSearchApiResponse apiResponseLocalVar, string sortField, bool descending, bool activeOnly, int start, int limit, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude, Option<string> keyword);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="activeOnly"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="keyword"></param>
        private void OnErrorGroupSearchDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string sortField, bool descending, bool activeOnly, int start, int limit, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude, Option<string> keyword)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGroupSearch(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, sortField, descending, activeOnly, start, limit, deviceId, accountId, latitude, longitude, keyword);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="activeOnly"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="keyword"></param>
        partial void OnErrorGroupSearch(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string sortField, bool descending, bool activeOnly, int start, int limit, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude, Option<string> keyword);

        /// <summary>
        /// Search Connection Groups Gets a user&#39;s private groups and default groups.
        /// </summary>
        /// <param name="sortField">the field to sort by</param>
        /// <param name="descending">whether to return results in descending or ascending order</param>
        /// <param name="activeOnly">to search on active only or not</param>
        /// <param name="start">The start of the pagination</param>
        /// <param name="limit">the limit of the pagination</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="keyword">keyword search string (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGroupSearchApiResponse"/>&gt;</returns>
        public async Task<IGroupSearchApiResponse?> GroupSearchOrDefaultAsync(string sortField, bool descending, bool activeOnly, int start, int limit, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> keyword = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GroupSearchAsync(sortField, descending, activeOnly, start, limit, deviceId, accountId, latitude, longitude, keyword, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Connection Groups Gets a user&#39;s private groups and default groups.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortField">the field to sort by</param>
        /// <param name="descending">whether to return results in descending or ascending order</param>
        /// <param name="activeOnly">to search on active only or not</param>
        /// <param name="start">The start of the pagination</param>
        /// <param name="limit">the limit of the pagination</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="keyword">keyword search string (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGroupSearchApiResponse"/>&gt;</returns>
        public async Task<IGroupSearchApiResponse> GroupSearchAsync(string sortField, bool descending, bool activeOnly, int start, int limit, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> keyword = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGroupSearch(sortField, deviceId, keyword);

                FormatGroupSearch(ref sortField, ref descending, ref activeOnly, ref start, ref limit, ref deviceId, ref accountId, ref latitude, ref longitude, ref keyword);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/connection/group/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/connection/group/search");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["sortField"] = ClientUtils.ParameterToString(sortField);
                    parseQueryStringLocalVar["descending"] = ClientUtils.ParameterToString(descending);
                    parseQueryStringLocalVar["activeOnly"] = ClientUtils.ParameterToString(activeOnly);
                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    if (keyword.IsSet)
                        parseQueryStringLocalVar["keyword"] = ClientUtils.ParameterToString(keyword.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GroupSearchApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GroupSearchApiResponse>();
                        GroupSearchApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/connection/group/search", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGroupSearchDefaultImplementation(apiResponseLocalVar, sortField, descending, activeOnly, start, limit, deviceId, accountId, latitude, longitude, keyword);

                        Events.ExecuteOnGroupSearch(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGroupSearchDefaultImplementation(e, "/connection/group/search", uriBuilderLocalVar.Path, sortField, descending, activeOnly, start, limit, deviceId, accountId, latitude, longitude, keyword);
                Events.ExecuteOnErrorGroupSearch(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GroupSearchApiResponse"/>
        /// </summary>
        public partial class GroupSearchApiResponse : Org.OpenAPITools.Client.ApiResponse, IGroupSearchApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GroupSearchApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GroupSearchApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GroupSearchApiResponse(ILogger<GroupSearchApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GroupSearchApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GroupSearchApiResponse(ILogger<GroupSearchApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<ConnectionInfoResponse>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<ConnectionInfoResponse>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<ConnectionInfoResponse>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRemoveConnectionFromGroup(ref bool returnNulls, ref long groupId, ref Option<string> deviceId, ref Option<long> accountId, ref Option<long> connectionId, ref Option<long> connectionAccountId, ref Option<long> pendingId, ref Option<double> latitude, ref Option<double> longitude);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <returns></returns>
        private void ValidateRemoveConnectionFromGroup(Option<string> deviceId)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="pendingId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void AfterRemoveConnectionFromGroupDefaultImplementation(IRemoveConnectionFromGroupApiResponse apiResponseLocalVar, bool returnNulls, long groupId, Option<string> deviceId, Option<long> accountId, Option<long> connectionId, Option<long> connectionAccountId, Option<long> pendingId, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLog = false;
            AfterRemoveConnectionFromGroup(ref suppressDefaultLog, apiResponseLocalVar, returnNulls, groupId, deviceId, accountId, connectionId, connectionAccountId, pendingId, latitude, longitude);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="pendingId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void AfterRemoveConnectionFromGroup(ref bool suppressDefaultLog, IRemoveConnectionFromGroupApiResponse apiResponseLocalVar, bool returnNulls, long groupId, Option<string> deviceId, Option<long> accountId, Option<long> connectionId, Option<long> connectionAccountId, Option<long> pendingId, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="pendingId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void OnErrorRemoveConnectionFromGroupDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, bool returnNulls, long groupId, Option<string> deviceId, Option<long> accountId, Option<long> connectionId, Option<long> connectionAccountId, Option<long> pendingId, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorRemoveConnectionFromGroup(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, returnNulls, groupId, deviceId, accountId, connectionId, connectionAccountId, pendingId, latitude, longitude);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="pendingId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void OnErrorRemoveConnectionFromGroup(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, bool returnNulls, long groupId, Option<string> deviceId, Option<long> accountId, Option<long> connectionId, Option<long> connectionAccountId, Option<long> pendingId, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Delete Connection Removes the connection from group.
        /// </summary>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the group id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionId">the connection id (optional)</param>
        /// <param name="connectionAccountId">the connection account id (optional)</param>
        /// <param name="pendingId">the pending id (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveConnectionFromGroupApiResponse"/>&gt;</returns>
        public async Task<IRemoveConnectionFromGroupApiResponse?> RemoveConnectionFromGroupOrDefaultAsync(bool returnNulls, long groupId, Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionId = default, Option<long> connectionAccountId = default, Option<long> pendingId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RemoveConnectionFromGroupAsync(returnNulls, groupId, deviceId, accountId, connectionId, connectionAccountId, pendingId, latitude, longitude, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete Connection Removes the connection from group.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the group id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionId">the connection id (optional)</param>
        /// <param name="connectionAccountId">the connection account id (optional)</param>
        /// <param name="pendingId">the pending id (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveConnectionFromGroupApiResponse"/>&gt;</returns>
        public async Task<IRemoveConnectionFromGroupApiResponse> RemoveConnectionFromGroupAsync(bool returnNulls, long groupId, Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionId = default, Option<long> connectionAccountId = default, Option<long> pendingId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateRemoveConnectionFromGroup(deviceId);

                FormatRemoveConnectionFromGroup(ref returnNulls, ref groupId, ref deviceId, ref accountId, ref connectionId, ref connectionAccountId, ref pendingId, ref latitude, ref longitude);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/connection/group/removeConnection"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/connection/group/removeConnection");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["returnNulls"] = ClientUtils.ParameterToString(returnNulls);
                    parseQueryStringLocalVar["groupId"] = ClientUtils.ParameterToString(groupId);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (connectionId.IsSet)
                        parseQueryStringLocalVar["connectionId"] = ClientUtils.ParameterToString(connectionId.Value);

                    if (connectionAccountId.IsSet)
                        parseQueryStringLocalVar["connectionAccountId"] = ClientUtils.ParameterToString(connectionAccountId.Value);

                    if (pendingId.IsSet)
                        parseQueryStringLocalVar["pendingId"] = ClientUtils.ParameterToString(pendingId.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<RemoveConnectionFromGroupApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RemoveConnectionFromGroupApiResponse>();
                        RemoveConnectionFromGroupApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/connection/group/removeConnection", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterRemoveConnectionFromGroupDefaultImplementation(apiResponseLocalVar, returnNulls, groupId, deviceId, accountId, connectionId, connectionAccountId, pendingId, latitude, longitude);

                        Events.ExecuteOnRemoveConnectionFromGroup(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRemoveConnectionFromGroupDefaultImplementation(e, "/consumer/connection/group/removeConnection", uriBuilderLocalVar.Path, returnNulls, groupId, deviceId, accountId, connectionId, connectionAccountId, pendingId, latitude, longitude);
                Events.ExecuteOnErrorRemoveConnectionFromGroup(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RemoveConnectionFromGroupApiResponse"/>
        /// </summary>
        public partial class RemoveConnectionFromGroupApiResponse : Org.OpenAPITools.Client.ApiResponse, IRemoveConnectionFromGroupApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RemoveConnectionFromGroupApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RemoveConnectionFromGroupApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveConnectionFromGroupApiResponse(ILogger<RemoveConnectionFromGroupApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="RemoveConnectionFromGroupApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveConnectionFromGroupApiResponse(ILogger<RemoveConnectionFromGroupApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRemoveConnectionsFromGroup(ref long connectionGroupId, ref Option<string> deviceId, ref Option<long> accountId, ref Option<string> connectionIds, ref Option<string> connectionAccountIds, ref Option<double> latitude, ref Option<double> longitude);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <returns></returns>
        private void ValidateRemoveConnectionsFromGroup(Option<string> deviceId, Option<string> connectionIds, Option<string> connectionAccountIds)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (connectionIds.IsSet && connectionIds.Value == null)
                throw new ArgumentNullException(nameof(connectionIds));

            if (connectionAccountIds.IsSet && connectionAccountIds.Value == null)
                throw new ArgumentNullException(nameof(connectionAccountIds));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="connectionGroupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void AfterRemoveConnectionsFromGroupDefaultImplementation(IRemoveConnectionsFromGroupApiResponse apiResponseLocalVar, long connectionGroupId, Option<string> deviceId, Option<long> accountId, Option<string> connectionIds, Option<string> connectionAccountIds, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLog = false;
            AfterRemoveConnectionsFromGroup(ref suppressDefaultLog, apiResponseLocalVar, connectionGroupId, deviceId, accountId, connectionIds, connectionAccountIds, latitude, longitude);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="connectionGroupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void AfterRemoveConnectionsFromGroup(ref bool suppressDefaultLog, IRemoveConnectionsFromGroupApiResponse apiResponseLocalVar, long connectionGroupId, Option<string> deviceId, Option<long> accountId, Option<string> connectionIds, Option<string> connectionAccountIds, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="connectionGroupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void OnErrorRemoveConnectionsFromGroupDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long connectionGroupId, Option<string> deviceId, Option<long> accountId, Option<string> connectionIds, Option<string> connectionAccountIds, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorRemoveConnectionsFromGroup(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, connectionGroupId, deviceId, accountId, connectionIds, connectionAccountIds, latitude, longitude);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="connectionGroupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void OnErrorRemoveConnectionsFromGroup(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long connectionGroupId, Option<string> deviceId, Option<long> accountId, Option<string> connectionIds, Option<string> connectionAccountIds, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Remove Connections Remove a list of connections from a group.
        /// </summary>
        /// <param name="connectionGroupId">connection group id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionIds">comma separated list of connection ids (optional)</param>
        /// <param name="connectionAccountIds">comma separated list of connection account ids (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveConnectionsFromGroupApiResponse"/>&gt;</returns>
        public async Task<IRemoveConnectionsFromGroupApiResponse?> RemoveConnectionsFromGroupOrDefaultAsync(long connectionGroupId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> connectionIds = default, Option<string> connectionAccountIds = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RemoveConnectionsFromGroupAsync(connectionGroupId, deviceId, accountId, connectionIds, connectionAccountIds, latitude, longitude, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Remove Connections Remove a list of connections from a group.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectionGroupId">connection group id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionIds">comma separated list of connection ids (optional)</param>
        /// <param name="connectionAccountIds">comma separated list of connection account ids (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveConnectionsFromGroupApiResponse"/>&gt;</returns>
        public async Task<IRemoveConnectionsFromGroupApiResponse> RemoveConnectionsFromGroupAsync(long connectionGroupId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> connectionIds = default, Option<string> connectionAccountIds = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateRemoveConnectionsFromGroup(deviceId, connectionIds, connectionAccountIds);

                FormatRemoveConnectionsFromGroup(ref connectionGroupId, ref deviceId, ref accountId, ref connectionIds, ref connectionAccountIds, ref latitude, ref longitude);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/connection/group/removeConnections"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/connection/group/removeConnections");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["connectionGroupId"] = ClientUtils.ParameterToString(connectionGroupId);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (connectionIds.IsSet)
                        parseQueryStringLocalVar["connectionIds"] = ClientUtils.ParameterToString(connectionIds.Value);

                    if (connectionAccountIds.IsSet)
                        parseQueryStringLocalVar["connectionAccountIds"] = ClientUtils.ParameterToString(connectionAccountIds.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<RemoveConnectionsFromGroupApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RemoveConnectionsFromGroupApiResponse>();
                        RemoveConnectionsFromGroupApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/connection/group/removeConnections", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterRemoveConnectionsFromGroupDefaultImplementation(apiResponseLocalVar, connectionGroupId, deviceId, accountId, connectionIds, connectionAccountIds, latitude, longitude);

                        Events.ExecuteOnRemoveConnectionsFromGroup(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRemoveConnectionsFromGroupDefaultImplementation(e, "/connection/group/removeConnections", uriBuilderLocalVar.Path, connectionGroupId, deviceId, accountId, connectionIds, connectionAccountIds, latitude, longitude);
                Events.ExecuteOnErrorRemoveConnectionsFromGroup(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RemoveConnectionsFromGroupApiResponse"/>
        /// </summary>
        public partial class RemoveConnectionsFromGroupApiResponse : Org.OpenAPITools.Client.ApiResponse, IRemoveConnectionsFromGroupApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RemoveConnectionsFromGroupApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RemoveConnectionsFromGroupApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveConnectionsFromGroupApiResponse(ILogger<RemoveConnectionsFromGroupApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="RemoveConnectionsFromGroupApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveConnectionsFromGroupApiResponse(ILogger<RemoveConnectionsFromGroupApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRemoveGroup(ref bool returnNulls, ref long groupId, ref Option<string> deviceId, ref Option<long> accountId, ref Option<double> latitude, ref Option<double> longitude);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <returns></returns>
        private void ValidateRemoveGroup(Option<string> deviceId)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void AfterRemoveGroupDefaultImplementation(IRemoveGroupApiResponse apiResponseLocalVar, bool returnNulls, long groupId, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLog = false;
            AfterRemoveGroup(ref suppressDefaultLog, apiResponseLocalVar, returnNulls, groupId, deviceId, accountId, latitude, longitude);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void AfterRemoveGroup(ref bool suppressDefaultLog, IRemoveGroupApiResponse apiResponseLocalVar, bool returnNulls, long groupId, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void OnErrorRemoveGroupDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, bool returnNulls, long groupId, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorRemoveGroup(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, returnNulls, groupId, deviceId, accountId, latitude, longitude);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void OnErrorRemoveGroup(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, bool returnNulls, long groupId, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Delete Connection Group Remove a user&#39;s group.
        /// </summary>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the group id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveGroupApiResponse"/>&gt;</returns>
        public async Task<IRemoveGroupApiResponse?> RemoveGroupOrDefaultAsync(bool returnNulls, long groupId, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RemoveGroupAsync(returnNulls, groupId, deviceId, accountId, latitude, longitude, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete Connection Group Remove a user&#39;s group.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the group id</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveGroupApiResponse"/>&gt;</returns>
        public async Task<IRemoveGroupApiResponse> RemoveGroupAsync(bool returnNulls, long groupId, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateRemoveGroup(deviceId);

                FormatRemoveGroup(ref returnNulls, ref groupId, ref deviceId, ref accountId, ref latitude, ref longitude);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/connection/group/remove"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/connection/group/remove");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["returnNulls"] = ClientUtils.ParameterToString(returnNulls);
                    parseQueryStringLocalVar["groupId"] = ClientUtils.ParameterToString(groupId);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<RemoveGroupApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RemoveGroupApiResponse>();
                        RemoveGroupApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/connection/group/remove", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterRemoveGroupDefaultImplementation(apiResponseLocalVar, returnNulls, groupId, deviceId, accountId, latitude, longitude);

                        Events.ExecuteOnRemoveGroup(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRemoveGroupDefaultImplementation(e, "/consumer/connection/group/remove", uriBuilderLocalVar.Path, returnNulls, groupId, deviceId, accountId, latitude, longitude);
                Events.ExecuteOnErrorRemoveGroup(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RemoveGroupApiResponse"/>
        /// </summary>
        public partial class RemoveGroupApiResponse : Org.OpenAPITools.Client.ApiResponse, IRemoveGroupApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RemoveGroupApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RemoveGroupApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveGroupApiResponse(ILogger<RemoveGroupApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="RemoveGroupApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveGroupApiResponse(ILogger<RemoveGroupApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRemoveSubGroups(ref bool returnNulls, ref long groupId, ref string subGroupIds, ref Option<string> deviceId, ref Option<long> accountId, ref Option<double> latitude, ref Option<double> longitude);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="subGroupIds"></param>
        /// <param name="deviceId"></param>
        /// <returns></returns>
        private void ValidateRemoveSubGroups(string subGroupIds, Option<string> deviceId)
        {
            if (subGroupIds == null)
                throw new ArgumentNullException(nameof(subGroupIds));

            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="subGroupIds"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void AfterRemoveSubGroupsDefaultImplementation(IRemoveSubGroupsApiResponse apiResponseLocalVar, bool returnNulls, long groupId, string subGroupIds, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLog = false;
            AfterRemoveSubGroups(ref suppressDefaultLog, apiResponseLocalVar, returnNulls, groupId, subGroupIds, deviceId, accountId, latitude, longitude);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="subGroupIds"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void AfterRemoveSubGroups(ref bool suppressDefaultLog, IRemoveSubGroupsApiResponse apiResponseLocalVar, bool returnNulls, long groupId, string subGroupIds, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="subGroupIds"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void OnErrorRemoveSubGroupsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, bool returnNulls, long groupId, string subGroupIds, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorRemoveSubGroups(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, returnNulls, groupId, subGroupIds, deviceId, accountId, latitude, longitude);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="groupId"></param>
        /// <param name="subGroupIds"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void OnErrorRemoveSubGroups(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, bool returnNulls, long groupId, string subGroupIds, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Remove Connection Groups Remove sub groups from a group
        /// </summary>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the parent group id</param>
        /// <param name="subGroupIds">comma separated list of group IDs to remove from the parent group</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveSubGroupsApiResponse"/>&gt;</returns>
        public async Task<IRemoveSubGroupsApiResponse?> RemoveSubGroupsOrDefaultAsync(bool returnNulls, long groupId, string subGroupIds, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RemoveSubGroupsAsync(returnNulls, groupId, subGroupIds, deviceId, accountId, latitude, longitude, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Remove Connection Groups Remove sub groups from a group
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnNulls">whether to return nulls or not</param>
        /// <param name="groupId">the parent group id</param>
        /// <param name="subGroupIds">comma separated list of group IDs to remove from the parent group</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveSubGroupsApiResponse"/>&gt;</returns>
        public async Task<IRemoveSubGroupsApiResponse> RemoveSubGroupsAsync(bool returnNulls, long groupId, string subGroupIds, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateRemoveSubGroups(subGroupIds, deviceId);

                FormatRemoveSubGroups(ref returnNulls, ref groupId, ref subGroupIds, ref deviceId, ref accountId, ref latitude, ref longitude);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/connection/group/removeSubGroup"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/connection/group/removeSubGroup");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["returnNulls"] = ClientUtils.ParameterToString(returnNulls);
                    parseQueryStringLocalVar["groupId"] = ClientUtils.ParameterToString(groupId);
                    parseQueryStringLocalVar["subGroupIds"] = ClientUtils.ParameterToString(subGroupIds);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<RemoveSubGroupsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RemoveSubGroupsApiResponse>();
                        RemoveSubGroupsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/connection/group/removeSubGroup", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterRemoveSubGroupsDefaultImplementation(apiResponseLocalVar, returnNulls, groupId, subGroupIds, deviceId, accountId, latitude, longitude);

                        Events.ExecuteOnRemoveSubGroups(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRemoveSubGroupsDefaultImplementation(e, "/consumer/connection/group/removeSubGroup", uriBuilderLocalVar.Path, returnNulls, groupId, subGroupIds, deviceId, accountId, latitude, longitude);
                Events.ExecuteOnErrorRemoveSubGroups(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RemoveSubGroupsApiResponse"/>
        /// </summary>
        public partial class RemoveSubGroupsApiResponse : Org.OpenAPITools.Client.ApiResponse, IRemoveSubGroupsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RemoveSubGroupsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RemoveSubGroupsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveSubGroupsApiResponse(ILogger<RemoveSubGroupsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="RemoveSubGroupsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveSubGroupsApiResponse(ILogger<RemoveSubGroupsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchConnections(ref bool returnNulls, ref int start, ref int limit, ref Option<string> deviceId, ref Option<long> accountId, ref Option<string> q, ref Option<string> keyword, ref Option<double> latitude, ref Option<double> longitude, ref Option<string> gameType, ref Option<string> appKey, ref Option<int> i, ref Option<int> l, ref Option<string> sortField, ref Option<bool> hasLocation);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <param name="q"></param>
        /// <param name="keyword"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="sortField"></param>
        /// <returns></returns>
        private void ValidateSearchConnections(Option<string> deviceId, Option<string> q, Option<string> keyword, Option<string> gameType, Option<string> appKey, Option<string> sortField)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (q.IsSet && q.Value == null)
                throw new ArgumentNullException(nameof(q));

            if (keyword.IsSet && keyword.Value == null)
                throw new ArgumentNullException(nameof(keyword));

            if (gameType.IsSet && gameType.Value == null)
                throw new ArgumentNullException(nameof(gameType));

            if (appKey.IsSet && appKey.Value == null)
                throw new ArgumentNullException(nameof(appKey));

            if (sortField.IsSet && sortField.Value == null)
                throw new ArgumentNullException(nameof(sortField));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="q"></param>
        /// <param name="keyword"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="i"></param>
        /// <param name="l"></param>
        /// <param name="sortField"></param>
        /// <param name="hasLocation"></param>
        private void AfterSearchConnectionsDefaultImplementation(ISearchConnectionsApiResponse apiResponseLocalVar, bool returnNulls, int start, int limit, Option<string> deviceId, Option<long> accountId, Option<string> q, Option<string> keyword, Option<double> latitude, Option<double> longitude, Option<string> gameType, Option<string> appKey, Option<int> i, Option<int> l, Option<string> sortField, Option<bool> hasLocation)
        {
            bool suppressDefaultLog = false;
            AfterSearchConnections(ref suppressDefaultLog, apiResponseLocalVar, returnNulls, start, limit, deviceId, accountId, q, keyword, latitude, longitude, gameType, appKey, i, l, sortField, hasLocation);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="q"></param>
        /// <param name="keyword"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="i"></param>
        /// <param name="l"></param>
        /// <param name="sortField"></param>
        /// <param name="hasLocation"></param>
        partial void AfterSearchConnections(ref bool suppressDefaultLog, ISearchConnectionsApiResponse apiResponseLocalVar, bool returnNulls, int start, int limit, Option<string> deviceId, Option<long> accountId, Option<string> q, Option<string> keyword, Option<double> latitude, Option<double> longitude, Option<string> gameType, Option<string> appKey, Option<int> i, Option<int> l, Option<string> sortField, Option<bool> hasLocation);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="q"></param>
        /// <param name="keyword"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="i"></param>
        /// <param name="l"></param>
        /// <param name="sortField"></param>
        /// <param name="hasLocation"></param>
        private void OnErrorSearchConnectionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, bool returnNulls, int start, int limit, Option<string> deviceId, Option<long> accountId, Option<string> q, Option<string> keyword, Option<double> latitude, Option<double> longitude, Option<string> gameType, Option<string> appKey, Option<int> i, Option<int> l, Option<string> sortField, Option<bool> hasLocation)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchConnections(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, returnNulls, start, limit, deviceId, accountId, q, keyword, latitude, longitude, gameType, appKey, i, l, sortField, hasLocation);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnNulls"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="q"></param>
        /// <param name="keyword"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="i"></param>
        /// <param name="l"></param>
        /// <param name="sortField"></param>
        /// <param name="hasLocation"></param>
        partial void OnErrorSearchConnections(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, bool returnNulls, int start, int limit, Option<string> deviceId, Option<long> accountId, Option<string> q, Option<string> keyword, Option<double> latitude, Option<double> longitude, Option<string> gameType, Option<string> appKey, Option<int> i, Option<int> l, Option<string> sortField, Option<bool> hasLocation);

        /// <summary>
        /// Search Possible Connections Search for accounts that the user may not have a connection with.
        /// </summary>
        /// <param name="returnNulls">return all json attributes if true. defualt is true.</param>
        /// <param name="start">start index of the pagination</param>
        /// <param name="limit">limit of the pagination</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id (deviceId or accountId required) (optional)</param>
        /// <param name="q">This parameter is deprecated. (optional)</param>
        /// <param name="keyword">keyword to search on, optional and this parameter is ignored if empt (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the public application key, if provided only looks for users of that application (optional)</param>
        /// <param name="i">This parameter is deprecated. (optional)</param>
        /// <param name="l">This parameter is deprecated. (optional)</param>
        /// <param name="sortField">the field to sort on (optional)</param>
        /// <param name="hasLocation">whether the search has location or not (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchConnectionsApiResponse"/>&gt;</returns>
        public async Task<ISearchConnectionsApiResponse?> SearchConnectionsOrDefaultAsync(bool returnNulls, int start, int limit, Option<string> deviceId = default, Option<long> accountId = default, Option<string> q = default, Option<string> keyword = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> gameType = default, Option<string> appKey = default, Option<int> i = default, Option<int> l = default, Option<string> sortField = default, Option<bool> hasLocation = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchConnectionsAsync(returnNulls, start, limit, deviceId, accountId, q, keyword, latitude, longitude, gameType, appKey, i, l, sortField, hasLocation, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Possible Connections Search for accounts that the user may not have a connection with.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnNulls">return all json attributes if true. defualt is true.</param>
        /// <param name="start">start index of the pagination</param>
        /// <param name="limit">limit of the pagination</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id (deviceId or accountId required) (optional)</param>
        /// <param name="q">This parameter is deprecated. (optional)</param>
        /// <param name="keyword">keyword to search on, optional and this parameter is ignored if empt (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">the public application key, if provided only looks for users of that application (optional)</param>
        /// <param name="i">This parameter is deprecated. (optional)</param>
        /// <param name="l">This parameter is deprecated. (optional)</param>
        /// <param name="sortField">the field to sort on (optional)</param>
        /// <param name="hasLocation">whether the search has location or not (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchConnectionsApiResponse"/>&gt;</returns>
        public async Task<ISearchConnectionsApiResponse> SearchConnectionsAsync(bool returnNulls, int start, int limit, Option<string> deviceId = default, Option<long> accountId = default, Option<string> q = default, Option<string> keyword = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> gameType = default, Option<string> appKey = default, Option<int> i = default, Option<int> l = default, Option<string> sortField = default, Option<bool> hasLocation = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchConnections(deviceId, q, keyword, gameType, appKey, sortField);

                FormatSearchConnections(ref returnNulls, ref start, ref limit, ref deviceId, ref accountId, ref q, ref keyword, ref latitude, ref longitude, ref gameType, ref appKey, ref i, ref l, ref sortField, ref hasLocation);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/connection/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/connection/search");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["returnNulls"] = ClientUtils.ParameterToString(returnNulls);
                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (q.IsSet)
                        parseQueryStringLocalVar["q"] = ClientUtils.ParameterToString(q.Value);

                    if (keyword.IsSet)
                        parseQueryStringLocalVar["keyword"] = ClientUtils.ParameterToString(keyword.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    if (gameType.IsSet)
                        parseQueryStringLocalVar["gameType"] = ClientUtils.ParameterToString(gameType.Value);

                    if (appKey.IsSet)
                        parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey.Value);

                    if (i.IsSet)
                        parseQueryStringLocalVar["_i"] = ClientUtils.ParameterToString(i.Value);

                    if (l.IsSet)
                        parseQueryStringLocalVar["_l"] = ClientUtils.ParameterToString(l.Value);

                    if (sortField.IsSet)
                        parseQueryStringLocalVar["sortField"] = ClientUtils.ParameterToString(sortField.Value);

                    if (hasLocation.IsSet)
                        parseQueryStringLocalVar["hasLocation"] = ClientUtils.ParameterToString(hasLocation.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchConnectionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchConnectionsApiResponse>();
                        SearchConnectionsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/connection/search", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchConnectionsDefaultImplementation(apiResponseLocalVar, returnNulls, start, limit, deviceId, accountId, q, keyword, latitude, longitude, gameType, appKey, i, l, sortField, hasLocation);

                        Events.ExecuteOnSearchConnections(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchConnectionsDefaultImplementation(e, "/connection/search", uriBuilderLocalVar.Path, returnNulls, start, limit, deviceId, accountId, q, keyword, latitude, longitude, gameType, appKey, i, l, sortField, hasLocation);
                Events.ExecuteOnErrorSearchConnections(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchConnectionsApiResponse"/>
        /// </summary>
        public partial class SearchConnectionsApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchConnectionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchConnectionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchConnectionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchConnectionsApiResponse(ILogger<SearchConnectionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchConnectionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchConnectionsApiResponse(ILogger<SearchConnectionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ConnectionListResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ConnectionListResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ConnectionListResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
