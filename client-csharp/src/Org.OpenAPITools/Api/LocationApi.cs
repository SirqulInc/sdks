// <auto-generated>
/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Net;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface ILocationApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        LocationApiEvents Events { get; }

        /// <summary>
        /// Create Trilateration Data with File
        /// </summary>
        /// <remarks>
        /// Creates trilateration samples for a source device (i.e. a router).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="udid">The unique identifier of the source device</param>
        /// <param name="sourceTime">The current timestamp of the source device (optional)</param>
        /// <param name="minimumSampleSize">the minimum number of Edysen devices that must be used to be able to trilaterate a device (optional)</param>
        /// <param name="data">The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;:\&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;: \&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60;  (optional)</param>
        /// <param name="dataFile">Binary file containing data (multipart upload) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICacheTrilaterationDataApiResponse"/>&gt;</returns>
        Task<ICacheTrilaterationDataApiResponse> CacheTrilaterationDataAsync(string udid, Option<long> sourceTime = default, Option<int> minimumSampleSize = default, Option<string> data = default, Option<System.IO.Stream> dataFile = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Trilateration Data with File
        /// </summary>
        /// <remarks>
        /// Creates trilateration samples for a source device (i.e. a router).
        /// </remarks>
        /// <param name="udid">The unique identifier of the source device</param>
        /// <param name="sourceTime">The current timestamp of the source device (optional)</param>
        /// <param name="minimumSampleSize">the minimum number of Edysen devices that must be used to be able to trilaterate a device (optional)</param>
        /// <param name="data">The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;:\&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;: \&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60;  (optional)</param>
        /// <param name="dataFile">Binary file containing data (multipart upload) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICacheTrilaterationDataApiResponse"/>?&gt;</returns>
        Task<ICacheTrilaterationDataApiResponse?> CacheTrilaterationDataOrDefaultAsync(string udid, Option<long> sourceTime = default, Option<int> minimumSampleSize = default, Option<string> data = default, Option<System.IO.Stream> dataFile = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Trilateration Data with Rest
        /// </summary>
        /// <remarks>
        /// Creates trilateration samples for a source device (i.e. a router).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICacheTrilaterationDataGzipApiResponse"/>&gt;</returns>
        Task<ICacheTrilaterationDataGzipApiResponse> CacheTrilaterationDataGzipAsync(Option<TrilatCacheRequest> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Trilateration Data with Rest
        /// </summary>
        /// <remarks>
        /// Creates trilateration samples for a source device (i.e. a router).
        /// </remarks>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICacheTrilaterationDataGzipApiResponse"/>?&gt;</returns>
        Task<ICacheTrilaterationDataGzipApiResponse?> CacheTrilaterationDataGzipOrDefaultAsync(Option<TrilatCacheRequest> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Location by IP
        /// </summary>
        /// <remarks>
        /// Get location information based on an IP address.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="ip">the ip address of the client device (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocationByIpApiResponse"/>&gt;</returns>
        Task<IGetLocationByIpApiResponse> GetLocationByIpAsync(Option<string> ip = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Location by IP
        /// </summary>
        /// <remarks>
        /// Get location information based on an IP address.
        /// </remarks>
        /// <param name="ip">the ip address of the client device (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocationByIpApiResponse"/>?&gt;</returns>
        Task<IGetLocationByIpApiResponse?> GetLocationByIpOrDefaultAsync(Option<string> ip = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Location by Trilateration
        /// </summary>
        /// <remarks>
        /// Send in device data and calculate a position based on signal strengths.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The account making the request, if provided the last know location will be updated (optional)</param>
        /// <param name="latitude">The known GPS latitude to compare to the calculated version (optional)</param>
        /// <param name="longitude">The known GPS longitude to compare to the calculated version (optional)</param>
        /// <param name="data">The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60;  (optional)</param>
        /// <param name="responseFilters">Optional response filters (not used currently) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocationByTrilaterationApiResponse"/>&gt;</returns>
        Task<IGetLocationByTrilaterationApiResponse> GetLocationByTrilaterationAsync(Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> data = default, Option<string> responseFilters = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Location by Trilateration
        /// </summary>
        /// <remarks>
        /// Send in device data and calculate a position based on signal strengths.
        /// </remarks>
        /// <param name="accountId">The account making the request, if provided the last know location will be updated (optional)</param>
        /// <param name="latitude">The known GPS latitude to compare to the calculated version (optional)</param>
        /// <param name="longitude">The known GPS longitude to compare to the calculated version (optional)</param>
        /// <param name="data">The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60;  (optional)</param>
        /// <param name="responseFilters">Optional response filters (not used currently) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocationByTrilaterationApiResponse"/>?&gt;</returns>
        Task<IGetLocationByTrilaterationApiResponse?> GetLocationByTrilaterationOrDefaultAsync(Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> data = default, Option<string> responseFilters = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Regions or Postal Codes
        /// </summary>
        /// <remarks>
        /// Searches geographic locations by proximity via address or keyword.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="deviceId">the device id (optional)</param>
        /// <param name="accountId">the account id (optional)</param>
        /// <param name="currentlatitude">This parameter is deprecated. (optional)</param>
        /// <param name="currentlongitude">This parameter is deprecated. (optional)</param>
        /// <param name="currentLatitude">the current latitude of the user (optional)</param>
        /// <param name="currentLongitude">the current longitude of the user (optional)</param>
        /// <param name="query">the query results by keyword or address (optional)</param>
        /// <param name="zipcode">This parameter is deprecated. (optional)</param>
        /// <param name="zipCode">the zip code to filter results (optional)</param>
        /// <param name="selectedMaplatitude">This parameter is deprecated. (optional)</param>
        /// <param name="selectedMaplongitude">This parameter is deprecated. (optional)</param>
        /// <param name="selectedMapLatitude">the latitude of where the search should originate from (optional)</param>
        /// <param name="selectedMapLongitude">the longitude of where the search should originate from (optional)</param>
        /// <param name="searchRange">the search range of the search in miles (optional, default to 5D)</param>
        /// <param name="useGeocode">determines whether to allow searches via address (optional, default to false)</param>
        /// <param name="i">This parameter is deprecated. (optional)</param>
        /// <param name="start">the start index for pagination (optional, default to 0)</param>
        /// <param name="l">This parameter is deprecated. (optional)</param>
        /// <param name="limit">the limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocationsApiResponse"/>&gt;</returns>
        Task<IGetLocationsApiResponse> GetLocationsAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<double> currentlatitude = default, Option<double> currentlongitude = default, Option<double> currentLatitude = default, Option<double> currentLongitude = default, Option<string> query = default, Option<string> zipcode = default, Option<string> zipCode = default, Option<double> selectedMaplatitude = default, Option<double> selectedMaplongitude = default, Option<double> selectedMapLatitude = default, Option<double> selectedMapLongitude = default, Option<double> searchRange = default, Option<bool> useGeocode = default, Option<int> i = default, Option<int> start = default, Option<int> l = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Regions or Postal Codes
        /// </summary>
        /// <remarks>
        /// Searches geographic locations by proximity via address or keyword.
        /// </remarks>
        /// <param name="deviceId">the device id (optional)</param>
        /// <param name="accountId">the account id (optional)</param>
        /// <param name="currentlatitude">This parameter is deprecated. (optional)</param>
        /// <param name="currentlongitude">This parameter is deprecated. (optional)</param>
        /// <param name="currentLatitude">the current latitude of the user (optional)</param>
        /// <param name="currentLongitude">the current longitude of the user (optional)</param>
        /// <param name="query">the query results by keyword or address (optional)</param>
        /// <param name="zipcode">This parameter is deprecated. (optional)</param>
        /// <param name="zipCode">the zip code to filter results (optional)</param>
        /// <param name="selectedMaplatitude">This parameter is deprecated. (optional)</param>
        /// <param name="selectedMaplongitude">This parameter is deprecated. (optional)</param>
        /// <param name="selectedMapLatitude">the latitude of where the search should originate from (optional)</param>
        /// <param name="selectedMapLongitude">the longitude of where the search should originate from (optional)</param>
        /// <param name="searchRange">the search range of the search in miles (optional, default to 5D)</param>
        /// <param name="useGeocode">determines whether to allow searches via address (optional, default to false)</param>
        /// <param name="i">This parameter is deprecated. (optional)</param>
        /// <param name="start">the start index for pagination (optional, default to 0)</param>
        /// <param name="l">This parameter is deprecated. (optional)</param>
        /// <param name="limit">the limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocationsApiResponse"/>?&gt;</returns>
        Task<IGetLocationsApiResponse?> GetLocationsOrDefaultAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<double> currentlatitude = default, Option<double> currentlongitude = default, Option<double> currentLatitude = default, Option<double> currentLongitude = default, Option<string> query = default, Option<string> zipcode = default, Option<string> zipCode = default, Option<double> selectedMaplatitude = default, Option<double> selectedMaplongitude = default, Option<double> selectedMapLatitude = default, Option<double> selectedMapLongitude = default, Option<double> searchRange = default, Option<bool> useGeocode = default, Option<int> i = default, Option<int> start = default, Option<int> l = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICacheTrilaterationDataApiResponse"/>
    /// </summary>
    public interface ICacheTrilaterationDataApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICacheTrilaterationDataGzipApiResponse"/>
    /// </summary>
    public interface ICacheTrilaterationDataGzipApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetLocationByIpApiResponse"/>
    /// </summary>
    public interface IGetLocationByIpApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.CoordsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetLocationByTrilaterationApiResponse"/>
    /// </summary>
    public interface IGetLocationByTrilaterationApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.GeoPointResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetLocationsApiResponse"/>
    /// </summary>
    public interface IGetLocationsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.LocationSearchResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class LocationApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCacheTrilaterationData;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCacheTrilaterationData;

        internal void ExecuteOnCacheTrilaterationData(LocationApi.CacheTrilaterationDataApiResponse apiResponse)
        {
            OnCacheTrilaterationData?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCacheTrilaterationData(Exception exception)
        {
            OnErrorCacheTrilaterationData?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCacheTrilaterationDataGzip;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCacheTrilaterationDataGzip;

        internal void ExecuteOnCacheTrilaterationDataGzip(LocationApi.CacheTrilaterationDataGzipApiResponse apiResponse)
        {
            OnCacheTrilaterationDataGzip?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCacheTrilaterationDataGzip(Exception exception)
        {
            OnErrorCacheTrilaterationDataGzip?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetLocationByIp;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetLocationByIp;

        internal void ExecuteOnGetLocationByIp(LocationApi.GetLocationByIpApiResponse apiResponse)
        {
            OnGetLocationByIp?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetLocationByIp(Exception exception)
        {
            OnErrorGetLocationByIp?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetLocationByTrilateration;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetLocationByTrilateration;

        internal void ExecuteOnGetLocationByTrilateration(LocationApi.GetLocationByTrilaterationApiResponse apiResponse)
        {
            OnGetLocationByTrilateration?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetLocationByTrilateration(Exception exception)
        {
            OnErrorGetLocationByTrilateration?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetLocations;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetLocations;

        internal void ExecuteOnGetLocations(LocationApi.GetLocationsApiResponse apiResponse)
        {
            OnGetLocations?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetLocations(Exception exception)
        {
            OnErrorGetLocations?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class LocationApi : ILocationApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<LocationApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public LocationApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="LocationApi"/> class.
        /// </summary>
        /// <returns></returns>
        public LocationApi(ILogger<LocationApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, LocationApiEvents locationApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<LocationApi>();
            HttpClient = httpClient;
            Events = locationApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatCacheTrilaterationData(ref string udid, ref Option<long> sourceTime, ref Option<int> minimumSampleSize, ref Option<string> data, ref Option<System.IO.Stream> dataFile);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="udid"></param>
        /// <param name="data"></param>
        /// <param name="dataFile"></param>
        /// <returns></returns>
        private void ValidateCacheTrilaterationData(string udid, Option<string> data, Option<System.IO.Stream> dataFile)
        {
            if (udid == null)
                throw new ArgumentNullException(nameof(udid));

            if (data.IsSet && data.Value == null)
                throw new ArgumentNullException(nameof(data));

            if (dataFile.IsSet && dataFile.Value == null)
                throw new ArgumentNullException(nameof(dataFile));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="udid"></param>
        /// <param name="sourceTime"></param>
        /// <param name="minimumSampleSize"></param>
        /// <param name="data"></param>
        /// <param name="dataFile"></param>
        private void AfterCacheTrilaterationDataDefaultImplementation(ICacheTrilaterationDataApiResponse apiResponseLocalVar, string udid, Option<long> sourceTime, Option<int> minimumSampleSize, Option<string> data, Option<System.IO.Stream> dataFile)
        {
            bool suppressDefaultLog = false;
            AfterCacheTrilaterationData(ref suppressDefaultLog, apiResponseLocalVar, udid, sourceTime, minimumSampleSize, data, dataFile);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="udid"></param>
        /// <param name="sourceTime"></param>
        /// <param name="minimumSampleSize"></param>
        /// <param name="data"></param>
        /// <param name="dataFile"></param>
        partial void AfterCacheTrilaterationData(ref bool suppressDefaultLog, ICacheTrilaterationDataApiResponse apiResponseLocalVar, string udid, Option<long> sourceTime, Option<int> minimumSampleSize, Option<string> data, Option<System.IO.Stream> dataFile);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="udid"></param>
        /// <param name="sourceTime"></param>
        /// <param name="minimumSampleSize"></param>
        /// <param name="data"></param>
        /// <param name="dataFile"></param>
        private void OnErrorCacheTrilaterationDataDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string udid, Option<long> sourceTime, Option<int> minimumSampleSize, Option<string> data, Option<System.IO.Stream> dataFile)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCacheTrilaterationData(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, udid, sourceTime, minimumSampleSize, data, dataFile);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="udid"></param>
        /// <param name="sourceTime"></param>
        /// <param name="minimumSampleSize"></param>
        /// <param name="data"></param>
        /// <param name="dataFile"></param>
        partial void OnErrorCacheTrilaterationData(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string udid, Option<long> sourceTime, Option<int> minimumSampleSize, Option<string> data, Option<System.IO.Stream> dataFile);

        /// <summary>
        /// Create Trilateration Data with File Creates trilateration samples for a source device (i.e. a router).
        /// </summary>
        /// <param name="udid">The unique identifier of the source device</param>
        /// <param name="sourceTime">The current timestamp of the source device (optional)</param>
        /// <param name="minimumSampleSize">the minimum number of Edysen devices that must be used to be able to trilaterate a device (optional)</param>
        /// <param name="data">The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;:\&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;: \&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60;  (optional)</param>
        /// <param name="dataFile">Binary file containing data (multipart upload) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICacheTrilaterationDataApiResponse"/>&gt;</returns>
        public async Task<ICacheTrilaterationDataApiResponse?> CacheTrilaterationDataOrDefaultAsync(string udid, Option<long> sourceTime = default, Option<int> minimumSampleSize = default, Option<string> data = default, Option<System.IO.Stream> dataFile = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CacheTrilaterationDataAsync(udid, sourceTime, minimumSampleSize, data, dataFile, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create Trilateration Data with File Creates trilateration samples for a source device (i.e. a router).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="udid">The unique identifier of the source device</param>
        /// <param name="sourceTime">The current timestamp of the source device (optional)</param>
        /// <param name="minimumSampleSize">the minimum number of Edysen devices that must be used to be able to trilaterate a device (optional)</param>
        /// <param name="data">The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;:\&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;: \&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60;  (optional)</param>
        /// <param name="dataFile">Binary file containing data (multipart upload) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICacheTrilaterationDataApiResponse"/>&gt;</returns>
        public async Task<ICacheTrilaterationDataApiResponse> CacheTrilaterationDataAsync(string udid, Option<long> sourceTime = default, Option<int> minimumSampleSize = default, Option<string> data = default, Option<System.IO.Stream> dataFile = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCacheTrilaterationData(udid, data, dataFile);

                FormatCacheTrilaterationData(ref udid, ref sourceTime, ref minimumSampleSize, ref data, ref dataFile);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/location/trilaterate/cache"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/location/trilaterate/cache");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["udid"] = ClientUtils.ParameterToString(udid);

                    if (sourceTime.IsSet)
                        parseQueryStringLocalVar["sourceTime"] = ClientUtils.ParameterToString(sourceTime.Value);

                    if (minimumSampleSize.IsSet)
                        parseQueryStringLocalVar["minimumSampleSize"] = ClientUtils.ParameterToString(minimumSampleSize.Value);

                    if (data.IsSet)
                        parseQueryStringLocalVar["data"] = ClientUtils.ParameterToString(data.Value);

                    if (dataFile.IsSet)
                        parseQueryStringLocalVar["dataFile"] = ClientUtils.ParameterToString(dataFile.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CacheTrilaterationDataApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CacheTrilaterationDataApiResponse>();
                        CacheTrilaterationDataApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/location/trilaterate/cache", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCacheTrilaterationDataDefaultImplementation(apiResponseLocalVar, udid, sourceTime, minimumSampleSize, data, dataFile);

                        Events.ExecuteOnCacheTrilaterationData(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCacheTrilaterationDataDefaultImplementation(e, "/location/trilaterate/cache", uriBuilderLocalVar.Path, udid, sourceTime, minimumSampleSize, data, dataFile);
                Events.ExecuteOnErrorCacheTrilaterationData(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CacheTrilaterationDataApiResponse"/>
        /// </summary>
        public partial class CacheTrilaterationDataApiResponse : Org.OpenAPITools.Client.ApiResponse, ICacheTrilaterationDataApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CacheTrilaterationDataApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CacheTrilaterationDataApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CacheTrilaterationDataApiResponse(ILogger<CacheTrilaterationDataApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CacheTrilaterationDataApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CacheTrilaterationDataApiResponse(ILogger<CacheTrilaterationDataApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCacheTrilaterationDataGzip(Option<TrilatCacheRequest> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateCacheTrilaterationDataGzip(Option<TrilatCacheRequest> body)
        {
            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="body"></param>
        private void AfterCacheTrilaterationDataGzipDefaultImplementation(ICacheTrilaterationDataGzipApiResponse apiResponseLocalVar, Option<TrilatCacheRequest> body)
        {
            bool suppressDefaultLog = false;
            AfterCacheTrilaterationDataGzip(ref suppressDefaultLog, apiResponseLocalVar, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="body"></param>
        partial void AfterCacheTrilaterationDataGzip(ref bool suppressDefaultLog, ICacheTrilaterationDataGzipApiResponse apiResponseLocalVar, Option<TrilatCacheRequest> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="body"></param>
        private void OnErrorCacheTrilaterationDataGzipDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<TrilatCacheRequest> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCacheTrilaterationDataGzip(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="body"></param>
        partial void OnErrorCacheTrilaterationDataGzip(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<TrilatCacheRequest> body);

        /// <summary>
        /// Create Trilateration Data with Rest Creates trilateration samples for a source device (i.e. a router).
        /// </summary>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICacheTrilaterationDataGzipApiResponse"/>&gt;</returns>
        public async Task<ICacheTrilaterationDataGzipApiResponse?> CacheTrilaterationDataGzipOrDefaultAsync(Option<TrilatCacheRequest> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CacheTrilaterationDataGzipAsync(body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create Trilateration Data with Rest Creates trilateration samples for a source device (i.e. a router).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICacheTrilaterationDataGzipApiResponse"/>&gt;</returns>
        public async Task<ICacheTrilaterationDataGzipApiResponse> CacheTrilaterationDataGzipAsync(Option<TrilatCacheRequest> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCacheTrilaterationDataGzip(body);

                FormatCacheTrilaterationDataGzip(body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/location/trilaterate/cache/submit"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/location/trilaterate/cache/submit");

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CacheTrilaterationDataGzipApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CacheTrilaterationDataGzipApiResponse>();
                        CacheTrilaterationDataGzipApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/location/trilaterate/cache/submit", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCacheTrilaterationDataGzipDefaultImplementation(apiResponseLocalVar, body);

                        Events.ExecuteOnCacheTrilaterationDataGzip(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCacheTrilaterationDataGzipDefaultImplementation(e, "/location/trilaterate/cache/submit", uriBuilderLocalVar.Path, body);
                Events.ExecuteOnErrorCacheTrilaterationDataGzip(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CacheTrilaterationDataGzipApiResponse"/>
        /// </summary>
        public partial class CacheTrilaterationDataGzipApiResponse : Org.OpenAPITools.Client.ApiResponse, ICacheTrilaterationDataGzipApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CacheTrilaterationDataGzipApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CacheTrilaterationDataGzipApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CacheTrilaterationDataGzipApiResponse(ILogger<CacheTrilaterationDataGzipApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CacheTrilaterationDataGzipApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CacheTrilaterationDataGzipApiResponse(ILogger<CacheTrilaterationDataGzipApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetLocationByIp(ref Option<string> ip);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="ip"></param>
        /// <returns></returns>
        private void ValidateGetLocationByIp(Option<string> ip)
        {
            if (ip.IsSet && ip.Value == null)
                throw new ArgumentNullException(nameof(ip));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="ip"></param>
        private void AfterGetLocationByIpDefaultImplementation(IGetLocationByIpApiResponse apiResponseLocalVar, Option<string> ip)
        {
            bool suppressDefaultLog = false;
            AfterGetLocationByIp(ref suppressDefaultLog, apiResponseLocalVar, ip);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="ip"></param>
        partial void AfterGetLocationByIp(ref bool suppressDefaultLog, IGetLocationByIpApiResponse apiResponseLocalVar, Option<string> ip);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="ip"></param>
        private void OnErrorGetLocationByIpDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> ip)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetLocationByIp(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, ip);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="ip"></param>
        partial void OnErrorGetLocationByIp(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> ip);

        /// <summary>
        /// Get Location by IP Get location information based on an IP address.
        /// </summary>
        /// <param name="ip">the ip address of the client device (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocationByIpApiResponse"/>&gt;</returns>
        public async Task<IGetLocationByIpApiResponse?> GetLocationByIpOrDefaultAsync(Option<string> ip = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetLocationByIpAsync(ip, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Location by IP Get location information based on an IP address.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="ip">the ip address of the client device (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocationByIpApiResponse"/>&gt;</returns>
        public async Task<IGetLocationByIpApiResponse> GetLocationByIpAsync(Option<string> ip = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetLocationByIp(ip);

                FormatGetLocationByIp(ref ip);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/location/ip"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/location/ip");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (ip.IsSet)
                        parseQueryStringLocalVar["ip"] = ClientUtils.ParameterToString(ip.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetLocationByIpApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetLocationByIpApiResponse>();
                        GetLocationByIpApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/location/ip", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetLocationByIpDefaultImplementation(apiResponseLocalVar, ip);

                        Events.ExecuteOnGetLocationByIp(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetLocationByIpDefaultImplementation(e, "/location/ip", uriBuilderLocalVar.Path, ip);
                Events.ExecuteOnErrorGetLocationByIp(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetLocationByIpApiResponse"/>
        /// </summary>
        public partial class GetLocationByIpApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetLocationByIpApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetLocationByIpApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetLocationByIpApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetLocationByIpApiResponse(ILogger<GetLocationByIpApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetLocationByIpApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetLocationByIpApiResponse(ILogger<GetLocationByIpApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.CoordsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.CoordsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.CoordsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetLocationByTrilateration(ref Option<long> accountId, ref Option<double> latitude, ref Option<double> longitude, ref Option<string> data, ref Option<string> responseFilters);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="data"></param>
        /// <param name="responseFilters"></param>
        /// <returns></returns>
        private void ValidateGetLocationByTrilateration(Option<string> data, Option<string> responseFilters)
        {
            if (data.IsSet && data.Value == null)
                throw new ArgumentNullException(nameof(data));

            if (responseFilters.IsSet && responseFilters.Value == null)
                throw new ArgumentNullException(nameof(responseFilters));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="data"></param>
        /// <param name="responseFilters"></param>
        private void AfterGetLocationByTrilaterationDefaultImplementation(IGetLocationByTrilaterationApiResponse apiResponseLocalVar, Option<long> accountId, Option<double> latitude, Option<double> longitude, Option<string> data, Option<string> responseFilters)
        {
            bool suppressDefaultLog = false;
            AfterGetLocationByTrilateration(ref suppressDefaultLog, apiResponseLocalVar, accountId, latitude, longitude, data, responseFilters);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="data"></param>
        /// <param name="responseFilters"></param>
        partial void AfterGetLocationByTrilateration(ref bool suppressDefaultLog, IGetLocationByTrilaterationApiResponse apiResponseLocalVar, Option<long> accountId, Option<double> latitude, Option<double> longitude, Option<string> data, Option<string> responseFilters);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="data"></param>
        /// <param name="responseFilters"></param>
        private void OnErrorGetLocationByTrilaterationDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> accountId, Option<double> latitude, Option<double> longitude, Option<string> data, Option<string> responseFilters)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetLocationByTrilateration(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, latitude, longitude, data, responseFilters);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="data"></param>
        /// <param name="responseFilters"></param>
        partial void OnErrorGetLocationByTrilateration(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> accountId, Option<double> latitude, Option<double> longitude, Option<string> data, Option<string> responseFilters);

        /// <summary>
        /// Get Location by Trilateration Send in device data and calculate a position based on signal strengths.
        /// </summary>
        /// <param name="accountId">The account making the request, if provided the last know location will be updated (optional)</param>
        /// <param name="latitude">The known GPS latitude to compare to the calculated version (optional)</param>
        /// <param name="longitude">The known GPS longitude to compare to the calculated version (optional)</param>
        /// <param name="data">The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60;  (optional)</param>
        /// <param name="responseFilters">Optional response filters (not used currently) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocationByTrilaterationApiResponse"/>&gt;</returns>
        public async Task<IGetLocationByTrilaterationApiResponse?> GetLocationByTrilaterationOrDefaultAsync(Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> data = default, Option<string> responseFilters = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetLocationByTrilaterationAsync(accountId, latitude, longitude, data, responseFilters, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Location by Trilateration Send in device data and calculate a position based on signal strengths.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The account making the request, if provided the last know location will be updated (optional)</param>
        /// <param name="latitude">The known GPS latitude to compare to the calculated version (optional)</param>
        /// <param name="longitude">The known GPS longitude to compare to the calculated version (optional)</param>
        /// <param name="data">The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60;  (optional)</param>
        /// <param name="responseFilters">Optional response filters (not used currently) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocationByTrilaterationApiResponse"/>&gt;</returns>
        public async Task<IGetLocationByTrilaterationApiResponse> GetLocationByTrilaterationAsync(Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> data = default, Option<string> responseFilters = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetLocationByTrilateration(data, responseFilters);

                FormatGetLocationByTrilateration(ref accountId, ref latitude, ref longitude, ref data, ref responseFilters);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/account/location/trilaterate"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/account/location/trilaterate");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    if (data.IsSet)
                        parseQueryStringLocalVar["data"] = ClientUtils.ParameterToString(data.Value);

                    if (responseFilters.IsSet)
                        parseQueryStringLocalVar["responseFilters"] = ClientUtils.ParameterToString(responseFilters.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetLocationByTrilaterationApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetLocationByTrilaterationApiResponse>();
                        GetLocationByTrilaterationApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/account/location/trilaterate", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetLocationByTrilaterationDefaultImplementation(apiResponseLocalVar, accountId, latitude, longitude, data, responseFilters);

                        Events.ExecuteOnGetLocationByTrilateration(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetLocationByTrilaterationDefaultImplementation(e, "/account/location/trilaterate", uriBuilderLocalVar.Path, accountId, latitude, longitude, data, responseFilters);
                Events.ExecuteOnErrorGetLocationByTrilateration(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetLocationByTrilaterationApiResponse"/>
        /// </summary>
        public partial class GetLocationByTrilaterationApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetLocationByTrilaterationApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetLocationByTrilaterationApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetLocationByTrilaterationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetLocationByTrilaterationApiResponse(ILogger<GetLocationByTrilaterationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetLocationByTrilaterationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetLocationByTrilaterationApiResponse(ILogger<GetLocationByTrilaterationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.GeoPointResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.GeoPointResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.GeoPointResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetLocations(ref Option<string> deviceId, ref Option<long> accountId, ref Option<double> currentlatitude, ref Option<double> currentlongitude, ref Option<double> currentLatitude, ref Option<double> currentLongitude, ref Option<string> query, ref Option<string> zipcode, ref Option<string> zipCode, ref Option<double> selectedMaplatitude, ref Option<double> selectedMaplongitude, ref Option<double> selectedMapLatitude, ref Option<double> selectedMapLongitude, ref Option<double> searchRange, ref Option<bool> useGeocode, ref Option<int> i, ref Option<int> start, ref Option<int> l, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <param name="query"></param>
        /// <param name="zipcode"></param>
        /// <param name="zipCode"></param>
        /// <returns></returns>
        private void ValidateGetLocations(Option<string> deviceId, Option<string> query, Option<string> zipcode, Option<string> zipCode)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (query.IsSet && query.Value == null)
                throw new ArgumentNullException(nameof(query));

            if (zipcode.IsSet && zipcode.Value == null)
                throw new ArgumentNullException(nameof(zipcode));

            if (zipCode.IsSet && zipCode.Value == null)
                throw new ArgumentNullException(nameof(zipCode));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="currentlatitude"></param>
        /// <param name="currentlongitude"></param>
        /// <param name="currentLatitude"></param>
        /// <param name="currentLongitude"></param>
        /// <param name="query"></param>
        /// <param name="zipcode"></param>
        /// <param name="zipCode"></param>
        /// <param name="selectedMaplatitude"></param>
        /// <param name="selectedMaplongitude"></param>
        /// <param name="selectedMapLatitude"></param>
        /// <param name="selectedMapLongitude"></param>
        /// <param name="searchRange"></param>
        /// <param name="useGeocode"></param>
        /// <param name="i"></param>
        /// <param name="start"></param>
        /// <param name="l"></param>
        /// <param name="limit"></param>
        private void AfterGetLocationsDefaultImplementation(IGetLocationsApiResponse apiResponseLocalVar, Option<string> deviceId, Option<long> accountId, Option<double> currentlatitude, Option<double> currentlongitude, Option<double> currentLatitude, Option<double> currentLongitude, Option<string> query, Option<string> zipcode, Option<string> zipCode, Option<double> selectedMaplatitude, Option<double> selectedMaplongitude, Option<double> selectedMapLatitude, Option<double> selectedMapLongitude, Option<double> searchRange, Option<bool> useGeocode, Option<int> i, Option<int> start, Option<int> l, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterGetLocations(ref suppressDefaultLog, apiResponseLocalVar, deviceId, accountId, currentlatitude, currentlongitude, currentLatitude, currentLongitude, query, zipcode, zipCode, selectedMaplatitude, selectedMaplongitude, selectedMapLatitude, selectedMapLongitude, searchRange, useGeocode, i, start, l, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="currentlatitude"></param>
        /// <param name="currentlongitude"></param>
        /// <param name="currentLatitude"></param>
        /// <param name="currentLongitude"></param>
        /// <param name="query"></param>
        /// <param name="zipcode"></param>
        /// <param name="zipCode"></param>
        /// <param name="selectedMaplatitude"></param>
        /// <param name="selectedMaplongitude"></param>
        /// <param name="selectedMapLatitude"></param>
        /// <param name="selectedMapLongitude"></param>
        /// <param name="searchRange"></param>
        /// <param name="useGeocode"></param>
        /// <param name="i"></param>
        /// <param name="start"></param>
        /// <param name="l"></param>
        /// <param name="limit"></param>
        partial void AfterGetLocations(ref bool suppressDefaultLog, IGetLocationsApiResponse apiResponseLocalVar, Option<string> deviceId, Option<long> accountId, Option<double> currentlatitude, Option<double> currentlongitude, Option<double> currentLatitude, Option<double> currentLongitude, Option<string> query, Option<string> zipcode, Option<string> zipCode, Option<double> selectedMaplatitude, Option<double> selectedMaplongitude, Option<double> selectedMapLatitude, Option<double> selectedMapLongitude, Option<double> searchRange, Option<bool> useGeocode, Option<int> i, Option<int> start, Option<int> l, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="currentlatitude"></param>
        /// <param name="currentlongitude"></param>
        /// <param name="currentLatitude"></param>
        /// <param name="currentLongitude"></param>
        /// <param name="query"></param>
        /// <param name="zipcode"></param>
        /// <param name="zipCode"></param>
        /// <param name="selectedMaplatitude"></param>
        /// <param name="selectedMaplongitude"></param>
        /// <param name="selectedMapLatitude"></param>
        /// <param name="selectedMapLongitude"></param>
        /// <param name="searchRange"></param>
        /// <param name="useGeocode"></param>
        /// <param name="i"></param>
        /// <param name="start"></param>
        /// <param name="l"></param>
        /// <param name="limit"></param>
        private void OnErrorGetLocationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> deviceId, Option<long> accountId, Option<double> currentlatitude, Option<double> currentlongitude, Option<double> currentLatitude, Option<double> currentLongitude, Option<string> query, Option<string> zipcode, Option<string> zipCode, Option<double> selectedMaplatitude, Option<double> selectedMaplongitude, Option<double> selectedMapLatitude, Option<double> selectedMapLongitude, Option<double> searchRange, Option<bool> useGeocode, Option<int> i, Option<int> start, Option<int> l, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetLocations(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, deviceId, accountId, currentlatitude, currentlongitude, currentLatitude, currentLongitude, query, zipcode, zipCode, selectedMaplatitude, selectedMaplongitude, selectedMapLatitude, selectedMapLongitude, searchRange, useGeocode, i, start, l, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="currentlatitude"></param>
        /// <param name="currentlongitude"></param>
        /// <param name="currentLatitude"></param>
        /// <param name="currentLongitude"></param>
        /// <param name="query"></param>
        /// <param name="zipcode"></param>
        /// <param name="zipCode"></param>
        /// <param name="selectedMaplatitude"></param>
        /// <param name="selectedMaplongitude"></param>
        /// <param name="selectedMapLatitude"></param>
        /// <param name="selectedMapLongitude"></param>
        /// <param name="searchRange"></param>
        /// <param name="useGeocode"></param>
        /// <param name="i"></param>
        /// <param name="start"></param>
        /// <param name="l"></param>
        /// <param name="limit"></param>
        partial void OnErrorGetLocations(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> deviceId, Option<long> accountId, Option<double> currentlatitude, Option<double> currentlongitude, Option<double> currentLatitude, Option<double> currentLongitude, Option<string> query, Option<string> zipcode, Option<string> zipCode, Option<double> selectedMaplatitude, Option<double> selectedMaplongitude, Option<double> selectedMapLatitude, Option<double> selectedMapLongitude, Option<double> searchRange, Option<bool> useGeocode, Option<int> i, Option<int> start, Option<int> l, Option<int> limit);

        /// <summary>
        /// Search Regions or Postal Codes Searches geographic locations by proximity via address or keyword.
        /// </summary>
        /// <param name="deviceId">the device id (optional)</param>
        /// <param name="accountId">the account id (optional)</param>
        /// <param name="currentlatitude">This parameter is deprecated. (optional)</param>
        /// <param name="currentlongitude">This parameter is deprecated. (optional)</param>
        /// <param name="currentLatitude">the current latitude of the user (optional)</param>
        /// <param name="currentLongitude">the current longitude of the user (optional)</param>
        /// <param name="query">the query results by keyword or address (optional)</param>
        /// <param name="zipcode">This parameter is deprecated. (optional)</param>
        /// <param name="zipCode">the zip code to filter results (optional)</param>
        /// <param name="selectedMaplatitude">This parameter is deprecated. (optional)</param>
        /// <param name="selectedMaplongitude">This parameter is deprecated. (optional)</param>
        /// <param name="selectedMapLatitude">the latitude of where the search should originate from (optional)</param>
        /// <param name="selectedMapLongitude">the longitude of where the search should originate from (optional)</param>
        /// <param name="searchRange">the search range of the search in miles (optional, default to 5D)</param>
        /// <param name="useGeocode">determines whether to allow searches via address (optional, default to false)</param>
        /// <param name="i">This parameter is deprecated. (optional)</param>
        /// <param name="start">the start index for pagination (optional, default to 0)</param>
        /// <param name="l">This parameter is deprecated. (optional)</param>
        /// <param name="limit">the limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocationsApiResponse"/>&gt;</returns>
        public async Task<IGetLocationsApiResponse?> GetLocationsOrDefaultAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<double> currentlatitude = default, Option<double> currentlongitude = default, Option<double> currentLatitude = default, Option<double> currentLongitude = default, Option<string> query = default, Option<string> zipcode = default, Option<string> zipCode = default, Option<double> selectedMaplatitude = default, Option<double> selectedMaplongitude = default, Option<double> selectedMapLatitude = default, Option<double> selectedMapLongitude = default, Option<double> searchRange = default, Option<bool> useGeocode = default, Option<int> i = default, Option<int> start = default, Option<int> l = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetLocationsAsync(deviceId, accountId, currentlatitude, currentlongitude, currentLatitude, currentLongitude, query, zipcode, zipCode, selectedMaplatitude, selectedMaplongitude, selectedMapLatitude, selectedMapLongitude, searchRange, useGeocode, i, start, l, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Regions or Postal Codes Searches geographic locations by proximity via address or keyword.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="deviceId">the device id (optional)</param>
        /// <param name="accountId">the account id (optional)</param>
        /// <param name="currentlatitude">This parameter is deprecated. (optional)</param>
        /// <param name="currentlongitude">This parameter is deprecated. (optional)</param>
        /// <param name="currentLatitude">the current latitude of the user (optional)</param>
        /// <param name="currentLongitude">the current longitude of the user (optional)</param>
        /// <param name="query">the query results by keyword or address (optional)</param>
        /// <param name="zipcode">This parameter is deprecated. (optional)</param>
        /// <param name="zipCode">the zip code to filter results (optional)</param>
        /// <param name="selectedMaplatitude">This parameter is deprecated. (optional)</param>
        /// <param name="selectedMaplongitude">This parameter is deprecated. (optional)</param>
        /// <param name="selectedMapLatitude">the latitude of where the search should originate from (optional)</param>
        /// <param name="selectedMapLongitude">the longitude of where the search should originate from (optional)</param>
        /// <param name="searchRange">the search range of the search in miles (optional, default to 5D)</param>
        /// <param name="useGeocode">determines whether to allow searches via address (optional, default to false)</param>
        /// <param name="i">This parameter is deprecated. (optional)</param>
        /// <param name="start">the start index for pagination (optional, default to 0)</param>
        /// <param name="l">This parameter is deprecated. (optional)</param>
        /// <param name="limit">the limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocationsApiResponse"/>&gt;</returns>
        public async Task<IGetLocationsApiResponse> GetLocationsAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<double> currentlatitude = default, Option<double> currentlongitude = default, Option<double> currentLatitude = default, Option<double> currentLongitude = default, Option<string> query = default, Option<string> zipcode = default, Option<string> zipCode = default, Option<double> selectedMaplatitude = default, Option<double> selectedMaplongitude = default, Option<double> selectedMapLatitude = default, Option<double> selectedMapLongitude = default, Option<double> searchRange = default, Option<bool> useGeocode = default, Option<int> i = default, Option<int> start = default, Option<int> l = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetLocations(deviceId, query, zipcode, zipCode);

                FormatGetLocations(ref deviceId, ref accountId, ref currentlatitude, ref currentlongitude, ref currentLatitude, ref currentLongitude, ref query, ref zipcode, ref zipCode, ref selectedMaplatitude, ref selectedMaplongitude, ref selectedMapLatitude, ref selectedMapLongitude, ref searchRange, ref useGeocode, ref i, ref start, ref l, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/location/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/location/search");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (currentlatitude.IsSet)
                        parseQueryStringLocalVar["currentlatitude"] = ClientUtils.ParameterToString(currentlatitude.Value);

                    if (currentlongitude.IsSet)
                        parseQueryStringLocalVar["currentlongitude"] = ClientUtils.ParameterToString(currentlongitude.Value);

                    if (currentLatitude.IsSet)
                        parseQueryStringLocalVar["currentLatitude"] = ClientUtils.ParameterToString(currentLatitude.Value);

                    if (currentLongitude.IsSet)
                        parseQueryStringLocalVar["currentLongitude"] = ClientUtils.ParameterToString(currentLongitude.Value);

                    if (query.IsSet)
                        parseQueryStringLocalVar["query"] = ClientUtils.ParameterToString(query.Value);

                    if (zipcode.IsSet)
                        parseQueryStringLocalVar["zipcode"] = ClientUtils.ParameterToString(zipcode.Value);

                    if (zipCode.IsSet)
                        parseQueryStringLocalVar["zipCode"] = ClientUtils.ParameterToString(zipCode.Value);

                    if (selectedMaplatitude.IsSet)
                        parseQueryStringLocalVar["selectedMaplatitude"] = ClientUtils.ParameterToString(selectedMaplatitude.Value);

                    if (selectedMaplongitude.IsSet)
                        parseQueryStringLocalVar["selectedMaplongitude"] = ClientUtils.ParameterToString(selectedMaplongitude.Value);

                    if (selectedMapLatitude.IsSet)
                        parseQueryStringLocalVar["selectedMapLatitude"] = ClientUtils.ParameterToString(selectedMapLatitude.Value);

                    if (selectedMapLongitude.IsSet)
                        parseQueryStringLocalVar["selectedMapLongitude"] = ClientUtils.ParameterToString(selectedMapLongitude.Value);

                    if (searchRange.IsSet)
                        parseQueryStringLocalVar["searchRange"] = ClientUtils.ParameterToString(searchRange.Value);

                    if (useGeocode.IsSet)
                        parseQueryStringLocalVar["useGeocode"] = ClientUtils.ParameterToString(useGeocode.Value);

                    if (i.IsSet)
                        parseQueryStringLocalVar["_i"] = ClientUtils.ParameterToString(i.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (l.IsSet)
                        parseQueryStringLocalVar["_l"] = ClientUtils.ParameterToString(l.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetLocationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetLocationsApiResponse>();
                        GetLocationsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/location/search", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetLocationsDefaultImplementation(apiResponseLocalVar, deviceId, accountId, currentlatitude, currentlongitude, currentLatitude, currentLongitude, query, zipcode, zipCode, selectedMaplatitude, selectedMaplongitude, selectedMapLatitude, selectedMapLongitude, searchRange, useGeocode, i, start, l, limit);

                        Events.ExecuteOnGetLocations(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetLocationsDefaultImplementation(e, "/location/search", uriBuilderLocalVar.Path, deviceId, accountId, currentlatitude, currentlongitude, currentLatitude, currentLongitude, query, zipcode, zipCode, selectedMaplatitude, selectedMaplongitude, selectedMapLatitude, selectedMapLongitude, searchRange, useGeocode, i, start, l, limit);
                Events.ExecuteOnErrorGetLocations(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetLocationsApiResponse"/>
        /// </summary>
        public partial class GetLocationsApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetLocationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetLocationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetLocationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetLocationsApiResponse(ILogger<GetLocationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetLocationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetLocationsApiResponse(ILogger<GetLocationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.LocationSearchResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.LocationSearchResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.LocationSearchResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
