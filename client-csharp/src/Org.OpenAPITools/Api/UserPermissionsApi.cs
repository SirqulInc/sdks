// <auto-generated>
/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Net;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IUserPermissionsApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        UserPermissionsApiEvents Events { get; }

        /// <summary>
        /// Add User
        /// </summary>
        /// <remarks>
        /// Adds a user to a permissionable object.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="permissionableType">the permissionable type of the object</param>
        /// <param name="permissionableId">the id of the permissionable object</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="read">the read permission of the users/groups (optional, default to true)</param>
        /// <param name="write">the write permission of the users/groups (optional, default to false)</param>
        /// <param name="delete">the delete permission of the users/groups (optional, default to false)</param>
        /// <param name="add">the add permission of the users/groups (optional, default to false)</param>
        /// <param name="connectionIds">a comma separated list of connection ids (NOT the account ids) (optional)</param>
        /// <param name="connectionAccountIds">a comma separated list of account ids (optional)</param>
        /// <param name="connectionGroupIds">a comma separated list of connection group ids (these are groups made by the user) (optional)</param>
        /// <param name="pending">sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept) (optional, default to false)</param>
        /// <param name="admin">sets whether the added users will become admins or not (optional)</param>
        /// <param name="includeFriendGroup">flag to determine whether to include the built-in \&quot;friends\&quot; group (optional, default to false)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="audienceIds">comma separated list of audience ids. This is a feature only available to the permissionable&#39;s application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddUsersToPermissionableApiResponse"/>&gt;</returns>
        Task<IAddUsersToPermissionableApiResponse> AddUsersToPermissionableAsync(string permissionableType, long permissionableId, Option<string> deviceId = default, Option<long> accountId = default, Option<bool> read = default, Option<bool> write = default, Option<bool> delete = default, Option<bool> add = default, Option<string> connectionIds = default, Option<string> connectionAccountIds = default, Option<string> connectionGroupIds = default, Option<bool> pending = default, Option<bool> admin = default, Option<bool> includeFriendGroup = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> audienceIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Add User
        /// </summary>
        /// <remarks>
        /// Adds a user to a permissionable object.
        /// </remarks>
        /// <param name="permissionableType">the permissionable type of the object</param>
        /// <param name="permissionableId">the id of the permissionable object</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="read">the read permission of the users/groups (optional, default to true)</param>
        /// <param name="write">the write permission of the users/groups (optional, default to false)</param>
        /// <param name="delete">the delete permission of the users/groups (optional, default to false)</param>
        /// <param name="add">the add permission of the users/groups (optional, default to false)</param>
        /// <param name="connectionIds">a comma separated list of connection ids (NOT the account ids) (optional)</param>
        /// <param name="connectionAccountIds">a comma separated list of account ids (optional)</param>
        /// <param name="connectionGroupIds">a comma separated list of connection group ids (these are groups made by the user) (optional)</param>
        /// <param name="pending">sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept) (optional, default to false)</param>
        /// <param name="admin">sets whether the added users will become admins or not (optional)</param>
        /// <param name="includeFriendGroup">flag to determine whether to include the built-in \&quot;friends\&quot; group (optional, default to false)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="audienceIds">comma separated list of audience ids. This is a feature only available to the permissionable&#39;s application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddUsersToPermissionableApiResponse"/>?&gt;</returns>
        Task<IAddUsersToPermissionableApiResponse?> AddUsersToPermissionableOrDefaultAsync(string permissionableType, long permissionableId, Option<string> deviceId = default, Option<long> accountId = default, Option<bool> read = default, Option<bool> write = default, Option<bool> delete = default, Option<bool> add = default, Option<string> connectionIds = default, Option<string> connectionAccountIds = default, Option<string> connectionGroupIds = default, Option<bool> pending = default, Option<bool> admin = default, Option<bool> includeFriendGroup = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> audienceIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Approve Permissionable
        /// </summary>
        /// <remarks>
        /// Sets the approval status of a permissionable object.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="permissionableType">The permissionable type of the object</param>
        /// <param name="permissionableId">The id of the permissionable object</param>
        /// <param name="deviceId">A unique ID given by the device (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">The account ID of the user (deviceId or accountId required) (optional)</param>
        /// <param name="approvalStatus">The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional, default to APPROVED)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApprovePermissionableApiResponse"/>&gt;</returns>
        Task<IApprovePermissionableApiResponse> ApprovePermissionableAsync(string permissionableType, long permissionableId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> approvalStatus = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Approve Permissionable
        /// </summary>
        /// <remarks>
        /// Sets the approval status of a permissionable object.
        /// </remarks>
        /// <param name="permissionableType">The permissionable type of the object</param>
        /// <param name="permissionableId">The id of the permissionable object</param>
        /// <param name="deviceId">A unique ID given by the device (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">The account ID of the user (deviceId or accountId required) (optional)</param>
        /// <param name="approvalStatus">The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional, default to APPROVED)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApprovePermissionableApiResponse"/>?&gt;</returns>
        Task<IApprovePermissionableApiResponse?> ApprovePermissionableOrDefaultAsync(string permissionableType, long permissionableId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> approvalStatus = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Leave
        /// </summary>
        /// <remarks>
        /// Used when the user wants to leave from someone else&#39;s permissionable object
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="permissionableType">the permissionable type PermissionableType</param>
        /// <param name="permissionableId">the id of the permissionable object</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ILeaveFromPermissionableApiResponse"/>&gt;</returns>
        Task<ILeaveFromPermissionableApiResponse> LeaveFromPermissionableAsync(string permissionableType, long permissionableId, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Leave
        /// </summary>
        /// <remarks>
        /// Used when the user wants to leave from someone else&#39;s permissionable object
        /// </remarks>
        /// <param name="permissionableType">the permissionable type PermissionableType</param>
        /// <param name="permissionableId">the id of the permissionable object</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ILeaveFromPermissionableApiResponse"/>?&gt;</returns>
        Task<ILeaveFromPermissionableApiResponse?> LeaveFromPermissionableOrDefaultAsync(string permissionableType, long permissionableId, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Remove User
        /// </summary>
        /// <remarks>
        /// Used to remove someone (assuming they have permission) from a permissionable object
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="permissionableType">the permissionable type of the object</param>
        /// <param name="permissionableId">the id of the permissionable object</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionIds">a comma separated list of connection ids (NOT the account ids) (optional)</param>
        /// <param name="connectionAccountIds">a comma separated list of account ids (optional)</param>
        /// <param name="connectionGroupIds">a comma separated list of connection group ids (these are groups made by the user) (optional)</param>
        /// <param name="removeFriendGroup">flag to determine whether to remove the built-in \&quot;friends\&quot; group (optional, default to false)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="audienceIds">comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveUsersFromPermissionableApiResponse"/>&gt;</returns>
        Task<IRemoveUsersFromPermissionableApiResponse> RemoveUsersFromPermissionableAsync(string permissionableType, long permissionableId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> connectionIds = default, Option<string> connectionAccountIds = default, Option<string> connectionGroupIds = default, Option<bool> removeFriendGroup = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> audienceIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Remove User
        /// </summary>
        /// <remarks>
        /// Used to remove someone (assuming they have permission) from a permissionable object
        /// </remarks>
        /// <param name="permissionableType">the permissionable type of the object</param>
        /// <param name="permissionableId">the id of the permissionable object</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionIds">a comma separated list of connection ids (NOT the account ids) (optional)</param>
        /// <param name="connectionAccountIds">a comma separated list of account ids (optional)</param>
        /// <param name="connectionGroupIds">a comma separated list of connection group ids (these are groups made by the user) (optional)</param>
        /// <param name="removeFriendGroup">flag to determine whether to remove the built-in \&quot;friends\&quot; group (optional, default to false)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="audienceIds">comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveUsersFromPermissionableApiResponse"/>?&gt;</returns>
        Task<IRemoveUsersFromPermissionableApiResponse?> RemoveUsersFromPermissionableOrDefaultAsync(string permissionableType, long permissionableId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> connectionIds = default, Option<string> connectionAccountIds = default, Option<string> connectionGroupIds = default, Option<bool> removeFriendGroup = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> audienceIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Permissionables
        /// </summary>
        /// <remarks>
        /// Search on UserPermissions
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="deviceId">A unique ID given by the device (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">The account ID of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionAccountId">Filter results for a specific user account (optional)</param>
        /// <param name="connectionAccountIds">Comma separated list of account IDs to filter results with (optional)</param>
        /// <param name="permissionableType">Filter user permissions by the permissionable object type (optional)</param>
        /// <param name="permissionableId">The id of the permissionable object to filter by (optional)</param>
        /// <param name="keyword">Keyword to search within permissionable records (optional)</param>
        /// <param name="sortField">Field to sort results on (optional)</param>
        /// <param name="descending">Sort descending when true (optional)</param>
        /// <param name="pending">Return user permissions that are pending (optional)</param>
        /// <param name="admin">Return user permissions that are admins (optional)</param>
        /// <param name="start">the start index for pagination (optional, default to 0)</param>
        /// <param name="limit">the limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPermissionablesApiResponse"/>&gt;</returns>
        Task<ISearchPermissionablesApiResponse> SearchPermissionablesAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionAccountId = default, Option<string> connectionAccountIds = default, Option<string> permissionableType = default, Option<long> permissionableId = default, Option<string> keyword = default, Option<string> sortField = default, Option<bool> descending = default, Option<bool> pending = default, Option<bool> admin = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Permissionables
        /// </summary>
        /// <remarks>
        /// Search on UserPermissions
        /// </remarks>
        /// <param name="deviceId">A unique ID given by the device (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">The account ID of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionAccountId">Filter results for a specific user account (optional)</param>
        /// <param name="connectionAccountIds">Comma separated list of account IDs to filter results with (optional)</param>
        /// <param name="permissionableType">Filter user permissions by the permissionable object type (optional)</param>
        /// <param name="permissionableId">The id of the permissionable object to filter by (optional)</param>
        /// <param name="keyword">Keyword to search within permissionable records (optional)</param>
        /// <param name="sortField">Field to sort results on (optional)</param>
        /// <param name="descending">Sort descending when true (optional)</param>
        /// <param name="pending">Return user permissions that are pending (optional)</param>
        /// <param name="admin">Return user permissions that are admins (optional)</param>
        /// <param name="start">the start index for pagination (optional, default to 0)</param>
        /// <param name="limit">the limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPermissionablesApiResponse"/>?&gt;</returns>
        Task<ISearchPermissionablesApiResponse?> SearchPermissionablesOrDefaultAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionAccountId = default, Option<string> connectionAccountIds = default, Option<string> permissionableType = default, Option<long> permissionableId = default, Option<string> keyword = default, Option<string> sortField = default, Option<bool> descending = default, Option<bool> pending = default, Option<bool> admin = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Permissionables by Distnace
        /// </summary>
        /// <remarks>
        /// Search on UserPermissions by distance
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude">The latitude of the current account</param>
        /// <param name="longitude">The longitude of the current account</param>
        /// <param name="deviceId">A unique ID given by the device (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">The account ID of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionAccountId">Filter results for a specific user account (optional)</param>
        /// <param name="connectionAccountIds">Comma separated list of account IDs to filter results with (optional)</param>
        /// <param name="permissionableType">Filter user permissions by the permissionable object type (optional)</param>
        /// <param name="permissionableId">The id of the permissionable object to filter by (optional)</param>
        /// <param name="searchRange">The search range in miles (optional, default to 5D)</param>
        /// <param name="keyword">Keyword to search within permissionable records (optional)</param>
        /// <param name="pending">Return user permissions that are pending (optional)</param>
        /// <param name="admin">Return user permissions that are admins (optional)</param>
        /// <param name="start">The start index for pagination (optional, default to 0)</param>
        /// <param name="limit">The limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPermissionablesFollowingDistanceApiResponse"/>&gt;</returns>
        Task<ISearchPermissionablesFollowingDistanceApiResponse> SearchPermissionablesFollowingDistanceAsync(double latitude, double longitude, Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionAccountId = default, Option<string> connectionAccountIds = default, Option<string> permissionableType = default, Option<long> permissionableId = default, Option<double> searchRange = default, Option<string> keyword = default, Option<bool> pending = default, Option<bool> admin = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Permissionables by Distnace
        /// </summary>
        /// <remarks>
        /// Search on UserPermissions by distance
        /// </remarks>
        /// <param name="latitude">The latitude of the current account</param>
        /// <param name="longitude">The longitude of the current account</param>
        /// <param name="deviceId">A unique ID given by the device (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">The account ID of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionAccountId">Filter results for a specific user account (optional)</param>
        /// <param name="connectionAccountIds">Comma separated list of account IDs to filter results with (optional)</param>
        /// <param name="permissionableType">Filter user permissions by the permissionable object type (optional)</param>
        /// <param name="permissionableId">The id of the permissionable object to filter by (optional)</param>
        /// <param name="searchRange">The search range in miles (optional, default to 5D)</param>
        /// <param name="keyword">Keyword to search within permissionable records (optional)</param>
        /// <param name="pending">Return user permissions that are pending (optional)</param>
        /// <param name="admin">Return user permissions that are admins (optional)</param>
        /// <param name="start">The start index for pagination (optional, default to 0)</param>
        /// <param name="limit">The limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPermissionablesFollowingDistanceApiResponse"/>?&gt;</returns>
        Task<ISearchPermissionablesFollowingDistanceApiResponse?> SearchPermissionablesFollowingDistanceOrDefaultAsync(double latitude, double longitude, Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionAccountId = default, Option<string> connectionAccountIds = default, Option<string> permissionableType = default, Option<long> permissionableId = default, Option<double> searchRange = default, Option<string> keyword = default, Option<bool> pending = default, Option<bool> admin = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IAddUsersToPermissionableApiResponse"/>
    /// </summary>
    public interface IAddUsersToPermissionableApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IApprovePermissionableApiResponse"/>
    /// </summary>
    public interface IApprovePermissionableApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ILeaveFromPermissionableApiResponse"/>
    /// </summary>
    public interface ILeaveFromPermissionableApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IRemoveUsersFromPermissionableApiResponse"/>
    /// </summary>
    public interface IRemoveUsersFromPermissionableApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchPermissionablesApiResponse"/>
    /// </summary>
    public interface ISearchPermissionablesApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<UserPermissionsResponse>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchPermissionablesFollowingDistanceApiResponse"/>
    /// </summary>
    public interface ISearchPermissionablesFollowingDistanceApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<UserPermissionsResponse>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class UserPermissionsApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddUsersToPermissionable;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddUsersToPermissionable;

        internal void ExecuteOnAddUsersToPermissionable(UserPermissionsApi.AddUsersToPermissionableApiResponse apiResponse)
        {
            OnAddUsersToPermissionable?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddUsersToPermissionable(Exception exception)
        {
            OnErrorAddUsersToPermissionable?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApprovePermissionable;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApprovePermissionable;

        internal void ExecuteOnApprovePermissionable(UserPermissionsApi.ApprovePermissionableApiResponse apiResponse)
        {
            OnApprovePermissionable?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApprovePermissionable(Exception exception)
        {
            OnErrorApprovePermissionable?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnLeaveFromPermissionable;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorLeaveFromPermissionable;

        internal void ExecuteOnLeaveFromPermissionable(UserPermissionsApi.LeaveFromPermissionableApiResponse apiResponse)
        {
            OnLeaveFromPermissionable?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorLeaveFromPermissionable(Exception exception)
        {
            OnErrorLeaveFromPermissionable?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRemoveUsersFromPermissionable;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRemoveUsersFromPermissionable;

        internal void ExecuteOnRemoveUsersFromPermissionable(UserPermissionsApi.RemoveUsersFromPermissionableApiResponse apiResponse)
        {
            OnRemoveUsersFromPermissionable?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRemoveUsersFromPermissionable(Exception exception)
        {
            OnErrorRemoveUsersFromPermissionable?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchPermissionables;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchPermissionables;

        internal void ExecuteOnSearchPermissionables(UserPermissionsApi.SearchPermissionablesApiResponse apiResponse)
        {
            OnSearchPermissionables?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchPermissionables(Exception exception)
        {
            OnErrorSearchPermissionables?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchPermissionablesFollowingDistance;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchPermissionablesFollowingDistance;

        internal void ExecuteOnSearchPermissionablesFollowingDistance(UserPermissionsApi.SearchPermissionablesFollowingDistanceApiResponse apiResponse)
        {
            OnSearchPermissionablesFollowingDistance?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchPermissionablesFollowingDistance(Exception exception)
        {
            OnErrorSearchPermissionablesFollowingDistance?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class UserPermissionsApi : IUserPermissionsApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<UserPermissionsApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public UserPermissionsApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="UserPermissionsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public UserPermissionsApi(ILogger<UserPermissionsApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, UserPermissionsApiEvents userPermissionsApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<UserPermissionsApi>();
            HttpClient = httpClient;
            Events = userPermissionsApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatAddUsersToPermissionable(ref string permissionableType, ref long permissionableId, ref Option<string> deviceId, ref Option<long> accountId, ref Option<bool> read, ref Option<bool> write, ref Option<bool> delete, ref Option<bool> add, ref Option<string> connectionIds, ref Option<string> connectionAccountIds, ref Option<string> connectionGroupIds, ref Option<bool> pending, ref Option<bool> admin, ref Option<bool> includeFriendGroup, ref Option<double> latitude, ref Option<double> longitude, ref Option<string> audienceIds);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="permissionableType"></param>
        /// <param name="deviceId"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="audienceIds"></param>
        /// <returns></returns>
        private void ValidateAddUsersToPermissionable(string permissionableType, Option<string> deviceId, Option<string> connectionIds, Option<string> connectionAccountIds, Option<string> connectionGroupIds, Option<string> audienceIds)
        {
            if (permissionableType == null)
                throw new ArgumentNullException(nameof(permissionableType));

            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (connectionIds.IsSet && connectionIds.Value == null)
                throw new ArgumentNullException(nameof(connectionIds));

            if (connectionAccountIds.IsSet && connectionAccountIds.Value == null)
                throw new ArgumentNullException(nameof(connectionAccountIds));

            if (connectionGroupIds.IsSet && connectionGroupIds.Value == null)
                throw new ArgumentNullException(nameof(connectionGroupIds));

            if (audienceIds.IsSet && audienceIds.Value == null)
                throw new ArgumentNullException(nameof(audienceIds));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="read"></param>
        /// <param name="write"></param>
        /// <param name="delete"></param>
        /// <param name="add"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="pending"></param>
        /// <param name="admin"></param>
        /// <param name="includeFriendGroup"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="audienceIds"></param>
        private void AfterAddUsersToPermissionableDefaultImplementation(IAddUsersToPermissionableApiResponse apiResponseLocalVar, string permissionableType, long permissionableId, Option<string> deviceId, Option<long> accountId, Option<bool> read, Option<bool> write, Option<bool> delete, Option<bool> add, Option<string> connectionIds, Option<string> connectionAccountIds, Option<string> connectionGroupIds, Option<bool> pending, Option<bool> admin, Option<bool> includeFriendGroup, Option<double> latitude, Option<double> longitude, Option<string> audienceIds)
        {
            bool suppressDefaultLog = false;
            AfterAddUsersToPermissionable(ref suppressDefaultLog, apiResponseLocalVar, permissionableType, permissionableId, deviceId, accountId, read, write, delete, add, connectionIds, connectionAccountIds, connectionGroupIds, pending, admin, includeFriendGroup, latitude, longitude, audienceIds);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="read"></param>
        /// <param name="write"></param>
        /// <param name="delete"></param>
        /// <param name="add"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="pending"></param>
        /// <param name="admin"></param>
        /// <param name="includeFriendGroup"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="audienceIds"></param>
        partial void AfterAddUsersToPermissionable(ref bool suppressDefaultLog, IAddUsersToPermissionableApiResponse apiResponseLocalVar, string permissionableType, long permissionableId, Option<string> deviceId, Option<long> accountId, Option<bool> read, Option<bool> write, Option<bool> delete, Option<bool> add, Option<string> connectionIds, Option<string> connectionAccountIds, Option<string> connectionGroupIds, Option<bool> pending, Option<bool> admin, Option<bool> includeFriendGroup, Option<double> latitude, Option<double> longitude, Option<string> audienceIds);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="read"></param>
        /// <param name="write"></param>
        /// <param name="delete"></param>
        /// <param name="add"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="pending"></param>
        /// <param name="admin"></param>
        /// <param name="includeFriendGroup"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="audienceIds"></param>
        private void OnErrorAddUsersToPermissionableDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string permissionableType, long permissionableId, Option<string> deviceId, Option<long> accountId, Option<bool> read, Option<bool> write, Option<bool> delete, Option<bool> add, Option<string> connectionIds, Option<string> connectionAccountIds, Option<string> connectionGroupIds, Option<bool> pending, Option<bool> admin, Option<bool> includeFriendGroup, Option<double> latitude, Option<double> longitude, Option<string> audienceIds)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAddUsersToPermissionable(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, permissionableType, permissionableId, deviceId, accountId, read, write, delete, add, connectionIds, connectionAccountIds, connectionGroupIds, pending, admin, includeFriendGroup, latitude, longitude, audienceIds);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="read"></param>
        /// <param name="write"></param>
        /// <param name="delete"></param>
        /// <param name="add"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="pending"></param>
        /// <param name="admin"></param>
        /// <param name="includeFriendGroup"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="audienceIds"></param>
        partial void OnErrorAddUsersToPermissionable(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string permissionableType, long permissionableId, Option<string> deviceId, Option<long> accountId, Option<bool> read, Option<bool> write, Option<bool> delete, Option<bool> add, Option<string> connectionIds, Option<string> connectionAccountIds, Option<string> connectionGroupIds, Option<bool> pending, Option<bool> admin, Option<bool> includeFriendGroup, Option<double> latitude, Option<double> longitude, Option<string> audienceIds);

        /// <summary>
        /// Add User Adds a user to a permissionable object.
        /// </summary>
        /// <param name="permissionableType">the permissionable type of the object</param>
        /// <param name="permissionableId">the id of the permissionable object</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="read">the read permission of the users/groups (optional, default to true)</param>
        /// <param name="write">the write permission of the users/groups (optional, default to false)</param>
        /// <param name="delete">the delete permission of the users/groups (optional, default to false)</param>
        /// <param name="add">the add permission of the users/groups (optional, default to false)</param>
        /// <param name="connectionIds">a comma separated list of connection ids (NOT the account ids) (optional)</param>
        /// <param name="connectionAccountIds">a comma separated list of account ids (optional)</param>
        /// <param name="connectionGroupIds">a comma separated list of connection group ids (these are groups made by the user) (optional)</param>
        /// <param name="pending">sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept) (optional, default to false)</param>
        /// <param name="admin">sets whether the added users will become admins or not (optional)</param>
        /// <param name="includeFriendGroup">flag to determine whether to include the built-in \&quot;friends\&quot; group (optional, default to false)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="audienceIds">comma separated list of audience ids. This is a feature only available to the permissionable&#39;s application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddUsersToPermissionableApiResponse"/>&gt;</returns>
        public async Task<IAddUsersToPermissionableApiResponse?> AddUsersToPermissionableOrDefaultAsync(string permissionableType, long permissionableId, Option<string> deviceId = default, Option<long> accountId = default, Option<bool> read = default, Option<bool> write = default, Option<bool> delete = default, Option<bool> add = default, Option<string> connectionIds = default, Option<string> connectionAccountIds = default, Option<string> connectionGroupIds = default, Option<bool> pending = default, Option<bool> admin = default, Option<bool> includeFriendGroup = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> audienceIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddUsersToPermissionableAsync(permissionableType, permissionableId, deviceId, accountId, read, write, delete, add, connectionIds, connectionAccountIds, connectionGroupIds, pending, admin, includeFriendGroup, latitude, longitude, audienceIds, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Add User Adds a user to a permissionable object.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="permissionableType">the permissionable type of the object</param>
        /// <param name="permissionableId">the id of the permissionable object</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="read">the read permission of the users/groups (optional, default to true)</param>
        /// <param name="write">the write permission of the users/groups (optional, default to false)</param>
        /// <param name="delete">the delete permission of the users/groups (optional, default to false)</param>
        /// <param name="add">the add permission of the users/groups (optional, default to false)</param>
        /// <param name="connectionIds">a comma separated list of connection ids (NOT the account ids) (optional)</param>
        /// <param name="connectionAccountIds">a comma separated list of account ids (optional)</param>
        /// <param name="connectionGroupIds">a comma separated list of connection group ids (these are groups made by the user) (optional)</param>
        /// <param name="pending">sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept) (optional, default to false)</param>
        /// <param name="admin">sets whether the added users will become admins or not (optional)</param>
        /// <param name="includeFriendGroup">flag to determine whether to include the built-in \&quot;friends\&quot; group (optional, default to false)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="audienceIds">comma separated list of audience ids. This is a feature only available to the permissionable&#39;s application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddUsersToPermissionableApiResponse"/>&gt;</returns>
        public async Task<IAddUsersToPermissionableApiResponse> AddUsersToPermissionableAsync(string permissionableType, long permissionableId, Option<string> deviceId = default, Option<long> accountId = default, Option<bool> read = default, Option<bool> write = default, Option<bool> delete = default, Option<bool> add = default, Option<string> connectionIds = default, Option<string> connectionAccountIds = default, Option<string> connectionGroupIds = default, Option<bool> pending = default, Option<bool> admin = default, Option<bool> includeFriendGroup = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> audienceIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddUsersToPermissionable(permissionableType, deviceId, connectionIds, connectionAccountIds, connectionGroupIds, audienceIds);

                FormatAddUsersToPermissionable(ref permissionableType, ref permissionableId, ref deviceId, ref accountId, ref read, ref write, ref delete, ref add, ref connectionIds, ref connectionAccountIds, ref connectionGroupIds, ref pending, ref admin, ref includeFriendGroup, ref latitude, ref longitude, ref audienceIds);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/permissions/add"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/permissions/add");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["permissionableType"] = ClientUtils.ParameterToString(permissionableType);
                    parseQueryStringLocalVar["permissionableId"] = ClientUtils.ParameterToString(permissionableId);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (read.IsSet)
                        parseQueryStringLocalVar["read"] = ClientUtils.ParameterToString(read.Value);

                    if (write.IsSet)
                        parseQueryStringLocalVar["write"] = ClientUtils.ParameterToString(write.Value);

                    if (delete.IsSet)
                        parseQueryStringLocalVar["delete"] = ClientUtils.ParameterToString(delete.Value);

                    if (add.IsSet)
                        parseQueryStringLocalVar["add"] = ClientUtils.ParameterToString(add.Value);

                    if (connectionIds.IsSet)
                        parseQueryStringLocalVar["connectionIds"] = ClientUtils.ParameterToString(connectionIds.Value);

                    if (connectionAccountIds.IsSet)
                        parseQueryStringLocalVar["connectionAccountIds"] = ClientUtils.ParameterToString(connectionAccountIds.Value);

                    if (connectionGroupIds.IsSet)
                        parseQueryStringLocalVar["connectionGroupIds"] = ClientUtils.ParameterToString(connectionGroupIds.Value);

                    if (pending.IsSet)
                        parseQueryStringLocalVar["pending"] = ClientUtils.ParameterToString(pending.Value);

                    if (admin.IsSet)
                        parseQueryStringLocalVar["admin"] = ClientUtils.ParameterToString(admin.Value);

                    if (includeFriendGroup.IsSet)
                        parseQueryStringLocalVar["includeFriendGroup"] = ClientUtils.ParameterToString(includeFriendGroup.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    if (audienceIds.IsSet)
                        parseQueryStringLocalVar["audienceIds"] = ClientUtils.ParameterToString(audienceIds.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<AddUsersToPermissionableApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddUsersToPermissionableApiResponse>();
                        AddUsersToPermissionableApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/permissions/add", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterAddUsersToPermissionableDefaultImplementation(apiResponseLocalVar, permissionableType, permissionableId, deviceId, accountId, read, write, delete, add, connectionIds, connectionAccountIds, connectionGroupIds, pending, admin, includeFriendGroup, latitude, longitude, audienceIds);

                        Events.ExecuteOnAddUsersToPermissionable(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddUsersToPermissionableDefaultImplementation(e, "/consumer/permissions/add", uriBuilderLocalVar.Path, permissionableType, permissionableId, deviceId, accountId, read, write, delete, add, connectionIds, connectionAccountIds, connectionGroupIds, pending, admin, includeFriendGroup, latitude, longitude, audienceIds);
                Events.ExecuteOnErrorAddUsersToPermissionable(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddUsersToPermissionableApiResponse"/>
        /// </summary>
        public partial class AddUsersToPermissionableApiResponse : Org.OpenAPITools.Client.ApiResponse, IAddUsersToPermissionableApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddUsersToPermissionableApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddUsersToPermissionableApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddUsersToPermissionableApiResponse(ILogger<AddUsersToPermissionableApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="AddUsersToPermissionableApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddUsersToPermissionableApiResponse(ILogger<AddUsersToPermissionableApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatApprovePermissionable(ref string permissionableType, ref long permissionableId, ref Option<string> deviceId, ref Option<long> accountId, ref Option<string> approvalStatus);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="permissionableType"></param>
        /// <param name="deviceId"></param>
        /// <param name="approvalStatus"></param>
        /// <returns></returns>
        private void ValidateApprovePermissionable(string permissionableType, Option<string> deviceId, Option<string> approvalStatus)
        {
            if (permissionableType == null)
                throw new ArgumentNullException(nameof(permissionableType));

            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (approvalStatus.IsSet && approvalStatus.Value == null)
                throw new ArgumentNullException(nameof(approvalStatus));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="approvalStatus"></param>
        private void AfterApprovePermissionableDefaultImplementation(IApprovePermissionableApiResponse apiResponseLocalVar, string permissionableType, long permissionableId, Option<string> deviceId, Option<long> accountId, Option<string> approvalStatus)
        {
            bool suppressDefaultLog = false;
            AfterApprovePermissionable(ref suppressDefaultLog, apiResponseLocalVar, permissionableType, permissionableId, deviceId, accountId, approvalStatus);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="approvalStatus"></param>
        partial void AfterApprovePermissionable(ref bool suppressDefaultLog, IApprovePermissionableApiResponse apiResponseLocalVar, string permissionableType, long permissionableId, Option<string> deviceId, Option<long> accountId, Option<string> approvalStatus);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="approvalStatus"></param>
        private void OnErrorApprovePermissionableDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string permissionableType, long permissionableId, Option<string> deviceId, Option<long> accountId, Option<string> approvalStatus)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApprovePermissionable(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, permissionableType, permissionableId, deviceId, accountId, approvalStatus);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="approvalStatus"></param>
        partial void OnErrorApprovePermissionable(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string permissionableType, long permissionableId, Option<string> deviceId, Option<long> accountId, Option<string> approvalStatus);

        /// <summary>
        /// Approve Permissionable Sets the approval status of a permissionable object.
        /// </summary>
        /// <param name="permissionableType">The permissionable type of the object</param>
        /// <param name="permissionableId">The id of the permissionable object</param>
        /// <param name="deviceId">A unique ID given by the device (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">The account ID of the user (deviceId or accountId required) (optional)</param>
        /// <param name="approvalStatus">The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional, default to APPROVED)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApprovePermissionableApiResponse"/>&gt;</returns>
        public async Task<IApprovePermissionableApiResponse?> ApprovePermissionableOrDefaultAsync(string permissionableType, long permissionableId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> approvalStatus = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApprovePermissionableAsync(permissionableType, permissionableId, deviceId, accountId, approvalStatus, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Approve Permissionable Sets the approval status of a permissionable object.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="permissionableType">The permissionable type of the object</param>
        /// <param name="permissionableId">The id of the permissionable object</param>
        /// <param name="deviceId">A unique ID given by the device (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">The account ID of the user (deviceId or accountId required) (optional)</param>
        /// <param name="approvalStatus">The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (optional, default to APPROVED)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApprovePermissionableApiResponse"/>&gt;</returns>
        public async Task<IApprovePermissionableApiResponse> ApprovePermissionableAsync(string permissionableType, long permissionableId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> approvalStatus = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApprovePermissionable(permissionableType, deviceId, approvalStatus);

                FormatApprovePermissionable(ref permissionableType, ref permissionableId, ref deviceId, ref accountId, ref approvalStatus);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/permissionable/approve"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/permissionable/approve");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["permissionableType"] = ClientUtils.ParameterToString(permissionableType);
                    parseQueryStringLocalVar["permissionableId"] = ClientUtils.ParameterToString(permissionableId);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (approvalStatus.IsSet)
                        parseQueryStringLocalVar["approvalStatus"] = ClientUtils.ParameterToString(approvalStatus.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ApprovePermissionableApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApprovePermissionableApiResponse>();
                        ApprovePermissionableApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/permissionable/approve", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterApprovePermissionableDefaultImplementation(apiResponseLocalVar, permissionableType, permissionableId, deviceId, accountId, approvalStatus);

                        Events.ExecuteOnApprovePermissionable(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApprovePermissionableDefaultImplementation(e, "/permissionable/approve", uriBuilderLocalVar.Path, permissionableType, permissionableId, deviceId, accountId, approvalStatus);
                Events.ExecuteOnErrorApprovePermissionable(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApprovePermissionableApiResponse"/>
        /// </summary>
        public partial class ApprovePermissionableApiResponse : Org.OpenAPITools.Client.ApiResponse, IApprovePermissionableApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApprovePermissionableApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApprovePermissionableApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApprovePermissionableApiResponse(ILogger<ApprovePermissionableApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ApprovePermissionableApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApprovePermissionableApiResponse(ILogger<ApprovePermissionableApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatLeaveFromPermissionable(ref string permissionableType, ref long permissionableId, ref Option<string> deviceId, ref Option<long> accountId, ref Option<double> latitude, ref Option<double> longitude);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="permissionableType"></param>
        /// <param name="deviceId"></param>
        /// <returns></returns>
        private void ValidateLeaveFromPermissionable(string permissionableType, Option<string> deviceId)
        {
            if (permissionableType == null)
                throw new ArgumentNullException(nameof(permissionableType));

            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void AfterLeaveFromPermissionableDefaultImplementation(ILeaveFromPermissionableApiResponse apiResponseLocalVar, string permissionableType, long permissionableId, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLog = false;
            AfterLeaveFromPermissionable(ref suppressDefaultLog, apiResponseLocalVar, permissionableType, permissionableId, deviceId, accountId, latitude, longitude);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void AfterLeaveFromPermissionable(ref bool suppressDefaultLog, ILeaveFromPermissionableApiResponse apiResponseLocalVar, string permissionableType, long permissionableId, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void OnErrorLeaveFromPermissionableDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string permissionableType, long permissionableId, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorLeaveFromPermissionable(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, permissionableType, permissionableId, deviceId, accountId, latitude, longitude);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void OnErrorLeaveFromPermissionable(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string permissionableType, long permissionableId, Option<string> deviceId, Option<long> accountId, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Leave Used when the user wants to leave from someone else&#39;s permissionable object
        /// </summary>
        /// <param name="permissionableType">the permissionable type PermissionableType</param>
        /// <param name="permissionableId">the id of the permissionable object</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ILeaveFromPermissionableApiResponse"/>&gt;</returns>
        public async Task<ILeaveFromPermissionableApiResponse?> LeaveFromPermissionableOrDefaultAsync(string permissionableType, long permissionableId, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await LeaveFromPermissionableAsync(permissionableType, permissionableId, deviceId, accountId, latitude, longitude, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Leave Used when the user wants to leave from someone else&#39;s permissionable object
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="permissionableType">the permissionable type PermissionableType</param>
        /// <param name="permissionableId">the id of the permissionable object</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ILeaveFromPermissionableApiResponse"/>&gt;</returns>
        public async Task<ILeaveFromPermissionableApiResponse> LeaveFromPermissionableAsync(string permissionableType, long permissionableId, Option<string> deviceId = default, Option<long> accountId = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateLeaveFromPermissionable(permissionableType, deviceId);

                FormatLeaveFromPermissionable(ref permissionableType, ref permissionableId, ref deviceId, ref accountId, ref latitude, ref longitude);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/permissions/leave"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/permissions/leave");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["permissionableType"] = ClientUtils.ParameterToString(permissionableType);
                    parseQueryStringLocalVar["permissionableId"] = ClientUtils.ParameterToString(permissionableId);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<LeaveFromPermissionableApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<LeaveFromPermissionableApiResponse>();
                        LeaveFromPermissionableApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/permissions/leave", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterLeaveFromPermissionableDefaultImplementation(apiResponseLocalVar, permissionableType, permissionableId, deviceId, accountId, latitude, longitude);

                        Events.ExecuteOnLeaveFromPermissionable(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorLeaveFromPermissionableDefaultImplementation(e, "/consumer/permissions/leave", uriBuilderLocalVar.Path, permissionableType, permissionableId, deviceId, accountId, latitude, longitude);
                Events.ExecuteOnErrorLeaveFromPermissionable(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="LeaveFromPermissionableApiResponse"/>
        /// </summary>
        public partial class LeaveFromPermissionableApiResponse : Org.OpenAPITools.Client.ApiResponse, ILeaveFromPermissionableApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<LeaveFromPermissionableApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="LeaveFromPermissionableApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public LeaveFromPermissionableApiResponse(ILogger<LeaveFromPermissionableApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="LeaveFromPermissionableApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public LeaveFromPermissionableApiResponse(ILogger<LeaveFromPermissionableApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRemoveUsersFromPermissionable(ref string permissionableType, ref long permissionableId, ref Option<string> deviceId, ref Option<long> accountId, ref Option<string> connectionIds, ref Option<string> connectionAccountIds, ref Option<string> connectionGroupIds, ref Option<bool> removeFriendGroup, ref Option<double> latitude, ref Option<double> longitude, ref Option<string> audienceIds);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="permissionableType"></param>
        /// <param name="deviceId"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="audienceIds"></param>
        /// <returns></returns>
        private void ValidateRemoveUsersFromPermissionable(string permissionableType, Option<string> deviceId, Option<string> connectionIds, Option<string> connectionAccountIds, Option<string> connectionGroupIds, Option<string> audienceIds)
        {
            if (permissionableType == null)
                throw new ArgumentNullException(nameof(permissionableType));

            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (connectionIds.IsSet && connectionIds.Value == null)
                throw new ArgumentNullException(nameof(connectionIds));

            if (connectionAccountIds.IsSet && connectionAccountIds.Value == null)
                throw new ArgumentNullException(nameof(connectionAccountIds));

            if (connectionGroupIds.IsSet && connectionGroupIds.Value == null)
                throw new ArgumentNullException(nameof(connectionGroupIds));

            if (audienceIds.IsSet && audienceIds.Value == null)
                throw new ArgumentNullException(nameof(audienceIds));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="removeFriendGroup"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="audienceIds"></param>
        private void AfterRemoveUsersFromPermissionableDefaultImplementation(IRemoveUsersFromPermissionableApiResponse apiResponseLocalVar, string permissionableType, long permissionableId, Option<string> deviceId, Option<long> accountId, Option<string> connectionIds, Option<string> connectionAccountIds, Option<string> connectionGroupIds, Option<bool> removeFriendGroup, Option<double> latitude, Option<double> longitude, Option<string> audienceIds)
        {
            bool suppressDefaultLog = false;
            AfterRemoveUsersFromPermissionable(ref suppressDefaultLog, apiResponseLocalVar, permissionableType, permissionableId, deviceId, accountId, connectionIds, connectionAccountIds, connectionGroupIds, removeFriendGroup, latitude, longitude, audienceIds);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="removeFriendGroup"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="audienceIds"></param>
        partial void AfterRemoveUsersFromPermissionable(ref bool suppressDefaultLog, IRemoveUsersFromPermissionableApiResponse apiResponseLocalVar, string permissionableType, long permissionableId, Option<string> deviceId, Option<long> accountId, Option<string> connectionIds, Option<string> connectionAccountIds, Option<string> connectionGroupIds, Option<bool> removeFriendGroup, Option<double> latitude, Option<double> longitude, Option<string> audienceIds);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="removeFriendGroup"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="audienceIds"></param>
        private void OnErrorRemoveUsersFromPermissionableDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string permissionableType, long permissionableId, Option<string> deviceId, Option<long> accountId, Option<string> connectionIds, Option<string> connectionAccountIds, Option<string> connectionGroupIds, Option<bool> removeFriendGroup, Option<double> latitude, Option<double> longitude, Option<string> audienceIds)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorRemoveUsersFromPermissionable(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, permissionableType, permissionableId, deviceId, accountId, connectionIds, connectionAccountIds, connectionGroupIds, removeFriendGroup, latitude, longitude, audienceIds);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="removeFriendGroup"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="audienceIds"></param>
        partial void OnErrorRemoveUsersFromPermissionable(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string permissionableType, long permissionableId, Option<string> deviceId, Option<long> accountId, Option<string> connectionIds, Option<string> connectionAccountIds, Option<string> connectionGroupIds, Option<bool> removeFriendGroup, Option<double> latitude, Option<double> longitude, Option<string> audienceIds);

        /// <summary>
        /// Remove User Used to remove someone (assuming they have permission) from a permissionable object
        /// </summary>
        /// <param name="permissionableType">the permissionable type of the object</param>
        /// <param name="permissionableId">the id of the permissionable object</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionIds">a comma separated list of connection ids (NOT the account ids) (optional)</param>
        /// <param name="connectionAccountIds">a comma separated list of account ids (optional)</param>
        /// <param name="connectionGroupIds">a comma separated list of connection group ids (these are groups made by the user) (optional)</param>
        /// <param name="removeFriendGroup">flag to determine whether to remove the built-in \&quot;friends\&quot; group (optional, default to false)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="audienceIds">comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveUsersFromPermissionableApiResponse"/>&gt;</returns>
        public async Task<IRemoveUsersFromPermissionableApiResponse?> RemoveUsersFromPermissionableOrDefaultAsync(string permissionableType, long permissionableId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> connectionIds = default, Option<string> connectionAccountIds = default, Option<string> connectionGroupIds = default, Option<bool> removeFriendGroup = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> audienceIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RemoveUsersFromPermissionableAsync(permissionableType, permissionableId, deviceId, accountId, connectionIds, connectionAccountIds, connectionGroupIds, removeFriendGroup, latitude, longitude, audienceIds, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Remove User Used to remove someone (assuming they have permission) from a permissionable object
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="permissionableType">the permissionable type of the object</param>
        /// <param name="permissionableId">the id of the permissionable object</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionIds">a comma separated list of connection ids (NOT the account ids) (optional)</param>
        /// <param name="connectionAccountIds">a comma separated list of account ids (optional)</param>
        /// <param name="connectionGroupIds">a comma separated list of connection group ids (these are groups made by the user) (optional)</param>
        /// <param name="removeFriendGroup">flag to determine whether to remove the built-in \&quot;friends\&quot; group (optional, default to false)</param>
        /// <param name="latitude">the current latitude of the user (optional)</param>
        /// <param name="longitude">the current longitude of the user (optional)</param>
        /// <param name="audienceIds">comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveUsersFromPermissionableApiResponse"/>&gt;</returns>
        public async Task<IRemoveUsersFromPermissionableApiResponse> RemoveUsersFromPermissionableAsync(string permissionableType, long permissionableId, Option<string> deviceId = default, Option<long> accountId = default, Option<string> connectionIds = default, Option<string> connectionAccountIds = default, Option<string> connectionGroupIds = default, Option<bool> removeFriendGroup = default, Option<double> latitude = default, Option<double> longitude = default, Option<string> audienceIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateRemoveUsersFromPermissionable(permissionableType, deviceId, connectionIds, connectionAccountIds, connectionGroupIds, audienceIds);

                FormatRemoveUsersFromPermissionable(ref permissionableType, ref permissionableId, ref deviceId, ref accountId, ref connectionIds, ref connectionAccountIds, ref connectionGroupIds, ref removeFriendGroup, ref latitude, ref longitude, ref audienceIds);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/consumer/permissions/remove"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/consumer/permissions/remove");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["permissionableType"] = ClientUtils.ParameterToString(permissionableType);
                    parseQueryStringLocalVar["permissionableId"] = ClientUtils.ParameterToString(permissionableId);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (connectionIds.IsSet)
                        parseQueryStringLocalVar["connectionIds"] = ClientUtils.ParameterToString(connectionIds.Value);

                    if (connectionAccountIds.IsSet)
                        parseQueryStringLocalVar["connectionAccountIds"] = ClientUtils.ParameterToString(connectionAccountIds.Value);

                    if (connectionGroupIds.IsSet)
                        parseQueryStringLocalVar["connectionGroupIds"] = ClientUtils.ParameterToString(connectionGroupIds.Value);

                    if (removeFriendGroup.IsSet)
                        parseQueryStringLocalVar["removeFriendGroup"] = ClientUtils.ParameterToString(removeFriendGroup.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    if (audienceIds.IsSet)
                        parseQueryStringLocalVar["audienceIds"] = ClientUtils.ParameterToString(audienceIds.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<RemoveUsersFromPermissionableApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RemoveUsersFromPermissionableApiResponse>();
                        RemoveUsersFromPermissionableApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/consumer/permissions/remove", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterRemoveUsersFromPermissionableDefaultImplementation(apiResponseLocalVar, permissionableType, permissionableId, deviceId, accountId, connectionIds, connectionAccountIds, connectionGroupIds, removeFriendGroup, latitude, longitude, audienceIds);

                        Events.ExecuteOnRemoveUsersFromPermissionable(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRemoveUsersFromPermissionableDefaultImplementation(e, "/consumer/permissions/remove", uriBuilderLocalVar.Path, permissionableType, permissionableId, deviceId, accountId, connectionIds, connectionAccountIds, connectionGroupIds, removeFriendGroup, latitude, longitude, audienceIds);
                Events.ExecuteOnErrorRemoveUsersFromPermissionable(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RemoveUsersFromPermissionableApiResponse"/>
        /// </summary>
        public partial class RemoveUsersFromPermissionableApiResponse : Org.OpenAPITools.Client.ApiResponse, IRemoveUsersFromPermissionableApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RemoveUsersFromPermissionableApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RemoveUsersFromPermissionableApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveUsersFromPermissionableApiResponse(ILogger<RemoveUsersFromPermissionableApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="RemoveUsersFromPermissionableApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveUsersFromPermissionableApiResponse(ILogger<RemoveUsersFromPermissionableApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchPermissionables(ref Option<string> deviceId, ref Option<long> accountId, ref Option<long> connectionAccountId, ref Option<string> connectionAccountIds, ref Option<string> permissionableType, ref Option<long> permissionableId, ref Option<string> keyword, ref Option<string> sortField, ref Option<bool> descending, ref Option<bool> pending, ref Option<bool> admin, ref Option<int> start, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="permissionableType"></param>
        /// <param name="keyword"></param>
        /// <param name="sortField"></param>
        /// <returns></returns>
        private void ValidateSearchPermissionables(Option<string> deviceId, Option<string> connectionAccountIds, Option<string> permissionableType, Option<string> keyword, Option<string> sortField)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (connectionAccountIds.IsSet && connectionAccountIds.Value == null)
                throw new ArgumentNullException(nameof(connectionAccountIds));

            if (permissionableType.IsSet && permissionableType.Value == null)
                throw new ArgumentNullException(nameof(permissionableType));

            if (keyword.IsSet && keyword.Value == null)
                throw new ArgumentNullException(nameof(keyword));

            if (sortField.IsSet && sortField.Value == null)
                throw new ArgumentNullException(nameof(sortField));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="keyword"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="pending"></param>
        /// <param name="admin"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void AfterSearchPermissionablesDefaultImplementation(ISearchPermissionablesApiResponse apiResponseLocalVar, Option<string> deviceId, Option<long> accountId, Option<long> connectionAccountId, Option<string> connectionAccountIds, Option<string> permissionableType, Option<long> permissionableId, Option<string> keyword, Option<string> sortField, Option<bool> descending, Option<bool> pending, Option<bool> admin, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterSearchPermissionables(ref suppressDefaultLog, apiResponseLocalVar, deviceId, accountId, connectionAccountId, connectionAccountIds, permissionableType, permissionableId, keyword, sortField, descending, pending, admin, start, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="keyword"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="pending"></param>
        /// <param name="admin"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void AfterSearchPermissionables(ref bool suppressDefaultLog, ISearchPermissionablesApiResponse apiResponseLocalVar, Option<string> deviceId, Option<long> accountId, Option<long> connectionAccountId, Option<string> connectionAccountIds, Option<string> permissionableType, Option<long> permissionableId, Option<string> keyword, Option<string> sortField, Option<bool> descending, Option<bool> pending, Option<bool> admin, Option<int> start, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="keyword"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="pending"></param>
        /// <param name="admin"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void OnErrorSearchPermissionablesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> deviceId, Option<long> accountId, Option<long> connectionAccountId, Option<string> connectionAccountIds, Option<string> permissionableType, Option<long> permissionableId, Option<string> keyword, Option<string> sortField, Option<bool> descending, Option<bool> pending, Option<bool> admin, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchPermissionables(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, deviceId, accountId, connectionAccountId, connectionAccountIds, permissionableType, permissionableId, keyword, sortField, descending, pending, admin, start, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="keyword"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="pending"></param>
        /// <param name="admin"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void OnErrorSearchPermissionables(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> deviceId, Option<long> accountId, Option<long> connectionAccountId, Option<string> connectionAccountIds, Option<string> permissionableType, Option<long> permissionableId, Option<string> keyword, Option<string> sortField, Option<bool> descending, Option<bool> pending, Option<bool> admin, Option<int> start, Option<int> limit);

        /// <summary>
        /// Search Permissionables Search on UserPermissions
        /// </summary>
        /// <param name="deviceId">A unique ID given by the device (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">The account ID of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionAccountId">Filter results for a specific user account (optional)</param>
        /// <param name="connectionAccountIds">Comma separated list of account IDs to filter results with (optional)</param>
        /// <param name="permissionableType">Filter user permissions by the permissionable object type (optional)</param>
        /// <param name="permissionableId">The id of the permissionable object to filter by (optional)</param>
        /// <param name="keyword">Keyword to search within permissionable records (optional)</param>
        /// <param name="sortField">Field to sort results on (optional)</param>
        /// <param name="descending">Sort descending when true (optional)</param>
        /// <param name="pending">Return user permissions that are pending (optional)</param>
        /// <param name="admin">Return user permissions that are admins (optional)</param>
        /// <param name="start">the start index for pagination (optional, default to 0)</param>
        /// <param name="limit">the limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPermissionablesApiResponse"/>&gt;</returns>
        public async Task<ISearchPermissionablesApiResponse?> SearchPermissionablesOrDefaultAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionAccountId = default, Option<string> connectionAccountIds = default, Option<string> permissionableType = default, Option<long> permissionableId = default, Option<string> keyword = default, Option<string> sortField = default, Option<bool> descending = default, Option<bool> pending = default, Option<bool> admin = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchPermissionablesAsync(deviceId, accountId, connectionAccountId, connectionAccountIds, permissionableType, permissionableId, keyword, sortField, descending, pending, admin, start, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Permissionables Search on UserPermissions
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="deviceId">A unique ID given by the device (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">The account ID of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionAccountId">Filter results for a specific user account (optional)</param>
        /// <param name="connectionAccountIds">Comma separated list of account IDs to filter results with (optional)</param>
        /// <param name="permissionableType">Filter user permissions by the permissionable object type (optional)</param>
        /// <param name="permissionableId">The id of the permissionable object to filter by (optional)</param>
        /// <param name="keyword">Keyword to search within permissionable records (optional)</param>
        /// <param name="sortField">Field to sort results on (optional)</param>
        /// <param name="descending">Sort descending when true (optional)</param>
        /// <param name="pending">Return user permissions that are pending (optional)</param>
        /// <param name="admin">Return user permissions that are admins (optional)</param>
        /// <param name="start">the start index for pagination (optional, default to 0)</param>
        /// <param name="limit">the limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPermissionablesApiResponse"/>&gt;</returns>
        public async Task<ISearchPermissionablesApiResponse> SearchPermissionablesAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionAccountId = default, Option<string> connectionAccountIds = default, Option<string> permissionableType = default, Option<long> permissionableId = default, Option<string> keyword = default, Option<string> sortField = default, Option<bool> descending = default, Option<bool> pending = default, Option<bool> admin = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchPermissionables(deviceId, connectionAccountIds, permissionableType, keyword, sortField);

                FormatSearchPermissionables(ref deviceId, ref accountId, ref connectionAccountId, ref connectionAccountIds, ref permissionableType, ref permissionableId, ref keyword, ref sortField, ref descending, ref pending, ref admin, ref start, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/permissions/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/permissions/search");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (connectionAccountId.IsSet)
                        parseQueryStringLocalVar["connectionAccountId"] = ClientUtils.ParameterToString(connectionAccountId.Value);

                    if (connectionAccountIds.IsSet)
                        parseQueryStringLocalVar["connectionAccountIds"] = ClientUtils.ParameterToString(connectionAccountIds.Value);

                    if (permissionableType.IsSet)
                        parseQueryStringLocalVar["permissionableType"] = ClientUtils.ParameterToString(permissionableType.Value);

                    if (permissionableId.IsSet)
                        parseQueryStringLocalVar["permissionableId"] = ClientUtils.ParameterToString(permissionableId.Value);

                    if (keyword.IsSet)
                        parseQueryStringLocalVar["keyword"] = ClientUtils.ParameterToString(keyword.Value);

                    if (sortField.IsSet)
                        parseQueryStringLocalVar["sortField"] = ClientUtils.ParameterToString(sortField.Value);

                    if (descending.IsSet)
                        parseQueryStringLocalVar["descending"] = ClientUtils.ParameterToString(descending.Value);

                    if (pending.IsSet)
                        parseQueryStringLocalVar["pending"] = ClientUtils.ParameterToString(pending.Value);

                    if (admin.IsSet)
                        parseQueryStringLocalVar["admin"] = ClientUtils.ParameterToString(admin.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchPermissionablesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchPermissionablesApiResponse>();
                        SearchPermissionablesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/permissions/search", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchPermissionablesDefaultImplementation(apiResponseLocalVar, deviceId, accountId, connectionAccountId, connectionAccountIds, permissionableType, permissionableId, keyword, sortField, descending, pending, admin, start, limit);

                        Events.ExecuteOnSearchPermissionables(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchPermissionablesDefaultImplementation(e, "/permissions/search", uriBuilderLocalVar.Path, deviceId, accountId, connectionAccountId, connectionAccountIds, permissionableType, permissionableId, keyword, sortField, descending, pending, admin, start, limit);
                Events.ExecuteOnErrorSearchPermissionables(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchPermissionablesApiResponse"/>
        /// </summary>
        public partial class SearchPermissionablesApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchPermissionablesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchPermissionablesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchPermissionablesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchPermissionablesApiResponse(ILogger<SearchPermissionablesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchPermissionablesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchPermissionablesApiResponse(ILogger<SearchPermissionablesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<UserPermissionsResponse>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<UserPermissionsResponse>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<UserPermissionsResponse>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchPermissionablesFollowingDistance(ref double latitude, ref double longitude, ref Option<string> deviceId, ref Option<long> accountId, ref Option<long> connectionAccountId, ref Option<string> connectionAccountIds, ref Option<string> permissionableType, ref Option<long> permissionableId, ref Option<double> searchRange, ref Option<string> keyword, ref Option<bool> pending, ref Option<bool> admin, ref Option<int> start, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="permissionableType"></param>
        /// <param name="keyword"></param>
        /// <returns></returns>
        private void ValidateSearchPermissionablesFollowingDistance(Option<string> deviceId, Option<string> connectionAccountIds, Option<string> permissionableType, Option<string> keyword)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (connectionAccountIds.IsSet && connectionAccountIds.Value == null)
                throw new ArgumentNullException(nameof(connectionAccountIds));

            if (permissionableType.IsSet && permissionableType.Value == null)
                throw new ArgumentNullException(nameof(permissionableType));

            if (keyword.IsSet && keyword.Value == null)
                throw new ArgumentNullException(nameof(keyword));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="searchRange"></param>
        /// <param name="keyword"></param>
        /// <param name="pending"></param>
        /// <param name="admin"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void AfterSearchPermissionablesFollowingDistanceDefaultImplementation(ISearchPermissionablesFollowingDistanceApiResponse apiResponseLocalVar, double latitude, double longitude, Option<string> deviceId, Option<long> accountId, Option<long> connectionAccountId, Option<string> connectionAccountIds, Option<string> permissionableType, Option<long> permissionableId, Option<double> searchRange, Option<string> keyword, Option<bool> pending, Option<bool> admin, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterSearchPermissionablesFollowingDistance(ref suppressDefaultLog, apiResponseLocalVar, latitude, longitude, deviceId, accountId, connectionAccountId, connectionAccountIds, permissionableType, permissionableId, searchRange, keyword, pending, admin, start, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="searchRange"></param>
        /// <param name="keyword"></param>
        /// <param name="pending"></param>
        /// <param name="admin"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void AfterSearchPermissionablesFollowingDistance(ref bool suppressDefaultLog, ISearchPermissionablesFollowingDistanceApiResponse apiResponseLocalVar, double latitude, double longitude, Option<string> deviceId, Option<long> accountId, Option<long> connectionAccountId, Option<string> connectionAccountIds, Option<string> permissionableType, Option<long> permissionableId, Option<double> searchRange, Option<string> keyword, Option<bool> pending, Option<bool> admin, Option<int> start, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="searchRange"></param>
        /// <param name="keyword"></param>
        /// <param name="pending"></param>
        /// <param name="admin"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void OnErrorSearchPermissionablesFollowingDistanceDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, double latitude, double longitude, Option<string> deviceId, Option<long> accountId, Option<long> connectionAccountId, Option<string> connectionAccountIds, Option<string> permissionableType, Option<long> permissionableId, Option<double> searchRange, Option<string> keyword, Option<bool> pending, Option<bool> admin, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchPermissionablesFollowingDistance(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, latitude, longitude, deviceId, accountId, connectionAccountId, connectionAccountIds, permissionableType, permissionableId, searchRange, keyword, pending, admin, start, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="permissionableType"></param>
        /// <param name="permissionableId"></param>
        /// <param name="searchRange"></param>
        /// <param name="keyword"></param>
        /// <param name="pending"></param>
        /// <param name="admin"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void OnErrorSearchPermissionablesFollowingDistance(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, double latitude, double longitude, Option<string> deviceId, Option<long> accountId, Option<long> connectionAccountId, Option<string> connectionAccountIds, Option<string> permissionableType, Option<long> permissionableId, Option<double> searchRange, Option<string> keyword, Option<bool> pending, Option<bool> admin, Option<int> start, Option<int> limit);

        /// <summary>
        /// Search Permissionables by Distnace Search on UserPermissions by distance
        /// </summary>
        /// <param name="latitude">The latitude of the current account</param>
        /// <param name="longitude">The longitude of the current account</param>
        /// <param name="deviceId">A unique ID given by the device (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">The account ID of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionAccountId">Filter results for a specific user account (optional)</param>
        /// <param name="connectionAccountIds">Comma separated list of account IDs to filter results with (optional)</param>
        /// <param name="permissionableType">Filter user permissions by the permissionable object type (optional)</param>
        /// <param name="permissionableId">The id of the permissionable object to filter by (optional)</param>
        /// <param name="searchRange">The search range in miles (optional, default to 5D)</param>
        /// <param name="keyword">Keyword to search within permissionable records (optional)</param>
        /// <param name="pending">Return user permissions that are pending (optional)</param>
        /// <param name="admin">Return user permissions that are admins (optional)</param>
        /// <param name="start">The start index for pagination (optional, default to 0)</param>
        /// <param name="limit">The limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPermissionablesFollowingDistanceApiResponse"/>&gt;</returns>
        public async Task<ISearchPermissionablesFollowingDistanceApiResponse?> SearchPermissionablesFollowingDistanceOrDefaultAsync(double latitude, double longitude, Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionAccountId = default, Option<string> connectionAccountIds = default, Option<string> permissionableType = default, Option<long> permissionableId = default, Option<double> searchRange = default, Option<string> keyword = default, Option<bool> pending = default, Option<bool> admin = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchPermissionablesFollowingDistanceAsync(latitude, longitude, deviceId, accountId, connectionAccountId, connectionAccountIds, permissionableType, permissionableId, searchRange, keyword, pending, admin, start, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Permissionables by Distnace Search on UserPermissions by distance
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude">The latitude of the current account</param>
        /// <param name="longitude">The longitude of the current account</param>
        /// <param name="deviceId">A unique ID given by the device (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">The account ID of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionAccountId">Filter results for a specific user account (optional)</param>
        /// <param name="connectionAccountIds">Comma separated list of account IDs to filter results with (optional)</param>
        /// <param name="permissionableType">Filter user permissions by the permissionable object type (optional)</param>
        /// <param name="permissionableId">The id of the permissionable object to filter by (optional)</param>
        /// <param name="searchRange">The search range in miles (optional, default to 5D)</param>
        /// <param name="keyword">Keyword to search within permissionable records (optional)</param>
        /// <param name="pending">Return user permissions that are pending (optional)</param>
        /// <param name="admin">Return user permissions that are admins (optional)</param>
        /// <param name="start">The start index for pagination (optional, default to 0)</param>
        /// <param name="limit">The limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPermissionablesFollowingDistanceApiResponse"/>&gt;</returns>
        public async Task<ISearchPermissionablesFollowingDistanceApiResponse> SearchPermissionablesFollowingDistanceAsync(double latitude, double longitude, Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionAccountId = default, Option<string> connectionAccountIds = default, Option<string> permissionableType = default, Option<long> permissionableId = default, Option<double> searchRange = default, Option<string> keyword = default, Option<bool> pending = default, Option<bool> admin = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchPermissionablesFollowingDistance(deviceId, connectionAccountIds, permissionableType, keyword);

                FormatSearchPermissionablesFollowingDistance(ref latitude, ref longitude, ref deviceId, ref accountId, ref connectionAccountId, ref connectionAccountIds, ref permissionableType, ref permissionableId, ref searchRange, ref keyword, ref pending, ref admin, ref start, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/permissions/distancesearch"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/permissions/distancesearch");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude);
                    parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (connectionAccountId.IsSet)
                        parseQueryStringLocalVar["connectionAccountId"] = ClientUtils.ParameterToString(connectionAccountId.Value);

                    if (connectionAccountIds.IsSet)
                        parseQueryStringLocalVar["connectionAccountIds"] = ClientUtils.ParameterToString(connectionAccountIds.Value);

                    if (permissionableType.IsSet)
                        parseQueryStringLocalVar["permissionableType"] = ClientUtils.ParameterToString(permissionableType.Value);

                    if (permissionableId.IsSet)
                        parseQueryStringLocalVar["permissionableId"] = ClientUtils.ParameterToString(permissionableId.Value);

                    if (searchRange.IsSet)
                        parseQueryStringLocalVar["searchRange"] = ClientUtils.ParameterToString(searchRange.Value);

                    if (keyword.IsSet)
                        parseQueryStringLocalVar["keyword"] = ClientUtils.ParameterToString(keyword.Value);

                    if (pending.IsSet)
                        parseQueryStringLocalVar["pending"] = ClientUtils.ParameterToString(pending.Value);

                    if (admin.IsSet)
                        parseQueryStringLocalVar["admin"] = ClientUtils.ParameterToString(admin.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchPermissionablesFollowingDistanceApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchPermissionablesFollowingDistanceApiResponse>();
                        SearchPermissionablesFollowingDistanceApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/permissions/distancesearch", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchPermissionablesFollowingDistanceDefaultImplementation(apiResponseLocalVar, latitude, longitude, deviceId, accountId, connectionAccountId, connectionAccountIds, permissionableType, permissionableId, searchRange, keyword, pending, admin, start, limit);

                        Events.ExecuteOnSearchPermissionablesFollowingDistance(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchPermissionablesFollowingDistanceDefaultImplementation(e, "/permissions/distancesearch", uriBuilderLocalVar.Path, latitude, longitude, deviceId, accountId, connectionAccountId, connectionAccountIds, permissionableType, permissionableId, searchRange, keyword, pending, admin, start, limit);
                Events.ExecuteOnErrorSearchPermissionablesFollowingDistance(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchPermissionablesFollowingDistanceApiResponse"/>
        /// </summary>
        public partial class SearchPermissionablesFollowingDistanceApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchPermissionablesFollowingDistanceApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchPermissionablesFollowingDistanceApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchPermissionablesFollowingDistanceApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchPermissionablesFollowingDistanceApiResponse(ILogger<SearchPermissionablesFollowingDistanceApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchPermissionablesFollowingDistanceApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchPermissionablesFollowingDistanceApiResponse(ILogger<SearchPermissionablesFollowingDistanceApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<UserPermissionsResponse>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<UserPermissionsResponse>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<UserPermissionsResponse>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
