// <auto-generated>
/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Net;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface ITrackingApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        TrackingApiEvents Events { get; }

        /// <summary>
        /// Create Batch Tracking
        /// </summary>
        /// <remarks>
        /// Batch create tracking legs
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="data">JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60; </param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="generateAccounts">Whether to generate accounts for tracking entries when the owner does not exist (optional)</param>
        /// <param name="updateAccountLocations">Whether to update the account&#39;s current location from the incoming tracking data (optional)</param>
        /// <param name="defaultTag">The default tag to apply to incoming legs when no tag is provided (optional, default to &quot;PASSIVE&quot;)</param>
        /// <param name="slaveUID"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBatchSaveTrackingApiResponse"/>&gt;</returns>
        Task<IBatchSaveTrackingApiResponse> BatchSaveTrackingAsync(decimal version, string data, Option<string> deviceId = default, Option<long> accountId = default, Option<bool> generateAccounts = default, Option<bool> updateAccountLocations = default, Option<string> defaultTag = default, Option<string> slaveUID = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Batch Tracking
        /// </summary>
        /// <remarks>
        /// Batch create tracking legs
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="data">JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60; </param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="generateAccounts">Whether to generate accounts for tracking entries when the owner does not exist (optional)</param>
        /// <param name="updateAccountLocations">Whether to update the account&#39;s current location from the incoming tracking data (optional)</param>
        /// <param name="defaultTag">The default tag to apply to incoming legs when no tag is provided (optional, default to &quot;PASSIVE&quot;)</param>
        /// <param name="slaveUID"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBatchSaveTrackingApiResponse"/>?&gt;</returns>
        Task<IBatchSaveTrackingApiResponse?> BatchSaveTrackingOrDefaultAsync(decimal version, string data, Option<string> deviceId = default, Option<long> accountId = default, Option<bool> generateAccounts = default, Option<bool> updateAccountLocations = default, Option<string> defaultTag = default, Option<string> slaveUID = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Predicted Locations
        /// </summary>
        /// <remarks>
        /// Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The account id of the customer</param>
        /// <param name="latitude">latitude to return a more likely result set based on the user&#39;s current location (optional)</param>
        /// <param name="longitude">longitude to return a more likely result set based on the user&#39;s current location (optional)</param>
        /// <param name="dateCheck">Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)</param>
        /// <param name="hourCheck">Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)</param>
        /// <param name="threshold">The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1)</param>
        /// <param name="distanceUnit">Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to MILES)</param>
        /// <param name="searchRange">Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0D)</param>
        /// <param name="sortOrder">The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to MATCHES)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPredictedLocationsApiResponse"/>&gt;</returns>
        Task<IGetPredictedLocationsApiResponse> GetPredictedLocationsAsync(decimal version, long accountId, Option<double> latitude = default, Option<double> longitude = default, Option<long> dateCheck = default, Option<string> hourCheck = default, Option<long> threshold = default, Option<string> distanceUnit = default, Option<double> searchRange = default, Option<string> sortOrder = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Predicted Locations
        /// </summary>
        /// <remarks>
        /// Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">The account id of the customer</param>
        /// <param name="latitude">latitude to return a more likely result set based on the user&#39;s current location (optional)</param>
        /// <param name="longitude">longitude to return a more likely result set based on the user&#39;s current location (optional)</param>
        /// <param name="dateCheck">Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)</param>
        /// <param name="hourCheck">Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)</param>
        /// <param name="threshold">The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1)</param>
        /// <param name="distanceUnit">Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to MILES)</param>
        /// <param name="searchRange">Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0D)</param>
        /// <param name="sortOrder">The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to MATCHES)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPredictedLocationsApiResponse"/>?&gt;</returns>
        Task<IGetPredictedLocationsApiResponse?> GetPredictedLocationsOrDefaultAsync(decimal version, long accountId, Option<double> latitude = default, Option<double> longitude = default, Option<long> dateCheck = default, Option<string> hourCheck = default, Option<long> threshold = default, Option<string> distanceUnit = default, Option<double> searchRange = default, Option<string> sortOrder = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Tracking Path
        /// </summary>
        /// <remarks>
        /// Get the path (lat/long coordinates) between 2 steps previously logged for a customer.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The account id of the customer</param>
        /// <param name="startStepId">The stepId to begin from</param>
        /// <param name="endStepId">The stepId to end with</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPredictedPathApiResponse"/>&gt;</returns>
        Task<IGetPredictedPathApiResponse> GetPredictedPathAsync(decimal version, long accountId, long startStepId, long endStepId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Tracking Path
        /// </summary>
        /// <remarks>
        /// Get the path (lat/long coordinates) between 2 steps previously logged for a customer.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">The account id of the customer</param>
        /// <param name="startStepId">The stepId to begin from</param>
        /// <param name="endStepId">The stepId to end with</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPredictedPathApiResponse"/>?&gt;</returns>
        Task<IGetPredictedPathApiResponse?> GetPredictedPathOrDefaultAsync(decimal version, long accountId, long startStepId, long endStepId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Preferred Locations
        /// </summary>
        /// <remarks>
        /// Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The account id of the customer</param>
        /// <param name="latitude">latitude to return a more likely result set based on the user&#39;s current location (optional)</param>
        /// <param name="longitude">longitude to return a more likely result set based on the user&#39;s current location (optional)</param>
        /// <param name="dateCheck">Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)</param>
        /// <param name="hourCheck">Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)</param>
        /// <param name="sortField">Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to &quot;PREFERRED_DATE&quot;)</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order (optional, default to true)</param>
        /// <param name="start">The start index for pagination (optional, default to 0)</param>
        /// <param name="limit">The limit for pagination (optional, default to 20)</param>
        /// <param name="searchRange">Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0D)</param>
        /// <param name="distanceUnit">Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to MILES)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPreferredLocationsApiResponse"/>&gt;</returns>
        Task<IGetPreferredLocationsApiResponse> GetPreferredLocationsAsync(decimal version, long accountId, Option<double> latitude = default, Option<double> longitude = default, Option<long> dateCheck = default, Option<string> hourCheck = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, Option<double> searchRange = default, Option<string> distanceUnit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Preferred Locations
        /// </summary>
        /// <remarks>
        /// Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">The account id of the customer</param>
        /// <param name="latitude">latitude to return a more likely result set based on the user&#39;s current location (optional)</param>
        /// <param name="longitude">longitude to return a more likely result set based on the user&#39;s current location (optional)</param>
        /// <param name="dateCheck">Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)</param>
        /// <param name="hourCheck">Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)</param>
        /// <param name="sortField">Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to &quot;PREFERRED_DATE&quot;)</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order (optional, default to true)</param>
        /// <param name="start">The start index for pagination (optional, default to 0)</param>
        /// <param name="limit">The limit for pagination (optional, default to 20)</param>
        /// <param name="searchRange">Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0D)</param>
        /// <param name="distanceUnit">Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to MILES)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPreferredLocationsApiResponse"/>?&gt;</returns>
        Task<IGetPreferredLocationsApiResponse?> GetPreferredLocationsOrDefaultAsync(decimal version, long accountId, Option<double> latitude = default, Option<double> longitude = default, Option<long> dateCheck = default, Option<string> hourCheck = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, Option<double> searchRange = default, Option<string> distanceUnit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Tracking
        /// </summary>
        /// <remarks>
        /// Retrieve tracking data to be able to show where a user has been.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="ownerId">the account id of the person the user wants to tracking data for (optional)</param>
        /// <param name="trackingDeviceId">the id of the tracking device (optional)</param>
        /// <param name="startDate">the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)</param>
        /// <param name="endDate">the end date in (UTC milliseconds) to filter the tracking results (optional)</param>
        /// <param name="tags">filter results by tag (optional)</param>
        /// <param name="getLastPoint">gets the last known location of the user (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTrackingLegsApiResponse"/>&gt;</returns>
        Task<IGetTrackingLegsApiResponse> GetTrackingLegsAsync(decimal version, Option<string> deviceId = default, Option<long> accountId = default, Option<long> ownerId = default, Option<string> trackingDeviceId = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> tags = default, Option<bool> getLastPoint = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Tracking
        /// </summary>
        /// <remarks>
        /// Retrieve tracking data to be able to show where a user has been.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="ownerId">the account id of the person the user wants to tracking data for (optional)</param>
        /// <param name="trackingDeviceId">the id of the tracking device (optional)</param>
        /// <param name="startDate">the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)</param>
        /// <param name="endDate">the end date in (UTC milliseconds) to filter the tracking results (optional)</param>
        /// <param name="tags">filter results by tag (optional)</param>
        /// <param name="getLastPoint">gets the last known location of the user (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTrackingLegsApiResponse"/>?&gt;</returns>
        Task<IGetTrackingLegsApiResponse?> GetTrackingLegsOrDefaultAsync(decimal version, Option<string> deviceId = default, Option<long> accountId = default, Option<long> ownerId = default, Option<string> trackingDeviceId = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> tags = default, Option<bool> getLastPoint = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Tracking Leg
        /// </summary>
        /// <remarks>
        /// Send tracking points to be able to generate pathing data
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="startLat">the latitude of the first point</param>
        /// <param name="startLng">the longitude of the first point</param>
        /// <param name="startDate">the start date (in UTC milliseconds) of the first point</param>
        /// <param name="endLat">the latitude of the last point</param>
        /// <param name="endLng">the longitude of the last point</param>
        /// <param name="endDate">the end date (in UTC milliseconds) of the last point</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="distance">the total distance (optional)</param>
        /// <param name="duration">the total duration (optional)</param>
        /// <param name="steps">JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60;  (optional)</param>
        /// <param name="tags">name the leg for searching (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISaveTrackingLegApiResponse"/>&gt;</returns>
        Task<ISaveTrackingLegApiResponse> SaveTrackingLegAsync(decimal version, double startLat, double startLng, long startDate, double endLat, double endLng, long endDate, Option<string> deviceId = default, Option<long> accountId = default, Option<double> distance = default, Option<long> duration = default, Option<string> steps = default, Option<string> tags = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Tracking Leg
        /// </summary>
        /// <remarks>
        /// Send tracking points to be able to generate pathing data
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="startLat">the latitude of the first point</param>
        /// <param name="startLng">the longitude of the first point</param>
        /// <param name="startDate">the start date (in UTC milliseconds) of the first point</param>
        /// <param name="endLat">the latitude of the last point</param>
        /// <param name="endLng">the longitude of the last point</param>
        /// <param name="endDate">the end date (in UTC milliseconds) of the last point</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="distance">the total distance (optional)</param>
        /// <param name="duration">the total duration (optional)</param>
        /// <param name="steps">JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60;  (optional)</param>
        /// <param name="tags">name the leg for searching (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISaveTrackingLegApiResponse"/>?&gt;</returns>
        Task<ISaveTrackingLegApiResponse?> SaveTrackingLegOrDefaultAsync(decimal version, double startLat, double startLng, long startDate, double endLat, double endLng, long endDate, Option<string> deviceId = default, Option<long> accountId = default, Option<double> distance = default, Option<long> duration = default, Option<string> steps = default, Option<string> tags = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Tracking Step
        /// </summary>
        /// <remarks>
        /// Send tracking points to be able to generate pathing data
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="legId">the leg to add the step to</param>
        /// <param name="startLat">the latitude of the first point</param>
        /// <param name="startLng">the longitude of the first point</param>
        /// <param name="startDate">the start date (in UTC milliseconds) of the first point</param>
        /// <param name="endLat">the latitude of the last point</param>
        /// <param name="endLng">the longitude of the last point</param>
        /// <param name="endDate">the end date (in UTC milliseconds) of the last point</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="distance">the total distance (optional)</param>
        /// <param name="duration">the total duration (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISaveTrackingStepApiResponse"/>&gt;</returns>
        Task<ISaveTrackingStepApiResponse> SaveTrackingStepAsync(decimal version, long legId, double startLat, double startLng, long startDate, double endLat, double endLng, long endDate, Option<string> deviceId = default, Option<long> accountId = default, Option<double> distance = default, Option<long> duration = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Tracking Step
        /// </summary>
        /// <remarks>
        /// Send tracking points to be able to generate pathing data
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="legId">the leg to add the step to</param>
        /// <param name="startLat">the latitude of the first point</param>
        /// <param name="startLng">the longitude of the first point</param>
        /// <param name="startDate">the start date (in UTC milliseconds) of the first point</param>
        /// <param name="endLat">the latitude of the last point</param>
        /// <param name="endLng">the longitude of the last point</param>
        /// <param name="endDate">the end date (in UTC milliseconds) of the last point</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="distance">the total distance (optional)</param>
        /// <param name="duration">the total duration (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISaveTrackingStepApiResponse"/>?&gt;</returns>
        Task<ISaveTrackingStepApiResponse?> SaveTrackingStepOrDefaultAsync(decimal version, long legId, double startLat, double startLng, long startDate, double endLat, double endLng, long endDate, Option<string> deviceId = default, Option<long> accountId = default, Option<double> distance = default, Option<long> duration = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Tracking
        /// </summary>
        /// <remarks>
        /// Search for all accounts that have tracking legs data by the given constraints.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The account id of the user</param>
        /// <param name="keyword">Used for LIKE search of first or last name on the acocunt (optional)</param>
        /// <param name="startDate">Range to begin in UTC milliseconds (optional)</param>
        /// <param name="endDate">Range to end in UTC milliseconds (optional)</param>
        /// <param name="tags">Exact match on tag field of Legs&#39;s searchTag (optional)</param>
        /// <param name="audienceIds"> (optional)</param>
        /// <param name="latitude">Origin latitude to perform searching constraints with given range (optional)</param>
        /// <param name="longitude">Origin longitude to perform searching constraints with given range (optional)</param>
        /// <param name="range">The radius, in miles, to perform the search for (optional, default to 5D)</param>
        /// <param name="sortField">The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to &quot;LEG_START_DATE&quot;)</param>
        /// <param name="descending">The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)</param>
        /// <param name="start">The index into the record set to start with. Default is 0. (optional, default to 0)</param>
        /// <param name="limit">The total number of records to return. Default is 20. (optional, default to 20)</param>
        /// <param name="activeOnly">Determines whether to return only active results. Default is false. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchAccountsWithTrackingLegsApiResponse"/>&gt;</returns>
        Task<ISearchAccountsWithTrackingLegsApiResponse> SearchAccountsWithTrackingLegsAsync(decimal version, long accountId, Option<string> keyword = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> tags = default, Option<string> audienceIds = default, Option<double> latitude = default, Option<double> longitude = default, Option<double> range = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, Option<bool> activeOnly = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Tracking
        /// </summary>
        /// <remarks>
        /// Search for all accounts that have tracking legs data by the given constraints.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">The account id of the user</param>
        /// <param name="keyword">Used for LIKE search of first or last name on the acocunt (optional)</param>
        /// <param name="startDate">Range to begin in UTC milliseconds (optional)</param>
        /// <param name="endDate">Range to end in UTC milliseconds (optional)</param>
        /// <param name="tags">Exact match on tag field of Legs&#39;s searchTag (optional)</param>
        /// <param name="audienceIds"> (optional)</param>
        /// <param name="latitude">Origin latitude to perform searching constraints with given range (optional)</param>
        /// <param name="longitude">Origin longitude to perform searching constraints with given range (optional)</param>
        /// <param name="range">The radius, in miles, to perform the search for (optional, default to 5D)</param>
        /// <param name="sortField">The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to &quot;LEG_START_DATE&quot;)</param>
        /// <param name="descending">The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)</param>
        /// <param name="start">The index into the record set to start with. Default is 0. (optional, default to 0)</param>
        /// <param name="limit">The total number of records to return. Default is 20. (optional, default to 20)</param>
        /// <param name="activeOnly">Determines whether to return only active results. Default is false. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchAccountsWithTrackingLegsApiResponse"/>?&gt;</returns>
        Task<ISearchAccountsWithTrackingLegsApiResponse?> SearchAccountsWithTrackingLegsOrDefaultAsync(decimal version, long accountId, Option<string> keyword = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> tags = default, Option<string> audienceIds = default, Option<double> latitude = default, Option<double> longitude = default, Option<double> range = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, Option<bool> activeOnly = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Tracking (Billable)
        /// </summary>
        /// <remarks>
        /// Retrieve tracking data for billable/account scoped queries.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The account id to search tracking for</param>
        /// <param name="appKey">The application key</param>
        /// <param name="trackingDeviceId">The id of the tracking device (optional)</param>
        /// <param name="startDate">The start date in (UTC milliseconds) to filter the tracking results (optional)</param>
        /// <param name="endDate">The end date in (UTC milliseconds) to filter the tracking results (optional)</param>
        /// <param name="tags">Filter results by tag (optional)</param>
        /// <param name="start">The start index for pagination (optional, default to 0)</param>
        /// <param name="limit">The limit for pagination (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchTrackingLegsApiResponse"/>&gt;</returns>
        Task<ISearchTrackingLegsApiResponse> SearchTrackingLegsAsync(decimal version, long accountId, string appKey, Option<string> trackingDeviceId = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> tags = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Tracking (Billable)
        /// </summary>
        /// <remarks>
        /// Retrieve tracking data for billable/account scoped queries.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">The account id to search tracking for</param>
        /// <param name="appKey">The application key</param>
        /// <param name="trackingDeviceId">The id of the tracking device (optional)</param>
        /// <param name="startDate">The start date in (UTC milliseconds) to filter the tracking results (optional)</param>
        /// <param name="endDate">The end date in (UTC milliseconds) to filter the tracking results (optional)</param>
        /// <param name="tags">Filter results by tag (optional)</param>
        /// <param name="start">The start index for pagination (optional, default to 0)</param>
        /// <param name="limit">The limit for pagination (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchTrackingLegsApiResponse"/>?&gt;</returns>
        Task<ISearchTrackingLegsApiResponse?> SearchTrackingLegsOrDefaultAsync(decimal version, long accountId, string appKey, Option<string> trackingDeviceId = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> tags = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IBatchSaveTrackingApiResponse"/>
    /// </summary>
    public interface IBatchSaveTrackingApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<Leg>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetPredictedLocationsApiResponse"/>
    /// </summary>
    public interface IGetPredictedLocationsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.PredictedLocationResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetPredictedPathApiResponse"/>
    /// </summary>
    public interface IGetPredictedPathApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<StepResponse>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetPreferredLocationsApiResponse"/>
    /// </summary>
    public interface IGetPreferredLocationsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<PreferredLocationResponse>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetTrackingLegsApiResponse"/>
    /// </summary>
    public interface IGetTrackingLegsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<LegResponse>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISaveTrackingLegApiResponse"/>
    /// </summary>
    public interface ISaveTrackingLegApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISaveTrackingStepApiResponse"/>
    /// </summary>
    public interface ISaveTrackingStepApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchAccountsWithTrackingLegsApiResponse"/>
    /// </summary>
    public interface ISearchAccountsWithTrackingLegsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<AccountMiniResponse>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchTrackingLegsApiResponse"/>
    /// </summary>
    public interface ISearchTrackingLegsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<LegResponse>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class TrackingApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnBatchSaveTracking;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorBatchSaveTracking;

        internal void ExecuteOnBatchSaveTracking(TrackingApi.BatchSaveTrackingApiResponse apiResponse)
        {
            OnBatchSaveTracking?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorBatchSaveTracking(Exception exception)
        {
            OnErrorBatchSaveTracking?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetPredictedLocations;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetPredictedLocations;

        internal void ExecuteOnGetPredictedLocations(TrackingApi.GetPredictedLocationsApiResponse apiResponse)
        {
            OnGetPredictedLocations?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetPredictedLocations(Exception exception)
        {
            OnErrorGetPredictedLocations?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetPredictedPath;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetPredictedPath;

        internal void ExecuteOnGetPredictedPath(TrackingApi.GetPredictedPathApiResponse apiResponse)
        {
            OnGetPredictedPath?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetPredictedPath(Exception exception)
        {
            OnErrorGetPredictedPath?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetPreferredLocations;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetPreferredLocations;

        internal void ExecuteOnGetPreferredLocations(TrackingApi.GetPreferredLocationsApiResponse apiResponse)
        {
            OnGetPreferredLocations?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetPreferredLocations(Exception exception)
        {
            OnErrorGetPreferredLocations?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetTrackingLegs;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetTrackingLegs;

        internal void ExecuteOnGetTrackingLegs(TrackingApi.GetTrackingLegsApiResponse apiResponse)
        {
            OnGetTrackingLegs?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetTrackingLegs(Exception exception)
        {
            OnErrorGetTrackingLegs?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSaveTrackingLeg;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSaveTrackingLeg;

        internal void ExecuteOnSaveTrackingLeg(TrackingApi.SaveTrackingLegApiResponse apiResponse)
        {
            OnSaveTrackingLeg?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSaveTrackingLeg(Exception exception)
        {
            OnErrorSaveTrackingLeg?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSaveTrackingStep;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSaveTrackingStep;

        internal void ExecuteOnSaveTrackingStep(TrackingApi.SaveTrackingStepApiResponse apiResponse)
        {
            OnSaveTrackingStep?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSaveTrackingStep(Exception exception)
        {
            OnErrorSaveTrackingStep?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchAccountsWithTrackingLegs;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchAccountsWithTrackingLegs;

        internal void ExecuteOnSearchAccountsWithTrackingLegs(TrackingApi.SearchAccountsWithTrackingLegsApiResponse apiResponse)
        {
            OnSearchAccountsWithTrackingLegs?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchAccountsWithTrackingLegs(Exception exception)
        {
            OnErrorSearchAccountsWithTrackingLegs?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchTrackingLegs;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchTrackingLegs;

        internal void ExecuteOnSearchTrackingLegs(TrackingApi.SearchTrackingLegsApiResponse apiResponse)
        {
            OnSearchTrackingLegs?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchTrackingLegs(Exception exception)
        {
            OnErrorSearchTrackingLegs?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class TrackingApi : ITrackingApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<TrackingApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public TrackingApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="TrackingApi"/> class.
        /// </summary>
        /// <returns></returns>
        public TrackingApi(ILogger<TrackingApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, TrackingApiEvents trackingApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<TrackingApi>();
            HttpClient = httpClient;
            Events = trackingApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatBatchSaveTracking(ref decimal version, ref string data, ref Option<string> deviceId, ref Option<long> accountId, ref Option<bool> generateAccounts, ref Option<bool> updateAccountLocations, ref Option<string> defaultTag, ref Option<string> slaveUID);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="data"></param>
        /// <param name="deviceId"></param>
        /// <param name="defaultTag"></param>
        /// <param name="slaveUID"></param>
        /// <returns></returns>
        private void ValidateBatchSaveTracking(string data, Option<string> deviceId, Option<string> defaultTag, Option<string> slaveUID)
        {
            if (data == null)
                throw new ArgumentNullException(nameof(data));

            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (defaultTag.IsSet && defaultTag.Value == null)
                throw new ArgumentNullException(nameof(defaultTag));

            if (slaveUID.IsSet && slaveUID.Value == null)
                throw new ArgumentNullException(nameof(slaveUID));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="data"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="generateAccounts"></param>
        /// <param name="updateAccountLocations"></param>
        /// <param name="defaultTag"></param>
        /// <param name="slaveUID"></param>
        private void AfterBatchSaveTrackingDefaultImplementation(IBatchSaveTrackingApiResponse apiResponseLocalVar, decimal version, string data, Option<string> deviceId, Option<long> accountId, Option<bool> generateAccounts, Option<bool> updateAccountLocations, Option<string> defaultTag, Option<string> slaveUID)
        {
            bool suppressDefaultLog = false;
            AfterBatchSaveTracking(ref suppressDefaultLog, apiResponseLocalVar, version, data, deviceId, accountId, generateAccounts, updateAccountLocations, defaultTag, slaveUID);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="data"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="generateAccounts"></param>
        /// <param name="updateAccountLocations"></param>
        /// <param name="defaultTag"></param>
        /// <param name="slaveUID"></param>
        partial void AfterBatchSaveTracking(ref bool suppressDefaultLog, IBatchSaveTrackingApiResponse apiResponseLocalVar, decimal version, string data, Option<string> deviceId, Option<long> accountId, Option<bool> generateAccounts, Option<bool> updateAccountLocations, Option<string> defaultTag, Option<string> slaveUID);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="data"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="generateAccounts"></param>
        /// <param name="updateAccountLocations"></param>
        /// <param name="defaultTag"></param>
        /// <param name="slaveUID"></param>
        private void OnErrorBatchSaveTrackingDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string data, Option<string> deviceId, Option<long> accountId, Option<bool> generateAccounts, Option<bool> updateAccountLocations, Option<string> defaultTag, Option<string> slaveUID)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorBatchSaveTracking(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, data, deviceId, accountId, generateAccounts, updateAccountLocations, defaultTag, slaveUID);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="data"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="generateAccounts"></param>
        /// <param name="updateAccountLocations"></param>
        /// <param name="defaultTag"></param>
        /// <param name="slaveUID"></param>
        partial void OnErrorBatchSaveTracking(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string data, Option<string> deviceId, Option<long> accountId, Option<bool> generateAccounts, Option<bool> updateAccountLocations, Option<string> defaultTag, Option<string> slaveUID);

        /// <summary>
        /// Create Batch Tracking Batch create tracking legs
        /// </summary>
        /// <param name="version"></param>
        /// <param name="data">JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60; </param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="generateAccounts">Whether to generate accounts for tracking entries when the owner does not exist (optional)</param>
        /// <param name="updateAccountLocations">Whether to update the account&#39;s current location from the incoming tracking data (optional)</param>
        /// <param name="defaultTag">The default tag to apply to incoming legs when no tag is provided (optional, default to &quot;PASSIVE&quot;)</param>
        /// <param name="slaveUID"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBatchSaveTrackingApiResponse"/>&gt;</returns>
        public async Task<IBatchSaveTrackingApiResponse?> BatchSaveTrackingOrDefaultAsync(decimal version, string data, Option<string> deviceId = default, Option<long> accountId = default, Option<bool> generateAccounts = default, Option<bool> updateAccountLocations = default, Option<string> defaultTag = default, Option<string> slaveUID = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await BatchSaveTrackingAsync(version, data, deviceId, accountId, generateAccounts, updateAccountLocations, defaultTag, slaveUID, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create Batch Tracking Batch create tracking legs
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="data">JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60; </param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="generateAccounts">Whether to generate accounts for tracking entries when the owner does not exist (optional)</param>
        /// <param name="updateAccountLocations">Whether to update the account&#39;s current location from the incoming tracking data (optional)</param>
        /// <param name="defaultTag">The default tag to apply to incoming legs when no tag is provided (optional, default to &quot;PASSIVE&quot;)</param>
        /// <param name="slaveUID"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBatchSaveTrackingApiResponse"/>&gt;</returns>
        public async Task<IBatchSaveTrackingApiResponse> BatchSaveTrackingAsync(decimal version, string data, Option<string> deviceId = default, Option<long> accountId = default, Option<bool> generateAccounts = default, Option<bool> updateAccountLocations = default, Option<string> defaultTag = default, Option<string> slaveUID = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateBatchSaveTracking(data, deviceId, defaultTag, slaveUID);

                FormatBatchSaveTracking(ref version, ref data, ref deviceId, ref accountId, ref generateAccounts, ref updateAccountLocations, ref defaultTag, ref slaveUID);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/tracking/batch/create"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/tracking/batch/create");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["data"] = ClientUtils.ParameterToString(data);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (generateAccounts.IsSet)
                        parseQueryStringLocalVar["generateAccounts"] = ClientUtils.ParameterToString(generateAccounts.Value);

                    if (updateAccountLocations.IsSet)
                        parseQueryStringLocalVar["updateAccountLocations"] = ClientUtils.ParameterToString(updateAccountLocations.Value);

                    if (defaultTag.IsSet)
                        parseQueryStringLocalVar["defaultTag"] = ClientUtils.ParameterToString(defaultTag.Value);

                    if (slaveUID.IsSet)
                        parseQueryStringLocalVar["slaveUID"] = ClientUtils.ParameterToString(slaveUID.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<BatchSaveTrackingApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<BatchSaveTrackingApiResponse>();
                        BatchSaveTrackingApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/tracking/batch/create", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterBatchSaveTrackingDefaultImplementation(apiResponseLocalVar, version, data, deviceId, accountId, generateAccounts, updateAccountLocations, defaultTag, slaveUID);

                        Events.ExecuteOnBatchSaveTracking(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorBatchSaveTrackingDefaultImplementation(e, "/api/{version}/tracking/batch/create", uriBuilderLocalVar.Path, version, data, deviceId, accountId, generateAccounts, updateAccountLocations, defaultTag, slaveUID);
                Events.ExecuteOnErrorBatchSaveTracking(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="BatchSaveTrackingApiResponse"/>
        /// </summary>
        public partial class BatchSaveTrackingApiResponse : Org.OpenAPITools.Client.ApiResponse, IBatchSaveTrackingApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<BatchSaveTrackingApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="BatchSaveTrackingApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BatchSaveTrackingApiResponse(ILogger<BatchSaveTrackingApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="BatchSaveTrackingApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BatchSaveTrackingApiResponse(ILogger<BatchSaveTrackingApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<Leg>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<Leg>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<Leg>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetPredictedLocations(ref decimal version, ref long accountId, ref Option<double> latitude, ref Option<double> longitude, ref Option<long> dateCheck, ref Option<string> hourCheck, ref Option<long> threshold, ref Option<string> distanceUnit, ref Option<double> searchRange, ref Option<string> sortOrder);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="hourCheck"></param>
        /// <param name="distanceUnit"></param>
        /// <param name="sortOrder"></param>
        /// <returns></returns>
        private void ValidateGetPredictedLocations(Option<string> hourCheck, Option<string> distanceUnit, Option<string> sortOrder)
        {
            if (hourCheck.IsSet && hourCheck.Value == null)
                throw new ArgumentNullException(nameof(hourCheck));

            if (distanceUnit.IsSet && distanceUnit.Value == null)
                throw new ArgumentNullException(nameof(distanceUnit));

            if (sortOrder.IsSet && sortOrder.Value == null)
                throw new ArgumentNullException(nameof(sortOrder));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="dateCheck"></param>
        /// <param name="hourCheck"></param>
        /// <param name="threshold"></param>
        /// <param name="distanceUnit"></param>
        /// <param name="searchRange"></param>
        /// <param name="sortOrder"></param>
        private void AfterGetPredictedLocationsDefaultImplementation(IGetPredictedLocationsApiResponse apiResponseLocalVar, decimal version, long accountId, Option<double> latitude, Option<double> longitude, Option<long> dateCheck, Option<string> hourCheck, Option<long> threshold, Option<string> distanceUnit, Option<double> searchRange, Option<string> sortOrder)
        {
            bool suppressDefaultLog = false;
            AfterGetPredictedLocations(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, latitude, longitude, dateCheck, hourCheck, threshold, distanceUnit, searchRange, sortOrder);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="dateCheck"></param>
        /// <param name="hourCheck"></param>
        /// <param name="threshold"></param>
        /// <param name="distanceUnit"></param>
        /// <param name="searchRange"></param>
        /// <param name="sortOrder"></param>
        partial void AfterGetPredictedLocations(ref bool suppressDefaultLog, IGetPredictedLocationsApiResponse apiResponseLocalVar, decimal version, long accountId, Option<double> latitude, Option<double> longitude, Option<long> dateCheck, Option<string> hourCheck, Option<long> threshold, Option<string> distanceUnit, Option<double> searchRange, Option<string> sortOrder);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="dateCheck"></param>
        /// <param name="hourCheck"></param>
        /// <param name="threshold"></param>
        /// <param name="distanceUnit"></param>
        /// <param name="searchRange"></param>
        /// <param name="sortOrder"></param>
        private void OnErrorGetPredictedLocationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, Option<double> latitude, Option<double> longitude, Option<long> dateCheck, Option<string> hourCheck, Option<long> threshold, Option<string> distanceUnit, Option<double> searchRange, Option<string> sortOrder)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetPredictedLocations(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, latitude, longitude, dateCheck, hourCheck, threshold, distanceUnit, searchRange, sortOrder);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="dateCheck"></param>
        /// <param name="hourCheck"></param>
        /// <param name="threshold"></param>
        /// <param name="distanceUnit"></param>
        /// <param name="searchRange"></param>
        /// <param name="sortOrder"></param>
        partial void OnErrorGetPredictedLocations(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, Option<double> latitude, Option<double> longitude, Option<long> dateCheck, Option<string> hourCheck, Option<long> threshold, Option<string> distanceUnit, Option<double> searchRange, Option<string> sortOrder);

        /// <summary>
        /// Get Predicted Locations Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">The account id of the customer</param>
        /// <param name="latitude">latitude to return a more likely result set based on the user&#39;s current location (optional)</param>
        /// <param name="longitude">longitude to return a more likely result set based on the user&#39;s current location (optional)</param>
        /// <param name="dateCheck">Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)</param>
        /// <param name="hourCheck">Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)</param>
        /// <param name="threshold">The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1)</param>
        /// <param name="distanceUnit">Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to MILES)</param>
        /// <param name="searchRange">Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0D)</param>
        /// <param name="sortOrder">The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to MATCHES)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPredictedLocationsApiResponse"/>&gt;</returns>
        public async Task<IGetPredictedLocationsApiResponse?> GetPredictedLocationsOrDefaultAsync(decimal version, long accountId, Option<double> latitude = default, Option<double> longitude = default, Option<long> dateCheck = default, Option<string> hourCheck = default, Option<long> threshold = default, Option<string> distanceUnit = default, Option<double> searchRange = default, Option<string> sortOrder = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetPredictedLocationsAsync(version, accountId, latitude, longitude, dateCheck, hourCheck, threshold, distanceUnit, searchRange, sortOrder, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Predicted Locations Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The account id of the customer</param>
        /// <param name="latitude">latitude to return a more likely result set based on the user&#39;s current location (optional)</param>
        /// <param name="longitude">longitude to return a more likely result set based on the user&#39;s current location (optional)</param>
        /// <param name="dateCheck">Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)</param>
        /// <param name="hourCheck">Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)</param>
        /// <param name="threshold">The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1)</param>
        /// <param name="distanceUnit">Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to MILES)</param>
        /// <param name="searchRange">Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0D)</param>
        /// <param name="sortOrder">The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to MATCHES)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPredictedLocationsApiResponse"/>&gt;</returns>
        public async Task<IGetPredictedLocationsApiResponse> GetPredictedLocationsAsync(decimal version, long accountId, Option<double> latitude = default, Option<double> longitude = default, Option<long> dateCheck = default, Option<string> hourCheck = default, Option<long> threshold = default, Option<string> distanceUnit = default, Option<double> searchRange = default, Option<string> sortOrder = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetPredictedLocations(hourCheck, distanceUnit, sortOrder);

                FormatGetPredictedLocations(ref version, ref accountId, ref latitude, ref longitude, ref dateCheck, ref hourCheck, ref threshold, ref distanceUnit, ref searchRange, ref sortOrder);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/tracking/predicted/get"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/tracking/predicted/get");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    if (dateCheck.IsSet)
                        parseQueryStringLocalVar["dateCheck"] = ClientUtils.ParameterToString(dateCheck.Value);

                    if (hourCheck.IsSet)
                        parseQueryStringLocalVar["hourCheck"] = ClientUtils.ParameterToString(hourCheck.Value);

                    if (threshold.IsSet)
                        parseQueryStringLocalVar["threshold"] = ClientUtils.ParameterToString(threshold.Value);

                    if (distanceUnit.IsSet)
                        parseQueryStringLocalVar["distanceUnit"] = ClientUtils.ParameterToString(distanceUnit.Value);

                    if (searchRange.IsSet)
                        parseQueryStringLocalVar["searchRange"] = ClientUtils.ParameterToString(searchRange.Value);

                    if (sortOrder.IsSet)
                        parseQueryStringLocalVar["sortOrder"] = ClientUtils.ParameterToString(sortOrder.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetPredictedLocationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetPredictedLocationsApiResponse>();
                        GetPredictedLocationsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/tracking/predicted/get", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetPredictedLocationsDefaultImplementation(apiResponseLocalVar, version, accountId, latitude, longitude, dateCheck, hourCheck, threshold, distanceUnit, searchRange, sortOrder);

                        Events.ExecuteOnGetPredictedLocations(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetPredictedLocationsDefaultImplementation(e, "/api/{version}/tracking/predicted/get", uriBuilderLocalVar.Path, version, accountId, latitude, longitude, dateCheck, hourCheck, threshold, distanceUnit, searchRange, sortOrder);
                Events.ExecuteOnErrorGetPredictedLocations(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetPredictedLocationsApiResponse"/>
        /// </summary>
        public partial class GetPredictedLocationsApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetPredictedLocationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetPredictedLocationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetPredictedLocationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetPredictedLocationsApiResponse(ILogger<GetPredictedLocationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetPredictedLocationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetPredictedLocationsApiResponse(ILogger<GetPredictedLocationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.PredictedLocationResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.PredictedLocationResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.PredictedLocationResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetPredictedPath(ref decimal version, ref long accountId, ref long startStepId, ref long endStepId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="startStepId"></param>
        /// <param name="endStepId"></param>
        private void AfterGetPredictedPathDefaultImplementation(IGetPredictedPathApiResponse apiResponseLocalVar, decimal version, long accountId, long startStepId, long endStepId)
        {
            bool suppressDefaultLog = false;
            AfterGetPredictedPath(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, startStepId, endStepId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="startStepId"></param>
        /// <param name="endStepId"></param>
        partial void AfterGetPredictedPath(ref bool suppressDefaultLog, IGetPredictedPathApiResponse apiResponseLocalVar, decimal version, long accountId, long startStepId, long endStepId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="startStepId"></param>
        /// <param name="endStepId"></param>
        private void OnErrorGetPredictedPathDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, long startStepId, long endStepId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetPredictedPath(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, startStepId, endStepId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="startStepId"></param>
        /// <param name="endStepId"></param>
        partial void OnErrorGetPredictedPath(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, long startStepId, long endStepId);

        /// <summary>
        /// Get Tracking Path Get the path (lat/long coordinates) between 2 steps previously logged for a customer.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">The account id of the customer</param>
        /// <param name="startStepId">The stepId to begin from</param>
        /// <param name="endStepId">The stepId to end with</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPredictedPathApiResponse"/>&gt;</returns>
        public async Task<IGetPredictedPathApiResponse?> GetPredictedPathOrDefaultAsync(decimal version, long accountId, long startStepId, long endStepId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetPredictedPathAsync(version, accountId, startStepId, endStepId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Tracking Path Get the path (lat/long coordinates) between 2 steps previously logged for a customer.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The account id of the customer</param>
        /// <param name="startStepId">The stepId to begin from</param>
        /// <param name="endStepId">The stepId to end with</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPredictedPathApiResponse"/>&gt;</returns>
        public async Task<IGetPredictedPathApiResponse> GetPredictedPathAsync(decimal version, long accountId, long startStepId, long endStepId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetPredictedPath(ref version, ref accountId, ref startStepId, ref endStepId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/tracking/path/get"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/tracking/path/get");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["startStepId"] = ClientUtils.ParameterToString(startStepId);
                    parseQueryStringLocalVar["endStepId"] = ClientUtils.ParameterToString(endStepId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetPredictedPathApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetPredictedPathApiResponse>();
                        GetPredictedPathApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/tracking/path/get", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetPredictedPathDefaultImplementation(apiResponseLocalVar, version, accountId, startStepId, endStepId);

                        Events.ExecuteOnGetPredictedPath(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetPredictedPathDefaultImplementation(e, "/api/{version}/tracking/path/get", uriBuilderLocalVar.Path, version, accountId, startStepId, endStepId);
                Events.ExecuteOnErrorGetPredictedPath(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetPredictedPathApiResponse"/>
        /// </summary>
        public partial class GetPredictedPathApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetPredictedPathApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetPredictedPathApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetPredictedPathApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetPredictedPathApiResponse(ILogger<GetPredictedPathApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetPredictedPathApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetPredictedPathApiResponse(ILogger<GetPredictedPathApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<StepResponse>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<StepResponse>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<StepResponse>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetPreferredLocations(ref decimal version, ref long accountId, ref Option<double> latitude, ref Option<double> longitude, ref Option<long> dateCheck, ref Option<string> hourCheck, ref Option<string> sortField, ref Option<bool> descending, ref Option<int> start, ref Option<int> limit, ref Option<double> searchRange, ref Option<string> distanceUnit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="hourCheck"></param>
        /// <param name="sortField"></param>
        /// <param name="distanceUnit"></param>
        /// <returns></returns>
        private void ValidateGetPreferredLocations(Option<string> hourCheck, Option<string> sortField, Option<string> distanceUnit)
        {
            if (hourCheck.IsSet && hourCheck.Value == null)
                throw new ArgumentNullException(nameof(hourCheck));

            if (sortField.IsSet && sortField.Value == null)
                throw new ArgumentNullException(nameof(sortField));

            if (distanceUnit.IsSet && distanceUnit.Value == null)
                throw new ArgumentNullException(nameof(distanceUnit));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="dateCheck"></param>
        /// <param name="hourCheck"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="searchRange"></param>
        /// <param name="distanceUnit"></param>
        private void AfterGetPreferredLocationsDefaultImplementation(IGetPreferredLocationsApiResponse apiResponseLocalVar, decimal version, long accountId, Option<double> latitude, Option<double> longitude, Option<long> dateCheck, Option<string> hourCheck, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit, Option<double> searchRange, Option<string> distanceUnit)
        {
            bool suppressDefaultLog = false;
            AfterGetPreferredLocations(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, latitude, longitude, dateCheck, hourCheck, sortField, descending, start, limit, searchRange, distanceUnit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="dateCheck"></param>
        /// <param name="hourCheck"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="searchRange"></param>
        /// <param name="distanceUnit"></param>
        partial void AfterGetPreferredLocations(ref bool suppressDefaultLog, IGetPreferredLocationsApiResponse apiResponseLocalVar, decimal version, long accountId, Option<double> latitude, Option<double> longitude, Option<long> dateCheck, Option<string> hourCheck, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit, Option<double> searchRange, Option<string> distanceUnit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="dateCheck"></param>
        /// <param name="hourCheck"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="searchRange"></param>
        /// <param name="distanceUnit"></param>
        private void OnErrorGetPreferredLocationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, Option<double> latitude, Option<double> longitude, Option<long> dateCheck, Option<string> hourCheck, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit, Option<double> searchRange, Option<string> distanceUnit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetPreferredLocations(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, latitude, longitude, dateCheck, hourCheck, sortField, descending, start, limit, searchRange, distanceUnit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="dateCheck"></param>
        /// <param name="hourCheck"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="searchRange"></param>
        /// <param name="distanceUnit"></param>
        partial void OnErrorGetPreferredLocations(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, Option<double> latitude, Option<double> longitude, Option<long> dateCheck, Option<string> hourCheck, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit, Option<double> searchRange, Option<string> distanceUnit);

        /// <summary>
        /// Search Preferred Locations Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">The account id of the customer</param>
        /// <param name="latitude">latitude to return a more likely result set based on the user&#39;s current location (optional)</param>
        /// <param name="longitude">longitude to return a more likely result set based on the user&#39;s current location (optional)</param>
        /// <param name="dateCheck">Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)</param>
        /// <param name="hourCheck">Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)</param>
        /// <param name="sortField">Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to &quot;PREFERRED_DATE&quot;)</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order (optional, default to true)</param>
        /// <param name="start">The start index for pagination (optional, default to 0)</param>
        /// <param name="limit">The limit for pagination (optional, default to 20)</param>
        /// <param name="searchRange">Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0D)</param>
        /// <param name="distanceUnit">Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to MILES)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPreferredLocationsApiResponse"/>&gt;</returns>
        public async Task<IGetPreferredLocationsApiResponse?> GetPreferredLocationsOrDefaultAsync(decimal version, long accountId, Option<double> latitude = default, Option<double> longitude = default, Option<long> dateCheck = default, Option<string> hourCheck = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, Option<double> searchRange = default, Option<string> distanceUnit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetPreferredLocationsAsync(version, accountId, latitude, longitude, dateCheck, hourCheck, sortField, descending, start, limit, searchRange, distanceUnit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Preferred Locations Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The account id of the customer</param>
        /// <param name="latitude">latitude to return a more likely result set based on the user&#39;s current location (optional)</param>
        /// <param name="longitude">longitude to return a more likely result set based on the user&#39;s current location (optional)</param>
        /// <param name="dateCheck">Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)</param>
        /// <param name="hourCheck">Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)</param>
        /// <param name="sortField">Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to &quot;PREFERRED_DATE&quot;)</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order (optional, default to true)</param>
        /// <param name="start">The start index for pagination (optional, default to 0)</param>
        /// <param name="limit">The limit for pagination (optional, default to 20)</param>
        /// <param name="searchRange">Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0D)</param>
        /// <param name="distanceUnit">Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to MILES)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPreferredLocationsApiResponse"/>&gt;</returns>
        public async Task<IGetPreferredLocationsApiResponse> GetPreferredLocationsAsync(decimal version, long accountId, Option<double> latitude = default, Option<double> longitude = default, Option<long> dateCheck = default, Option<string> hourCheck = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, Option<double> searchRange = default, Option<string> distanceUnit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetPreferredLocations(hourCheck, sortField, distanceUnit);

                FormatGetPreferredLocations(ref version, ref accountId, ref latitude, ref longitude, ref dateCheck, ref hourCheck, ref sortField, ref descending, ref start, ref limit, ref searchRange, ref distanceUnit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/tracking/preferred/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/tracking/preferred/search");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    if (dateCheck.IsSet)
                        parseQueryStringLocalVar["dateCheck"] = ClientUtils.ParameterToString(dateCheck.Value);

                    if (hourCheck.IsSet)
                        parseQueryStringLocalVar["hourCheck"] = ClientUtils.ParameterToString(hourCheck.Value);

                    if (sortField.IsSet)
                        parseQueryStringLocalVar["sortField"] = ClientUtils.ParameterToString(sortField.Value);

                    if (descending.IsSet)
                        parseQueryStringLocalVar["descending"] = ClientUtils.ParameterToString(descending.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (searchRange.IsSet)
                        parseQueryStringLocalVar["searchRange"] = ClientUtils.ParameterToString(searchRange.Value);

                    if (distanceUnit.IsSet)
                        parseQueryStringLocalVar["distanceUnit"] = ClientUtils.ParameterToString(distanceUnit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetPreferredLocationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetPreferredLocationsApiResponse>();
                        GetPreferredLocationsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/tracking/preferred/search", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetPreferredLocationsDefaultImplementation(apiResponseLocalVar, version, accountId, latitude, longitude, dateCheck, hourCheck, sortField, descending, start, limit, searchRange, distanceUnit);

                        Events.ExecuteOnGetPreferredLocations(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetPreferredLocationsDefaultImplementation(e, "/api/{version}/tracking/preferred/search", uriBuilderLocalVar.Path, version, accountId, latitude, longitude, dateCheck, hourCheck, sortField, descending, start, limit, searchRange, distanceUnit);
                Events.ExecuteOnErrorGetPreferredLocations(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetPreferredLocationsApiResponse"/>
        /// </summary>
        public partial class GetPreferredLocationsApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetPreferredLocationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetPreferredLocationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetPreferredLocationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetPreferredLocationsApiResponse(ILogger<GetPreferredLocationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetPreferredLocationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetPreferredLocationsApiResponse(ILogger<GetPreferredLocationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<PreferredLocationResponse>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<PreferredLocationResponse>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<PreferredLocationResponse>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetTrackingLegs(ref decimal version, ref Option<string> deviceId, ref Option<long> accountId, ref Option<long> ownerId, ref Option<string> trackingDeviceId, ref Option<long> startDate, ref Option<long> endDate, ref Option<string> tags, ref Option<bool> getLastPoint);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <param name="trackingDeviceId"></param>
        /// <param name="tags"></param>
        /// <returns></returns>
        private void ValidateGetTrackingLegs(Option<string> deviceId, Option<string> trackingDeviceId, Option<string> tags)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (trackingDeviceId.IsSet && trackingDeviceId.Value == null)
                throw new ArgumentNullException(nameof(trackingDeviceId));

            if (tags.IsSet && tags.Value == null)
                throw new ArgumentNullException(nameof(tags));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="ownerId"></param>
        /// <param name="trackingDeviceId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="tags"></param>
        /// <param name="getLastPoint"></param>
        private void AfterGetTrackingLegsDefaultImplementation(IGetTrackingLegsApiResponse apiResponseLocalVar, decimal version, Option<string> deviceId, Option<long> accountId, Option<long> ownerId, Option<string> trackingDeviceId, Option<long> startDate, Option<long> endDate, Option<string> tags, Option<bool> getLastPoint)
        {
            bool suppressDefaultLog = false;
            AfterGetTrackingLegs(ref suppressDefaultLog, apiResponseLocalVar, version, deviceId, accountId, ownerId, trackingDeviceId, startDate, endDate, tags, getLastPoint);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="ownerId"></param>
        /// <param name="trackingDeviceId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="tags"></param>
        /// <param name="getLastPoint"></param>
        partial void AfterGetTrackingLegs(ref bool suppressDefaultLog, IGetTrackingLegsApiResponse apiResponseLocalVar, decimal version, Option<string> deviceId, Option<long> accountId, Option<long> ownerId, Option<string> trackingDeviceId, Option<long> startDate, Option<long> endDate, Option<string> tags, Option<bool> getLastPoint);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="ownerId"></param>
        /// <param name="trackingDeviceId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="tags"></param>
        /// <param name="getLastPoint"></param>
        private void OnErrorGetTrackingLegsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, Option<string> deviceId, Option<long> accountId, Option<long> ownerId, Option<string> trackingDeviceId, Option<long> startDate, Option<long> endDate, Option<string> tags, Option<bool> getLastPoint)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetTrackingLegs(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, deviceId, accountId, ownerId, trackingDeviceId, startDate, endDate, tags, getLastPoint);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="ownerId"></param>
        /// <param name="trackingDeviceId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="tags"></param>
        /// <param name="getLastPoint"></param>
        partial void OnErrorGetTrackingLegs(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, Option<string> deviceId, Option<long> accountId, Option<long> ownerId, Option<string> trackingDeviceId, Option<long> startDate, Option<long> endDate, Option<string> tags, Option<bool> getLastPoint);

        /// <summary>
        /// Search Tracking Retrieve tracking data to be able to show where a user has been.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="ownerId">the account id of the person the user wants to tracking data for (optional)</param>
        /// <param name="trackingDeviceId">the id of the tracking device (optional)</param>
        /// <param name="startDate">the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)</param>
        /// <param name="endDate">the end date in (UTC milliseconds) to filter the tracking results (optional)</param>
        /// <param name="tags">filter results by tag (optional)</param>
        /// <param name="getLastPoint">gets the last known location of the user (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTrackingLegsApiResponse"/>&gt;</returns>
        public async Task<IGetTrackingLegsApiResponse?> GetTrackingLegsOrDefaultAsync(decimal version, Option<string> deviceId = default, Option<long> accountId = default, Option<long> ownerId = default, Option<string> trackingDeviceId = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> tags = default, Option<bool> getLastPoint = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetTrackingLegsAsync(version, deviceId, accountId, ownerId, trackingDeviceId, startDate, endDate, tags, getLastPoint, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Tracking Retrieve tracking data to be able to show where a user has been.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="ownerId">the account id of the person the user wants to tracking data for (optional)</param>
        /// <param name="trackingDeviceId">the id of the tracking device (optional)</param>
        /// <param name="startDate">the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)</param>
        /// <param name="endDate">the end date in (UTC milliseconds) to filter the tracking results (optional)</param>
        /// <param name="tags">filter results by tag (optional)</param>
        /// <param name="getLastPoint">gets the last known location of the user (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTrackingLegsApiResponse"/>&gt;</returns>
        public async Task<IGetTrackingLegsApiResponse> GetTrackingLegsAsync(decimal version, Option<string> deviceId = default, Option<long> accountId = default, Option<long> ownerId = default, Option<string> trackingDeviceId = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> tags = default, Option<bool> getLastPoint = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetTrackingLegs(deviceId, trackingDeviceId, tags);

                FormatGetTrackingLegs(ref version, ref deviceId, ref accountId, ref ownerId, ref trackingDeviceId, ref startDate, ref endDate, ref tags, ref getLastPoint);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/tracking/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/tracking/search");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (ownerId.IsSet)
                        parseQueryStringLocalVar["ownerId"] = ClientUtils.ParameterToString(ownerId.Value);

                    if (trackingDeviceId.IsSet)
                        parseQueryStringLocalVar["trackingDeviceId"] = ClientUtils.ParameterToString(trackingDeviceId.Value);

                    if (startDate.IsSet)
                        parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate.Value);

                    if (endDate.IsSet)
                        parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate.Value);

                    if (tags.IsSet)
                        parseQueryStringLocalVar["tags"] = ClientUtils.ParameterToString(tags.Value);

                    if (getLastPoint.IsSet)
                        parseQueryStringLocalVar["getLastPoint"] = ClientUtils.ParameterToString(getLastPoint.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetTrackingLegsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetTrackingLegsApiResponse>();
                        GetTrackingLegsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/tracking/search", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetTrackingLegsDefaultImplementation(apiResponseLocalVar, version, deviceId, accountId, ownerId, trackingDeviceId, startDate, endDate, tags, getLastPoint);

                        Events.ExecuteOnGetTrackingLegs(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetTrackingLegsDefaultImplementation(e, "/api/{version}/tracking/search", uriBuilderLocalVar.Path, version, deviceId, accountId, ownerId, trackingDeviceId, startDate, endDate, tags, getLastPoint);
                Events.ExecuteOnErrorGetTrackingLegs(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetTrackingLegsApiResponse"/>
        /// </summary>
        public partial class GetTrackingLegsApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetTrackingLegsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetTrackingLegsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetTrackingLegsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTrackingLegsApiResponse(ILogger<GetTrackingLegsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetTrackingLegsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTrackingLegsApiResponse(ILogger<GetTrackingLegsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<LegResponse>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<LegResponse>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<LegResponse>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSaveTrackingLeg(ref decimal version, ref double startLat, ref double startLng, ref long startDate, ref double endLat, ref double endLng, ref long endDate, ref Option<string> deviceId, ref Option<long> accountId, ref Option<double> distance, ref Option<long> duration, ref Option<string> steps, ref Option<string> tags);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <param name="steps"></param>
        /// <param name="tags"></param>
        /// <returns></returns>
        private void ValidateSaveTrackingLeg(Option<string> deviceId, Option<string> steps, Option<string> tags)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (steps.IsSet && steps.Value == null)
                throw new ArgumentNullException(nameof(steps));

            if (tags.IsSet && tags.Value == null)
                throw new ArgumentNullException(nameof(tags));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="startLat"></param>
        /// <param name="startLng"></param>
        /// <param name="startDate"></param>
        /// <param name="endLat"></param>
        /// <param name="endLng"></param>
        /// <param name="endDate"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="distance"></param>
        /// <param name="duration"></param>
        /// <param name="steps"></param>
        /// <param name="tags"></param>
        private void AfterSaveTrackingLegDefaultImplementation(ISaveTrackingLegApiResponse apiResponseLocalVar, decimal version, double startLat, double startLng, long startDate, double endLat, double endLng, long endDate, Option<string> deviceId, Option<long> accountId, Option<double> distance, Option<long> duration, Option<string> steps, Option<string> tags)
        {
            bool suppressDefaultLog = false;
            AfterSaveTrackingLeg(ref suppressDefaultLog, apiResponseLocalVar, version, startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration, steps, tags);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="startLat"></param>
        /// <param name="startLng"></param>
        /// <param name="startDate"></param>
        /// <param name="endLat"></param>
        /// <param name="endLng"></param>
        /// <param name="endDate"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="distance"></param>
        /// <param name="duration"></param>
        /// <param name="steps"></param>
        /// <param name="tags"></param>
        partial void AfterSaveTrackingLeg(ref bool suppressDefaultLog, ISaveTrackingLegApiResponse apiResponseLocalVar, decimal version, double startLat, double startLng, long startDate, double endLat, double endLng, long endDate, Option<string> deviceId, Option<long> accountId, Option<double> distance, Option<long> duration, Option<string> steps, Option<string> tags);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="startLat"></param>
        /// <param name="startLng"></param>
        /// <param name="startDate"></param>
        /// <param name="endLat"></param>
        /// <param name="endLng"></param>
        /// <param name="endDate"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="distance"></param>
        /// <param name="duration"></param>
        /// <param name="steps"></param>
        /// <param name="tags"></param>
        private void OnErrorSaveTrackingLegDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, double startLat, double startLng, long startDate, double endLat, double endLng, long endDate, Option<string> deviceId, Option<long> accountId, Option<double> distance, Option<long> duration, Option<string> steps, Option<string> tags)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSaveTrackingLeg(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration, steps, tags);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="startLat"></param>
        /// <param name="startLng"></param>
        /// <param name="startDate"></param>
        /// <param name="endLat"></param>
        /// <param name="endLng"></param>
        /// <param name="endDate"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="distance"></param>
        /// <param name="duration"></param>
        /// <param name="steps"></param>
        /// <param name="tags"></param>
        partial void OnErrorSaveTrackingLeg(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, double startLat, double startLng, long startDate, double endLat, double endLng, long endDate, Option<string> deviceId, Option<long> accountId, Option<double> distance, Option<long> duration, Option<string> steps, Option<string> tags);

        /// <summary>
        /// Create Tracking Leg Send tracking points to be able to generate pathing data
        /// </summary>
        /// <param name="version"></param>
        /// <param name="startLat">the latitude of the first point</param>
        /// <param name="startLng">the longitude of the first point</param>
        /// <param name="startDate">the start date (in UTC milliseconds) of the first point</param>
        /// <param name="endLat">the latitude of the last point</param>
        /// <param name="endLng">the longitude of the last point</param>
        /// <param name="endDate">the end date (in UTC milliseconds) of the last point</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="distance">the total distance (optional)</param>
        /// <param name="duration">the total duration (optional)</param>
        /// <param name="steps">JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60;  (optional)</param>
        /// <param name="tags">name the leg for searching (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISaveTrackingLegApiResponse"/>&gt;</returns>
        public async Task<ISaveTrackingLegApiResponse?> SaveTrackingLegOrDefaultAsync(decimal version, double startLat, double startLng, long startDate, double endLat, double endLng, long endDate, Option<string> deviceId = default, Option<long> accountId = default, Option<double> distance = default, Option<long> duration = default, Option<string> steps = default, Option<string> tags = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SaveTrackingLegAsync(version, startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration, steps, tags, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create Tracking Leg Send tracking points to be able to generate pathing data
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="startLat">the latitude of the first point</param>
        /// <param name="startLng">the longitude of the first point</param>
        /// <param name="startDate">the start date (in UTC milliseconds) of the first point</param>
        /// <param name="endLat">the latitude of the last point</param>
        /// <param name="endLng">the longitude of the last point</param>
        /// <param name="endDate">the end date (in UTC milliseconds) of the last point</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="distance">the total distance (optional)</param>
        /// <param name="duration">the total duration (optional)</param>
        /// <param name="steps">JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60;  (optional)</param>
        /// <param name="tags">name the leg for searching (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISaveTrackingLegApiResponse"/>&gt;</returns>
        public async Task<ISaveTrackingLegApiResponse> SaveTrackingLegAsync(decimal version, double startLat, double startLng, long startDate, double endLat, double endLng, long endDate, Option<string> deviceId = default, Option<long> accountId = default, Option<double> distance = default, Option<long> duration = default, Option<string> steps = default, Option<string> tags = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSaveTrackingLeg(deviceId, steps, tags);

                FormatSaveTrackingLeg(ref version, ref startLat, ref startLng, ref startDate, ref endLat, ref endLng, ref endDate, ref deviceId, ref accountId, ref distance, ref duration, ref steps, ref tags);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/tracking/leg/create"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/tracking/leg/create");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["startLat"] = ClientUtils.ParameterToString(startLat);
                    parseQueryStringLocalVar["startLng"] = ClientUtils.ParameterToString(startLng);
                    parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate);
                    parseQueryStringLocalVar["endLat"] = ClientUtils.ParameterToString(endLat);
                    parseQueryStringLocalVar["endLng"] = ClientUtils.ParameterToString(endLng);
                    parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (distance.IsSet)
                        parseQueryStringLocalVar["distance"] = ClientUtils.ParameterToString(distance.Value);

                    if (duration.IsSet)
                        parseQueryStringLocalVar["duration"] = ClientUtils.ParameterToString(duration.Value);

                    if (steps.IsSet)
                        parseQueryStringLocalVar["steps"] = ClientUtils.ParameterToString(steps.Value);

                    if (tags.IsSet)
                        parseQueryStringLocalVar["tags"] = ClientUtils.ParameterToString(tags.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SaveTrackingLegApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SaveTrackingLegApiResponse>();
                        SaveTrackingLegApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/tracking/leg/create", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSaveTrackingLegDefaultImplementation(apiResponseLocalVar, version, startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration, steps, tags);

                        Events.ExecuteOnSaveTrackingLeg(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSaveTrackingLegDefaultImplementation(e, "/api/{version}/tracking/leg/create", uriBuilderLocalVar.Path, version, startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration, steps, tags);
                Events.ExecuteOnErrorSaveTrackingLeg(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SaveTrackingLegApiResponse"/>
        /// </summary>
        public partial class SaveTrackingLegApiResponse : Org.OpenAPITools.Client.ApiResponse, ISaveTrackingLegApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SaveTrackingLegApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SaveTrackingLegApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SaveTrackingLegApiResponse(ILogger<SaveTrackingLegApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SaveTrackingLegApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SaveTrackingLegApiResponse(ILogger<SaveTrackingLegApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSaveTrackingStep(ref decimal version, ref long legId, ref double startLat, ref double startLng, ref long startDate, ref double endLat, ref double endLng, ref long endDate, ref Option<string> deviceId, ref Option<long> accountId, ref Option<double> distance, ref Option<long> duration);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <returns></returns>
        private void ValidateSaveTrackingStep(Option<string> deviceId)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="legId"></param>
        /// <param name="startLat"></param>
        /// <param name="startLng"></param>
        /// <param name="startDate"></param>
        /// <param name="endLat"></param>
        /// <param name="endLng"></param>
        /// <param name="endDate"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="distance"></param>
        /// <param name="duration"></param>
        private void AfterSaveTrackingStepDefaultImplementation(ISaveTrackingStepApiResponse apiResponseLocalVar, decimal version, long legId, double startLat, double startLng, long startDate, double endLat, double endLng, long endDate, Option<string> deviceId, Option<long> accountId, Option<double> distance, Option<long> duration)
        {
            bool suppressDefaultLog = false;
            AfterSaveTrackingStep(ref suppressDefaultLog, apiResponseLocalVar, version, legId, startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="legId"></param>
        /// <param name="startLat"></param>
        /// <param name="startLng"></param>
        /// <param name="startDate"></param>
        /// <param name="endLat"></param>
        /// <param name="endLng"></param>
        /// <param name="endDate"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="distance"></param>
        /// <param name="duration"></param>
        partial void AfterSaveTrackingStep(ref bool suppressDefaultLog, ISaveTrackingStepApiResponse apiResponseLocalVar, decimal version, long legId, double startLat, double startLng, long startDate, double endLat, double endLng, long endDate, Option<string> deviceId, Option<long> accountId, Option<double> distance, Option<long> duration);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="legId"></param>
        /// <param name="startLat"></param>
        /// <param name="startLng"></param>
        /// <param name="startDate"></param>
        /// <param name="endLat"></param>
        /// <param name="endLng"></param>
        /// <param name="endDate"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="distance"></param>
        /// <param name="duration"></param>
        private void OnErrorSaveTrackingStepDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long legId, double startLat, double startLng, long startDate, double endLat, double endLng, long endDate, Option<string> deviceId, Option<long> accountId, Option<double> distance, Option<long> duration)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSaveTrackingStep(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, legId, startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="legId"></param>
        /// <param name="startLat"></param>
        /// <param name="startLng"></param>
        /// <param name="startDate"></param>
        /// <param name="endLat"></param>
        /// <param name="endLng"></param>
        /// <param name="endDate"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="distance"></param>
        /// <param name="duration"></param>
        partial void OnErrorSaveTrackingStep(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long legId, double startLat, double startLng, long startDate, double endLat, double endLng, long endDate, Option<string> deviceId, Option<long> accountId, Option<double> distance, Option<long> duration);

        /// <summary>
        /// Create Tracking Step Send tracking points to be able to generate pathing data
        /// </summary>
        /// <param name="version"></param>
        /// <param name="legId">the leg to add the step to</param>
        /// <param name="startLat">the latitude of the first point</param>
        /// <param name="startLng">the longitude of the first point</param>
        /// <param name="startDate">the start date (in UTC milliseconds) of the first point</param>
        /// <param name="endLat">the latitude of the last point</param>
        /// <param name="endLng">the longitude of the last point</param>
        /// <param name="endDate">the end date (in UTC milliseconds) of the last point</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="distance">the total distance (optional)</param>
        /// <param name="duration">the total duration (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISaveTrackingStepApiResponse"/>&gt;</returns>
        public async Task<ISaveTrackingStepApiResponse?> SaveTrackingStepOrDefaultAsync(decimal version, long legId, double startLat, double startLng, long startDate, double endLat, double endLng, long endDate, Option<string> deviceId = default, Option<long> accountId = default, Option<double> distance = default, Option<long> duration = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SaveTrackingStepAsync(version, legId, startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create Tracking Step Send tracking points to be able to generate pathing data
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="legId">the leg to add the step to</param>
        /// <param name="startLat">the latitude of the first point</param>
        /// <param name="startLng">the longitude of the first point</param>
        /// <param name="startDate">the start date (in UTC milliseconds) of the first point</param>
        /// <param name="endLat">the latitude of the last point</param>
        /// <param name="endLng">the longitude of the last point</param>
        /// <param name="endDate">the end date (in UTC milliseconds) of the last point</param>
        /// <param name="deviceId">the device id (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="distance">the total distance (optional)</param>
        /// <param name="duration">the total duration (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISaveTrackingStepApiResponse"/>&gt;</returns>
        public async Task<ISaveTrackingStepApiResponse> SaveTrackingStepAsync(decimal version, long legId, double startLat, double startLng, long startDate, double endLat, double endLng, long endDate, Option<string> deviceId = default, Option<long> accountId = default, Option<double> distance = default, Option<long> duration = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSaveTrackingStep(deviceId);

                FormatSaveTrackingStep(ref version, ref legId, ref startLat, ref startLng, ref startDate, ref endLat, ref endLng, ref endDate, ref deviceId, ref accountId, ref distance, ref duration);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/tracking/step/create"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/tracking/step/create");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["legId"] = ClientUtils.ParameterToString(legId);
                    parseQueryStringLocalVar["startLat"] = ClientUtils.ParameterToString(startLat);
                    parseQueryStringLocalVar["startLng"] = ClientUtils.ParameterToString(startLng);
                    parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate);
                    parseQueryStringLocalVar["endLat"] = ClientUtils.ParameterToString(endLat);
                    parseQueryStringLocalVar["endLng"] = ClientUtils.ParameterToString(endLng);
                    parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (distance.IsSet)
                        parseQueryStringLocalVar["distance"] = ClientUtils.ParameterToString(distance.Value);

                    if (duration.IsSet)
                        parseQueryStringLocalVar["duration"] = ClientUtils.ParameterToString(duration.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SaveTrackingStepApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SaveTrackingStepApiResponse>();
                        SaveTrackingStepApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/tracking/step/create", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSaveTrackingStepDefaultImplementation(apiResponseLocalVar, version, legId, startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration);

                        Events.ExecuteOnSaveTrackingStep(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSaveTrackingStepDefaultImplementation(e, "/api/{version}/tracking/step/create", uriBuilderLocalVar.Path, version, legId, startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration);
                Events.ExecuteOnErrorSaveTrackingStep(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SaveTrackingStepApiResponse"/>
        /// </summary>
        public partial class SaveTrackingStepApiResponse : Org.OpenAPITools.Client.ApiResponse, ISaveTrackingStepApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SaveTrackingStepApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SaveTrackingStepApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SaveTrackingStepApiResponse(ILogger<SaveTrackingStepApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SaveTrackingStepApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SaveTrackingStepApiResponse(ILogger<SaveTrackingStepApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchAccountsWithTrackingLegs(ref decimal version, ref long accountId, ref Option<string> keyword, ref Option<long> startDate, ref Option<long> endDate, ref Option<string> tags, ref Option<string> audienceIds, ref Option<double> latitude, ref Option<double> longitude, ref Option<double> range, ref Option<string> sortField, ref Option<bool> descending, ref Option<int> start, ref Option<int> limit, ref Option<bool> activeOnly);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="keyword"></param>
        /// <param name="tags"></param>
        /// <param name="audienceIds"></param>
        /// <param name="sortField"></param>
        /// <returns></returns>
        private void ValidateSearchAccountsWithTrackingLegs(Option<string> keyword, Option<string> tags, Option<string> audienceIds, Option<string> sortField)
        {
            if (keyword.IsSet && keyword.Value == null)
                throw new ArgumentNullException(nameof(keyword));

            if (tags.IsSet && tags.Value == null)
                throw new ArgumentNullException(nameof(tags));

            if (audienceIds.IsSet && audienceIds.Value == null)
                throw new ArgumentNullException(nameof(audienceIds));

            if (sortField.IsSet && sortField.Value == null)
                throw new ArgumentNullException(nameof(sortField));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="keyword"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="tags"></param>
        /// <param name="audienceIds"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="range"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        private void AfterSearchAccountsWithTrackingLegsDefaultImplementation(ISearchAccountsWithTrackingLegsApiResponse apiResponseLocalVar, decimal version, long accountId, Option<string> keyword, Option<long> startDate, Option<long> endDate, Option<string> tags, Option<string> audienceIds, Option<double> latitude, Option<double> longitude, Option<double> range, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit, Option<bool> activeOnly)
        {
            bool suppressDefaultLog = false;
            AfterSearchAccountsWithTrackingLegs(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, keyword, startDate, endDate, tags, audienceIds, latitude, longitude, range, sortField, descending, start, limit, activeOnly);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="keyword"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="tags"></param>
        /// <param name="audienceIds"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="range"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        partial void AfterSearchAccountsWithTrackingLegs(ref bool suppressDefaultLog, ISearchAccountsWithTrackingLegsApiResponse apiResponseLocalVar, decimal version, long accountId, Option<string> keyword, Option<long> startDate, Option<long> endDate, Option<string> tags, Option<string> audienceIds, Option<double> latitude, Option<double> longitude, Option<double> range, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit, Option<bool> activeOnly);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="keyword"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="tags"></param>
        /// <param name="audienceIds"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="range"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        private void OnErrorSearchAccountsWithTrackingLegsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, Option<string> keyword, Option<long> startDate, Option<long> endDate, Option<string> tags, Option<string> audienceIds, Option<double> latitude, Option<double> longitude, Option<double> range, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit, Option<bool> activeOnly)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchAccountsWithTrackingLegs(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, keyword, startDate, endDate, tags, audienceIds, latitude, longitude, range, sortField, descending, start, limit, activeOnly);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="keyword"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="tags"></param>
        /// <param name="audienceIds"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="range"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        partial void OnErrorSearchAccountsWithTrackingLegs(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, Option<string> keyword, Option<long> startDate, Option<long> endDate, Option<string> tags, Option<string> audienceIds, Option<double> latitude, Option<double> longitude, Option<double> range, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit, Option<bool> activeOnly);

        /// <summary>
        /// List Tracking Search for all accounts that have tracking legs data by the given constraints.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">The account id of the user</param>
        /// <param name="keyword">Used for LIKE search of first or last name on the acocunt (optional)</param>
        /// <param name="startDate">Range to begin in UTC milliseconds (optional)</param>
        /// <param name="endDate">Range to end in UTC milliseconds (optional)</param>
        /// <param name="tags">Exact match on tag field of Legs&#39;s searchTag (optional)</param>
        /// <param name="audienceIds"> (optional)</param>
        /// <param name="latitude">Origin latitude to perform searching constraints with given range (optional)</param>
        /// <param name="longitude">Origin longitude to perform searching constraints with given range (optional)</param>
        /// <param name="range">The radius, in miles, to perform the search for (optional, default to 5D)</param>
        /// <param name="sortField">The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to &quot;LEG_START_DATE&quot;)</param>
        /// <param name="descending">The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)</param>
        /// <param name="start">The index into the record set to start with. Default is 0. (optional, default to 0)</param>
        /// <param name="limit">The total number of records to return. Default is 20. (optional, default to 20)</param>
        /// <param name="activeOnly">Determines whether to return only active results. Default is false. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchAccountsWithTrackingLegsApiResponse"/>&gt;</returns>
        public async Task<ISearchAccountsWithTrackingLegsApiResponse?> SearchAccountsWithTrackingLegsOrDefaultAsync(decimal version, long accountId, Option<string> keyword = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> tags = default, Option<string> audienceIds = default, Option<double> latitude = default, Option<double> longitude = default, Option<double> range = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, Option<bool> activeOnly = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchAccountsWithTrackingLegsAsync(version, accountId, keyword, startDate, endDate, tags, audienceIds, latitude, longitude, range, sortField, descending, start, limit, activeOnly, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List Tracking Search for all accounts that have tracking legs data by the given constraints.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The account id of the user</param>
        /// <param name="keyword">Used for LIKE search of first or last name on the acocunt (optional)</param>
        /// <param name="startDate">Range to begin in UTC milliseconds (optional)</param>
        /// <param name="endDate">Range to end in UTC milliseconds (optional)</param>
        /// <param name="tags">Exact match on tag field of Legs&#39;s searchTag (optional)</param>
        /// <param name="audienceIds"> (optional)</param>
        /// <param name="latitude">Origin latitude to perform searching constraints with given range (optional)</param>
        /// <param name="longitude">Origin longitude to perform searching constraints with given range (optional)</param>
        /// <param name="range">The radius, in miles, to perform the search for (optional, default to 5D)</param>
        /// <param name="sortField">The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to &quot;LEG_START_DATE&quot;)</param>
        /// <param name="descending">The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)</param>
        /// <param name="start">The index into the record set to start with. Default is 0. (optional, default to 0)</param>
        /// <param name="limit">The total number of records to return. Default is 20. (optional, default to 20)</param>
        /// <param name="activeOnly">Determines whether to return only active results. Default is false. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchAccountsWithTrackingLegsApiResponse"/>&gt;</returns>
        public async Task<ISearchAccountsWithTrackingLegsApiResponse> SearchAccountsWithTrackingLegsAsync(decimal version, long accountId, Option<string> keyword = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> tags = default, Option<string> audienceIds = default, Option<double> latitude = default, Option<double> longitude = default, Option<double> range = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, Option<bool> activeOnly = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchAccountsWithTrackingLegs(keyword, tags, audienceIds, sortField);

                FormatSearchAccountsWithTrackingLegs(ref version, ref accountId, ref keyword, ref startDate, ref endDate, ref tags, ref audienceIds, ref latitude, ref longitude, ref range, ref sortField, ref descending, ref start, ref limit, ref activeOnly);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/tracking/list"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/tracking/list");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    if (keyword.IsSet)
                        parseQueryStringLocalVar["keyword"] = ClientUtils.ParameterToString(keyword.Value);

                    if (startDate.IsSet)
                        parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate.Value);

                    if (endDate.IsSet)
                        parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate.Value);

                    if (tags.IsSet)
                        parseQueryStringLocalVar["tags"] = ClientUtils.ParameterToString(tags.Value);

                    if (audienceIds.IsSet)
                        parseQueryStringLocalVar["audienceIds"] = ClientUtils.ParameterToString(audienceIds.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    if (range.IsSet)
                        parseQueryStringLocalVar["range"] = ClientUtils.ParameterToString(range.Value);

                    if (sortField.IsSet)
                        parseQueryStringLocalVar["sortField"] = ClientUtils.ParameterToString(sortField.Value);

                    if (descending.IsSet)
                        parseQueryStringLocalVar["descending"] = ClientUtils.ParameterToString(descending.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (activeOnly.IsSet)
                        parseQueryStringLocalVar["activeOnly"] = ClientUtils.ParameterToString(activeOnly.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchAccountsWithTrackingLegsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchAccountsWithTrackingLegsApiResponse>();
                        SearchAccountsWithTrackingLegsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/tracking/list", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchAccountsWithTrackingLegsDefaultImplementation(apiResponseLocalVar, version, accountId, keyword, startDate, endDate, tags, audienceIds, latitude, longitude, range, sortField, descending, start, limit, activeOnly);

                        Events.ExecuteOnSearchAccountsWithTrackingLegs(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchAccountsWithTrackingLegsDefaultImplementation(e, "/api/{version}/tracking/list", uriBuilderLocalVar.Path, version, accountId, keyword, startDate, endDate, tags, audienceIds, latitude, longitude, range, sortField, descending, start, limit, activeOnly);
                Events.ExecuteOnErrorSearchAccountsWithTrackingLegs(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchAccountsWithTrackingLegsApiResponse"/>
        /// </summary>
        public partial class SearchAccountsWithTrackingLegsApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchAccountsWithTrackingLegsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchAccountsWithTrackingLegsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchAccountsWithTrackingLegsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchAccountsWithTrackingLegsApiResponse(ILogger<SearchAccountsWithTrackingLegsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchAccountsWithTrackingLegsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchAccountsWithTrackingLegsApiResponse(ILogger<SearchAccountsWithTrackingLegsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<AccountMiniResponse>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<AccountMiniResponse>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<AccountMiniResponse>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchTrackingLegs(ref decimal version, ref long accountId, ref string appKey, ref Option<string> trackingDeviceId, ref Option<long> startDate, ref Option<long> endDate, ref Option<string> tags, ref Option<int> start, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="appKey"></param>
        /// <param name="trackingDeviceId"></param>
        /// <param name="tags"></param>
        /// <returns></returns>
        private void ValidateSearchTrackingLegs(string appKey, Option<string> trackingDeviceId, Option<string> tags)
        {
            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));

            if (trackingDeviceId.IsSet && trackingDeviceId.Value == null)
                throw new ArgumentNullException(nameof(trackingDeviceId));

            if (tags.IsSet && tags.Value == null)
                throw new ArgumentNullException(nameof(tags));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="trackingDeviceId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="tags"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void AfterSearchTrackingLegsDefaultImplementation(ISearchTrackingLegsApiResponse apiResponseLocalVar, decimal version, long accountId, string appKey, Option<string> trackingDeviceId, Option<long> startDate, Option<long> endDate, Option<string> tags, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterSearchTrackingLegs(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, appKey, trackingDeviceId, startDate, endDate, tags, start, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="trackingDeviceId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="tags"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void AfterSearchTrackingLegs(ref bool suppressDefaultLog, ISearchTrackingLegsApiResponse apiResponseLocalVar, decimal version, long accountId, string appKey, Option<string> trackingDeviceId, Option<long> startDate, Option<long> endDate, Option<string> tags, Option<int> start, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="trackingDeviceId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="tags"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void OnErrorSearchTrackingLegsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string appKey, Option<string> trackingDeviceId, Option<long> startDate, Option<long> endDate, Option<string> tags, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchTrackingLegs(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, appKey, trackingDeviceId, startDate, endDate, tags, start, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="trackingDeviceId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="tags"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void OnErrorSearchTrackingLegs(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string appKey, Option<string> trackingDeviceId, Option<long> startDate, Option<long> endDate, Option<string> tags, Option<int> start, Option<int> limit);

        /// <summary>
        /// Search Tracking (Billable) Retrieve tracking data for billable/account scoped queries.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">The account id to search tracking for</param>
        /// <param name="appKey">The application key</param>
        /// <param name="trackingDeviceId">The id of the tracking device (optional)</param>
        /// <param name="startDate">The start date in (UTC milliseconds) to filter the tracking results (optional)</param>
        /// <param name="endDate">The end date in (UTC milliseconds) to filter the tracking results (optional)</param>
        /// <param name="tags">Filter results by tag (optional)</param>
        /// <param name="start">The start index for pagination (optional, default to 0)</param>
        /// <param name="limit">The limit for pagination (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchTrackingLegsApiResponse"/>&gt;</returns>
        public async Task<ISearchTrackingLegsApiResponse?> SearchTrackingLegsOrDefaultAsync(decimal version, long accountId, string appKey, Option<string> trackingDeviceId = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> tags = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchTrackingLegsAsync(version, accountId, appKey, trackingDeviceId, startDate, endDate, tags, start, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Tracking (Billable) Retrieve tracking data for billable/account scoped queries.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The account id to search tracking for</param>
        /// <param name="appKey">The application key</param>
        /// <param name="trackingDeviceId">The id of the tracking device (optional)</param>
        /// <param name="startDate">The start date in (UTC milliseconds) to filter the tracking results (optional)</param>
        /// <param name="endDate">The end date in (UTC milliseconds) to filter the tracking results (optional)</param>
        /// <param name="tags">Filter results by tag (optional)</param>
        /// <param name="start">The start index for pagination (optional, default to 0)</param>
        /// <param name="limit">The limit for pagination (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchTrackingLegsApiResponse"/>&gt;</returns>
        public async Task<ISearchTrackingLegsApiResponse> SearchTrackingLegsAsync(decimal version, long accountId, string appKey, Option<string> trackingDeviceId = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> tags = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchTrackingLegs(appKey, trackingDeviceId, tags);

                FormatSearchTrackingLegs(ref version, ref accountId, ref appKey, ref trackingDeviceId, ref startDate, ref endDate, ref tags, ref start, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/tracking/searchByBillable"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/tracking/searchByBillable");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey);

                    if (trackingDeviceId.IsSet)
                        parseQueryStringLocalVar["trackingDeviceId"] = ClientUtils.ParameterToString(trackingDeviceId.Value);

                    if (startDate.IsSet)
                        parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate.Value);

                    if (endDate.IsSet)
                        parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate.Value);

                    if (tags.IsSet)
                        parseQueryStringLocalVar["tags"] = ClientUtils.ParameterToString(tags.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchTrackingLegsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchTrackingLegsApiResponse>();
                        SearchTrackingLegsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/tracking/searchByBillable", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchTrackingLegsDefaultImplementation(apiResponseLocalVar, version, accountId, appKey, trackingDeviceId, startDate, endDate, tags, start, limit);

                        Events.ExecuteOnSearchTrackingLegs(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchTrackingLegsDefaultImplementation(e, "/api/{version}/tracking/searchByBillable", uriBuilderLocalVar.Path, version, accountId, appKey, trackingDeviceId, startDate, endDate, tags, start, limit);
                Events.ExecuteOnErrorSearchTrackingLegs(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchTrackingLegsApiResponse"/>
        /// </summary>
        public partial class SearchTrackingLegsApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchTrackingLegsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchTrackingLegsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchTrackingLegsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchTrackingLegsApiResponse(ILogger<SearchTrackingLegsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchTrackingLegsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchTrackingLegsApiResponse(ILogger<SearchTrackingLegsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<LegResponse>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<LegResponse>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<LegResponse>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
