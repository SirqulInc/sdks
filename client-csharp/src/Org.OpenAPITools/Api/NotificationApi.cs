// <auto-generated>
/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Net;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface INotificationApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        NotificationApiEvents Events { get; }

        /// <summary>
        /// Create Notification Template
        /// </summary>
        /// <remarks>
        /// Create a notification template. Developers will only be able to create notification templates for their own applications.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The account ID of the user.</param>
        /// <param name="conduit">Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.</param>
        /// <param name="title">title of the notification template</param>
        /// <param name="body">body of the notification template</param>
        /// <param name="appKey">Filter results by application. (optional)</param>
        /// <param name="varEvent">Filter results by event. (optional)</param>
        /// <param name="tags">tags associated with the note template (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateNotificationTemplateApiResponse"/>&gt;</returns>
        Task<ICreateNotificationTemplateApiResponse> CreateNotificationTemplateAsync(long accountId, string conduit, string title, string body, Option<string> appKey = default, Option<string> varEvent = default, Option<string> tags = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Notification Template
        /// </summary>
        /// <remarks>
        /// Create a notification template. Developers will only be able to create notification templates for their own applications.
        /// </remarks>
        /// <param name="accountId">The account ID of the user.</param>
        /// <param name="conduit">Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.</param>
        /// <param name="title">title of the notification template</param>
        /// <param name="body">body of the notification template</param>
        /// <param name="appKey">Filter results by application. (optional)</param>
        /// <param name="varEvent">Filter results by event. (optional)</param>
        /// <param name="tags">tags associated with the note template (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateNotificationTemplateApiResponse"/>?&gt;</returns>
        Task<ICreateNotificationTemplateApiResponse?> CreateNotificationTemplateOrDefaultAsync(long accountId, string conduit, string title, string body, Option<string> appKey = default, Option<string> varEvent = default, Option<string> tags = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create or update blocked notification settings
        /// </summary>
        /// <remarks>
        /// Create or update blocked notification settings
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="appKey">The application key</param>
        /// <param name="data">batch data payload (application specific)</param>
        /// <param name="accountId">the account id of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateOrUpdateBlockedNotificationsApiResponse"/>&gt;</returns>
        Task<ICreateOrUpdateBlockedNotificationsApiResponse> CreateOrUpdateBlockedNotificationsAsync(string appKey, string data, Option<long> accountId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create or update blocked notification settings
        /// </summary>
        /// <remarks>
        /// Create or update blocked notification settings
        /// </remarks>
        /// <param name="appKey">The application key</param>
        /// <param name="data">batch data payload (application specific)</param>
        /// <param name="accountId">the account id of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateOrUpdateBlockedNotificationsApiResponse"/>?&gt;</returns>
        Task<ICreateOrUpdateBlockedNotificationsApiResponse?> CreateOrUpdateBlockedNotificationsOrDefaultAsync(string appKey, string data, Option<long> accountId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Notification Template
        /// </summary>
        /// <remarks>
        /// Deletes a notification template. Developers will only be able to delete notification templates for their own applications.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="notificationTemplateId">the id of the notification template to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteNotificationTemplateApiResponse"/>&gt;</returns>
        Task<IDeleteNotificationTemplateApiResponse> DeleteNotificationTemplateAsync(long accountId, long notificationTemplateId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Notification Template
        /// </summary>
        /// <remarks>
        /// Deletes a notification template. Developers will only be able to delete notification templates for their own applications.
        /// </remarks>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="notificationTemplateId">the id of the notification template to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteNotificationTemplateApiResponse"/>?&gt;</returns>
        Task<IDeleteNotificationTemplateApiResponse?> DeleteNotificationTemplateOrDefaultAsync(long accountId, long notificationTemplateId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Notification Template
        /// </summary>
        /// <remarks>
        /// Get the details of a notification template. Developers will only be able to see notification templates for their own applications.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the id of the account</param>
        /// <param name="notificationTemplateId">the id of the notification template to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNotificationTemplateApiResponse"/>&gt;</returns>
        Task<IGetNotificationTemplateApiResponse> GetNotificationTemplateAsync(long accountId, long notificationTemplateId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Notification Template
        /// </summary>
        /// <remarks>
        /// Get the details of a notification template. Developers will only be able to see notification templates for their own applications.
        /// </remarks>
        /// <param name="accountId">the id of the account</param>
        /// <param name="notificationTemplateId">the id of the notification template to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNotificationTemplateApiResponse"/>?&gt;</returns>
        Task<IGetNotificationTemplateApiResponse?> GetNotificationTemplateOrDefaultAsync(long accountId, long notificationTemplateId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Notifications
        /// </summary>
        /// <remarks>
        /// Get a list of notifications for a user. If the \&quot;markAsRead\&quot; parameter is set to true, the returned notifications will be marked as \&quot;read\&quot; after the response has been sent. By default, read messages will not be returned, so to see read messages, set \&quot;returnReadMessages\&quot; to true.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="deviceId">the unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionAccountId">the account id used to view another person&#39;s notifications (optional)</param>
        /// <param name="appKey">the application key to filter messages by application (optional)</param>
        /// <param name="eventType">comma separated list of EVENTS. Filters search results to only include these events. Don&#39;t include this parameter or pass in an empty string to return all event types. (optional)</param>
        /// <param name="contentIds">comma separated list of content ids to search notifications on (optional)</param>
        /// <param name="contentTypes">comma separated list of content types to search notifications on (optional)</param>
        /// <param name="parentIds">comma separated list of parent ids to search notifications on (optional)</param>
        /// <param name="parentTypes">comma separated list of parent types to search notifications on (optional)</param>
        /// <param name="actionCategory">Action category used to filter notifications (optional)</param>
        /// <param name="conduits">comma separated list of conduits to search notifications on (optional)</param>
        /// <param name="keyword">search notifications via keyword (optional)</param>
        /// <param name="returnReadMessages">if set to true, will return notifications that have been marked as read (optional)</param>
        /// <param name="markAsRead">if set to true, the returned notifications will be marked as \\\&quot;read\\\&quot; after the response has been sent (optional)</param>
        /// <param name="fromDate">filter notifications from this date (optional)</param>
        /// <param name="latitude">latitude used to update the user&#39;s current location (optional)</param>
        /// <param name="longitude">longitude used to update the user&#39;s current location (optional)</param>
        /// <param name="returnSent">whether to include notifications sent by the requester in the response (optional)</param>
        /// <param name="ignoreFlagged">whether to ignore flagged notifications (optional)</param>
        /// <param name="start">start of the pagination (optional)</param>
        /// <param name="limit">limit of the pagination (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNotificationsApiResponse"/>&gt;</returns>
        Task<IGetNotificationsApiResponse> GetNotificationsAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionAccountId = default, Option<string> appKey = default, Option<string> eventType = default, Option<string> contentIds = default, Option<string> contentTypes = default, Option<string> parentIds = default, Option<string> parentTypes = default, Option<string> actionCategory = default, Option<string> conduits = default, Option<string> keyword = default, Option<bool> returnReadMessages = default, Option<bool> markAsRead = default, Option<long> fromDate = default, Option<double> latitude = default, Option<double> longitude = default, Option<bool> returnSent = default, Option<bool> ignoreFlagged = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Notifications
        /// </summary>
        /// <remarks>
        /// Get a list of notifications for a user. If the \&quot;markAsRead\&quot; parameter is set to true, the returned notifications will be marked as \&quot;read\&quot; after the response has been sent. By default, read messages will not be returned, so to see read messages, set \&quot;returnReadMessages\&quot; to true.
        /// </remarks>
        /// <param name="deviceId">the unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionAccountId">the account id used to view another person&#39;s notifications (optional)</param>
        /// <param name="appKey">the application key to filter messages by application (optional)</param>
        /// <param name="eventType">comma separated list of EVENTS. Filters search results to only include these events. Don&#39;t include this parameter or pass in an empty string to return all event types. (optional)</param>
        /// <param name="contentIds">comma separated list of content ids to search notifications on (optional)</param>
        /// <param name="contentTypes">comma separated list of content types to search notifications on (optional)</param>
        /// <param name="parentIds">comma separated list of parent ids to search notifications on (optional)</param>
        /// <param name="parentTypes">comma separated list of parent types to search notifications on (optional)</param>
        /// <param name="actionCategory">Action category used to filter notifications (optional)</param>
        /// <param name="conduits">comma separated list of conduits to search notifications on (optional)</param>
        /// <param name="keyword">search notifications via keyword (optional)</param>
        /// <param name="returnReadMessages">if set to true, will return notifications that have been marked as read (optional)</param>
        /// <param name="markAsRead">if set to true, the returned notifications will be marked as \\\&quot;read\\\&quot; after the response has been sent (optional)</param>
        /// <param name="fromDate">filter notifications from this date (optional)</param>
        /// <param name="latitude">latitude used to update the user&#39;s current location (optional)</param>
        /// <param name="longitude">longitude used to update the user&#39;s current location (optional)</param>
        /// <param name="returnSent">whether to include notifications sent by the requester in the response (optional)</param>
        /// <param name="ignoreFlagged">whether to ignore flagged notifications (optional)</param>
        /// <param name="start">start of the pagination (optional)</param>
        /// <param name="limit">limit of the pagination (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNotificationsApiResponse"/>?&gt;</returns>
        Task<IGetNotificationsApiResponse?> GetNotificationsOrDefaultAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionAccountId = default, Option<string> appKey = default, Option<string> eventType = default, Option<string> contentIds = default, Option<string> contentTypes = default, Option<string> parentIds = default, Option<string> parentTypes = default, Option<string> actionCategory = default, Option<string> conduits = default, Option<string> keyword = default, Option<bool> returnReadMessages = default, Option<bool> markAsRead = default, Option<long> fromDate = default, Option<double> latitude = default, Option<double> longitude = default, Option<bool> returnSent = default, Option<bool> ignoreFlagged = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Register Notification Token
        /// </summary>
        /// <remarks>
        /// Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">A token that is generated by the device to sign requests for the notification service providers</param>
        /// <param name="pushType">The type of push notification. Possible values include: APNS, GCM</param>
        /// <param name="deviceId">The unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">The account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="environment">Determines if the token is a DEVELOPMENT or PRODUCTION token (optional)</param>
        /// <param name="appKey">The application key (optional)</param>
        /// <param name="gameType">This parameter is deprecated (use appKey instead) (optional)</param>
        /// <param name="active">Sets whether the token is active or not (non-active tokens are not used) (optional)</param>
        /// <param name="latitude">Latitude used to update the user&#39;s current location (optional)</param>
        /// <param name="longitude">Longitude used to update the user&#39;s current location (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRegisterNotificationTokenApiResponse"/>&gt;</returns>
        Task<IRegisterNotificationTokenApiResponse> RegisterNotificationTokenAsync(string token, string pushType, Option<string> deviceId = default, Option<long> accountId = default, Option<string> environment = default, Option<string> appKey = default, Option<string> gameType = default, Option<bool> active = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Register Notification Token
        /// </summary>
        /// <remarks>
        /// Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.
        /// </remarks>
        /// <param name="token">A token that is generated by the device to sign requests for the notification service providers</param>
        /// <param name="pushType">The type of push notification. Possible values include: APNS, GCM</param>
        /// <param name="deviceId">The unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">The account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="environment">Determines if the token is a DEVELOPMENT or PRODUCTION token (optional)</param>
        /// <param name="appKey">The application key (optional)</param>
        /// <param name="gameType">This parameter is deprecated (use appKey instead) (optional)</param>
        /// <param name="active">Sets whether the token is active or not (non-active tokens are not used) (optional)</param>
        /// <param name="latitude">Latitude used to update the user&#39;s current location (optional)</param>
        /// <param name="longitude">Longitude used to update the user&#39;s current location (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRegisterNotificationTokenApiResponse"/>?&gt;</returns>
        Task<IRegisterNotificationTokenApiResponse?> RegisterNotificationTokenOrDefaultAsync(string token, string pushType, Option<string> deviceId = default, Option<long> accountId = default, Option<string> environment = default, Option<string> appKey = default, Option<string> gameType = default, Option<bool> active = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search on the user&#39;s blocked notification settings
        /// </summary>
        /// <remarks>
        /// Search on the user&#39;s blocked notification settings
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="appKey">The application key</param>
        /// <param name="accountId">the account id of the user (optional)</param>
        /// <param name="searchTags">search tags to filter results (optional)</param>
        /// <param name="events">events to filter by (comma separated) (optional)</param>
        /// <param name="conduits">conduits to filter by (comma separated) (optional)</param>
        /// <param name="customTypes">custom types to filter by (comma separated) (optional)</param>
        /// <param name="contentTypes">content types to filter by (comma separated) (optional)</param>
        /// <param name="contentIds">content ids to filter by (comma separated) (optional)</param>
        /// <param name="sortField">sort field for results (optional)</param>
        /// <param name="descending">whether to sort descending (optional)</param>
        /// <param name="start">start of the pagination (optional)</param>
        /// <param name="limit">limit of the pagination (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchBlockedNotificationsApiResponse"/>&gt;</returns>
        Task<ISearchBlockedNotificationsApiResponse> SearchBlockedNotificationsAsync(string appKey, Option<long> accountId = default, Option<string> searchTags = default, Option<string> events = default, Option<string> conduits = default, Option<string> customTypes = default, Option<string> contentTypes = default, Option<string> contentIds = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search on the user&#39;s blocked notification settings
        /// </summary>
        /// <remarks>
        /// Search on the user&#39;s blocked notification settings
        /// </remarks>
        /// <param name="appKey">The application key</param>
        /// <param name="accountId">the account id of the user (optional)</param>
        /// <param name="searchTags">search tags to filter results (optional)</param>
        /// <param name="events">events to filter by (comma separated) (optional)</param>
        /// <param name="conduits">conduits to filter by (comma separated) (optional)</param>
        /// <param name="customTypes">custom types to filter by (comma separated) (optional)</param>
        /// <param name="contentTypes">content types to filter by (comma separated) (optional)</param>
        /// <param name="contentIds">content ids to filter by (comma separated) (optional)</param>
        /// <param name="sortField">sort field for results (optional)</param>
        /// <param name="descending">whether to sort descending (optional)</param>
        /// <param name="start">start of the pagination (optional)</param>
        /// <param name="limit">limit of the pagination (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchBlockedNotificationsApiResponse"/>?&gt;</returns>
        Task<ISearchBlockedNotificationsApiResponse?> SearchBlockedNotificationsOrDefaultAsync(string appKey, Option<long> accountId = default, Option<string> searchTags = default, Option<string> events = default, Option<string> conduits = default, Option<string> customTypes = default, Option<string> contentTypes = default, Option<string> contentIds = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Notification Templates
        /// </summary>
        /// <remarks>
        /// Search for notification templates on owned applications.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The account ID of the user.</param>
        /// <param name="sortField">Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name (&#39;global&#39; templates will not have an application and will be returned last if &#39;descending&#39; is set to false.</param>
        /// <param name="descending">Specified whether the results are returned in descending or ascending order.</param>
        /// <param name="start">The start of the pagination.</param>
        /// <param name="limit">The limit of the pagination.</param>
        /// <param name="appKey">Filter results by application. (optional)</param>
        /// <param name="varEvent">Filter results by event. (optional)</param>
        /// <param name="conduit">Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="globalOnly">Returns only templates that have been reserved for system use on all applications (only for admin accounts). (optional)</param>
        /// <param name="reservedOnly">Returns only templates that use reserved events. (optional)</param>
        /// <param name="keyword">Filter results by keyword on the title, tags. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchNotificationTemplateApiResponse"/>&gt;</returns>
        Task<ISearchNotificationTemplateApiResponse> SearchNotificationTemplateAsync(long accountId, string sortField, bool descending, int start, int limit, Option<string> appKey = default, Option<string> varEvent = default, Option<string> conduit = default, Option<bool> globalOnly = default, Option<bool> reservedOnly = default, Option<string> keyword = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Notification Templates
        /// </summary>
        /// <remarks>
        /// Search for notification templates on owned applications.
        /// </remarks>
        /// <param name="accountId">The account ID of the user.</param>
        /// <param name="sortField">Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name (&#39;global&#39; templates will not have an application and will be returned last if &#39;descending&#39; is set to false.</param>
        /// <param name="descending">Specified whether the results are returned in descending or ascending order.</param>
        /// <param name="start">The start of the pagination.</param>
        /// <param name="limit">The limit of the pagination.</param>
        /// <param name="appKey">Filter results by application. (optional)</param>
        /// <param name="varEvent">Filter results by event. (optional)</param>
        /// <param name="conduit">Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="globalOnly">Returns only templates that have been reserved for system use on all applications (only for admin accounts). (optional)</param>
        /// <param name="reservedOnly">Returns only templates that use reserved events. (optional)</param>
        /// <param name="keyword">Filter results by keyword on the title, tags. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchNotificationTemplateApiResponse"/>?&gt;</returns>
        Task<ISearchNotificationTemplateApiResponse?> SearchNotificationTemplateOrDefaultAsync(long accountId, string sortField, bool descending, int start, int limit, Option<string> appKey = default, Option<string> varEvent = default, Option<string> conduit = default, Option<bool> globalOnly = default, Option<bool> reservedOnly = default, Option<string> keyword = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search for Recipients
        /// </summary>
        /// <remarks>
        /// Search for application users to send notifications.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortField">The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}</param>
        /// <param name="deviceId">the unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="appKey">filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)</param>
        /// <param name="conduit">the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="keyword">search by keyword on user&#39;s display name and email (optional)</param>
        /// <param name="audienceId">This parameter is deprecated. filter results by audience (optional)</param>
        /// <param name="audienceIds">filter results by audiences (comma separated list of audience ids) (optional)</param>
        /// <param name="connectionGroupIds">filter results by connection groups (comma separated list of connection group ids) (optional)</param>
        /// <param name="recipientAccountIds">filter results by accounts (comma separated list of account ids) (optional)</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order (optional)</param>
        /// <param name="start">start of the pagination (optional)</param>
        /// <param name="limit">limit of the pagination (hard limit of 1000) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchRecipientsApiResponse"/>&gt;</returns>
        Task<ISearchRecipientsApiResponse> SearchRecipientsAsync(string sortField, Option<string> deviceId = default, Option<long> accountId = default, Option<string> appKey = default, Option<string> conduit = default, Option<string> keyword = default, Option<long> audienceId = default, Option<string> audienceIds = default, Option<string> connectionGroupIds = default, Option<string> recipientAccountIds = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search for Recipients
        /// </summary>
        /// <remarks>
        /// Search for application users to send notifications.
        /// </remarks>
        /// <param name="sortField">The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}</param>
        /// <param name="deviceId">the unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="appKey">filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)</param>
        /// <param name="conduit">the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="keyword">search by keyword on user&#39;s display name and email (optional)</param>
        /// <param name="audienceId">This parameter is deprecated. filter results by audience (optional)</param>
        /// <param name="audienceIds">filter results by audiences (comma separated list of audience ids) (optional)</param>
        /// <param name="connectionGroupIds">filter results by connection groups (comma separated list of connection group ids) (optional)</param>
        /// <param name="recipientAccountIds">filter results by accounts (comma separated list of account ids) (optional)</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order (optional)</param>
        /// <param name="start">start of the pagination (optional)</param>
        /// <param name="limit">limit of the pagination (hard limit of 1000) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchRecipientsApiResponse"/>?&gt;</returns>
        Task<ISearchRecipientsApiResponse?> SearchRecipientsOrDefaultAsync(string sortField, Option<string> deviceId = default, Option<long> accountId = default, Option<string> appKey = default, Option<string> conduit = default, Option<string> keyword = default, Option<long> audienceId = default, Option<string> audienceIds = default, Option<string> connectionGroupIds = default, Option<string> recipientAccountIds = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search for Recipients (Counts/Grouped)
        /// </summary>
        /// <remarks>
        /// Search for application users to send notifications (count/grouped variant).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="deviceId">the unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="appKey">filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)</param>
        /// <param name="conduit">the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="keyword">search by keyword on user&#39;s display name and email (optional)</param>
        /// <param name="audienceId">This parameter is deprecated. filter results by audience (optional)</param>
        /// <param name="audienceIds">filter results by audiences (comma separated list of audience ids) (optional)</param>
        /// <param name="connectionGroupIds">filter results by connection groups (comma separated list of connection group ids) (optional)</param>
        /// <param name="sortField">The field to sort by (see API docs for allowed values). (optional)</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order (optional)</param>
        /// <param name="start">start of the pagination (optional)</param>
        /// <param name="limit">limit of the pagination (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchRecipientsCountApiResponse"/>&gt;</returns>
        Task<ISearchRecipientsCountApiResponse> SearchRecipientsCountAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<string> appKey = default, Option<string> conduit = default, Option<string> keyword = default, Option<long> audienceId = default, Option<string> audienceIds = default, Option<string> connectionGroupIds = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search for Recipients (Counts/Grouped)
        /// </summary>
        /// <remarks>
        /// Search for application users to send notifications (count/grouped variant).
        /// </remarks>
        /// <param name="deviceId">the unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="appKey">filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)</param>
        /// <param name="conduit">the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="keyword">search by keyword on user&#39;s display name and email (optional)</param>
        /// <param name="audienceId">This parameter is deprecated. filter results by audience (optional)</param>
        /// <param name="audienceIds">filter results by audiences (comma separated list of audience ids) (optional)</param>
        /// <param name="connectionGroupIds">filter results by connection groups (comma separated list of connection group ids) (optional)</param>
        /// <param name="sortField">The field to sort by (see API docs for allowed values). (optional)</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order (optional)</param>
        /// <param name="start">start of the pagination (optional)</param>
        /// <param name="limit">limit of the pagination (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchRecipientsCountApiResponse"/>?&gt;</returns>
        Task<ISearchRecipientsCountApiResponse?> SearchRecipientsCountOrDefaultAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<string> appKey = default, Option<string> conduit = default, Option<string> keyword = default, Option<long> audienceId = default, Option<string> audienceIds = default, Option<string> connectionGroupIds = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send Batch Notifications
        /// </summary>
        /// <remarks>
        /// Send notifications to all users of an application. Only someone with permissions to the application can do this.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The account id of the application owner/manager</param>
        /// <param name="appKey">The application key for updating an existing application</param>
        /// <param name="customMessage">Message string that will be displayed in on the notification</param>
        /// <param name="conduit">The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="contentId">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="contentName">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="contentType">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="parentId">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="parentType">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendBatchNotificationsApiResponse"/>&gt;</returns>
        Task<ISendBatchNotificationsApiResponse> SendBatchNotificationsAsync(long accountId, string appKey, string customMessage, Option<string> conduit = default, Option<long> contentId = default, Option<string> contentName = default, Option<string> contentType = default, Option<long> parentId = default, Option<string> parentType = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send Batch Notifications
        /// </summary>
        /// <remarks>
        /// Send notifications to all users of an application. Only someone with permissions to the application can do this.
        /// </remarks>
        /// <param name="accountId">The account id of the application owner/manager</param>
        /// <param name="appKey">The application key for updating an existing application</param>
        /// <param name="customMessage">Message string that will be displayed in on the notification</param>
        /// <param name="conduit">The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="contentId">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="contentName">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="contentType">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="parentId">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="parentType">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendBatchNotificationsApiResponse"/>?&gt;</returns>
        Task<ISendBatchNotificationsApiResponse?> SendBatchNotificationsOrDefaultAsync(long accountId, string appKey, string customMessage, Option<string> conduit = default, Option<long> contentId = default, Option<string> contentName = default, Option<string> contentType = default, Option<long> parentId = default, Option<string> parentType = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send Custom Notifications
        /// </summary>
        /// <remarks>
        /// Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="deviceId">the unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="receiverAccountIds">comma separated list of account IDs that will receive the notification (optional)</param>
        /// <param name="includeFriendGroup">determines whether to send to all of the user&#39;s friends, this flag must be true or receiverAccountIds must not be empty (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="conduit">the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="contentId">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="contentName">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="contentType">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="parentId">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="parentType">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="actionCategory"> (optional)</param>
        /// <param name="subject">the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="customMessage">message string that will be displayed in on the notification (optional)</param>
        /// <param name="friendOnlyAPNS">only sends APNS to people who are friends of the user (still saves the notification message for feed polling) (optional)</param>
        /// <param name="latitude">latitude used to update the user&#39;s current location (optional)</param>
        /// <param name="longitude">longitude used to update the user&#39;s current location (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendCustomNotificationsApiResponse"/>&gt;</returns>
        Task<ISendCustomNotificationsApiResponse> SendCustomNotificationsAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<string> receiverAccountIds = default, Option<bool> includeFriendGroup = default, Option<string> appKey = default, Option<string> gameType = default, Option<string> conduit = default, Option<long> contentId = default, Option<string> contentName = default, Option<string> contentType = default, Option<long> parentId = default, Option<string> parentType = default, Option<string> actionCategory = default, Option<string> subject = default, Option<string> customMessage = default, Option<bool> friendOnlyAPNS = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Send Custom Notifications
        /// </summary>
        /// <remarks>
        /// Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.
        /// </remarks>
        /// <param name="deviceId">the unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="receiverAccountIds">comma separated list of account IDs that will receive the notification (optional)</param>
        /// <param name="includeFriendGroup">determines whether to send to all of the user&#39;s friends, this flag must be true or receiverAccountIds must not be empty (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="conduit">the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="contentId">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="contentName">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="contentType">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="parentId">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="parentType">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="actionCategory"> (optional)</param>
        /// <param name="subject">the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="customMessage">message string that will be displayed in on the notification (optional)</param>
        /// <param name="friendOnlyAPNS">only sends APNS to people who are friends of the user (still saves the notification message for feed polling) (optional)</param>
        /// <param name="latitude">latitude used to update the user&#39;s current location (optional)</param>
        /// <param name="longitude">longitude used to update the user&#39;s current location (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendCustomNotificationsApiResponse"/>?&gt;</returns>
        Task<ISendCustomNotificationsApiResponse?> SendCustomNotificationsOrDefaultAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<string> receiverAccountIds = default, Option<bool> includeFriendGroup = default, Option<string> appKey = default, Option<string> gameType = default, Option<string> conduit = default, Option<long> contentId = default, Option<string> contentName = default, Option<string> contentType = default, Option<long> parentId = default, Option<string> parentType = default, Option<string> actionCategory = default, Option<string> subject = default, Option<string> customMessage = default, Option<bool> friendOnlyAPNS = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Notification Template
        /// </summary>
        /// <remarks>
        /// Update a notification template. Developers will only be able to update notification templates for their own applications.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The account ID of the user.</param>
        /// <param name="notificationTemplateId">The notification template ID to update.</param>
        /// <param name="title">The title of the message (this would become the subject title for emails). There is a 191 character limit. (optional)</param>
        /// <param name="body">The body of the message. (optional)</param>
        /// <param name="tags">The search tags on the template used during search queries. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateNotificationTemplateApiResponse"/>&gt;</returns>
        Task<IUpdateNotificationTemplateApiResponse> UpdateNotificationTemplateAsync(long accountId, long notificationTemplateId, Option<string> title = default, Option<string> body = default, Option<string> tags = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Notification Template
        /// </summary>
        /// <remarks>
        /// Update a notification template. Developers will only be able to update notification templates for their own applications.
        /// </remarks>
        /// <param name="accountId">The account ID of the user.</param>
        /// <param name="notificationTemplateId">The notification template ID to update.</param>
        /// <param name="title">The title of the message (this would become the subject title for emails). There is a 191 character limit. (optional)</param>
        /// <param name="body">The body of the message. (optional)</param>
        /// <param name="tags">The search tags on the template used during search queries. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateNotificationTemplateApiResponse"/>?&gt;</returns>
        Task<IUpdateNotificationTemplateApiResponse?> UpdateNotificationTemplateOrDefaultAsync(long accountId, long notificationTemplateId, Option<string> title = default, Option<string> body = default, Option<string> tags = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICreateNotificationTemplateApiResponse"/>
    /// </summary>
    public interface ICreateNotificationTemplateApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.NotificationTemplateResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICreateOrUpdateBlockedNotificationsApiResponse"/>
    /// </summary>
    public interface ICreateOrUpdateBlockedNotificationsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.BlockedNotificationResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteNotificationTemplateApiResponse"/>
    /// </summary>
    public interface IDeleteNotificationTemplateApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.NotificationTemplateResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetNotificationTemplateApiResponse"/>
    /// </summary>
    public interface IGetNotificationTemplateApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.NotificationTemplateResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetNotificationsApiResponse"/>
    /// </summary>
    public interface IGetNotificationsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.NotificationMessageListResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IRegisterNotificationTokenApiResponse"/>
    /// </summary>
    public interface IRegisterNotificationTokenApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchBlockedNotificationsApiResponse"/>
    /// </summary>
    public interface ISearchBlockedNotificationsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.BlockedNotificationResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchNotificationTemplateApiResponse"/>
    /// </summary>
    public interface ISearchNotificationTemplateApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.NotificationTemplateResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchRecipientsApiResponse"/>
    /// </summary>
    public interface ISearchRecipientsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<NotificationRecipientResponse>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchRecipientsCountApiResponse"/>
    /// </summary>
    public interface ISearchRecipientsCountApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.NotificationRecipientResponseListResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISendBatchNotificationsApiResponse"/>
    /// </summary>
    public interface ISendBatchNotificationsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISendCustomNotificationsApiResponse"/>
    /// </summary>
    public interface ISendCustomNotificationsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateNotificationTemplateApiResponse"/>
    /// </summary>
    public interface IUpdateNotificationTemplateApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.NotificationTemplateResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class NotificationApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateNotificationTemplate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateNotificationTemplate;

        internal void ExecuteOnCreateNotificationTemplate(NotificationApi.CreateNotificationTemplateApiResponse apiResponse)
        {
            OnCreateNotificationTemplate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateNotificationTemplate(Exception exception)
        {
            OnErrorCreateNotificationTemplate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateOrUpdateBlockedNotifications;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateOrUpdateBlockedNotifications;

        internal void ExecuteOnCreateOrUpdateBlockedNotifications(NotificationApi.CreateOrUpdateBlockedNotificationsApiResponse apiResponse)
        {
            OnCreateOrUpdateBlockedNotifications?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateOrUpdateBlockedNotifications(Exception exception)
        {
            OnErrorCreateOrUpdateBlockedNotifications?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteNotificationTemplate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteNotificationTemplate;

        internal void ExecuteOnDeleteNotificationTemplate(NotificationApi.DeleteNotificationTemplateApiResponse apiResponse)
        {
            OnDeleteNotificationTemplate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteNotificationTemplate(Exception exception)
        {
            OnErrorDeleteNotificationTemplate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetNotificationTemplate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetNotificationTemplate;

        internal void ExecuteOnGetNotificationTemplate(NotificationApi.GetNotificationTemplateApiResponse apiResponse)
        {
            OnGetNotificationTemplate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetNotificationTemplate(Exception exception)
        {
            OnErrorGetNotificationTemplate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetNotifications;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetNotifications;

        internal void ExecuteOnGetNotifications(NotificationApi.GetNotificationsApiResponse apiResponse)
        {
            OnGetNotifications?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetNotifications(Exception exception)
        {
            OnErrorGetNotifications?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRegisterNotificationToken;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRegisterNotificationToken;

        internal void ExecuteOnRegisterNotificationToken(NotificationApi.RegisterNotificationTokenApiResponse apiResponse)
        {
            OnRegisterNotificationToken?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRegisterNotificationToken(Exception exception)
        {
            OnErrorRegisterNotificationToken?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchBlockedNotifications;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchBlockedNotifications;

        internal void ExecuteOnSearchBlockedNotifications(NotificationApi.SearchBlockedNotificationsApiResponse apiResponse)
        {
            OnSearchBlockedNotifications?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchBlockedNotifications(Exception exception)
        {
            OnErrorSearchBlockedNotifications?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchNotificationTemplate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchNotificationTemplate;

        internal void ExecuteOnSearchNotificationTemplate(NotificationApi.SearchNotificationTemplateApiResponse apiResponse)
        {
            OnSearchNotificationTemplate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchNotificationTemplate(Exception exception)
        {
            OnErrorSearchNotificationTemplate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchRecipients;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchRecipients;

        internal void ExecuteOnSearchRecipients(NotificationApi.SearchRecipientsApiResponse apiResponse)
        {
            OnSearchRecipients?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchRecipients(Exception exception)
        {
            OnErrorSearchRecipients?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchRecipientsCount;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchRecipientsCount;

        internal void ExecuteOnSearchRecipientsCount(NotificationApi.SearchRecipientsCountApiResponse apiResponse)
        {
            OnSearchRecipientsCount?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchRecipientsCount(Exception exception)
        {
            OnErrorSearchRecipientsCount?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSendBatchNotifications;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSendBatchNotifications;

        internal void ExecuteOnSendBatchNotifications(NotificationApi.SendBatchNotificationsApiResponse apiResponse)
        {
            OnSendBatchNotifications?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendBatchNotifications(Exception exception)
        {
            OnErrorSendBatchNotifications?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSendCustomNotifications;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSendCustomNotifications;

        internal void ExecuteOnSendCustomNotifications(NotificationApi.SendCustomNotificationsApiResponse apiResponse)
        {
            OnSendCustomNotifications?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSendCustomNotifications(Exception exception)
        {
            OnErrorSendCustomNotifications?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateNotificationTemplate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateNotificationTemplate;

        internal void ExecuteOnUpdateNotificationTemplate(NotificationApi.UpdateNotificationTemplateApiResponse apiResponse)
        {
            OnUpdateNotificationTemplate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateNotificationTemplate(Exception exception)
        {
            OnErrorUpdateNotificationTemplate?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class NotificationApi : INotificationApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<NotificationApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public NotificationApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="NotificationApi"/> class.
        /// </summary>
        /// <returns></returns>
        public NotificationApi(ILogger<NotificationApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, NotificationApiEvents notificationApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<NotificationApi>();
            HttpClient = httpClient;
            Events = notificationApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatCreateNotificationTemplate(ref long accountId, ref string conduit, ref string title, ref string body, ref Option<string> appKey, ref Option<string> varEvent, ref Option<string> tags);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="conduit"></param>
        /// <param name="title"></param>
        /// <param name="body"></param>
        /// <param name="appKey"></param>
        /// <param name="varEvent"></param>
        /// <param name="tags"></param>
        /// <returns></returns>
        private void ValidateCreateNotificationTemplate(string conduit, string title, string body, Option<string> appKey, Option<string> varEvent, Option<string> tags)
        {
            if (conduit == null)
                throw new ArgumentNullException(nameof(conduit));

            if (title == null)
                throw new ArgumentNullException(nameof(title));

            if (body == null)
                throw new ArgumentNullException(nameof(body));

            if (appKey.IsSet && appKey.Value == null)
                throw new ArgumentNullException(nameof(appKey));

            if (varEvent.IsSet && varEvent.Value == null)
                throw new ArgumentNullException(nameof(varEvent));

            if (tags.IsSet && tags.Value == null)
                throw new ArgumentNullException(nameof(tags));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="conduit"></param>
        /// <param name="title"></param>
        /// <param name="body"></param>
        /// <param name="appKey"></param>
        /// <param name="varEvent"></param>
        /// <param name="tags"></param>
        private void AfterCreateNotificationTemplateDefaultImplementation(ICreateNotificationTemplateApiResponse apiResponseLocalVar, long accountId, string conduit, string title, string body, Option<string> appKey, Option<string> varEvent, Option<string> tags)
        {
            bool suppressDefaultLog = false;
            AfterCreateNotificationTemplate(ref suppressDefaultLog, apiResponseLocalVar, accountId, conduit, title, body, appKey, varEvent, tags);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="conduit"></param>
        /// <param name="title"></param>
        /// <param name="body"></param>
        /// <param name="appKey"></param>
        /// <param name="varEvent"></param>
        /// <param name="tags"></param>
        partial void AfterCreateNotificationTemplate(ref bool suppressDefaultLog, ICreateNotificationTemplateApiResponse apiResponseLocalVar, long accountId, string conduit, string title, string body, Option<string> appKey, Option<string> varEvent, Option<string> tags);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="conduit"></param>
        /// <param name="title"></param>
        /// <param name="body"></param>
        /// <param name="appKey"></param>
        /// <param name="varEvent"></param>
        /// <param name="tags"></param>
        private void OnErrorCreateNotificationTemplateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string conduit, string title, string body, Option<string> appKey, Option<string> varEvent, Option<string> tags)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateNotificationTemplate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, conduit, title, body, appKey, varEvent, tags);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="conduit"></param>
        /// <param name="title"></param>
        /// <param name="body"></param>
        /// <param name="appKey"></param>
        /// <param name="varEvent"></param>
        /// <param name="tags"></param>
        partial void OnErrorCreateNotificationTemplate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string conduit, string title, string body, Option<string> appKey, Option<string> varEvent, Option<string> tags);

        /// <summary>
        /// Create Notification Template Create a notification template. Developers will only be able to create notification templates for their own applications.
        /// </summary>
        /// <param name="accountId">The account ID of the user.</param>
        /// <param name="conduit">Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.</param>
        /// <param name="title">title of the notification template</param>
        /// <param name="body">body of the notification template</param>
        /// <param name="appKey">Filter results by application. (optional)</param>
        /// <param name="varEvent">Filter results by event. (optional)</param>
        /// <param name="tags">tags associated with the note template (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateNotificationTemplateApiResponse"/>&gt;</returns>
        public async Task<ICreateNotificationTemplateApiResponse?> CreateNotificationTemplateOrDefaultAsync(long accountId, string conduit, string title, string body, Option<string> appKey = default, Option<string> varEvent = default, Option<string> tags = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateNotificationTemplateAsync(accountId, conduit, title, body, appKey, varEvent, tags, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create Notification Template Create a notification template. Developers will only be able to create notification templates for their own applications.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The account ID of the user.</param>
        /// <param name="conduit">Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.</param>
        /// <param name="title">title of the notification template</param>
        /// <param name="body">body of the notification template</param>
        /// <param name="appKey">Filter results by application. (optional)</param>
        /// <param name="varEvent">Filter results by event. (optional)</param>
        /// <param name="tags">tags associated with the note template (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateNotificationTemplateApiResponse"/>&gt;</returns>
        public async Task<ICreateNotificationTemplateApiResponse> CreateNotificationTemplateAsync(long accountId, string conduit, string title, string body, Option<string> appKey = default, Option<string> varEvent = default, Option<string> tags = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateNotificationTemplate(conduit, title, body, appKey, varEvent, tags);

                FormatCreateNotificationTemplate(ref accountId, ref conduit, ref title, ref body, ref appKey, ref varEvent, ref tags);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/notification/template/create"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/notification/template/create");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["conduit"] = ClientUtils.ParameterToString(conduit);
                    parseQueryStringLocalVar["title"] = ClientUtils.ParameterToString(title);
                    parseQueryStringLocalVar["body"] = ClientUtils.ParameterToString(body);

                    if (appKey.IsSet)
                        parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey.Value);

                    if (varEvent.IsSet)
                        parseQueryStringLocalVar["event"] = ClientUtils.ParameterToString(varEvent.Value);

                    if (tags.IsSet)
                        parseQueryStringLocalVar["tags"] = ClientUtils.ParameterToString(tags.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateNotificationTemplateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateNotificationTemplateApiResponse>();
                        CreateNotificationTemplateApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/notification/template/create", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateNotificationTemplateDefaultImplementation(apiResponseLocalVar, accountId, conduit, title, body, appKey, varEvent, tags);

                        Events.ExecuteOnCreateNotificationTemplate(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateNotificationTemplateDefaultImplementation(e, "/notification/template/create", uriBuilderLocalVar.Path, accountId, conduit, title, body, appKey, varEvent, tags);
                Events.ExecuteOnErrorCreateNotificationTemplate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateNotificationTemplateApiResponse"/>
        /// </summary>
        public partial class CreateNotificationTemplateApiResponse : Org.OpenAPITools.Client.ApiResponse, ICreateNotificationTemplateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateNotificationTemplateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateNotificationTemplateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateNotificationTemplateApiResponse(ILogger<CreateNotificationTemplateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateNotificationTemplateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateNotificationTemplateApiResponse(ILogger<CreateNotificationTemplateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.NotificationTemplateResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.NotificationTemplateResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.NotificationTemplateResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateOrUpdateBlockedNotifications(ref string appKey, ref string data, ref Option<long> accountId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="appKey"></param>
        /// <param name="data"></param>
        /// <returns></returns>
        private void ValidateCreateOrUpdateBlockedNotifications(string appKey, string data)
        {
            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));

            if (data == null)
                throw new ArgumentNullException(nameof(data));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="appKey"></param>
        /// <param name="data"></param>
        /// <param name="accountId"></param>
        private void AfterCreateOrUpdateBlockedNotificationsDefaultImplementation(ICreateOrUpdateBlockedNotificationsApiResponse apiResponseLocalVar, string appKey, string data, Option<long> accountId)
        {
            bool suppressDefaultLog = false;
            AfterCreateOrUpdateBlockedNotifications(ref suppressDefaultLog, apiResponseLocalVar, appKey, data, accountId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="appKey"></param>
        /// <param name="data"></param>
        /// <param name="accountId"></param>
        partial void AfterCreateOrUpdateBlockedNotifications(ref bool suppressDefaultLog, ICreateOrUpdateBlockedNotificationsApiResponse apiResponseLocalVar, string appKey, string data, Option<long> accountId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="appKey"></param>
        /// <param name="data"></param>
        /// <param name="accountId"></param>
        private void OnErrorCreateOrUpdateBlockedNotificationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string appKey, string data, Option<long> accountId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateOrUpdateBlockedNotifications(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, appKey, data, accountId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="appKey"></param>
        /// <param name="data"></param>
        /// <param name="accountId"></param>
        partial void OnErrorCreateOrUpdateBlockedNotifications(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string appKey, string data, Option<long> accountId);

        /// <summary>
        /// Create or update blocked notification settings Create or update blocked notification settings
        /// </summary>
        /// <param name="appKey">The application key</param>
        /// <param name="data">batch data payload (application specific)</param>
        /// <param name="accountId">the account id of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateOrUpdateBlockedNotificationsApiResponse"/>&gt;</returns>
        public async Task<ICreateOrUpdateBlockedNotificationsApiResponse?> CreateOrUpdateBlockedNotificationsOrDefaultAsync(string appKey, string data, Option<long> accountId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateOrUpdateBlockedNotificationsAsync(appKey, data, accountId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create or update blocked notification settings Create or update blocked notification settings
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="appKey">The application key</param>
        /// <param name="data">batch data payload (application specific)</param>
        /// <param name="accountId">the account id of the user (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateOrUpdateBlockedNotificationsApiResponse"/>&gt;</returns>
        public async Task<ICreateOrUpdateBlockedNotificationsApiResponse> CreateOrUpdateBlockedNotificationsAsync(string appKey, string data, Option<long> accountId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateOrUpdateBlockedNotifications(appKey, data);

                FormatCreateOrUpdateBlockedNotifications(ref appKey, ref data, ref accountId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/notification/blocked/batch"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/notification/blocked/batch");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey);
                    parseQueryStringLocalVar["data"] = ClientUtils.ParameterToString(data);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateOrUpdateBlockedNotificationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateOrUpdateBlockedNotificationsApiResponse>();
                        CreateOrUpdateBlockedNotificationsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/notification/blocked/batch", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateOrUpdateBlockedNotificationsDefaultImplementation(apiResponseLocalVar, appKey, data, accountId);

                        Events.ExecuteOnCreateOrUpdateBlockedNotifications(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateOrUpdateBlockedNotificationsDefaultImplementation(e, "/notification/blocked/batch", uriBuilderLocalVar.Path, appKey, data, accountId);
                Events.ExecuteOnErrorCreateOrUpdateBlockedNotifications(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateOrUpdateBlockedNotificationsApiResponse"/>
        /// </summary>
        public partial class CreateOrUpdateBlockedNotificationsApiResponse : Org.OpenAPITools.Client.ApiResponse, ICreateOrUpdateBlockedNotificationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateOrUpdateBlockedNotificationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateOrUpdateBlockedNotificationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateOrUpdateBlockedNotificationsApiResponse(ILogger<CreateOrUpdateBlockedNotificationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateOrUpdateBlockedNotificationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateOrUpdateBlockedNotificationsApiResponse(ILogger<CreateOrUpdateBlockedNotificationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.BlockedNotificationResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.BlockedNotificationResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.BlockedNotificationResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteNotificationTemplate(ref long accountId, ref long notificationTemplateId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="notificationTemplateId"></param>
        private void AfterDeleteNotificationTemplateDefaultImplementation(IDeleteNotificationTemplateApiResponse apiResponseLocalVar, long accountId, long notificationTemplateId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteNotificationTemplate(ref suppressDefaultLog, apiResponseLocalVar, accountId, notificationTemplateId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="notificationTemplateId"></param>
        partial void AfterDeleteNotificationTemplate(ref bool suppressDefaultLog, IDeleteNotificationTemplateApiResponse apiResponseLocalVar, long accountId, long notificationTemplateId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="notificationTemplateId"></param>
        private void OnErrorDeleteNotificationTemplateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long notificationTemplateId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteNotificationTemplate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, notificationTemplateId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="notificationTemplateId"></param>
        partial void OnErrorDeleteNotificationTemplate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long notificationTemplateId);

        /// <summary>
        /// Delete Notification Template Deletes a notification template. Developers will only be able to delete notification templates for their own applications.
        /// </summary>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="notificationTemplateId">the id of the notification template to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteNotificationTemplateApiResponse"/>&gt;</returns>
        public async Task<IDeleteNotificationTemplateApiResponse?> DeleteNotificationTemplateOrDefaultAsync(long accountId, long notificationTemplateId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteNotificationTemplateAsync(accountId, notificationTemplateId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete Notification Template Deletes a notification template. Developers will only be able to delete notification templates for their own applications.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the account id of the user</param>
        /// <param name="notificationTemplateId">the id of the notification template to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteNotificationTemplateApiResponse"/>&gt;</returns>
        public async Task<IDeleteNotificationTemplateApiResponse> DeleteNotificationTemplateAsync(long accountId, long notificationTemplateId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeleteNotificationTemplate(ref accountId, ref notificationTemplateId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/notification/template/delete"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/notification/template/delete");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["notificationTemplateId"] = ClientUtils.ParameterToString(notificationTemplateId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DeleteNotificationTemplateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteNotificationTemplateApiResponse>();
                        DeleteNotificationTemplateApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/notification/template/delete", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDeleteNotificationTemplateDefaultImplementation(apiResponseLocalVar, accountId, notificationTemplateId);

                        Events.ExecuteOnDeleteNotificationTemplate(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteNotificationTemplateDefaultImplementation(e, "/notification/template/delete", uriBuilderLocalVar.Path, accountId, notificationTemplateId);
                Events.ExecuteOnErrorDeleteNotificationTemplate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteNotificationTemplateApiResponse"/>
        /// </summary>
        public partial class DeleteNotificationTemplateApiResponse : Org.OpenAPITools.Client.ApiResponse, IDeleteNotificationTemplateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteNotificationTemplateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteNotificationTemplateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteNotificationTemplateApiResponse(ILogger<DeleteNotificationTemplateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DeleteNotificationTemplateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteNotificationTemplateApiResponse(ILogger<DeleteNotificationTemplateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.NotificationTemplateResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.NotificationTemplateResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.NotificationTemplateResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetNotificationTemplate(ref long accountId, ref long notificationTemplateId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="notificationTemplateId"></param>
        private void AfterGetNotificationTemplateDefaultImplementation(IGetNotificationTemplateApiResponse apiResponseLocalVar, long accountId, long notificationTemplateId)
        {
            bool suppressDefaultLog = false;
            AfterGetNotificationTemplate(ref suppressDefaultLog, apiResponseLocalVar, accountId, notificationTemplateId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="notificationTemplateId"></param>
        partial void AfterGetNotificationTemplate(ref bool suppressDefaultLog, IGetNotificationTemplateApiResponse apiResponseLocalVar, long accountId, long notificationTemplateId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="notificationTemplateId"></param>
        private void OnErrorGetNotificationTemplateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long notificationTemplateId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetNotificationTemplate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, notificationTemplateId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="notificationTemplateId"></param>
        partial void OnErrorGetNotificationTemplate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long notificationTemplateId);

        /// <summary>
        /// Get Notification Template Get the details of a notification template. Developers will only be able to see notification templates for their own applications.
        /// </summary>
        /// <param name="accountId">the id of the account</param>
        /// <param name="notificationTemplateId">the id of the notification template to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNotificationTemplateApiResponse"/>&gt;</returns>
        public async Task<IGetNotificationTemplateApiResponse?> GetNotificationTemplateOrDefaultAsync(long accountId, long notificationTemplateId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetNotificationTemplateAsync(accountId, notificationTemplateId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Notification Template Get the details of a notification template. Developers will only be able to see notification templates for their own applications.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the id of the account</param>
        /// <param name="notificationTemplateId">the id of the notification template to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNotificationTemplateApiResponse"/>&gt;</returns>
        public async Task<IGetNotificationTemplateApiResponse> GetNotificationTemplateAsync(long accountId, long notificationTemplateId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetNotificationTemplate(ref accountId, ref notificationTemplateId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/notification/template/get"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/notification/template/get");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["notificationTemplateId"] = ClientUtils.ParameterToString(notificationTemplateId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetNotificationTemplateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetNotificationTemplateApiResponse>();
                        GetNotificationTemplateApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/notification/template/get", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetNotificationTemplateDefaultImplementation(apiResponseLocalVar, accountId, notificationTemplateId);

                        Events.ExecuteOnGetNotificationTemplate(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetNotificationTemplateDefaultImplementation(e, "/notification/template/get", uriBuilderLocalVar.Path, accountId, notificationTemplateId);
                Events.ExecuteOnErrorGetNotificationTemplate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetNotificationTemplateApiResponse"/>
        /// </summary>
        public partial class GetNotificationTemplateApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetNotificationTemplateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetNotificationTemplateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetNotificationTemplateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNotificationTemplateApiResponse(ILogger<GetNotificationTemplateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetNotificationTemplateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNotificationTemplateApiResponse(ILogger<GetNotificationTemplateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.NotificationTemplateResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.NotificationTemplateResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.NotificationTemplateResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetNotifications(ref Option<string> deviceId, ref Option<long> accountId, ref Option<long> connectionAccountId, ref Option<string> appKey, ref Option<string> eventType, ref Option<string> contentIds, ref Option<string> contentTypes, ref Option<string> parentIds, ref Option<string> parentTypes, ref Option<string> actionCategory, ref Option<string> conduits, ref Option<string> keyword, ref Option<bool> returnReadMessages, ref Option<bool> markAsRead, ref Option<long> fromDate, ref Option<double> latitude, ref Option<double> longitude, ref Option<bool> returnSent, ref Option<bool> ignoreFlagged, ref Option<int> start, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <param name="appKey"></param>
        /// <param name="eventType"></param>
        /// <param name="contentIds"></param>
        /// <param name="contentTypes"></param>
        /// <param name="parentIds"></param>
        /// <param name="parentTypes"></param>
        /// <param name="actionCategory"></param>
        /// <param name="conduits"></param>
        /// <param name="keyword"></param>
        /// <returns></returns>
        private void ValidateGetNotifications(Option<string> deviceId, Option<string> appKey, Option<string> eventType, Option<string> contentIds, Option<string> contentTypes, Option<string> parentIds, Option<string> parentTypes, Option<string> actionCategory, Option<string> conduits, Option<string> keyword)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (appKey.IsSet && appKey.Value == null)
                throw new ArgumentNullException(nameof(appKey));

            if (eventType.IsSet && eventType.Value == null)
                throw new ArgumentNullException(nameof(eventType));

            if (contentIds.IsSet && contentIds.Value == null)
                throw new ArgumentNullException(nameof(contentIds));

            if (contentTypes.IsSet && contentTypes.Value == null)
                throw new ArgumentNullException(nameof(contentTypes));

            if (parentIds.IsSet && parentIds.Value == null)
                throw new ArgumentNullException(nameof(parentIds));

            if (parentTypes.IsSet && parentTypes.Value == null)
                throw new ArgumentNullException(nameof(parentTypes));

            if (actionCategory.IsSet && actionCategory.Value == null)
                throw new ArgumentNullException(nameof(actionCategory));

            if (conduits.IsSet && conduits.Value == null)
                throw new ArgumentNullException(nameof(conduits));

            if (keyword.IsSet && keyword.Value == null)
                throw new ArgumentNullException(nameof(keyword));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        /// <param name="eventType"></param>
        /// <param name="contentIds"></param>
        /// <param name="contentTypes"></param>
        /// <param name="parentIds"></param>
        /// <param name="parentTypes"></param>
        /// <param name="actionCategory"></param>
        /// <param name="conduits"></param>
        /// <param name="keyword"></param>
        /// <param name="returnReadMessages"></param>
        /// <param name="markAsRead"></param>
        /// <param name="fromDate"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="returnSent"></param>
        /// <param name="ignoreFlagged"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void AfterGetNotificationsDefaultImplementation(IGetNotificationsApiResponse apiResponseLocalVar, Option<string> deviceId, Option<long> accountId, Option<long> connectionAccountId, Option<string> appKey, Option<string> eventType, Option<string> contentIds, Option<string> contentTypes, Option<string> parentIds, Option<string> parentTypes, Option<string> actionCategory, Option<string> conduits, Option<string> keyword, Option<bool> returnReadMessages, Option<bool> markAsRead, Option<long> fromDate, Option<double> latitude, Option<double> longitude, Option<bool> returnSent, Option<bool> ignoreFlagged, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterGetNotifications(ref suppressDefaultLog, apiResponseLocalVar, deviceId, accountId, connectionAccountId, appKey, eventType, contentIds, contentTypes, parentIds, parentTypes, actionCategory, conduits, keyword, returnReadMessages, markAsRead, fromDate, latitude, longitude, returnSent, ignoreFlagged, start, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        /// <param name="eventType"></param>
        /// <param name="contentIds"></param>
        /// <param name="contentTypes"></param>
        /// <param name="parentIds"></param>
        /// <param name="parentTypes"></param>
        /// <param name="actionCategory"></param>
        /// <param name="conduits"></param>
        /// <param name="keyword"></param>
        /// <param name="returnReadMessages"></param>
        /// <param name="markAsRead"></param>
        /// <param name="fromDate"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="returnSent"></param>
        /// <param name="ignoreFlagged"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void AfterGetNotifications(ref bool suppressDefaultLog, IGetNotificationsApiResponse apiResponseLocalVar, Option<string> deviceId, Option<long> accountId, Option<long> connectionAccountId, Option<string> appKey, Option<string> eventType, Option<string> contentIds, Option<string> contentTypes, Option<string> parentIds, Option<string> parentTypes, Option<string> actionCategory, Option<string> conduits, Option<string> keyword, Option<bool> returnReadMessages, Option<bool> markAsRead, Option<long> fromDate, Option<double> latitude, Option<double> longitude, Option<bool> returnSent, Option<bool> ignoreFlagged, Option<int> start, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        /// <param name="eventType"></param>
        /// <param name="contentIds"></param>
        /// <param name="contentTypes"></param>
        /// <param name="parentIds"></param>
        /// <param name="parentTypes"></param>
        /// <param name="actionCategory"></param>
        /// <param name="conduits"></param>
        /// <param name="keyword"></param>
        /// <param name="returnReadMessages"></param>
        /// <param name="markAsRead"></param>
        /// <param name="fromDate"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="returnSent"></param>
        /// <param name="ignoreFlagged"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void OnErrorGetNotificationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> deviceId, Option<long> accountId, Option<long> connectionAccountId, Option<string> appKey, Option<string> eventType, Option<string> contentIds, Option<string> contentTypes, Option<string> parentIds, Option<string> parentTypes, Option<string> actionCategory, Option<string> conduits, Option<string> keyword, Option<bool> returnReadMessages, Option<bool> markAsRead, Option<long> fromDate, Option<double> latitude, Option<double> longitude, Option<bool> returnSent, Option<bool> ignoreFlagged, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetNotifications(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, deviceId, accountId, connectionAccountId, appKey, eventType, contentIds, contentTypes, parentIds, parentTypes, actionCategory, conduits, keyword, returnReadMessages, markAsRead, fromDate, latitude, longitude, returnSent, ignoreFlagged, start, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="connectionAccountId"></param>
        /// <param name="appKey"></param>
        /// <param name="eventType"></param>
        /// <param name="contentIds"></param>
        /// <param name="contentTypes"></param>
        /// <param name="parentIds"></param>
        /// <param name="parentTypes"></param>
        /// <param name="actionCategory"></param>
        /// <param name="conduits"></param>
        /// <param name="keyword"></param>
        /// <param name="returnReadMessages"></param>
        /// <param name="markAsRead"></param>
        /// <param name="fromDate"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="returnSent"></param>
        /// <param name="ignoreFlagged"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void OnErrorGetNotifications(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> deviceId, Option<long> accountId, Option<long> connectionAccountId, Option<string> appKey, Option<string> eventType, Option<string> contentIds, Option<string> contentTypes, Option<string> parentIds, Option<string> parentTypes, Option<string> actionCategory, Option<string> conduits, Option<string> keyword, Option<bool> returnReadMessages, Option<bool> markAsRead, Option<long> fromDate, Option<double> latitude, Option<double> longitude, Option<bool> returnSent, Option<bool> ignoreFlagged, Option<int> start, Option<int> limit);

        /// <summary>
        /// Get Notifications Get a list of notifications for a user. If the \&quot;markAsRead\&quot; parameter is set to true, the returned notifications will be marked as \&quot;read\&quot; after the response has been sent. By default, read messages will not be returned, so to see read messages, set \&quot;returnReadMessages\&quot; to true.
        /// </summary>
        /// <param name="deviceId">the unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionAccountId">the account id used to view another person&#39;s notifications (optional)</param>
        /// <param name="appKey">the application key to filter messages by application (optional)</param>
        /// <param name="eventType">comma separated list of EVENTS. Filters search results to only include these events. Don&#39;t include this parameter or pass in an empty string to return all event types. (optional)</param>
        /// <param name="contentIds">comma separated list of content ids to search notifications on (optional)</param>
        /// <param name="contentTypes">comma separated list of content types to search notifications on (optional)</param>
        /// <param name="parentIds">comma separated list of parent ids to search notifications on (optional)</param>
        /// <param name="parentTypes">comma separated list of parent types to search notifications on (optional)</param>
        /// <param name="actionCategory">Action category used to filter notifications (optional)</param>
        /// <param name="conduits">comma separated list of conduits to search notifications on (optional)</param>
        /// <param name="keyword">search notifications via keyword (optional)</param>
        /// <param name="returnReadMessages">if set to true, will return notifications that have been marked as read (optional)</param>
        /// <param name="markAsRead">if set to true, the returned notifications will be marked as \\\&quot;read\\\&quot; after the response has been sent (optional)</param>
        /// <param name="fromDate">filter notifications from this date (optional)</param>
        /// <param name="latitude">latitude used to update the user&#39;s current location (optional)</param>
        /// <param name="longitude">longitude used to update the user&#39;s current location (optional)</param>
        /// <param name="returnSent">whether to include notifications sent by the requester in the response (optional)</param>
        /// <param name="ignoreFlagged">whether to ignore flagged notifications (optional)</param>
        /// <param name="start">start of the pagination (optional)</param>
        /// <param name="limit">limit of the pagination (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNotificationsApiResponse"/>&gt;</returns>
        public async Task<IGetNotificationsApiResponse?> GetNotificationsOrDefaultAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionAccountId = default, Option<string> appKey = default, Option<string> eventType = default, Option<string> contentIds = default, Option<string> contentTypes = default, Option<string> parentIds = default, Option<string> parentTypes = default, Option<string> actionCategory = default, Option<string> conduits = default, Option<string> keyword = default, Option<bool> returnReadMessages = default, Option<bool> markAsRead = default, Option<long> fromDate = default, Option<double> latitude = default, Option<double> longitude = default, Option<bool> returnSent = default, Option<bool> ignoreFlagged = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetNotificationsAsync(deviceId, accountId, connectionAccountId, appKey, eventType, contentIds, contentTypes, parentIds, parentTypes, actionCategory, conduits, keyword, returnReadMessages, markAsRead, fromDate, latitude, longitude, returnSent, ignoreFlagged, start, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Notifications Get a list of notifications for a user. If the \&quot;markAsRead\&quot; parameter is set to true, the returned notifications will be marked as \&quot;read\&quot; after the response has been sent. By default, read messages will not be returned, so to see read messages, set \&quot;returnReadMessages\&quot; to true.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="deviceId">the unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="connectionAccountId">the account id used to view another person&#39;s notifications (optional)</param>
        /// <param name="appKey">the application key to filter messages by application (optional)</param>
        /// <param name="eventType">comma separated list of EVENTS. Filters search results to only include these events. Don&#39;t include this parameter or pass in an empty string to return all event types. (optional)</param>
        /// <param name="contentIds">comma separated list of content ids to search notifications on (optional)</param>
        /// <param name="contentTypes">comma separated list of content types to search notifications on (optional)</param>
        /// <param name="parentIds">comma separated list of parent ids to search notifications on (optional)</param>
        /// <param name="parentTypes">comma separated list of parent types to search notifications on (optional)</param>
        /// <param name="actionCategory">Action category used to filter notifications (optional)</param>
        /// <param name="conduits">comma separated list of conduits to search notifications on (optional)</param>
        /// <param name="keyword">search notifications via keyword (optional)</param>
        /// <param name="returnReadMessages">if set to true, will return notifications that have been marked as read (optional)</param>
        /// <param name="markAsRead">if set to true, the returned notifications will be marked as \\\&quot;read\\\&quot; after the response has been sent (optional)</param>
        /// <param name="fromDate">filter notifications from this date (optional)</param>
        /// <param name="latitude">latitude used to update the user&#39;s current location (optional)</param>
        /// <param name="longitude">longitude used to update the user&#39;s current location (optional)</param>
        /// <param name="returnSent">whether to include notifications sent by the requester in the response (optional)</param>
        /// <param name="ignoreFlagged">whether to ignore flagged notifications (optional)</param>
        /// <param name="start">start of the pagination (optional)</param>
        /// <param name="limit">limit of the pagination (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNotificationsApiResponse"/>&gt;</returns>
        public async Task<IGetNotificationsApiResponse> GetNotificationsAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<long> connectionAccountId = default, Option<string> appKey = default, Option<string> eventType = default, Option<string> contentIds = default, Option<string> contentTypes = default, Option<string> parentIds = default, Option<string> parentTypes = default, Option<string> actionCategory = default, Option<string> conduits = default, Option<string> keyword = default, Option<bool> returnReadMessages = default, Option<bool> markAsRead = default, Option<long> fromDate = default, Option<double> latitude = default, Option<double> longitude = default, Option<bool> returnSent = default, Option<bool> ignoreFlagged = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetNotifications(deviceId, appKey, eventType, contentIds, contentTypes, parentIds, parentTypes, actionCategory, conduits, keyword);

                FormatGetNotifications(ref deviceId, ref accountId, ref connectionAccountId, ref appKey, ref eventType, ref contentIds, ref contentTypes, ref parentIds, ref parentTypes, ref actionCategory, ref conduits, ref keyword, ref returnReadMessages, ref markAsRead, ref fromDate, ref latitude, ref longitude, ref returnSent, ref ignoreFlagged, ref start, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/notification/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/notification/search");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (connectionAccountId.IsSet)
                        parseQueryStringLocalVar["connectionAccountId"] = ClientUtils.ParameterToString(connectionAccountId.Value);

                    if (appKey.IsSet)
                        parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey.Value);

                    if (eventType.IsSet)
                        parseQueryStringLocalVar["eventType"] = ClientUtils.ParameterToString(eventType.Value);

                    if (contentIds.IsSet)
                        parseQueryStringLocalVar["contentIds"] = ClientUtils.ParameterToString(contentIds.Value);

                    if (contentTypes.IsSet)
                        parseQueryStringLocalVar["contentTypes"] = ClientUtils.ParameterToString(contentTypes.Value);

                    if (parentIds.IsSet)
                        parseQueryStringLocalVar["parentIds"] = ClientUtils.ParameterToString(parentIds.Value);

                    if (parentTypes.IsSet)
                        parseQueryStringLocalVar["parentTypes"] = ClientUtils.ParameterToString(parentTypes.Value);

                    if (actionCategory.IsSet)
                        parseQueryStringLocalVar["actionCategory"] = ClientUtils.ParameterToString(actionCategory.Value);

                    if (conduits.IsSet)
                        parseQueryStringLocalVar["conduits"] = ClientUtils.ParameterToString(conduits.Value);

                    if (keyword.IsSet)
                        parseQueryStringLocalVar["keyword"] = ClientUtils.ParameterToString(keyword.Value);

                    if (returnReadMessages.IsSet)
                        parseQueryStringLocalVar["returnReadMessages"] = ClientUtils.ParameterToString(returnReadMessages.Value);

                    if (markAsRead.IsSet)
                        parseQueryStringLocalVar["markAsRead"] = ClientUtils.ParameterToString(markAsRead.Value);

                    if (fromDate.IsSet)
                        parseQueryStringLocalVar["fromDate"] = ClientUtils.ParameterToString(fromDate.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    if (returnSent.IsSet)
                        parseQueryStringLocalVar["returnSent"] = ClientUtils.ParameterToString(returnSent.Value);

                    if (ignoreFlagged.IsSet)
                        parseQueryStringLocalVar["ignoreFlagged"] = ClientUtils.ParameterToString(ignoreFlagged.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetNotificationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetNotificationsApiResponse>();
                        GetNotificationsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/notification/search", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetNotificationsDefaultImplementation(apiResponseLocalVar, deviceId, accountId, connectionAccountId, appKey, eventType, contentIds, contentTypes, parentIds, parentTypes, actionCategory, conduits, keyword, returnReadMessages, markAsRead, fromDate, latitude, longitude, returnSent, ignoreFlagged, start, limit);

                        Events.ExecuteOnGetNotifications(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetNotificationsDefaultImplementation(e, "/notification/search", uriBuilderLocalVar.Path, deviceId, accountId, connectionAccountId, appKey, eventType, contentIds, contentTypes, parentIds, parentTypes, actionCategory, conduits, keyword, returnReadMessages, markAsRead, fromDate, latitude, longitude, returnSent, ignoreFlagged, start, limit);
                Events.ExecuteOnErrorGetNotifications(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetNotificationsApiResponse"/>
        /// </summary>
        public partial class GetNotificationsApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetNotificationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetNotificationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetNotificationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNotificationsApiResponse(ILogger<GetNotificationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetNotificationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNotificationsApiResponse(ILogger<GetNotificationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.NotificationMessageListResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.NotificationMessageListResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.NotificationMessageListResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRegisterNotificationToken(ref string token, ref string pushType, ref Option<string> deviceId, ref Option<long> accountId, ref Option<string> environment, ref Option<string> appKey, ref Option<string> gameType, ref Option<bool> active, ref Option<double> latitude, ref Option<double> longitude);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="token"></param>
        /// <param name="pushType"></param>
        /// <param name="deviceId"></param>
        /// <param name="environment"></param>
        /// <param name="appKey"></param>
        /// <param name="gameType"></param>
        /// <returns></returns>
        private void ValidateRegisterNotificationToken(string token, string pushType, Option<string> deviceId, Option<string> environment, Option<string> appKey, Option<string> gameType)
        {
            if (token == null)
                throw new ArgumentNullException(nameof(token));

            if (pushType == null)
                throw new ArgumentNullException(nameof(pushType));

            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (environment.IsSet && environment.Value == null)
                throw new ArgumentNullException(nameof(environment));

            if (appKey.IsSet && appKey.Value == null)
                throw new ArgumentNullException(nameof(appKey));

            if (gameType.IsSet && gameType.Value == null)
                throw new ArgumentNullException(nameof(gameType));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="token"></param>
        /// <param name="pushType"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="environment"></param>
        /// <param name="appKey"></param>
        /// <param name="gameType"></param>
        /// <param name="active"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void AfterRegisterNotificationTokenDefaultImplementation(IRegisterNotificationTokenApiResponse apiResponseLocalVar, string token, string pushType, Option<string> deviceId, Option<long> accountId, Option<string> environment, Option<string> appKey, Option<string> gameType, Option<bool> active, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLog = false;
            AfterRegisterNotificationToken(ref suppressDefaultLog, apiResponseLocalVar, token, pushType, deviceId, accountId, environment, appKey, gameType, active, latitude, longitude);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="token"></param>
        /// <param name="pushType"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="environment"></param>
        /// <param name="appKey"></param>
        /// <param name="gameType"></param>
        /// <param name="active"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void AfterRegisterNotificationToken(ref bool suppressDefaultLog, IRegisterNotificationTokenApiResponse apiResponseLocalVar, string token, string pushType, Option<string> deviceId, Option<long> accountId, Option<string> environment, Option<string> appKey, Option<string> gameType, Option<bool> active, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="token"></param>
        /// <param name="pushType"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="environment"></param>
        /// <param name="appKey"></param>
        /// <param name="gameType"></param>
        /// <param name="active"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void OnErrorRegisterNotificationTokenDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string token, string pushType, Option<string> deviceId, Option<long> accountId, Option<string> environment, Option<string> appKey, Option<string> gameType, Option<bool> active, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorRegisterNotificationToken(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, token, pushType, deviceId, accountId, environment, appKey, gameType, active, latitude, longitude);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="token"></param>
        /// <param name="pushType"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="environment"></param>
        /// <param name="appKey"></param>
        /// <param name="gameType"></param>
        /// <param name="active"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void OnErrorRegisterNotificationToken(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string token, string pushType, Option<string> deviceId, Option<long> accountId, Option<string> environment, Option<string> appKey, Option<string> gameType, Option<bool> active, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Register Notification Token Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.
        /// </summary>
        /// <param name="token">A token that is generated by the device to sign requests for the notification service providers</param>
        /// <param name="pushType">The type of push notification. Possible values include: APNS, GCM</param>
        /// <param name="deviceId">The unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">The account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="environment">Determines if the token is a DEVELOPMENT or PRODUCTION token (optional)</param>
        /// <param name="appKey">The application key (optional)</param>
        /// <param name="gameType">This parameter is deprecated (use appKey instead) (optional)</param>
        /// <param name="active">Sets whether the token is active or not (non-active tokens are not used) (optional)</param>
        /// <param name="latitude">Latitude used to update the user&#39;s current location (optional)</param>
        /// <param name="longitude">Longitude used to update the user&#39;s current location (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRegisterNotificationTokenApiResponse"/>&gt;</returns>
        public async Task<IRegisterNotificationTokenApiResponse?> RegisterNotificationTokenOrDefaultAsync(string token, string pushType, Option<string> deviceId = default, Option<long> accountId = default, Option<string> environment = default, Option<string> appKey = default, Option<string> gameType = default, Option<bool> active = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RegisterNotificationTokenAsync(token, pushType, deviceId, accountId, environment, appKey, gameType, active, latitude, longitude, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Register Notification Token Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">A token that is generated by the device to sign requests for the notification service providers</param>
        /// <param name="pushType">The type of push notification. Possible values include: APNS, GCM</param>
        /// <param name="deviceId">The unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">The account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="environment">Determines if the token is a DEVELOPMENT or PRODUCTION token (optional)</param>
        /// <param name="appKey">The application key (optional)</param>
        /// <param name="gameType">This parameter is deprecated (use appKey instead) (optional)</param>
        /// <param name="active">Sets whether the token is active or not (non-active tokens are not used) (optional)</param>
        /// <param name="latitude">Latitude used to update the user&#39;s current location (optional)</param>
        /// <param name="longitude">Longitude used to update the user&#39;s current location (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRegisterNotificationTokenApiResponse"/>&gt;</returns>
        public async Task<IRegisterNotificationTokenApiResponse> RegisterNotificationTokenAsync(string token, string pushType, Option<string> deviceId = default, Option<long> accountId = default, Option<string> environment = default, Option<string> appKey = default, Option<string> gameType = default, Option<bool> active = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateRegisterNotificationToken(token, pushType, deviceId, environment, appKey, gameType);

                FormatRegisterNotificationToken(ref token, ref pushType, ref deviceId, ref accountId, ref environment, ref appKey, ref gameType, ref active, ref latitude, ref longitude);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/notification/token"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/notification/token");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["token"] = ClientUtils.ParameterToString(token);
                    parseQueryStringLocalVar["pushType"] = ClientUtils.ParameterToString(pushType);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (environment.IsSet)
                        parseQueryStringLocalVar["environment"] = ClientUtils.ParameterToString(environment.Value);

                    if (appKey.IsSet)
                        parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey.Value);

                    if (gameType.IsSet)
                        parseQueryStringLocalVar["gameType"] = ClientUtils.ParameterToString(gameType.Value);

                    if (active.IsSet)
                        parseQueryStringLocalVar["active"] = ClientUtils.ParameterToString(active.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<RegisterNotificationTokenApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RegisterNotificationTokenApiResponse>();
                        RegisterNotificationTokenApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/notification/token", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterRegisterNotificationTokenDefaultImplementation(apiResponseLocalVar, token, pushType, deviceId, accountId, environment, appKey, gameType, active, latitude, longitude);

                        Events.ExecuteOnRegisterNotificationToken(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRegisterNotificationTokenDefaultImplementation(e, "/notification/token", uriBuilderLocalVar.Path, token, pushType, deviceId, accountId, environment, appKey, gameType, active, latitude, longitude);
                Events.ExecuteOnErrorRegisterNotificationToken(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RegisterNotificationTokenApiResponse"/>
        /// </summary>
        public partial class RegisterNotificationTokenApiResponse : Org.OpenAPITools.Client.ApiResponse, IRegisterNotificationTokenApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RegisterNotificationTokenApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RegisterNotificationTokenApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RegisterNotificationTokenApiResponse(ILogger<RegisterNotificationTokenApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="RegisterNotificationTokenApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RegisterNotificationTokenApiResponse(ILogger<RegisterNotificationTokenApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchBlockedNotifications(ref string appKey, ref Option<long> accountId, ref Option<string> searchTags, ref Option<string> events, ref Option<string> conduits, ref Option<string> customTypes, ref Option<string> contentTypes, ref Option<string> contentIds, ref Option<string> sortField, ref Option<bool> descending, ref Option<int> start, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="appKey"></param>
        /// <param name="searchTags"></param>
        /// <param name="events"></param>
        /// <param name="conduits"></param>
        /// <param name="customTypes"></param>
        /// <param name="contentTypes"></param>
        /// <param name="contentIds"></param>
        /// <param name="sortField"></param>
        /// <returns></returns>
        private void ValidateSearchBlockedNotifications(string appKey, Option<string> searchTags, Option<string> events, Option<string> conduits, Option<string> customTypes, Option<string> contentTypes, Option<string> contentIds, Option<string> sortField)
        {
            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));

            if (searchTags.IsSet && searchTags.Value == null)
                throw new ArgumentNullException(nameof(searchTags));

            if (events.IsSet && events.Value == null)
                throw new ArgumentNullException(nameof(events));

            if (conduits.IsSet && conduits.Value == null)
                throw new ArgumentNullException(nameof(conduits));

            if (customTypes.IsSet && customTypes.Value == null)
                throw new ArgumentNullException(nameof(customTypes));

            if (contentTypes.IsSet && contentTypes.Value == null)
                throw new ArgumentNullException(nameof(contentTypes));

            if (contentIds.IsSet && contentIds.Value == null)
                throw new ArgumentNullException(nameof(contentIds));

            if (sortField.IsSet && sortField.Value == null)
                throw new ArgumentNullException(nameof(sortField));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="appKey"></param>
        /// <param name="accountId"></param>
        /// <param name="searchTags"></param>
        /// <param name="events"></param>
        /// <param name="conduits"></param>
        /// <param name="customTypes"></param>
        /// <param name="contentTypes"></param>
        /// <param name="contentIds"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void AfterSearchBlockedNotificationsDefaultImplementation(ISearchBlockedNotificationsApiResponse apiResponseLocalVar, string appKey, Option<long> accountId, Option<string> searchTags, Option<string> events, Option<string> conduits, Option<string> customTypes, Option<string> contentTypes, Option<string> contentIds, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterSearchBlockedNotifications(ref suppressDefaultLog, apiResponseLocalVar, appKey, accountId, searchTags, events, conduits, customTypes, contentTypes, contentIds, sortField, descending, start, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="appKey"></param>
        /// <param name="accountId"></param>
        /// <param name="searchTags"></param>
        /// <param name="events"></param>
        /// <param name="conduits"></param>
        /// <param name="customTypes"></param>
        /// <param name="contentTypes"></param>
        /// <param name="contentIds"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void AfterSearchBlockedNotifications(ref bool suppressDefaultLog, ISearchBlockedNotificationsApiResponse apiResponseLocalVar, string appKey, Option<long> accountId, Option<string> searchTags, Option<string> events, Option<string> conduits, Option<string> customTypes, Option<string> contentTypes, Option<string> contentIds, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="appKey"></param>
        /// <param name="accountId"></param>
        /// <param name="searchTags"></param>
        /// <param name="events"></param>
        /// <param name="conduits"></param>
        /// <param name="customTypes"></param>
        /// <param name="contentTypes"></param>
        /// <param name="contentIds"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void OnErrorSearchBlockedNotificationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string appKey, Option<long> accountId, Option<string> searchTags, Option<string> events, Option<string> conduits, Option<string> customTypes, Option<string> contentTypes, Option<string> contentIds, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchBlockedNotifications(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, appKey, accountId, searchTags, events, conduits, customTypes, contentTypes, contentIds, sortField, descending, start, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="appKey"></param>
        /// <param name="accountId"></param>
        /// <param name="searchTags"></param>
        /// <param name="events"></param>
        /// <param name="conduits"></param>
        /// <param name="customTypes"></param>
        /// <param name="contentTypes"></param>
        /// <param name="contentIds"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void OnErrorSearchBlockedNotifications(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string appKey, Option<long> accountId, Option<string> searchTags, Option<string> events, Option<string> conduits, Option<string> customTypes, Option<string> contentTypes, Option<string> contentIds, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit);

        /// <summary>
        /// Search on the user&#39;s blocked notification settings Search on the user&#39;s blocked notification settings
        /// </summary>
        /// <param name="appKey">The application key</param>
        /// <param name="accountId">the account id of the user (optional)</param>
        /// <param name="searchTags">search tags to filter results (optional)</param>
        /// <param name="events">events to filter by (comma separated) (optional)</param>
        /// <param name="conduits">conduits to filter by (comma separated) (optional)</param>
        /// <param name="customTypes">custom types to filter by (comma separated) (optional)</param>
        /// <param name="contentTypes">content types to filter by (comma separated) (optional)</param>
        /// <param name="contentIds">content ids to filter by (comma separated) (optional)</param>
        /// <param name="sortField">sort field for results (optional)</param>
        /// <param name="descending">whether to sort descending (optional)</param>
        /// <param name="start">start of the pagination (optional)</param>
        /// <param name="limit">limit of the pagination (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchBlockedNotificationsApiResponse"/>&gt;</returns>
        public async Task<ISearchBlockedNotificationsApiResponse?> SearchBlockedNotificationsOrDefaultAsync(string appKey, Option<long> accountId = default, Option<string> searchTags = default, Option<string> events = default, Option<string> conduits = default, Option<string> customTypes = default, Option<string> contentTypes = default, Option<string> contentIds = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchBlockedNotificationsAsync(appKey, accountId, searchTags, events, conduits, customTypes, contentTypes, contentIds, sortField, descending, start, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search on the user&#39;s blocked notification settings Search on the user&#39;s blocked notification settings
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="appKey">The application key</param>
        /// <param name="accountId">the account id of the user (optional)</param>
        /// <param name="searchTags">search tags to filter results (optional)</param>
        /// <param name="events">events to filter by (comma separated) (optional)</param>
        /// <param name="conduits">conduits to filter by (comma separated) (optional)</param>
        /// <param name="customTypes">custom types to filter by (comma separated) (optional)</param>
        /// <param name="contentTypes">content types to filter by (comma separated) (optional)</param>
        /// <param name="contentIds">content ids to filter by (comma separated) (optional)</param>
        /// <param name="sortField">sort field for results (optional)</param>
        /// <param name="descending">whether to sort descending (optional)</param>
        /// <param name="start">start of the pagination (optional)</param>
        /// <param name="limit">limit of the pagination (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchBlockedNotificationsApiResponse"/>&gt;</returns>
        public async Task<ISearchBlockedNotificationsApiResponse> SearchBlockedNotificationsAsync(string appKey, Option<long> accountId = default, Option<string> searchTags = default, Option<string> events = default, Option<string> conduits = default, Option<string> customTypes = default, Option<string> contentTypes = default, Option<string> contentIds = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchBlockedNotifications(appKey, searchTags, events, conduits, customTypes, contentTypes, contentIds, sortField);

                FormatSearchBlockedNotifications(ref appKey, ref accountId, ref searchTags, ref events, ref conduits, ref customTypes, ref contentTypes, ref contentIds, ref sortField, ref descending, ref start, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/notification/blocked/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/notification/blocked/search");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (searchTags.IsSet)
                        parseQueryStringLocalVar["searchTags"] = ClientUtils.ParameterToString(searchTags.Value);

                    if (events.IsSet)
                        parseQueryStringLocalVar["events"] = ClientUtils.ParameterToString(events.Value);

                    if (conduits.IsSet)
                        parseQueryStringLocalVar["conduits"] = ClientUtils.ParameterToString(conduits.Value);

                    if (customTypes.IsSet)
                        parseQueryStringLocalVar["customTypes"] = ClientUtils.ParameterToString(customTypes.Value);

                    if (contentTypes.IsSet)
                        parseQueryStringLocalVar["contentTypes"] = ClientUtils.ParameterToString(contentTypes.Value);

                    if (contentIds.IsSet)
                        parseQueryStringLocalVar["contentIds"] = ClientUtils.ParameterToString(contentIds.Value);

                    if (sortField.IsSet)
                        parseQueryStringLocalVar["sortField"] = ClientUtils.ParameterToString(sortField.Value);

                    if (descending.IsSet)
                        parseQueryStringLocalVar["descending"] = ClientUtils.ParameterToString(descending.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchBlockedNotificationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchBlockedNotificationsApiResponse>();
                        SearchBlockedNotificationsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/notification/blocked/search", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchBlockedNotificationsDefaultImplementation(apiResponseLocalVar, appKey, accountId, searchTags, events, conduits, customTypes, contentTypes, contentIds, sortField, descending, start, limit);

                        Events.ExecuteOnSearchBlockedNotifications(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchBlockedNotificationsDefaultImplementation(e, "/notification/blocked/search", uriBuilderLocalVar.Path, appKey, accountId, searchTags, events, conduits, customTypes, contentTypes, contentIds, sortField, descending, start, limit);
                Events.ExecuteOnErrorSearchBlockedNotifications(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchBlockedNotificationsApiResponse"/>
        /// </summary>
        public partial class SearchBlockedNotificationsApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchBlockedNotificationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchBlockedNotificationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchBlockedNotificationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchBlockedNotificationsApiResponse(ILogger<SearchBlockedNotificationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchBlockedNotificationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchBlockedNotificationsApiResponse(ILogger<SearchBlockedNotificationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.BlockedNotificationResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.BlockedNotificationResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.BlockedNotificationResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchNotificationTemplate(ref long accountId, ref string sortField, ref bool descending, ref int start, ref int limit, ref Option<string> appKey, ref Option<string> varEvent, ref Option<string> conduit, ref Option<bool> globalOnly, ref Option<bool> reservedOnly, ref Option<string> keyword);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sortField"></param>
        /// <param name="appKey"></param>
        /// <param name="varEvent"></param>
        /// <param name="conduit"></param>
        /// <param name="keyword"></param>
        /// <returns></returns>
        private void ValidateSearchNotificationTemplate(string sortField, Option<string> appKey, Option<string> varEvent, Option<string> conduit, Option<string> keyword)
        {
            if (sortField == null)
                throw new ArgumentNullException(nameof(sortField));

            if (appKey.IsSet && appKey.Value == null)
                throw new ArgumentNullException(nameof(appKey));

            if (varEvent.IsSet && varEvent.Value == null)
                throw new ArgumentNullException(nameof(varEvent));

            if (conduit.IsSet && conduit.Value == null)
                throw new ArgumentNullException(nameof(conduit));

            if (keyword.IsSet && keyword.Value == null)
                throw new ArgumentNullException(nameof(keyword));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="appKey"></param>
        /// <param name="varEvent"></param>
        /// <param name="conduit"></param>
        /// <param name="globalOnly"></param>
        /// <param name="reservedOnly"></param>
        /// <param name="keyword"></param>
        private void AfterSearchNotificationTemplateDefaultImplementation(ISearchNotificationTemplateApiResponse apiResponseLocalVar, long accountId, string sortField, bool descending, int start, int limit, Option<string> appKey, Option<string> varEvent, Option<string> conduit, Option<bool> globalOnly, Option<bool> reservedOnly, Option<string> keyword)
        {
            bool suppressDefaultLog = false;
            AfterSearchNotificationTemplate(ref suppressDefaultLog, apiResponseLocalVar, accountId, sortField, descending, start, limit, appKey, varEvent, conduit, globalOnly, reservedOnly, keyword);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="appKey"></param>
        /// <param name="varEvent"></param>
        /// <param name="conduit"></param>
        /// <param name="globalOnly"></param>
        /// <param name="reservedOnly"></param>
        /// <param name="keyword"></param>
        partial void AfterSearchNotificationTemplate(ref bool suppressDefaultLog, ISearchNotificationTemplateApiResponse apiResponseLocalVar, long accountId, string sortField, bool descending, int start, int limit, Option<string> appKey, Option<string> varEvent, Option<string> conduit, Option<bool> globalOnly, Option<bool> reservedOnly, Option<string> keyword);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="appKey"></param>
        /// <param name="varEvent"></param>
        /// <param name="conduit"></param>
        /// <param name="globalOnly"></param>
        /// <param name="reservedOnly"></param>
        /// <param name="keyword"></param>
        private void OnErrorSearchNotificationTemplateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string sortField, bool descending, int start, int limit, Option<string> appKey, Option<string> varEvent, Option<string> conduit, Option<bool> globalOnly, Option<bool> reservedOnly, Option<string> keyword)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchNotificationTemplate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, sortField, descending, start, limit, appKey, varEvent, conduit, globalOnly, reservedOnly, keyword);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="appKey"></param>
        /// <param name="varEvent"></param>
        /// <param name="conduit"></param>
        /// <param name="globalOnly"></param>
        /// <param name="reservedOnly"></param>
        /// <param name="keyword"></param>
        partial void OnErrorSearchNotificationTemplate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string sortField, bool descending, int start, int limit, Option<string> appKey, Option<string> varEvent, Option<string> conduit, Option<bool> globalOnly, Option<bool> reservedOnly, Option<string> keyword);

        /// <summary>
        /// Search Notification Templates Search for notification templates on owned applications.
        /// </summary>
        /// <param name="accountId">The account ID of the user.</param>
        /// <param name="sortField">Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name (&#39;global&#39; templates will not have an application and will be returned last if &#39;descending&#39; is set to false.</param>
        /// <param name="descending">Specified whether the results are returned in descending or ascending order.</param>
        /// <param name="start">The start of the pagination.</param>
        /// <param name="limit">The limit of the pagination.</param>
        /// <param name="appKey">Filter results by application. (optional)</param>
        /// <param name="varEvent">Filter results by event. (optional)</param>
        /// <param name="conduit">Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="globalOnly">Returns only templates that have been reserved for system use on all applications (only for admin accounts). (optional)</param>
        /// <param name="reservedOnly">Returns only templates that use reserved events. (optional)</param>
        /// <param name="keyword">Filter results by keyword on the title, tags. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchNotificationTemplateApiResponse"/>&gt;</returns>
        public async Task<ISearchNotificationTemplateApiResponse?> SearchNotificationTemplateOrDefaultAsync(long accountId, string sortField, bool descending, int start, int limit, Option<string> appKey = default, Option<string> varEvent = default, Option<string> conduit = default, Option<bool> globalOnly = default, Option<bool> reservedOnly = default, Option<string> keyword = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchNotificationTemplateAsync(accountId, sortField, descending, start, limit, appKey, varEvent, conduit, globalOnly, reservedOnly, keyword, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Notification Templates Search for notification templates on owned applications.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The account ID of the user.</param>
        /// <param name="sortField">Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name (&#39;global&#39; templates will not have an application and will be returned last if &#39;descending&#39; is set to false.</param>
        /// <param name="descending">Specified whether the results are returned in descending or ascending order.</param>
        /// <param name="start">The start of the pagination.</param>
        /// <param name="limit">The limit of the pagination.</param>
        /// <param name="appKey">Filter results by application. (optional)</param>
        /// <param name="varEvent">Filter results by event. (optional)</param>
        /// <param name="conduit">Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="globalOnly">Returns only templates that have been reserved for system use on all applications (only for admin accounts). (optional)</param>
        /// <param name="reservedOnly">Returns only templates that use reserved events. (optional)</param>
        /// <param name="keyword">Filter results by keyword on the title, tags. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchNotificationTemplateApiResponse"/>&gt;</returns>
        public async Task<ISearchNotificationTemplateApiResponse> SearchNotificationTemplateAsync(long accountId, string sortField, bool descending, int start, int limit, Option<string> appKey = default, Option<string> varEvent = default, Option<string> conduit = default, Option<bool> globalOnly = default, Option<bool> reservedOnly = default, Option<string> keyword = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchNotificationTemplate(sortField, appKey, varEvent, conduit, keyword);

                FormatSearchNotificationTemplate(ref accountId, ref sortField, ref descending, ref start, ref limit, ref appKey, ref varEvent, ref conduit, ref globalOnly, ref reservedOnly, ref keyword);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/notification/template/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/notification/template/search");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["sortField"] = ClientUtils.ParameterToString(sortField);
                    parseQueryStringLocalVar["descending"] = ClientUtils.ParameterToString(descending);
                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit);

                    if (appKey.IsSet)
                        parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey.Value);

                    if (varEvent.IsSet)
                        parseQueryStringLocalVar["event"] = ClientUtils.ParameterToString(varEvent.Value);

                    if (conduit.IsSet)
                        parseQueryStringLocalVar["conduit"] = ClientUtils.ParameterToString(conduit.Value);

                    if (globalOnly.IsSet)
                        parseQueryStringLocalVar["globalOnly"] = ClientUtils.ParameterToString(globalOnly.Value);

                    if (reservedOnly.IsSet)
                        parseQueryStringLocalVar["reservedOnly"] = ClientUtils.ParameterToString(reservedOnly.Value);

                    if (keyword.IsSet)
                        parseQueryStringLocalVar["keyword"] = ClientUtils.ParameterToString(keyword.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchNotificationTemplateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchNotificationTemplateApiResponse>();
                        SearchNotificationTemplateApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/notification/template/search", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchNotificationTemplateDefaultImplementation(apiResponseLocalVar, accountId, sortField, descending, start, limit, appKey, varEvent, conduit, globalOnly, reservedOnly, keyword);

                        Events.ExecuteOnSearchNotificationTemplate(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchNotificationTemplateDefaultImplementation(e, "/notification/template/search", uriBuilderLocalVar.Path, accountId, sortField, descending, start, limit, appKey, varEvent, conduit, globalOnly, reservedOnly, keyword);
                Events.ExecuteOnErrorSearchNotificationTemplate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchNotificationTemplateApiResponse"/>
        /// </summary>
        public partial class SearchNotificationTemplateApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchNotificationTemplateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchNotificationTemplateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchNotificationTemplateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchNotificationTemplateApiResponse(ILogger<SearchNotificationTemplateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchNotificationTemplateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchNotificationTemplateApiResponse(ILogger<SearchNotificationTemplateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.NotificationTemplateResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.NotificationTemplateResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.NotificationTemplateResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchRecipients(ref string sortField, ref Option<string> deviceId, ref Option<long> accountId, ref Option<string> appKey, ref Option<string> conduit, ref Option<string> keyword, ref Option<long> audienceId, ref Option<string> audienceIds, ref Option<string> connectionGroupIds, ref Option<string> recipientAccountIds, ref Option<bool> descending, ref Option<int> start, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sortField"></param>
        /// <param name="deviceId"></param>
        /// <param name="appKey"></param>
        /// <param name="conduit"></param>
        /// <param name="keyword"></param>
        /// <param name="audienceIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="recipientAccountIds"></param>
        /// <returns></returns>
        private void ValidateSearchRecipients(string sortField, Option<string> deviceId, Option<string> appKey, Option<string> conduit, Option<string> keyword, Option<string> audienceIds, Option<string> connectionGroupIds, Option<string> recipientAccountIds)
        {
            if (sortField == null)
                throw new ArgumentNullException(nameof(sortField));

            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (appKey.IsSet && appKey.Value == null)
                throw new ArgumentNullException(nameof(appKey));

            if (conduit.IsSet && conduit.Value == null)
                throw new ArgumentNullException(nameof(conduit));

            if (keyword.IsSet && keyword.Value == null)
                throw new ArgumentNullException(nameof(keyword));

            if (audienceIds.IsSet && audienceIds.Value == null)
                throw new ArgumentNullException(nameof(audienceIds));

            if (connectionGroupIds.IsSet && connectionGroupIds.Value == null)
                throw new ArgumentNullException(nameof(connectionGroupIds));

            if (recipientAccountIds.IsSet && recipientAccountIds.Value == null)
                throw new ArgumentNullException(nameof(recipientAccountIds));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="sortField"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="conduit"></param>
        /// <param name="keyword"></param>
        /// <param name="audienceId"></param>
        /// <param name="audienceIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="recipientAccountIds"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void AfterSearchRecipientsDefaultImplementation(ISearchRecipientsApiResponse apiResponseLocalVar, string sortField, Option<string> deviceId, Option<long> accountId, Option<string> appKey, Option<string> conduit, Option<string> keyword, Option<long> audienceId, Option<string> audienceIds, Option<string> connectionGroupIds, Option<string> recipientAccountIds, Option<bool> descending, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterSearchRecipients(ref suppressDefaultLog, apiResponseLocalVar, sortField, deviceId, accountId, appKey, conduit, keyword, audienceId, audienceIds, connectionGroupIds, recipientAccountIds, descending, start, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="sortField"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="conduit"></param>
        /// <param name="keyword"></param>
        /// <param name="audienceId"></param>
        /// <param name="audienceIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="recipientAccountIds"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void AfterSearchRecipients(ref bool suppressDefaultLog, ISearchRecipientsApiResponse apiResponseLocalVar, string sortField, Option<string> deviceId, Option<long> accountId, Option<string> appKey, Option<string> conduit, Option<string> keyword, Option<long> audienceId, Option<string> audienceIds, Option<string> connectionGroupIds, Option<string> recipientAccountIds, Option<bool> descending, Option<int> start, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="sortField"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="conduit"></param>
        /// <param name="keyword"></param>
        /// <param name="audienceId"></param>
        /// <param name="audienceIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="recipientAccountIds"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void OnErrorSearchRecipientsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string sortField, Option<string> deviceId, Option<long> accountId, Option<string> appKey, Option<string> conduit, Option<string> keyword, Option<long> audienceId, Option<string> audienceIds, Option<string> connectionGroupIds, Option<string> recipientAccountIds, Option<bool> descending, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchRecipients(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, sortField, deviceId, accountId, appKey, conduit, keyword, audienceId, audienceIds, connectionGroupIds, recipientAccountIds, descending, start, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="sortField"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="conduit"></param>
        /// <param name="keyword"></param>
        /// <param name="audienceId"></param>
        /// <param name="audienceIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="recipientAccountIds"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void OnErrorSearchRecipients(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string sortField, Option<string> deviceId, Option<long> accountId, Option<string> appKey, Option<string> conduit, Option<string> keyword, Option<long> audienceId, Option<string> audienceIds, Option<string> connectionGroupIds, Option<string> recipientAccountIds, Option<bool> descending, Option<int> start, Option<int> limit);

        /// <summary>
        /// Search for Recipients Search for application users to send notifications.
        /// </summary>
        /// <param name="sortField">The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}</param>
        /// <param name="deviceId">the unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="appKey">filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)</param>
        /// <param name="conduit">the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="keyword">search by keyword on user&#39;s display name and email (optional)</param>
        /// <param name="audienceId">This parameter is deprecated. filter results by audience (optional)</param>
        /// <param name="audienceIds">filter results by audiences (comma separated list of audience ids) (optional)</param>
        /// <param name="connectionGroupIds">filter results by connection groups (comma separated list of connection group ids) (optional)</param>
        /// <param name="recipientAccountIds">filter results by accounts (comma separated list of account ids) (optional)</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order (optional)</param>
        /// <param name="start">start of the pagination (optional)</param>
        /// <param name="limit">limit of the pagination (hard limit of 1000) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchRecipientsApiResponse"/>&gt;</returns>
        public async Task<ISearchRecipientsApiResponse?> SearchRecipientsOrDefaultAsync(string sortField, Option<string> deviceId = default, Option<long> accountId = default, Option<string> appKey = default, Option<string> conduit = default, Option<string> keyword = default, Option<long> audienceId = default, Option<string> audienceIds = default, Option<string> connectionGroupIds = default, Option<string> recipientAccountIds = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchRecipientsAsync(sortField, deviceId, accountId, appKey, conduit, keyword, audienceId, audienceIds, connectionGroupIds, recipientAccountIds, descending, start, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search for Recipients Search for application users to send notifications.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortField">The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}</param>
        /// <param name="deviceId">the unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="appKey">filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)</param>
        /// <param name="conduit">the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="keyword">search by keyword on user&#39;s display name and email (optional)</param>
        /// <param name="audienceId">This parameter is deprecated. filter results by audience (optional)</param>
        /// <param name="audienceIds">filter results by audiences (comma separated list of audience ids) (optional)</param>
        /// <param name="connectionGroupIds">filter results by connection groups (comma separated list of connection group ids) (optional)</param>
        /// <param name="recipientAccountIds">filter results by accounts (comma separated list of account ids) (optional)</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order (optional)</param>
        /// <param name="start">start of the pagination (optional)</param>
        /// <param name="limit">limit of the pagination (hard limit of 1000) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchRecipientsApiResponse"/>&gt;</returns>
        public async Task<ISearchRecipientsApiResponse> SearchRecipientsAsync(string sortField, Option<string> deviceId = default, Option<long> accountId = default, Option<string> appKey = default, Option<string> conduit = default, Option<string> keyword = default, Option<long> audienceId = default, Option<string> audienceIds = default, Option<string> connectionGroupIds = default, Option<string> recipientAccountIds = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchRecipients(sortField, deviceId, appKey, conduit, keyword, audienceIds, connectionGroupIds, recipientAccountIds);

                FormatSearchRecipients(ref sortField, ref deviceId, ref accountId, ref appKey, ref conduit, ref keyword, ref audienceId, ref audienceIds, ref connectionGroupIds, ref recipientAccountIds, ref descending, ref start, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/notification/recipient/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/notification/recipient/search");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["sortField"] = ClientUtils.ParameterToString(sortField);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (appKey.IsSet)
                        parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey.Value);

                    if (conduit.IsSet)
                        parseQueryStringLocalVar["conduit"] = ClientUtils.ParameterToString(conduit.Value);

                    if (keyword.IsSet)
                        parseQueryStringLocalVar["keyword"] = ClientUtils.ParameterToString(keyword.Value);

                    if (audienceId.IsSet)
                        parseQueryStringLocalVar["audienceId"] = ClientUtils.ParameterToString(audienceId.Value);

                    if (audienceIds.IsSet)
                        parseQueryStringLocalVar["audienceIds"] = ClientUtils.ParameterToString(audienceIds.Value);

                    if (connectionGroupIds.IsSet)
                        parseQueryStringLocalVar["connectionGroupIds"] = ClientUtils.ParameterToString(connectionGroupIds.Value);

                    if (recipientAccountIds.IsSet)
                        parseQueryStringLocalVar["recipientAccountIds"] = ClientUtils.ParameterToString(recipientAccountIds.Value);

                    if (descending.IsSet)
                        parseQueryStringLocalVar["descending"] = ClientUtils.ParameterToString(descending.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchRecipientsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchRecipientsApiResponse>();
                        SearchRecipientsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/notification/recipient/search", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchRecipientsDefaultImplementation(apiResponseLocalVar, sortField, deviceId, accountId, appKey, conduit, keyword, audienceId, audienceIds, connectionGroupIds, recipientAccountIds, descending, start, limit);

                        Events.ExecuteOnSearchRecipients(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchRecipientsDefaultImplementation(e, "/notification/recipient/search", uriBuilderLocalVar.Path, sortField, deviceId, accountId, appKey, conduit, keyword, audienceId, audienceIds, connectionGroupIds, recipientAccountIds, descending, start, limit);
                Events.ExecuteOnErrorSearchRecipients(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchRecipientsApiResponse"/>
        /// </summary>
        public partial class SearchRecipientsApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchRecipientsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchRecipientsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchRecipientsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchRecipientsApiResponse(ILogger<SearchRecipientsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchRecipientsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchRecipientsApiResponse(ILogger<SearchRecipientsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<NotificationRecipientResponse>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<NotificationRecipientResponse>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<NotificationRecipientResponse>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchRecipientsCount(ref Option<string> deviceId, ref Option<long> accountId, ref Option<string> appKey, ref Option<string> conduit, ref Option<string> keyword, ref Option<long> audienceId, ref Option<string> audienceIds, ref Option<string> connectionGroupIds, ref Option<string> sortField, ref Option<bool> descending, ref Option<int> start, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <param name="appKey"></param>
        /// <param name="conduit"></param>
        /// <param name="keyword"></param>
        /// <param name="audienceIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="sortField"></param>
        /// <returns></returns>
        private void ValidateSearchRecipientsCount(Option<string> deviceId, Option<string> appKey, Option<string> conduit, Option<string> keyword, Option<string> audienceIds, Option<string> connectionGroupIds, Option<string> sortField)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (appKey.IsSet && appKey.Value == null)
                throw new ArgumentNullException(nameof(appKey));

            if (conduit.IsSet && conduit.Value == null)
                throw new ArgumentNullException(nameof(conduit));

            if (keyword.IsSet && keyword.Value == null)
                throw new ArgumentNullException(nameof(keyword));

            if (audienceIds.IsSet && audienceIds.Value == null)
                throw new ArgumentNullException(nameof(audienceIds));

            if (connectionGroupIds.IsSet && connectionGroupIds.Value == null)
                throw new ArgumentNullException(nameof(connectionGroupIds));

            if (sortField.IsSet && sortField.Value == null)
                throw new ArgumentNullException(nameof(sortField));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="conduit"></param>
        /// <param name="keyword"></param>
        /// <param name="audienceId"></param>
        /// <param name="audienceIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void AfterSearchRecipientsCountDefaultImplementation(ISearchRecipientsCountApiResponse apiResponseLocalVar, Option<string> deviceId, Option<long> accountId, Option<string> appKey, Option<string> conduit, Option<string> keyword, Option<long> audienceId, Option<string> audienceIds, Option<string> connectionGroupIds, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterSearchRecipientsCount(ref suppressDefaultLog, apiResponseLocalVar, deviceId, accountId, appKey, conduit, keyword, audienceId, audienceIds, connectionGroupIds, sortField, descending, start, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="conduit"></param>
        /// <param name="keyword"></param>
        /// <param name="audienceId"></param>
        /// <param name="audienceIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void AfterSearchRecipientsCount(ref bool suppressDefaultLog, ISearchRecipientsCountApiResponse apiResponseLocalVar, Option<string> deviceId, Option<long> accountId, Option<string> appKey, Option<string> conduit, Option<string> keyword, Option<long> audienceId, Option<string> audienceIds, Option<string> connectionGroupIds, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="conduit"></param>
        /// <param name="keyword"></param>
        /// <param name="audienceId"></param>
        /// <param name="audienceIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void OnErrorSearchRecipientsCountDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> deviceId, Option<long> accountId, Option<string> appKey, Option<string> conduit, Option<string> keyword, Option<long> audienceId, Option<string> audienceIds, Option<string> connectionGroupIds, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchRecipientsCount(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, deviceId, accountId, appKey, conduit, keyword, audienceId, audienceIds, connectionGroupIds, sortField, descending, start, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="conduit"></param>
        /// <param name="keyword"></param>
        /// <param name="audienceId"></param>
        /// <param name="audienceIds"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void OnErrorSearchRecipientsCount(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> deviceId, Option<long> accountId, Option<string> appKey, Option<string> conduit, Option<string> keyword, Option<long> audienceId, Option<string> audienceIds, Option<string> connectionGroupIds, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit);

        /// <summary>
        /// Search for Recipients (Counts/Grouped) Search for application users to send notifications (count/grouped variant).
        /// </summary>
        /// <param name="deviceId">the unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="appKey">filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)</param>
        /// <param name="conduit">the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="keyword">search by keyword on user&#39;s display name and email (optional)</param>
        /// <param name="audienceId">This parameter is deprecated. filter results by audience (optional)</param>
        /// <param name="audienceIds">filter results by audiences (comma separated list of audience ids) (optional)</param>
        /// <param name="connectionGroupIds">filter results by connection groups (comma separated list of connection group ids) (optional)</param>
        /// <param name="sortField">The field to sort by (see API docs for allowed values). (optional)</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order (optional)</param>
        /// <param name="start">start of the pagination (optional)</param>
        /// <param name="limit">limit of the pagination (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchRecipientsCountApiResponse"/>&gt;</returns>
        public async Task<ISearchRecipientsCountApiResponse?> SearchRecipientsCountOrDefaultAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<string> appKey = default, Option<string> conduit = default, Option<string> keyword = default, Option<long> audienceId = default, Option<string> audienceIds = default, Option<string> connectionGroupIds = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchRecipientsCountAsync(deviceId, accountId, appKey, conduit, keyword, audienceId, audienceIds, connectionGroupIds, sortField, descending, start, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search for Recipients (Counts/Grouped) Search for application users to send notifications (count/grouped variant).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="deviceId">the unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="appKey">filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)</param>
        /// <param name="conduit">the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="keyword">search by keyword on user&#39;s display name and email (optional)</param>
        /// <param name="audienceId">This parameter is deprecated. filter results by audience (optional)</param>
        /// <param name="audienceIds">filter results by audiences (comma separated list of audience ids) (optional)</param>
        /// <param name="connectionGroupIds">filter results by connection groups (comma separated list of connection group ids) (optional)</param>
        /// <param name="sortField">The field to sort by (see API docs for allowed values). (optional)</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order (optional)</param>
        /// <param name="start">start of the pagination (optional)</param>
        /// <param name="limit">limit of the pagination (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchRecipientsCountApiResponse"/>&gt;</returns>
        public async Task<ISearchRecipientsCountApiResponse> SearchRecipientsCountAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<string> appKey = default, Option<string> conduit = default, Option<string> keyword = default, Option<long> audienceId = default, Option<string> audienceIds = default, Option<string> connectionGroupIds = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchRecipientsCount(deviceId, appKey, conduit, keyword, audienceIds, connectionGroupIds, sortField);

                FormatSearchRecipientsCount(ref deviceId, ref accountId, ref appKey, ref conduit, ref keyword, ref audienceId, ref audienceIds, ref connectionGroupIds, ref sortField, ref descending, ref start, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/notification/recipient/search/count"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/notification/recipient/search/count");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (appKey.IsSet)
                        parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey.Value);

                    if (conduit.IsSet)
                        parseQueryStringLocalVar["conduit"] = ClientUtils.ParameterToString(conduit.Value);

                    if (keyword.IsSet)
                        parseQueryStringLocalVar["keyword"] = ClientUtils.ParameterToString(keyword.Value);

                    if (audienceId.IsSet)
                        parseQueryStringLocalVar["audienceId"] = ClientUtils.ParameterToString(audienceId.Value);

                    if (audienceIds.IsSet)
                        parseQueryStringLocalVar["audienceIds"] = ClientUtils.ParameterToString(audienceIds.Value);

                    if (connectionGroupIds.IsSet)
                        parseQueryStringLocalVar["connectionGroupIds"] = ClientUtils.ParameterToString(connectionGroupIds.Value);

                    if (sortField.IsSet)
                        parseQueryStringLocalVar["sortField"] = ClientUtils.ParameterToString(sortField.Value);

                    if (descending.IsSet)
                        parseQueryStringLocalVar["descending"] = ClientUtils.ParameterToString(descending.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchRecipientsCountApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchRecipientsCountApiResponse>();
                        SearchRecipientsCountApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/notification/recipient/search/count", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchRecipientsCountDefaultImplementation(apiResponseLocalVar, deviceId, accountId, appKey, conduit, keyword, audienceId, audienceIds, connectionGroupIds, sortField, descending, start, limit);

                        Events.ExecuteOnSearchRecipientsCount(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchRecipientsCountDefaultImplementation(e, "/notification/recipient/search/count", uriBuilderLocalVar.Path, deviceId, accountId, appKey, conduit, keyword, audienceId, audienceIds, connectionGroupIds, sortField, descending, start, limit);
                Events.ExecuteOnErrorSearchRecipientsCount(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchRecipientsCountApiResponse"/>
        /// </summary>
        public partial class SearchRecipientsCountApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchRecipientsCountApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchRecipientsCountApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchRecipientsCountApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchRecipientsCountApiResponse(ILogger<SearchRecipientsCountApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchRecipientsCountApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchRecipientsCountApiResponse(ILogger<SearchRecipientsCountApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.NotificationRecipientResponseListResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.NotificationRecipientResponseListResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.NotificationRecipientResponseListResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendBatchNotifications(ref long accountId, ref string appKey, ref string customMessage, ref Option<string> conduit, ref Option<long> contentId, ref Option<string> contentName, ref Option<string> contentType, ref Option<long> parentId, ref Option<string> parentType);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="appKey"></param>
        /// <param name="customMessage"></param>
        /// <param name="conduit"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentType"></param>
        /// <returns></returns>
        private void ValidateSendBatchNotifications(string appKey, string customMessage, Option<string> conduit, Option<string> contentName, Option<string> contentType, Option<string> parentType)
        {
            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));

            if (customMessage == null)
                throw new ArgumentNullException(nameof(customMessage));

            if (conduit.IsSet && conduit.Value == null)
                throw new ArgumentNullException(nameof(conduit));

            if (contentName.IsSet && contentName.Value == null)
                throw new ArgumentNullException(nameof(contentName));

            if (contentType.IsSet && contentType.Value == null)
                throw new ArgumentNullException(nameof(contentType));

            if (parentType.IsSet && parentType.Value == null)
                throw new ArgumentNullException(nameof(parentType));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="customMessage"></param>
        /// <param name="conduit"></param>
        /// <param name="contentId"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentId"></param>
        /// <param name="parentType"></param>
        private void AfterSendBatchNotificationsDefaultImplementation(ISendBatchNotificationsApiResponse apiResponseLocalVar, long accountId, string appKey, string customMessage, Option<string> conduit, Option<long> contentId, Option<string> contentName, Option<string> contentType, Option<long> parentId, Option<string> parentType)
        {
            bool suppressDefaultLog = false;
            AfterSendBatchNotifications(ref suppressDefaultLog, apiResponseLocalVar, accountId, appKey, customMessage, conduit, contentId, contentName, contentType, parentId, parentType);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="customMessage"></param>
        /// <param name="conduit"></param>
        /// <param name="contentId"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentId"></param>
        /// <param name="parentType"></param>
        partial void AfterSendBatchNotifications(ref bool suppressDefaultLog, ISendBatchNotificationsApiResponse apiResponseLocalVar, long accountId, string appKey, string customMessage, Option<string> conduit, Option<long> contentId, Option<string> contentName, Option<string> contentType, Option<long> parentId, Option<string> parentType);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="customMessage"></param>
        /// <param name="conduit"></param>
        /// <param name="contentId"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentId"></param>
        /// <param name="parentType"></param>
        private void OnErrorSendBatchNotificationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string appKey, string customMessage, Option<string> conduit, Option<long> contentId, Option<string> contentName, Option<string> contentType, Option<long> parentId, Option<string> parentType)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendBatchNotifications(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, appKey, customMessage, conduit, contentId, contentName, contentType, parentId, parentType);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="customMessage"></param>
        /// <param name="conduit"></param>
        /// <param name="contentId"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentId"></param>
        /// <param name="parentType"></param>
        partial void OnErrorSendBatchNotifications(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string appKey, string customMessage, Option<string> conduit, Option<long> contentId, Option<string> contentName, Option<string> contentType, Option<long> parentId, Option<string> parentType);

        /// <summary>
        /// Send Batch Notifications Send notifications to all users of an application. Only someone with permissions to the application can do this.
        /// </summary>
        /// <param name="accountId">The account id of the application owner/manager</param>
        /// <param name="appKey">The application key for updating an existing application</param>
        /// <param name="customMessage">Message string that will be displayed in on the notification</param>
        /// <param name="conduit">The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="contentId">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="contentName">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="contentType">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="parentId">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="parentType">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendBatchNotificationsApiResponse"/>&gt;</returns>
        public async Task<ISendBatchNotificationsApiResponse?> SendBatchNotificationsOrDefaultAsync(long accountId, string appKey, string customMessage, Option<string> conduit = default, Option<long> contentId = default, Option<string> contentName = default, Option<string> contentType = default, Option<long> parentId = default, Option<string> parentType = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendBatchNotificationsAsync(accountId, appKey, customMessage, conduit, contentId, contentName, contentType, parentId, parentType, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Send Batch Notifications Send notifications to all users of an application. Only someone with permissions to the application can do this.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The account id of the application owner/manager</param>
        /// <param name="appKey">The application key for updating an existing application</param>
        /// <param name="customMessage">Message string that will be displayed in on the notification</param>
        /// <param name="conduit">The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="contentId">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="contentName">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="contentType">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="parentId">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="parentType">Default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendBatchNotificationsApiResponse"/>&gt;</returns>
        public async Task<ISendBatchNotificationsApiResponse> SendBatchNotificationsAsync(long accountId, string appKey, string customMessage, Option<string> conduit = default, Option<long> contentId = default, Option<string> contentName = default, Option<string> contentType = default, Option<long> parentId = default, Option<string> parentType = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSendBatchNotifications(appKey, customMessage, conduit, contentName, contentType, parentType);

                FormatSendBatchNotifications(ref accountId, ref appKey, ref customMessage, ref conduit, ref contentId, ref contentName, ref contentType, ref parentId, ref parentType);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/notification/batch"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/notification/batch");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey);
                    parseQueryStringLocalVar["customMessage"] = ClientUtils.ParameterToString(customMessage);

                    if (conduit.IsSet)
                        parseQueryStringLocalVar["conduit"] = ClientUtils.ParameterToString(conduit.Value);

                    if (contentId.IsSet)
                        parseQueryStringLocalVar["contentId"] = ClientUtils.ParameterToString(contentId.Value);

                    if (contentName.IsSet)
                        parseQueryStringLocalVar["contentName"] = ClientUtils.ParameterToString(contentName.Value);

                    if (contentType.IsSet)
                        parseQueryStringLocalVar["contentType"] = ClientUtils.ParameterToString(contentType.Value);

                    if (parentId.IsSet)
                        parseQueryStringLocalVar["parentId"] = ClientUtils.ParameterToString(parentId.Value);

                    if (parentType.IsSet)
                        parseQueryStringLocalVar["parentType"] = ClientUtils.ParameterToString(parentType.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SendBatchNotificationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendBatchNotificationsApiResponse>();
                        SendBatchNotificationsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/notification/batch", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSendBatchNotificationsDefaultImplementation(apiResponseLocalVar, accountId, appKey, customMessage, conduit, contentId, contentName, contentType, parentId, parentType);

                        Events.ExecuteOnSendBatchNotifications(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendBatchNotificationsDefaultImplementation(e, "/notification/batch", uriBuilderLocalVar.Path, accountId, appKey, customMessage, conduit, contentId, contentName, contentType, parentId, parentType);
                Events.ExecuteOnErrorSendBatchNotifications(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendBatchNotificationsApiResponse"/>
        /// </summary>
        public partial class SendBatchNotificationsApiResponse : Org.OpenAPITools.Client.ApiResponse, ISendBatchNotificationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendBatchNotificationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendBatchNotificationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendBatchNotificationsApiResponse(ILogger<SendBatchNotificationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SendBatchNotificationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendBatchNotificationsApiResponse(ILogger<SendBatchNotificationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSendCustomNotifications(ref Option<string> deviceId, ref Option<long> accountId, ref Option<string> receiverAccountIds, ref Option<bool> includeFriendGroup, ref Option<string> appKey, ref Option<string> gameType, ref Option<string> conduit, ref Option<long> contentId, ref Option<string> contentName, ref Option<string> contentType, ref Option<long> parentId, ref Option<string> parentType, ref Option<string> actionCategory, ref Option<string> subject, ref Option<string> customMessage, ref Option<bool> friendOnlyAPNS, ref Option<double> latitude, ref Option<double> longitude);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="deviceId"></param>
        /// <param name="receiverAccountIds"></param>
        /// <param name="appKey"></param>
        /// <param name="gameType"></param>
        /// <param name="conduit"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentType"></param>
        /// <param name="actionCategory"></param>
        /// <param name="subject"></param>
        /// <param name="customMessage"></param>
        /// <returns></returns>
        private void ValidateSendCustomNotifications(Option<string> deviceId, Option<string> receiverAccountIds, Option<string> appKey, Option<string> gameType, Option<string> conduit, Option<string> contentName, Option<string> contentType, Option<string> parentType, Option<string> actionCategory, Option<string> subject, Option<string> customMessage)
        {
            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));

            if (receiverAccountIds.IsSet && receiverAccountIds.Value == null)
                throw new ArgumentNullException(nameof(receiverAccountIds));

            if (appKey.IsSet && appKey.Value == null)
                throw new ArgumentNullException(nameof(appKey));

            if (gameType.IsSet && gameType.Value == null)
                throw new ArgumentNullException(nameof(gameType));

            if (conduit.IsSet && conduit.Value == null)
                throw new ArgumentNullException(nameof(conduit));

            if (contentName.IsSet && contentName.Value == null)
                throw new ArgumentNullException(nameof(contentName));

            if (contentType.IsSet && contentType.Value == null)
                throw new ArgumentNullException(nameof(contentType));

            if (parentType.IsSet && parentType.Value == null)
                throw new ArgumentNullException(nameof(parentType));

            if (actionCategory.IsSet && actionCategory.Value == null)
                throw new ArgumentNullException(nameof(actionCategory));

            if (subject.IsSet && subject.Value == null)
                throw new ArgumentNullException(nameof(subject));

            if (customMessage.IsSet && customMessage.Value == null)
                throw new ArgumentNullException(nameof(customMessage));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="receiverAccountIds"></param>
        /// <param name="includeFriendGroup"></param>
        /// <param name="appKey"></param>
        /// <param name="gameType"></param>
        /// <param name="conduit"></param>
        /// <param name="contentId"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentId"></param>
        /// <param name="parentType"></param>
        /// <param name="actionCategory"></param>
        /// <param name="subject"></param>
        /// <param name="customMessage"></param>
        /// <param name="friendOnlyAPNS"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void AfterSendCustomNotificationsDefaultImplementation(ISendCustomNotificationsApiResponse apiResponseLocalVar, Option<string> deviceId, Option<long> accountId, Option<string> receiverAccountIds, Option<bool> includeFriendGroup, Option<string> appKey, Option<string> gameType, Option<string> conduit, Option<long> contentId, Option<string> contentName, Option<string> contentType, Option<long> parentId, Option<string> parentType, Option<string> actionCategory, Option<string> subject, Option<string> customMessage, Option<bool> friendOnlyAPNS, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLog = false;
            AfterSendCustomNotifications(ref suppressDefaultLog, apiResponseLocalVar, deviceId, accountId, receiverAccountIds, includeFriendGroup, appKey, gameType, conduit, contentId, contentName, contentType, parentId, parentType, actionCategory, subject, customMessage, friendOnlyAPNS, latitude, longitude);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="receiverAccountIds"></param>
        /// <param name="includeFriendGroup"></param>
        /// <param name="appKey"></param>
        /// <param name="gameType"></param>
        /// <param name="conduit"></param>
        /// <param name="contentId"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentId"></param>
        /// <param name="parentType"></param>
        /// <param name="actionCategory"></param>
        /// <param name="subject"></param>
        /// <param name="customMessage"></param>
        /// <param name="friendOnlyAPNS"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void AfterSendCustomNotifications(ref bool suppressDefaultLog, ISendCustomNotificationsApiResponse apiResponseLocalVar, Option<string> deviceId, Option<long> accountId, Option<string> receiverAccountIds, Option<bool> includeFriendGroup, Option<string> appKey, Option<string> gameType, Option<string> conduit, Option<long> contentId, Option<string> contentName, Option<string> contentType, Option<long> parentId, Option<string> parentType, Option<string> actionCategory, Option<string> subject, Option<string> customMessage, Option<bool> friendOnlyAPNS, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="receiverAccountIds"></param>
        /// <param name="includeFriendGroup"></param>
        /// <param name="appKey"></param>
        /// <param name="gameType"></param>
        /// <param name="conduit"></param>
        /// <param name="contentId"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentId"></param>
        /// <param name="parentType"></param>
        /// <param name="actionCategory"></param>
        /// <param name="subject"></param>
        /// <param name="customMessage"></param>
        /// <param name="friendOnlyAPNS"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        private void OnErrorSendCustomNotificationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> deviceId, Option<long> accountId, Option<string> receiverAccountIds, Option<bool> includeFriendGroup, Option<string> appKey, Option<string> gameType, Option<string> conduit, Option<long> contentId, Option<string> contentName, Option<string> contentType, Option<long> parentId, Option<string> parentType, Option<string> actionCategory, Option<string> subject, Option<string> customMessage, Option<bool> friendOnlyAPNS, Option<double> latitude, Option<double> longitude)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSendCustomNotifications(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, deviceId, accountId, receiverAccountIds, includeFriendGroup, appKey, gameType, conduit, contentId, contentName, contentType, parentId, parentType, actionCategory, subject, customMessage, friendOnlyAPNS, latitude, longitude);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="deviceId"></param>
        /// <param name="accountId"></param>
        /// <param name="receiverAccountIds"></param>
        /// <param name="includeFriendGroup"></param>
        /// <param name="appKey"></param>
        /// <param name="gameType"></param>
        /// <param name="conduit"></param>
        /// <param name="contentId"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentId"></param>
        /// <param name="parentType"></param>
        /// <param name="actionCategory"></param>
        /// <param name="subject"></param>
        /// <param name="customMessage"></param>
        /// <param name="friendOnlyAPNS"></param>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        partial void OnErrorSendCustomNotifications(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> deviceId, Option<long> accountId, Option<string> receiverAccountIds, Option<bool> includeFriendGroup, Option<string> appKey, Option<string> gameType, Option<string> conduit, Option<long> contentId, Option<string> contentName, Option<string> contentType, Option<long> parentId, Option<string> parentType, Option<string> actionCategory, Option<string> subject, Option<string> customMessage, Option<bool> friendOnlyAPNS, Option<double> latitude, Option<double> longitude);

        /// <summary>
        /// Send Custom Notifications Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.
        /// </summary>
        /// <param name="deviceId">the unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="receiverAccountIds">comma separated list of account IDs that will receive the notification (optional)</param>
        /// <param name="includeFriendGroup">determines whether to send to all of the user&#39;s friends, this flag must be true or receiverAccountIds must not be empty (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="conduit">the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="contentId">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="contentName">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="contentType">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="parentId">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="parentType">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="actionCategory"> (optional)</param>
        /// <param name="subject">the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="customMessage">message string that will be displayed in on the notification (optional)</param>
        /// <param name="friendOnlyAPNS">only sends APNS to people who are friends of the user (still saves the notification message for feed polling) (optional)</param>
        /// <param name="latitude">latitude used to update the user&#39;s current location (optional)</param>
        /// <param name="longitude">longitude used to update the user&#39;s current location (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendCustomNotificationsApiResponse"/>&gt;</returns>
        public async Task<ISendCustomNotificationsApiResponse?> SendCustomNotificationsOrDefaultAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<string> receiverAccountIds = default, Option<bool> includeFriendGroup = default, Option<string> appKey = default, Option<string> gameType = default, Option<string> conduit = default, Option<long> contentId = default, Option<string> contentName = default, Option<string> contentType = default, Option<long> parentId = default, Option<string> parentType = default, Option<string> actionCategory = default, Option<string> subject = default, Option<string> customMessage = default, Option<bool> friendOnlyAPNS = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SendCustomNotificationsAsync(deviceId, accountId, receiverAccountIds, includeFriendGroup, appKey, gameType, conduit, contentId, contentName, contentType, parentId, parentType, actionCategory, subject, customMessage, friendOnlyAPNS, latitude, longitude, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Send Custom Notifications Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="deviceId">the unique id of the device making the request (deviceId or accountId required) (optional)</param>
        /// <param name="accountId">the account id of the user (deviceId or accountId required) (optional)</param>
        /// <param name="receiverAccountIds">comma separated list of account IDs that will receive the notification (optional)</param>
        /// <param name="includeFriendGroup">determines whether to send to all of the user&#39;s friends, this flag must be true or receiverAccountIds must not be empty (optional)</param>
        /// <param name="appKey">the application key (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="conduit">the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)</param>
        /// <param name="contentId">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="contentName">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="contentType">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="parentId">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="parentType">default notification pay-load field (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="actionCategory"> (optional)</param>
        /// <param name="subject">the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event) (optional)</param>
        /// <param name="customMessage">message string that will be displayed in on the notification (optional)</param>
        /// <param name="friendOnlyAPNS">only sends APNS to people who are friends of the user (still saves the notification message for feed polling) (optional)</param>
        /// <param name="latitude">latitude used to update the user&#39;s current location (optional)</param>
        /// <param name="longitude">longitude used to update the user&#39;s current location (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISendCustomNotificationsApiResponse"/>&gt;</returns>
        public async Task<ISendCustomNotificationsApiResponse> SendCustomNotificationsAsync(Option<string> deviceId = default, Option<long> accountId = default, Option<string> receiverAccountIds = default, Option<bool> includeFriendGroup = default, Option<string> appKey = default, Option<string> gameType = default, Option<string> conduit = default, Option<long> contentId = default, Option<string> contentName = default, Option<string> contentType = default, Option<long> parentId = default, Option<string> parentType = default, Option<string> actionCategory = default, Option<string> subject = default, Option<string> customMessage = default, Option<bool> friendOnlyAPNS = default, Option<double> latitude = default, Option<double> longitude = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSendCustomNotifications(deviceId, receiverAccountIds, appKey, gameType, conduit, contentName, contentType, parentType, actionCategory, subject, customMessage);

                FormatSendCustomNotifications(ref deviceId, ref accountId, ref receiverAccountIds, ref includeFriendGroup, ref appKey, ref gameType, ref conduit, ref contentId, ref contentName, ref contentType, ref parentId, ref parentType, ref actionCategory, ref subject, ref customMessage, ref friendOnlyAPNS, ref latitude, ref longitude);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/notification/custom"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/notification/custom");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId.Value);

                    if (receiverAccountIds.IsSet)
                        parseQueryStringLocalVar["receiverAccountIds"] = ClientUtils.ParameterToString(receiverAccountIds.Value);

                    if (includeFriendGroup.IsSet)
                        parseQueryStringLocalVar["includeFriendGroup"] = ClientUtils.ParameterToString(includeFriendGroup.Value);

                    if (appKey.IsSet)
                        parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey.Value);

                    if (gameType.IsSet)
                        parseQueryStringLocalVar["gameType"] = ClientUtils.ParameterToString(gameType.Value);

                    if (conduit.IsSet)
                        parseQueryStringLocalVar["conduit"] = ClientUtils.ParameterToString(conduit.Value);

                    if (contentId.IsSet)
                        parseQueryStringLocalVar["contentId"] = ClientUtils.ParameterToString(contentId.Value);

                    if (contentName.IsSet)
                        parseQueryStringLocalVar["contentName"] = ClientUtils.ParameterToString(contentName.Value);

                    if (contentType.IsSet)
                        parseQueryStringLocalVar["contentType"] = ClientUtils.ParameterToString(contentType.Value);

                    if (parentId.IsSet)
                        parseQueryStringLocalVar["parentId"] = ClientUtils.ParameterToString(parentId.Value);

                    if (parentType.IsSet)
                        parseQueryStringLocalVar["parentType"] = ClientUtils.ParameterToString(parentType.Value);

                    if (actionCategory.IsSet)
                        parseQueryStringLocalVar["actionCategory"] = ClientUtils.ParameterToString(actionCategory.Value);

                    if (subject.IsSet)
                        parseQueryStringLocalVar["subject"] = ClientUtils.ParameterToString(subject.Value);

                    if (customMessage.IsSet)
                        parseQueryStringLocalVar["customMessage"] = ClientUtils.ParameterToString(customMessage.Value);

                    if (friendOnlyAPNS.IsSet)
                        parseQueryStringLocalVar["friendOnlyAPNS"] = ClientUtils.ParameterToString(friendOnlyAPNS.Value);

                    if (latitude.IsSet)
                        parseQueryStringLocalVar["latitude"] = ClientUtils.ParameterToString(latitude.Value);

                    if (longitude.IsSet)
                        parseQueryStringLocalVar["longitude"] = ClientUtils.ParameterToString(longitude.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SendCustomNotificationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SendCustomNotificationsApiResponse>();
                        SendCustomNotificationsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/notification/custom", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSendCustomNotificationsDefaultImplementation(apiResponseLocalVar, deviceId, accountId, receiverAccountIds, includeFriendGroup, appKey, gameType, conduit, contentId, contentName, contentType, parentId, parentType, actionCategory, subject, customMessage, friendOnlyAPNS, latitude, longitude);

                        Events.ExecuteOnSendCustomNotifications(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSendCustomNotificationsDefaultImplementation(e, "/notification/custom", uriBuilderLocalVar.Path, deviceId, accountId, receiverAccountIds, includeFriendGroup, appKey, gameType, conduit, contentId, contentName, contentType, parentId, parentType, actionCategory, subject, customMessage, friendOnlyAPNS, latitude, longitude);
                Events.ExecuteOnErrorSendCustomNotifications(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SendCustomNotificationsApiResponse"/>
        /// </summary>
        public partial class SendCustomNotificationsApiResponse : Org.OpenAPITools.Client.ApiResponse, ISendCustomNotificationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SendCustomNotificationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SendCustomNotificationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendCustomNotificationsApiResponse(ILogger<SendCustomNotificationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SendCustomNotificationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SendCustomNotificationsApiResponse(ILogger<SendCustomNotificationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateNotificationTemplate(ref long accountId, ref long notificationTemplateId, ref Option<string> title, ref Option<string> body, ref Option<string> tags);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="title"></param>
        /// <param name="body"></param>
        /// <param name="tags"></param>
        /// <returns></returns>
        private void ValidateUpdateNotificationTemplate(Option<string> title, Option<string> body, Option<string> tags)
        {
            if (title.IsSet && title.Value == null)
                throw new ArgumentNullException(nameof(title));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));

            if (tags.IsSet && tags.Value == null)
                throw new ArgumentNullException(nameof(tags));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="notificationTemplateId"></param>
        /// <param name="title"></param>
        /// <param name="body"></param>
        /// <param name="tags"></param>
        private void AfterUpdateNotificationTemplateDefaultImplementation(IUpdateNotificationTemplateApiResponse apiResponseLocalVar, long accountId, long notificationTemplateId, Option<string> title, Option<string> body, Option<string> tags)
        {
            bool suppressDefaultLog = false;
            AfterUpdateNotificationTemplate(ref suppressDefaultLog, apiResponseLocalVar, accountId, notificationTemplateId, title, body, tags);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="notificationTemplateId"></param>
        /// <param name="title"></param>
        /// <param name="body"></param>
        /// <param name="tags"></param>
        partial void AfterUpdateNotificationTemplate(ref bool suppressDefaultLog, IUpdateNotificationTemplateApiResponse apiResponseLocalVar, long accountId, long notificationTemplateId, Option<string> title, Option<string> body, Option<string> tags);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="notificationTemplateId"></param>
        /// <param name="title"></param>
        /// <param name="body"></param>
        /// <param name="tags"></param>
        private void OnErrorUpdateNotificationTemplateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long notificationTemplateId, Option<string> title, Option<string> body, Option<string> tags)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateNotificationTemplate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, notificationTemplateId, title, body, tags);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="notificationTemplateId"></param>
        /// <param name="title"></param>
        /// <param name="body"></param>
        /// <param name="tags"></param>
        partial void OnErrorUpdateNotificationTemplate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long notificationTemplateId, Option<string> title, Option<string> body, Option<string> tags);

        /// <summary>
        /// Update Notification Template Update a notification template. Developers will only be able to update notification templates for their own applications.
        /// </summary>
        /// <param name="accountId">The account ID of the user.</param>
        /// <param name="notificationTemplateId">The notification template ID to update.</param>
        /// <param name="title">The title of the message (this would become the subject title for emails). There is a 191 character limit. (optional)</param>
        /// <param name="body">The body of the message. (optional)</param>
        /// <param name="tags">The search tags on the template used during search queries. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateNotificationTemplateApiResponse"/>&gt;</returns>
        public async Task<IUpdateNotificationTemplateApiResponse?> UpdateNotificationTemplateOrDefaultAsync(long accountId, long notificationTemplateId, Option<string> title = default, Option<string> body = default, Option<string> tags = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateNotificationTemplateAsync(accountId, notificationTemplateId, title, body, tags, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update Notification Template Update a notification template. Developers will only be able to update notification templates for their own applications.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The account ID of the user.</param>
        /// <param name="notificationTemplateId">The notification template ID to update.</param>
        /// <param name="title">The title of the message (this would become the subject title for emails). There is a 191 character limit. (optional)</param>
        /// <param name="body">The body of the message. (optional)</param>
        /// <param name="tags">The search tags on the template used during search queries. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateNotificationTemplateApiResponse"/>&gt;</returns>
        public async Task<IUpdateNotificationTemplateApiResponse> UpdateNotificationTemplateAsync(long accountId, long notificationTemplateId, Option<string> title = default, Option<string> body = default, Option<string> tags = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateNotificationTemplate(title, body, tags);

                FormatUpdateNotificationTemplate(ref accountId, ref notificationTemplateId, ref title, ref body, ref tags);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/notification/template/update"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/notification/template/update");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["notificationTemplateId"] = ClientUtils.ParameterToString(notificationTemplateId);

                    if (title.IsSet)
                        parseQueryStringLocalVar["title"] = ClientUtils.ParameterToString(title.Value);

                    if (body.IsSet)
                        parseQueryStringLocalVar["body"] = ClientUtils.ParameterToString(body.Value);

                    if (tags.IsSet)
                        parseQueryStringLocalVar["tags"] = ClientUtils.ParameterToString(tags.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UpdateNotificationTemplateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateNotificationTemplateApiResponse>();
                        UpdateNotificationTemplateApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/notification/template/update", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUpdateNotificationTemplateDefaultImplementation(apiResponseLocalVar, accountId, notificationTemplateId, title, body, tags);

                        Events.ExecuteOnUpdateNotificationTemplate(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateNotificationTemplateDefaultImplementation(e, "/notification/template/update", uriBuilderLocalVar.Path, accountId, notificationTemplateId, title, body, tags);
                Events.ExecuteOnErrorUpdateNotificationTemplate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateNotificationTemplateApiResponse"/>
        /// </summary>
        public partial class UpdateNotificationTemplateApiResponse : Org.OpenAPITools.Client.ApiResponse, IUpdateNotificationTemplateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateNotificationTemplateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateNotificationTemplateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateNotificationTemplateApiResponse(ILogger<UpdateNotificationTemplateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UpdateNotificationTemplateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateNotificationTemplateApiResponse(ILogger<UpdateNotificationTemplateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.NotificationTemplateResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.NotificationTemplateResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.NotificationTemplateResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
