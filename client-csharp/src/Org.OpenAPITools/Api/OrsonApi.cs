// <auto-generated>
/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Net;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IOrsonApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        OrsonApiEvents Events { get; }

        /// <summary>
        /// Add Movie
        /// </summary>
        /// <remarks>
        /// Add a movie to be indexed for Topics. Indexing a movie analyses the content and incorporates it into the topics model for future /topics calls. This does not store the movie file long-term.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="movieName">Movie Name</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="tags">A user defined list (comma-delimited) of tags associated with the movie (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddMovieApiResponse"/>&gt;</returns>
        Task<IAddMovieApiResponse> AddMovieAsync(decimal version, long accountId, string movieName, Option<string> thirdPartyAccountId = default, Option<string> tags = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Add Movie
        /// </summary>
        /// <remarks>
        /// Add a movie to be indexed for Topics. Indexing a movie analyses the content and incorporates it into the topics model for future /topics calls. This does not store the movie file long-term.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="movieName">Movie Name</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="tags">A user defined list (comma-delimited) of tags associated with the movie (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddMovieApiResponse"/>?&gt;</returns>
        Task<IAddMovieApiResponse?> AddMovieOrDefaultAsync(decimal version, long accountId, string movieName, Option<string> thirdPartyAccountId = default, Option<string> tags = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Docs
        /// </summary>
        /// <remarks>
        /// Takes in a text string representing one or more sentences and it returns a list of documents which are related to the provided document.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="doc">Doc</param>
        /// <param name="returnTopics">Return Topics (optional)</param>
        /// <param name="limit">Limit (optional)</param>
        /// <param name="offset">Offset (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAiDocsApiResponse"/>&gt;</returns>
        Task<IAiDocsApiResponse> AiDocsAsync(decimal version, long accountId, string doc, Option<bool> returnTopics = default, Option<int> limit = default, Option<int> offset = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Docs
        /// </summary>
        /// <remarks>
        /// Takes in a text string representing one or more sentences and it returns a list of documents which are related to the provided document.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="doc">Doc</param>
        /// <param name="returnTopics">Return Topics (optional)</param>
        /// <param name="limit">Limit (optional)</param>
        /// <param name="offset">Offset (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAiDocsApiResponse"/>?&gt;</returns>
        Task<IAiDocsApiResponse?> AiDocsOrDefaultAsync(decimal version, long accountId, string doc, Option<bool> returnTopics = default, Option<int> limit = default, Option<int> offset = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Find images
        /// </summary>
        /// <remarks>
        /// Returns a list of URIs of images that match the text.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="text">Text</param>
        /// <param name="parseFlag">Parse Flag (optional)</param>
        /// <param name="fetchFlag">Fetch Flag (optional)</param>
        /// <param name="size">Size (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAiFindImagesApiResponse"/>&gt;</returns>
        Task<IAiFindImagesApiResponse> AiFindImagesAsync(decimal version, long accountId, string text, Option<string> parseFlag = default, Option<string> fetchFlag = default, Option<string> size = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Find images
        /// </summary>
        /// <remarks>
        /// Returns a list of URIs of images that match the text.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="text">Text</param>
        /// <param name="parseFlag">Parse Flag (optional)</param>
        /// <param name="fetchFlag">Fetch Flag (optional)</param>
        /// <param name="size">Size (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAiFindImagesApiResponse"/>?&gt;</returns>
        Task<IAiFindImagesApiResponse?> AiFindImagesOrDefaultAsync(decimal version, long accountId, string text, Option<string> parseFlag = default, Option<string> fetchFlag = default, Option<string> size = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Tags
        /// </summary>
        /// <remarks>
        /// Search the tags column of user provided tags using this endpoint.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="tags">Tags</param>
        /// <param name="conditional">Conditional (optional)</param>
        /// <param name="limit">Limit (optional)</param>
        /// <param name="offset">Offset (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAiTagsApiResponse"/>&gt;</returns>
        Task<IAiTagsApiResponse> AiTagsAsync(decimal version, long accountId, string tags, Option<string> conditional = default, Option<int> limit = default, Option<int> offset = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Tags
        /// </summary>
        /// <remarks>
        /// Search the tags column of user provided tags using this endpoint.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="tags">Tags</param>
        /// <param name="conditional">Conditional (optional)</param>
        /// <param name="limit">Limit (optional)</param>
        /// <param name="offset">Offset (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAiTagsApiResponse"/>?&gt;</returns>
        Task<IAiTagsApiResponse?> AiTagsOrDefaultAsync(decimal version, long accountId, string tags, Option<string> conditional = default, Option<int> limit = default, Option<int> offset = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Text
        /// </summary>
        /// <remarks>
        /// Search the movie text column of movie text using this endpoint.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="terms">Terms</param>
        /// <param name="conditional">Conditional (optional)</param>
        /// <param name="limit">Limit (optional)</param>
        /// <param name="offset">Offset (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAiTextApiResponse"/>&gt;</returns>
        Task<IAiTextApiResponse> AiTextAsync(decimal version, long accountId, string terms, Option<string> conditional = default, Option<int> limit = default, Option<int> offset = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Text
        /// </summary>
        /// <remarks>
        /// Search the movie text column of movie text using this endpoint.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="terms">Terms</param>
        /// <param name="conditional">Conditional (optional)</param>
        /// <param name="limit">Limit (optional)</param>
        /// <param name="offset">Offset (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAiTextApiResponse"/>?&gt;</returns>
        Task<IAiTextApiResponse?> AiTextOrDefaultAsync(decimal version, long accountId, string terms, Option<string> conditional = default, Option<int> limit = default, Option<int> offset = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Batch Analysis
        /// </summary>
        /// <remarks>
        /// Run several types of analysis on an audio or video file in a single API call, instead of calling several operations for the same file..
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="limit">The number of topics to return (optional)</param>
        /// <param name="operations">The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBatchApiResponse"/>&gt;</returns>
        Task<IBatchApiResponse> BatchAsync(decimal version, long accountId, Option<string> thirdPartyAccountId = default, Option<int> limit = default, Option<string> operations = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Batch Analysis
        /// </summary>
        /// <remarks>
        /// Run several types of analysis on an audio or video file in a single API call, instead of calling several operations for the same file..
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="limit">The number of topics to return (optional)</param>
        /// <param name="operations">The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBatchApiResponse"/>?&gt;</returns>
        Task<IBatchApiResponse?> BatchOrDefaultAsync(decimal version, long accountId, Option<string> thirdPartyAccountId = default, Option<int> limit = default, Option<string> operations = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Creates an instant episode
        /// </summary>
        /// <remarks>
        /// Creates an instant episode for a given StoryStrip by providing all necessary inputs, interview recordings, and pictures, kicking off a render immediately.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="data">Request Data String</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInstantEpisodeApiResponse"/>&gt;</returns>
        Task<ICreateInstantEpisodeApiResponse> CreateInstantEpisodeAsync(decimal version, long accountId, string data, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Creates an instant episode
        /// </summary>
        /// <remarks>
        /// Creates an instant episode for a given StoryStrip by providing all necessary inputs, interview recordings, and pictures, kicking off a render immediately.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="data">Request Data String</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInstantEpisodeApiResponse"/>?&gt;</returns>
        Task<ICreateInstantEpisodeApiResponse?> CreateInstantEpisodeOrDefaultAsync(decimal version, long accountId, string data, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create VoiceCanvas images
        /// </summary>
        /// <remarks>
        /// Create VoiceCanvas images for provided text, file upload, or file URL
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="dimensions">Enum: \&quot;256x256\&quot; \&quot;512x512\&quot; \&quot;1024x1024\&quot;</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="text">Provide a transcript or previously extracted topics for image generation (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="parseFlag">When false, uses the raw value from text instead of identifying topics to fetch/generate from (optional)</param>
        /// <param name="fetchFlag">When true, fetches images instead of generating them (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateVoiceCanvasApiResponse"/>&gt;</returns>
        Task<ICreateVoiceCanvasApiResponse> CreateVoiceCanvasAsync(decimal version, long accountId, string dimensions, Option<string> thirdPartyAccountId = default, Option<string> text = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<bool> parseFlag = default, Option<bool> fetchFlag = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create VoiceCanvas images
        /// </summary>
        /// <remarks>
        /// Create VoiceCanvas images for provided text, file upload, or file URL
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="dimensions">Enum: \&quot;256x256\&quot; \&quot;512x512\&quot; \&quot;1024x1024\&quot;</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="text">Provide a transcript or previously extracted topics for image generation (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="parseFlag">When false, uses the raw value from text instead of identifying topics to fetch/generate from (optional)</param>
        /// <param name="fetchFlag">When true, fetches images instead of generating them (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateVoiceCanvasApiResponse"/>?&gt;</returns>
        Task<ICreateVoiceCanvasApiResponse?> CreateVoiceCanvasOrDefaultAsync(decimal version, long accountId, string dimensions, Option<string> thirdPartyAccountId = default, Option<string> text = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<bool> parseFlag = default, Option<bool> fetchFlag = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Detect emotions
        /// </summary>
        /// <remarks>
        /// Detects emotions in an audio or video recording.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEmotionApiResponse"/>&gt;</returns>
        Task<IEmotionApiResponse> EmotionAsync(decimal version, long accountId, Option<string> thirdPartyAccountId = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Detect emotions
        /// </summary>
        /// <remarks>
        /// Detects emotions in an audio or video recording.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEmotionApiResponse"/>?&gt;</returns>
        Task<IEmotionApiResponse?> EmotionOrDefaultAsync(decimal version, long accountId, Option<string> thirdPartyAccountId = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Add Movie Result
        /// </summary>
        /// <remarks>
        /// Get the result of an in progress Add Movie request from an earlier POST.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAddMovieResultApiResponse"/>&gt;</returns>
        Task<IGetAddMovieResultApiResponse> GetAddMovieResultAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Add Movie Result
        /// </summary>
        /// <remarks>
        /// Get the result of an in progress Add Movie request from an earlier POST.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAddMovieResultApiResponse"/>?&gt;</returns>
        Task<IGetAddMovieResultApiResponse?> GetAddMovieResultOrDefaultAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Batch Analysis Results
        /// </summary>
        /// <remarks>
        /// Gets the completed Video Batch results, if done, or an error or status update if not.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBatchApiResponse"/>&gt;</returns>
        Task<IGetBatchApiResponse> GetBatchAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Batch Analysis Results
        /// </summary>
        /// <remarks>
        /// Gets the completed Video Batch results, if done, or an error or status update if not.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBatchApiResponse"/>?&gt;</returns>
        Task<IGetBatchApiResponse?> GetBatchOrDefaultAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Emotion Results
        /// </summary>
        /// <remarks>
        /// Checks the Emotion analysis and returns in progress, results, or error.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmotionApiResponse"/>&gt;</returns>
        Task<IGetEmotionApiResponse> GetEmotionAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Emotion Results
        /// </summary>
        /// <remarks>
        /// Checks the Emotion analysis and returns in progress, results, or error.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmotionApiResponse"/>?&gt;</returns>
        Task<IGetEmotionApiResponse?> GetEmotionOrDefaultAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Check episode status
        /// </summary>
        /// <remarks>
        /// Gets a summary of the episode&#39;s status, including any renders.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="episodeId">Episode ID</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEpisodeStatusApiResponse"/>&gt;</returns>
        Task<IGetEpisodeStatusApiResponse> GetEpisodeStatusAsync(decimal version, long episodeId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Check episode status
        /// </summary>
        /// <remarks>
        /// Gets a summary of the episode&#39;s status, including any renders.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="episodeId">Episode ID</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEpisodeStatusApiResponse"/>?&gt;</returns>
        Task<IGetEpisodeStatusApiResponse?> GetEpisodeStatusOrDefaultAsync(decimal version, long episodeId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Check episode status
        /// </summary>
        /// <remarks>
        /// Gets a summary of the episode&#39;s status, including any renders.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="renderId">Render ID</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRenderStatusApiResponse"/>&gt;</returns>
        Task<IGetRenderStatusApiResponse> GetRenderStatusAsync(decimal version, string renderId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Check episode status
        /// </summary>
        /// <remarks>
        /// Gets a summary of the episode&#39;s status, including any renders.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="renderId">Render ID</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRenderStatusApiResponse"/>?&gt;</returns>
        Task<IGetRenderStatusApiResponse?> GetRenderStatusOrDefaultAsync(decimal version, string renderId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Speach to Text Result
        /// </summary>
        /// <remarks>
        /// The results of the video transcription and optional translation.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSTTApiResponse"/>&gt;</returns>
        Task<IGetSTTApiResponse> GetSTTAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Speach to Text Result
        /// </summary>
        /// <remarks>
        /// The results of the video transcription and optional translation.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSTTApiResponse"/>?&gt;</returns>
        Task<IGetSTTApiResponse?> GetSTTOrDefaultAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Text to Speach Result
        /// </summary>
        /// <remarks>
        /// Check the status of an in progress Text-to-Speech call or download the result.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTTSApiResponse"/>&gt;</returns>
        Task<IGetTTSApiResponse> GetTTSAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Text to Speach Result
        /// </summary>
        /// <remarks>
        /// Check the status of an in progress Text-to-Speech call or download the result.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTTSApiResponse"/>?&gt;</returns>
        Task<IGetTTSApiResponse?> GetTTSOrDefaultAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get TechTune Results
        /// </summary>
        /// <remarks>
        /// Get a result or continue waiting for a pending request for TechTune analysis.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTechTuneApiResponse"/>&gt;</returns>
        Task<IGetTechTuneApiResponse> GetTechTuneAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get TechTune Results
        /// </summary>
        /// <remarks>
        /// Get a result or continue waiting for a pending request for TechTune analysis.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTechTuneApiResponse"/>?&gt;</returns>
        Task<IGetTechTuneApiResponse?> GetTechTuneOrDefaultAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Topics
        /// </summary>
        /// <remarks>
        /// Get the result of an in progress Topics Analysis from an earlier POST.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTopicsApiResponse"/>&gt;</returns>
        Task<IGetTopicsApiResponse> GetTopicsAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Topics
        /// </summary>
        /// <remarks>
        /// Get the result of an in progress Topics Analysis from an earlier POST.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTopicsApiResponse"/>?&gt;</returns>
        Task<IGetTopicsApiResponse?> GetTopicsOrDefaultAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get VoiceCanvas images
        /// </summary>
        /// <remarks>
        /// Get a result or continue waiting for a pending request for VoiceCanvas Images.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetVoiceCanvasApiResponse"/>&gt;</returns>
        Task<IGetVoiceCanvasApiResponse> GetVoiceCanvasAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get VoiceCanvas images
        /// </summary>
        /// <remarks>
        /// Get a result or continue waiting for a pending request for VoiceCanvas Images.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetVoiceCanvasApiResponse"/>?&gt;</returns>
        Task<IGetVoiceCanvasApiResponse?> GetVoiceCanvasOrDefaultAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Starts a StoryStitch video render
        /// </summary>
        /// <remarks>
        /// Starts a StoryStitch video render to produce your final video, returning the status details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="data">Request Data String</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStartVideoRenderApiResponse"/>&gt;</returns>
        Task<IStartVideoRenderApiResponse> StartVideoRenderAsync(decimal version, long accountId, string data, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Starts a StoryStitch video render
        /// </summary>
        /// <remarks>
        /// Starts a StoryStitch video render to produce your final video, returning the status details.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="data">Request Data String</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStartVideoRenderApiResponse"/>?&gt;</returns>
        Task<IStartVideoRenderApiResponse?> StartVideoRenderOrDefaultAsync(decimal version, long accountId, string data, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Speach to Text
        /// </summary>
        /// <remarks>
        /// Accepts a movie URL or uploaded file and transcribes it. You also have the option to translate it into one of our additional supported languages.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="sourceLanguage">Source Language (optional)</param>
        /// <param name="targetLanguage">Target Language (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISttApiResponse"/>&gt;</returns>
        Task<ISttApiResponse> SttAsync(decimal version, long accountId, Option<string> thirdPartyAccountId = default, Option<string> sourceLanguage = default, Option<string> targetLanguage = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Speach to Text
        /// </summary>
        /// <remarks>
        /// Accepts a movie URL or uploaded file and transcribes it. You also have the option to translate it into one of our additional supported languages.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="sourceLanguage">Source Language (optional)</param>
        /// <param name="targetLanguage">Target Language (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISttApiResponse"/>?&gt;</returns>
        Task<ISttApiResponse?> SttOrDefaultAsync(decimal version, long accountId, Option<string> thirdPartyAccountId = default, Option<string> sourceLanguage = default, Option<string> targetLanguage = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Summarize Topics
        /// </summary>
        /// <remarks>
        /// Takes in a string of text sentences (also known as a document) and returns a list of associated topics and their proximity score.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="doc">The text to get topics for. (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="limit">The number of results to return (optional)</param>
        /// <param name="offset">The starting offset into the total result set to start from (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISummarizeTopicsApiResponse"/>&gt;</returns>
        Task<ISummarizeTopicsApiResponse> SummarizeTopicsAsync(decimal version, long accountId, Option<string> thirdPartyAccountId = default, Option<string> doc = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<int> limit = default, Option<int> offset = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Summarize Topics
        /// </summary>
        /// <remarks>
        /// Takes in a string of text sentences (also known as a document) and returns a list of associated topics and their proximity score.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="doc">The text to get topics for. (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="limit">The number of results to return (optional)</param>
        /// <param name="offset">The starting offset into the total result set to start from (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISummarizeTopicsApiResponse"/>?&gt;</returns>
        Task<ISummarizeTopicsApiResponse?> SummarizeTopicsOrDefaultAsync(decimal version, long accountId, Option<string> thirdPartyAccountId = default, Option<string> doc = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<int> limit = default, Option<int> offset = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Detect Technical Issues
        /// </summary>
        /// <remarks>
        /// Analyses a movie file to detect technical issues, such as too few people in frame.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="numFacesExpected">Number of expected faces</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITechTuneApiResponse"/>&gt;</returns>
        Task<ITechTuneApiResponse> TechTuneAsync(decimal version, long accountId, int numFacesExpected, Option<string> thirdPartyAccountId = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Detect Technical Issues
        /// </summary>
        /// <remarks>
        /// Analyses a movie file to detect technical issues, such as too few people in frame.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="numFacesExpected">Number of expected faces</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITechTuneApiResponse"/>?&gt;</returns>
        Task<ITechTuneApiResponse?> TechTuneOrDefaultAsync(decimal version, long accountId, int numFacesExpected, Option<string> thirdPartyAccountId = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Text to Speach
        /// </summary>
        /// <remarks>
        /// Creates an audio file for the given text, with the option of language and voice selection.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="text">Text</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="language">The language to use for the speaker and incoming text (optional)</param>
        /// <param name="voice">A language-specific voice to use, or picks the language default if not provided (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITtsApiResponse"/>&gt;</returns>
        Task<ITtsApiResponse> TtsAsync(decimal version, long accountId, string text, Option<string> thirdPartyAccountId = default, Option<string> language = default, Option<string> voice = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Text to Speach
        /// </summary>
        /// <remarks>
        /// Creates an audio file for the given text, with the option of language and voice selection.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="text">Text</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="language">The language to use for the speaker and incoming text (optional)</param>
        /// <param name="voice">A language-specific voice to use, or picks the language default if not provided (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITtsApiResponse"/>?&gt;</returns>
        Task<ITtsApiResponse?> TtsOrDefaultAsync(decimal version, long accountId, string text, Option<string> thirdPartyAccountId = default, Option<string> language = default, Option<string> voice = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IAddMovieApiResponse"/>
    /// </summary>
    public interface IAddMovieApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiAddMovieResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IAiDocsApiResponse"/>
    /// </summary>
    public interface IAiDocsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiProtoResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IAiFindImagesApiResponse"/>
    /// </summary>
    public interface IAiFindImagesApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiProtoResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IAiTagsApiResponse"/>
    /// </summary>
    public interface IAiTagsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiProtoResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IAiTextApiResponse"/>
    /// </summary>
    public interface IAiTextApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiProtoResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IBatchApiResponse"/>
    /// </summary>
    public interface IBatchApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiBatchResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICreateInstantEpisodeApiResponse"/>
    /// </summary>
    public interface ICreateInstantEpisodeApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonEpisodeResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICreateVoiceCanvasApiResponse"/>
    /// </summary>
    public interface ICreateVoiceCanvasApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiVoiceCanvasResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IEmotionApiResponse"/>
    /// </summary>
    public interface IEmotionApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiEmotionsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetAddMovieResultApiResponse"/>
    /// </summary>
    public interface IGetAddMovieResultApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiAddMovieResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetBatchApiResponse"/>
    /// </summary>
    public interface IGetBatchApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiBatchResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEmotionApiResponse"/>
    /// </summary>
    public interface IGetEmotionApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiEmotionsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetEpisodeStatusApiResponse"/>
    /// </summary>
    public interface IGetEpisodeStatusApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonEpisodeResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetRenderStatusApiResponse"/>
    /// </summary>
    public interface IGetRenderStatusApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonRenderResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetSTTApiResponse"/>
    /// </summary>
    public interface IGetSTTApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiSTTResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetTTSApiResponse"/>
    /// </summary>
    public interface IGetTTSApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiTTSResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetTechTuneApiResponse"/>
    /// </summary>
    public interface IGetTechTuneApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiTechTuneResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetTopicsApiResponse"/>
    /// </summary>
    public interface IGetTopicsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiTopicsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetVoiceCanvasApiResponse"/>
    /// </summary>
    public interface IGetVoiceCanvasApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiVoiceCanvasResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IStartVideoRenderApiResponse"/>
    /// </summary>
    public interface IStartVideoRenderApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonRenderResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISttApiResponse"/>
    /// </summary>
    public interface ISttApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiSTTResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISummarizeTopicsApiResponse"/>
    /// </summary>
    public interface ISummarizeTopicsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiTopicsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ITechTuneApiResponse"/>
    /// </summary>
    public interface ITechTuneApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiTechTuneResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ITtsApiResponse"/>
    /// </summary>
    public interface ITtsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.OrsonAiTTSResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class OrsonApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddMovie;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddMovie;

        internal void ExecuteOnAddMovie(OrsonApi.AddMovieApiResponse apiResponse)
        {
            OnAddMovie?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddMovie(Exception exception)
        {
            OnErrorAddMovie?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAiDocs;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAiDocs;

        internal void ExecuteOnAiDocs(OrsonApi.AiDocsApiResponse apiResponse)
        {
            OnAiDocs?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAiDocs(Exception exception)
        {
            OnErrorAiDocs?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAiFindImages;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAiFindImages;

        internal void ExecuteOnAiFindImages(OrsonApi.AiFindImagesApiResponse apiResponse)
        {
            OnAiFindImages?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAiFindImages(Exception exception)
        {
            OnErrorAiFindImages?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAiTags;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAiTags;

        internal void ExecuteOnAiTags(OrsonApi.AiTagsApiResponse apiResponse)
        {
            OnAiTags?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAiTags(Exception exception)
        {
            OnErrorAiTags?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAiText;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAiText;

        internal void ExecuteOnAiText(OrsonApi.AiTextApiResponse apiResponse)
        {
            OnAiText?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAiText(Exception exception)
        {
            OnErrorAiText?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnBatch;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorBatch;

        internal void ExecuteOnBatch(OrsonApi.BatchApiResponse apiResponse)
        {
            OnBatch?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorBatch(Exception exception)
        {
            OnErrorBatch?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateInstantEpisode;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateInstantEpisode;

        internal void ExecuteOnCreateInstantEpisode(OrsonApi.CreateInstantEpisodeApiResponse apiResponse)
        {
            OnCreateInstantEpisode?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateInstantEpisode(Exception exception)
        {
            OnErrorCreateInstantEpisode?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateVoiceCanvas;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateVoiceCanvas;

        internal void ExecuteOnCreateVoiceCanvas(OrsonApi.CreateVoiceCanvasApiResponse apiResponse)
        {
            OnCreateVoiceCanvas?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateVoiceCanvas(Exception exception)
        {
            OnErrorCreateVoiceCanvas?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnEmotion;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorEmotion;

        internal void ExecuteOnEmotion(OrsonApi.EmotionApiResponse apiResponse)
        {
            OnEmotion?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorEmotion(Exception exception)
        {
            OnErrorEmotion?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetAddMovieResult;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetAddMovieResult;

        internal void ExecuteOnGetAddMovieResult(OrsonApi.GetAddMovieResultApiResponse apiResponse)
        {
            OnGetAddMovieResult?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetAddMovieResult(Exception exception)
        {
            OnErrorGetAddMovieResult?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetBatch;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetBatch;

        internal void ExecuteOnGetBatch(OrsonApi.GetBatchApiResponse apiResponse)
        {
            OnGetBatch?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetBatch(Exception exception)
        {
            OnErrorGetBatch?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetEmotion;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetEmotion;

        internal void ExecuteOnGetEmotion(OrsonApi.GetEmotionApiResponse apiResponse)
        {
            OnGetEmotion?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEmotion(Exception exception)
        {
            OnErrorGetEmotion?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetEpisodeStatus;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetEpisodeStatus;

        internal void ExecuteOnGetEpisodeStatus(OrsonApi.GetEpisodeStatusApiResponse apiResponse)
        {
            OnGetEpisodeStatus?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetEpisodeStatus(Exception exception)
        {
            OnErrorGetEpisodeStatus?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetRenderStatus;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetRenderStatus;

        internal void ExecuteOnGetRenderStatus(OrsonApi.GetRenderStatusApiResponse apiResponse)
        {
            OnGetRenderStatus?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetRenderStatus(Exception exception)
        {
            OnErrorGetRenderStatus?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetSTT;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetSTT;

        internal void ExecuteOnGetSTT(OrsonApi.GetSTTApiResponse apiResponse)
        {
            OnGetSTT?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetSTT(Exception exception)
        {
            OnErrorGetSTT?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetTTS;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetTTS;

        internal void ExecuteOnGetTTS(OrsonApi.GetTTSApiResponse apiResponse)
        {
            OnGetTTS?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetTTS(Exception exception)
        {
            OnErrorGetTTS?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetTechTune;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetTechTune;

        internal void ExecuteOnGetTechTune(OrsonApi.GetTechTuneApiResponse apiResponse)
        {
            OnGetTechTune?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetTechTune(Exception exception)
        {
            OnErrorGetTechTune?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetTopics;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetTopics;

        internal void ExecuteOnGetTopics(OrsonApi.GetTopicsApiResponse apiResponse)
        {
            OnGetTopics?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetTopics(Exception exception)
        {
            OnErrorGetTopics?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetVoiceCanvas;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetVoiceCanvas;

        internal void ExecuteOnGetVoiceCanvas(OrsonApi.GetVoiceCanvasApiResponse apiResponse)
        {
            OnGetVoiceCanvas?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetVoiceCanvas(Exception exception)
        {
            OnErrorGetVoiceCanvas?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnStartVideoRender;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorStartVideoRender;

        internal void ExecuteOnStartVideoRender(OrsonApi.StartVideoRenderApiResponse apiResponse)
        {
            OnStartVideoRender?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorStartVideoRender(Exception exception)
        {
            OnErrorStartVideoRender?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnStt;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorStt;

        internal void ExecuteOnStt(OrsonApi.SttApiResponse apiResponse)
        {
            OnStt?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorStt(Exception exception)
        {
            OnErrorStt?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSummarizeTopics;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSummarizeTopics;

        internal void ExecuteOnSummarizeTopics(OrsonApi.SummarizeTopicsApiResponse apiResponse)
        {
            OnSummarizeTopics?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSummarizeTopics(Exception exception)
        {
            OnErrorSummarizeTopics?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnTechTune;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorTechTune;

        internal void ExecuteOnTechTune(OrsonApi.TechTuneApiResponse apiResponse)
        {
            OnTechTune?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorTechTune(Exception exception)
        {
            OnErrorTechTune?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnTts;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorTts;

        internal void ExecuteOnTts(OrsonApi.TtsApiResponse apiResponse)
        {
            OnTts?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorTts(Exception exception)
        {
            OnErrorTts?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class OrsonApi : IOrsonApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<OrsonApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public OrsonApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="OrsonApi"/> class.
        /// </summary>
        /// <returns></returns>
        public OrsonApi(ILogger<OrsonApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, OrsonApiEvents orsonApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<OrsonApi>();
            HttpClient = httpClient;
            Events = orsonApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatAddMovie(ref decimal version, ref long accountId, ref string movieName, ref Option<string> thirdPartyAccountId, ref Option<string> tags, ref Option<System.IO.Stream> file, ref Option<string> url, ref Option<string> callback);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="movieName"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="tags"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        /// <returns></returns>
        private void ValidateAddMovie(string movieName, Option<string> thirdPartyAccountId, Option<string> tags, Option<System.IO.Stream> file, Option<string> url, Option<string> callback)
        {
            if (movieName == null)
                throw new ArgumentNullException(nameof(movieName));

            if (thirdPartyAccountId.IsSet && thirdPartyAccountId.Value == null)
                throw new ArgumentNullException(nameof(thirdPartyAccountId));

            if (tags.IsSet && tags.Value == null)
                throw new ArgumentNullException(nameof(tags));

            if (file.IsSet && file.Value == null)
                throw new ArgumentNullException(nameof(file));

            if (url.IsSet && url.Value == null)
                throw new ArgumentNullException(nameof(url));

            if (callback.IsSet && callback.Value == null)
                throw new ArgumentNullException(nameof(callback));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="movieName"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="tags"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        private void AfterAddMovieDefaultImplementation(IAddMovieApiResponse apiResponseLocalVar, decimal version, long accountId, string movieName, Option<string> thirdPartyAccountId, Option<string> tags, Option<System.IO.Stream> file, Option<string> url, Option<string> callback)
        {
            bool suppressDefaultLog = false;
            AfterAddMovie(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, movieName, thirdPartyAccountId, tags, file, url, callback);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="movieName"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="tags"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        partial void AfterAddMovie(ref bool suppressDefaultLog, IAddMovieApiResponse apiResponseLocalVar, decimal version, long accountId, string movieName, Option<string> thirdPartyAccountId, Option<string> tags, Option<System.IO.Stream> file, Option<string> url, Option<string> callback);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="movieName"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="tags"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        private void OnErrorAddMovieDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string movieName, Option<string> thirdPartyAccountId, Option<string> tags, Option<System.IO.Stream> file, Option<string> url, Option<string> callback)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAddMovie(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, movieName, thirdPartyAccountId, tags, file, url, callback);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="movieName"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="tags"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        partial void OnErrorAddMovie(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string movieName, Option<string> thirdPartyAccountId, Option<string> tags, Option<System.IO.Stream> file, Option<string> url, Option<string> callback);

        /// <summary>
        /// Add Movie Add a movie to be indexed for Topics. Indexing a movie analyses the content and incorporates it into the topics model for future /topics calls. This does not store the movie file long-term.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="movieName">Movie Name</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="tags">A user defined list (comma-delimited) of tags associated with the movie (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddMovieApiResponse"/>&gt;</returns>
        public async Task<IAddMovieApiResponse?> AddMovieOrDefaultAsync(decimal version, long accountId, string movieName, Option<string> thirdPartyAccountId = default, Option<string> tags = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddMovieAsync(version, accountId, movieName, thirdPartyAccountId, tags, file, url, callback, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Add Movie Add a movie to be indexed for Topics. Indexing a movie analyses the content and incorporates it into the topics model for future /topics calls. This does not store the movie file long-term.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="movieName">Movie Name</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="tags">A user defined list (comma-delimited) of tags associated with the movie (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddMovieApiResponse"/>&gt;</returns>
        public async Task<IAddMovieApiResponse> AddMovieAsync(decimal version, long accountId, string movieName, Option<string> thirdPartyAccountId = default, Option<string> tags = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddMovie(movieName, thirdPartyAccountId, tags, file, url, callback);

                FormatAddMovie(ref version, ref accountId, ref movieName, ref thirdPartyAccountId, ref tags, ref file, ref url, ref callback);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/addMovie"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/addMovie");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["movieName"] = ClientUtils.ParameterToString(movieName);

                    if (thirdPartyAccountId.IsSet)
                        parseQueryStringLocalVar["thirdPartyAccountId"] = ClientUtils.ParameterToString(thirdPartyAccountId.Value);

                    if (tags.IsSet)
                        parseQueryStringLocalVar["tags"] = ClientUtils.ParameterToString(tags.Value);

                    if (file.IsSet)
                        parseQueryStringLocalVar["file"] = ClientUtils.ParameterToString(file.Value);

                    if (url.IsSet)
                        parseQueryStringLocalVar["url"] = ClientUtils.ParameterToString(url.Value);

                    if (callback.IsSet)
                        parseQueryStringLocalVar["callback"] = ClientUtils.ParameterToString(callback.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<AddMovieApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddMovieApiResponse>();
                        AddMovieApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/addMovie", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterAddMovieDefaultImplementation(apiResponseLocalVar, version, accountId, movieName, thirdPartyAccountId, tags, file, url, callback);

                        Events.ExecuteOnAddMovie(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddMovieDefaultImplementation(e, "/api/{version}/orson/ai/addMovie", uriBuilderLocalVar.Path, version, accountId, movieName, thirdPartyAccountId, tags, file, url, callback);
                Events.ExecuteOnErrorAddMovie(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddMovieApiResponse"/>
        /// </summary>
        public partial class AddMovieApiResponse : Org.OpenAPITools.Client.ApiResponse, IAddMovieApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddMovieApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddMovieApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddMovieApiResponse(ILogger<AddMovieApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="AddMovieApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddMovieApiResponse(ILogger<AddMovieApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiAddMovieResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiAddMovieResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiAddMovieResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatAiDocs(ref decimal version, ref long accountId, ref string doc, ref Option<bool> returnTopics, ref Option<int> limit, ref Option<int> offset);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="doc"></param>
        /// <returns></returns>
        private void ValidateAiDocs(string doc)
        {
            if (doc == null)
                throw new ArgumentNullException(nameof(doc));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="doc"></param>
        /// <param name="returnTopics"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        private void AfterAiDocsDefaultImplementation(IAiDocsApiResponse apiResponseLocalVar, decimal version, long accountId, string doc, Option<bool> returnTopics, Option<int> limit, Option<int> offset)
        {
            bool suppressDefaultLog = false;
            AfterAiDocs(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, doc, returnTopics, limit, offset);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="doc"></param>
        /// <param name="returnTopics"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        partial void AfterAiDocs(ref bool suppressDefaultLog, IAiDocsApiResponse apiResponseLocalVar, decimal version, long accountId, string doc, Option<bool> returnTopics, Option<int> limit, Option<int> offset);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="doc"></param>
        /// <param name="returnTopics"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        private void OnErrorAiDocsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string doc, Option<bool> returnTopics, Option<int> limit, Option<int> offset)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAiDocs(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, doc, returnTopics, limit, offset);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="doc"></param>
        /// <param name="returnTopics"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        partial void OnErrorAiDocs(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string doc, Option<bool> returnTopics, Option<int> limit, Option<int> offset);

        /// <summary>
        /// Search Docs Takes in a text string representing one or more sentences and it returns a list of documents which are related to the provided document.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="doc">Doc</param>
        /// <param name="returnTopics">Return Topics (optional)</param>
        /// <param name="limit">Limit (optional)</param>
        /// <param name="offset">Offset (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAiDocsApiResponse"/>&gt;</returns>
        public async Task<IAiDocsApiResponse?> AiDocsOrDefaultAsync(decimal version, long accountId, string doc, Option<bool> returnTopics = default, Option<int> limit = default, Option<int> offset = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AiDocsAsync(version, accountId, doc, returnTopics, limit, offset, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Docs Takes in a text string representing one or more sentences and it returns a list of documents which are related to the provided document.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="doc">Doc</param>
        /// <param name="returnTopics">Return Topics (optional)</param>
        /// <param name="limit">Limit (optional)</param>
        /// <param name="offset">Offset (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAiDocsApiResponse"/>&gt;</returns>
        public async Task<IAiDocsApiResponse> AiDocsAsync(decimal version, long accountId, string doc, Option<bool> returnTopics = default, Option<int> limit = default, Option<int> offset = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAiDocs(doc);

                FormatAiDocs(ref version, ref accountId, ref doc, ref returnTopics, ref limit, ref offset);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/docs"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/docs");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["doc"] = ClientUtils.ParameterToString(doc);

                    if (returnTopics.IsSet)
                        parseQueryStringLocalVar["return_topics"] = ClientUtils.ParameterToString(returnTopics.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (offset.IsSet)
                        parseQueryStringLocalVar["offset"] = ClientUtils.ParameterToString(offset.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<AiDocsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AiDocsApiResponse>();
                        AiDocsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/docs", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterAiDocsDefaultImplementation(apiResponseLocalVar, version, accountId, doc, returnTopics, limit, offset);

                        Events.ExecuteOnAiDocs(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAiDocsDefaultImplementation(e, "/api/{version}/orson/ai/docs", uriBuilderLocalVar.Path, version, accountId, doc, returnTopics, limit, offset);
                Events.ExecuteOnErrorAiDocs(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AiDocsApiResponse"/>
        /// </summary>
        public partial class AiDocsApiResponse : Org.OpenAPITools.Client.ApiResponse, IAiDocsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AiDocsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AiDocsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AiDocsApiResponse(ILogger<AiDocsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="AiDocsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AiDocsApiResponse(ILogger<AiDocsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiProtoResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiProtoResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiProtoResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatAiFindImages(ref decimal version, ref long accountId, ref string text, ref Option<string> parseFlag, ref Option<string> fetchFlag, ref Option<string> size);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="text"></param>
        /// <param name="parseFlag"></param>
        /// <param name="fetchFlag"></param>
        /// <param name="size"></param>
        /// <returns></returns>
        private void ValidateAiFindImages(string text, Option<string> parseFlag, Option<string> fetchFlag, Option<string> size)
        {
            if (text == null)
                throw new ArgumentNullException(nameof(text));

            if (parseFlag.IsSet && parseFlag.Value == null)
                throw new ArgumentNullException(nameof(parseFlag));

            if (fetchFlag.IsSet && fetchFlag.Value == null)
                throw new ArgumentNullException(nameof(fetchFlag));

            if (size.IsSet && size.Value == null)
                throw new ArgumentNullException(nameof(size));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="text"></param>
        /// <param name="parseFlag"></param>
        /// <param name="fetchFlag"></param>
        /// <param name="size"></param>
        private void AfterAiFindImagesDefaultImplementation(IAiFindImagesApiResponse apiResponseLocalVar, decimal version, long accountId, string text, Option<string> parseFlag, Option<string> fetchFlag, Option<string> size)
        {
            bool suppressDefaultLog = false;
            AfterAiFindImages(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, text, parseFlag, fetchFlag, size);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="text"></param>
        /// <param name="parseFlag"></param>
        /// <param name="fetchFlag"></param>
        /// <param name="size"></param>
        partial void AfterAiFindImages(ref bool suppressDefaultLog, IAiFindImagesApiResponse apiResponseLocalVar, decimal version, long accountId, string text, Option<string> parseFlag, Option<string> fetchFlag, Option<string> size);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="text"></param>
        /// <param name="parseFlag"></param>
        /// <param name="fetchFlag"></param>
        /// <param name="size"></param>
        private void OnErrorAiFindImagesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string text, Option<string> parseFlag, Option<string> fetchFlag, Option<string> size)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAiFindImages(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, text, parseFlag, fetchFlag, size);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="text"></param>
        /// <param name="parseFlag"></param>
        /// <param name="fetchFlag"></param>
        /// <param name="size"></param>
        partial void OnErrorAiFindImages(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string text, Option<string> parseFlag, Option<string> fetchFlag, Option<string> size);

        /// <summary>
        /// Find images Returns a list of URIs of images that match the text.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="text">Text</param>
        /// <param name="parseFlag">Parse Flag (optional)</param>
        /// <param name="fetchFlag">Fetch Flag (optional)</param>
        /// <param name="size">Size (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAiFindImagesApiResponse"/>&gt;</returns>
        public async Task<IAiFindImagesApiResponse?> AiFindImagesOrDefaultAsync(decimal version, long accountId, string text, Option<string> parseFlag = default, Option<string> fetchFlag = default, Option<string> size = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AiFindImagesAsync(version, accountId, text, parseFlag, fetchFlag, size, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Find images Returns a list of URIs of images that match the text.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="text">Text</param>
        /// <param name="parseFlag">Parse Flag (optional)</param>
        /// <param name="fetchFlag">Fetch Flag (optional)</param>
        /// <param name="size">Size (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAiFindImagesApiResponse"/>&gt;</returns>
        public async Task<IAiFindImagesApiResponse> AiFindImagesAsync(decimal version, long accountId, string text, Option<string> parseFlag = default, Option<string> fetchFlag = default, Option<string> size = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAiFindImages(text, parseFlag, fetchFlag, size);

                FormatAiFindImages(ref version, ref accountId, ref text, ref parseFlag, ref fetchFlag, ref size);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/img"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/img");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["text"] = ClientUtils.ParameterToString(text);

                    if (parseFlag.IsSet)
                        parseQueryStringLocalVar["parse_flag"] = ClientUtils.ParameterToString(parseFlag.Value);

                    if (fetchFlag.IsSet)
                        parseQueryStringLocalVar["fetch_flag"] = ClientUtils.ParameterToString(fetchFlag.Value);

                    if (size.IsSet)
                        parseQueryStringLocalVar["size"] = ClientUtils.ParameterToString(size.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<AiFindImagesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AiFindImagesApiResponse>();
                        AiFindImagesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/img", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterAiFindImagesDefaultImplementation(apiResponseLocalVar, version, accountId, text, parseFlag, fetchFlag, size);

                        Events.ExecuteOnAiFindImages(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAiFindImagesDefaultImplementation(e, "/api/{version}/orson/ai/img", uriBuilderLocalVar.Path, version, accountId, text, parseFlag, fetchFlag, size);
                Events.ExecuteOnErrorAiFindImages(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AiFindImagesApiResponse"/>
        /// </summary>
        public partial class AiFindImagesApiResponse : Org.OpenAPITools.Client.ApiResponse, IAiFindImagesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AiFindImagesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AiFindImagesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AiFindImagesApiResponse(ILogger<AiFindImagesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="AiFindImagesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AiFindImagesApiResponse(ILogger<AiFindImagesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiProtoResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiProtoResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiProtoResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatAiTags(ref decimal version, ref long accountId, ref string tags, ref Option<string> conditional, ref Option<int> limit, ref Option<int> offset);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="tags"></param>
        /// <param name="conditional"></param>
        /// <returns></returns>
        private void ValidateAiTags(string tags, Option<string> conditional)
        {
            if (tags == null)
                throw new ArgumentNullException(nameof(tags));

            if (conditional.IsSet && conditional.Value == null)
                throw new ArgumentNullException(nameof(conditional));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="tags"></param>
        /// <param name="conditional"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        private void AfterAiTagsDefaultImplementation(IAiTagsApiResponse apiResponseLocalVar, decimal version, long accountId, string tags, Option<string> conditional, Option<int> limit, Option<int> offset)
        {
            bool suppressDefaultLog = false;
            AfterAiTags(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, tags, conditional, limit, offset);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="tags"></param>
        /// <param name="conditional"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        partial void AfterAiTags(ref bool suppressDefaultLog, IAiTagsApiResponse apiResponseLocalVar, decimal version, long accountId, string tags, Option<string> conditional, Option<int> limit, Option<int> offset);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="tags"></param>
        /// <param name="conditional"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        private void OnErrorAiTagsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string tags, Option<string> conditional, Option<int> limit, Option<int> offset)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAiTags(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, tags, conditional, limit, offset);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="tags"></param>
        /// <param name="conditional"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        partial void OnErrorAiTags(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string tags, Option<string> conditional, Option<int> limit, Option<int> offset);

        /// <summary>
        /// Search Tags Search the tags column of user provided tags using this endpoint.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="tags">Tags</param>
        /// <param name="conditional">Conditional (optional)</param>
        /// <param name="limit">Limit (optional)</param>
        /// <param name="offset">Offset (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAiTagsApiResponse"/>&gt;</returns>
        public async Task<IAiTagsApiResponse?> AiTagsOrDefaultAsync(decimal version, long accountId, string tags, Option<string> conditional = default, Option<int> limit = default, Option<int> offset = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AiTagsAsync(version, accountId, tags, conditional, limit, offset, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Tags Search the tags column of user provided tags using this endpoint.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="tags">Tags</param>
        /// <param name="conditional">Conditional (optional)</param>
        /// <param name="limit">Limit (optional)</param>
        /// <param name="offset">Offset (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAiTagsApiResponse"/>&gt;</returns>
        public async Task<IAiTagsApiResponse> AiTagsAsync(decimal version, long accountId, string tags, Option<string> conditional = default, Option<int> limit = default, Option<int> offset = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAiTags(tags, conditional);

                FormatAiTags(ref version, ref accountId, ref tags, ref conditional, ref limit, ref offset);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/tags"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/tags");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["tags"] = ClientUtils.ParameterToString(tags);

                    if (conditional.IsSet)
                        parseQueryStringLocalVar["conditional"] = ClientUtils.ParameterToString(conditional.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (offset.IsSet)
                        parseQueryStringLocalVar["offset"] = ClientUtils.ParameterToString(offset.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<AiTagsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AiTagsApiResponse>();
                        AiTagsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/tags", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterAiTagsDefaultImplementation(apiResponseLocalVar, version, accountId, tags, conditional, limit, offset);

                        Events.ExecuteOnAiTags(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAiTagsDefaultImplementation(e, "/api/{version}/orson/ai/tags", uriBuilderLocalVar.Path, version, accountId, tags, conditional, limit, offset);
                Events.ExecuteOnErrorAiTags(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AiTagsApiResponse"/>
        /// </summary>
        public partial class AiTagsApiResponse : Org.OpenAPITools.Client.ApiResponse, IAiTagsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AiTagsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AiTagsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AiTagsApiResponse(ILogger<AiTagsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="AiTagsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AiTagsApiResponse(ILogger<AiTagsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiProtoResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiProtoResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiProtoResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatAiText(ref decimal version, ref long accountId, ref string terms, ref Option<string> conditional, ref Option<int> limit, ref Option<int> offset);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="terms"></param>
        /// <param name="conditional"></param>
        /// <returns></returns>
        private void ValidateAiText(string terms, Option<string> conditional)
        {
            if (terms == null)
                throw new ArgumentNullException(nameof(terms));

            if (conditional.IsSet && conditional.Value == null)
                throw new ArgumentNullException(nameof(conditional));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="terms"></param>
        /// <param name="conditional"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        private void AfterAiTextDefaultImplementation(IAiTextApiResponse apiResponseLocalVar, decimal version, long accountId, string terms, Option<string> conditional, Option<int> limit, Option<int> offset)
        {
            bool suppressDefaultLog = false;
            AfterAiText(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, terms, conditional, limit, offset);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="terms"></param>
        /// <param name="conditional"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        partial void AfterAiText(ref bool suppressDefaultLog, IAiTextApiResponse apiResponseLocalVar, decimal version, long accountId, string terms, Option<string> conditional, Option<int> limit, Option<int> offset);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="terms"></param>
        /// <param name="conditional"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        private void OnErrorAiTextDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string terms, Option<string> conditional, Option<int> limit, Option<int> offset)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAiText(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, terms, conditional, limit, offset);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="terms"></param>
        /// <param name="conditional"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        partial void OnErrorAiText(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string terms, Option<string> conditional, Option<int> limit, Option<int> offset);

        /// <summary>
        /// Search Text Search the movie text column of movie text using this endpoint.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="terms">Terms</param>
        /// <param name="conditional">Conditional (optional)</param>
        /// <param name="limit">Limit (optional)</param>
        /// <param name="offset">Offset (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAiTextApiResponse"/>&gt;</returns>
        public async Task<IAiTextApiResponse?> AiTextOrDefaultAsync(decimal version, long accountId, string terms, Option<string> conditional = default, Option<int> limit = default, Option<int> offset = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AiTextAsync(version, accountId, terms, conditional, limit, offset, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Text Search the movie text column of movie text using this endpoint.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="terms">Terms</param>
        /// <param name="conditional">Conditional (optional)</param>
        /// <param name="limit">Limit (optional)</param>
        /// <param name="offset">Offset (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAiTextApiResponse"/>&gt;</returns>
        public async Task<IAiTextApiResponse> AiTextAsync(decimal version, long accountId, string terms, Option<string> conditional = default, Option<int> limit = default, Option<int> offset = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAiText(terms, conditional);

                FormatAiText(ref version, ref accountId, ref terms, ref conditional, ref limit, ref offset);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/text"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/text");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["terms"] = ClientUtils.ParameterToString(terms);

                    if (conditional.IsSet)
                        parseQueryStringLocalVar["conditional"] = ClientUtils.ParameterToString(conditional.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (offset.IsSet)
                        parseQueryStringLocalVar["offset"] = ClientUtils.ParameterToString(offset.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<AiTextApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AiTextApiResponse>();
                        AiTextApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/text", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterAiTextDefaultImplementation(apiResponseLocalVar, version, accountId, terms, conditional, limit, offset);

                        Events.ExecuteOnAiText(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAiTextDefaultImplementation(e, "/api/{version}/orson/ai/text", uriBuilderLocalVar.Path, version, accountId, terms, conditional, limit, offset);
                Events.ExecuteOnErrorAiText(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AiTextApiResponse"/>
        /// </summary>
        public partial class AiTextApiResponse : Org.OpenAPITools.Client.ApiResponse, IAiTextApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AiTextApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AiTextApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AiTextApiResponse(ILogger<AiTextApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="AiTextApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AiTextApiResponse(ILogger<AiTextApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiProtoResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiProtoResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiProtoResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatBatch(ref decimal version, ref long accountId, ref Option<string> thirdPartyAccountId, ref Option<int> limit, ref Option<string> operations, ref Option<System.IO.Stream> file, ref Option<string> url, ref Option<string> callback);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="operations"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        /// <returns></returns>
        private void ValidateBatch(Option<string> thirdPartyAccountId, Option<string> operations, Option<System.IO.Stream> file, Option<string> url, Option<string> callback)
        {
            if (thirdPartyAccountId.IsSet && thirdPartyAccountId.Value == null)
                throw new ArgumentNullException(nameof(thirdPartyAccountId));

            if (operations.IsSet && operations.Value == null)
                throw new ArgumentNullException(nameof(operations));

            if (file.IsSet && file.Value == null)
                throw new ArgumentNullException(nameof(file));

            if (url.IsSet && url.Value == null)
                throw new ArgumentNullException(nameof(url));

            if (callback.IsSet && callback.Value == null)
                throw new ArgumentNullException(nameof(callback));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="limit"></param>
        /// <param name="operations"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        private void AfterBatchDefaultImplementation(IBatchApiResponse apiResponseLocalVar, decimal version, long accountId, Option<string> thirdPartyAccountId, Option<int> limit, Option<string> operations, Option<System.IO.Stream> file, Option<string> url, Option<string> callback)
        {
            bool suppressDefaultLog = false;
            AfterBatch(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, thirdPartyAccountId, limit, operations, file, url, callback);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="limit"></param>
        /// <param name="operations"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        partial void AfterBatch(ref bool suppressDefaultLog, IBatchApiResponse apiResponseLocalVar, decimal version, long accountId, Option<string> thirdPartyAccountId, Option<int> limit, Option<string> operations, Option<System.IO.Stream> file, Option<string> url, Option<string> callback);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="limit"></param>
        /// <param name="operations"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        private void OnErrorBatchDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, Option<string> thirdPartyAccountId, Option<int> limit, Option<string> operations, Option<System.IO.Stream> file, Option<string> url, Option<string> callback)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorBatch(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, thirdPartyAccountId, limit, operations, file, url, callback);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="limit"></param>
        /// <param name="operations"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        partial void OnErrorBatch(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, Option<string> thirdPartyAccountId, Option<int> limit, Option<string> operations, Option<System.IO.Stream> file, Option<string> url, Option<string> callback);

        /// <summary>
        /// Batch Analysis Run several types of analysis on an audio or video file in a single API call, instead of calling several operations for the same file..
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="limit">The number of topics to return (optional)</param>
        /// <param name="operations">The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBatchApiResponse"/>&gt;</returns>
        public async Task<IBatchApiResponse?> BatchOrDefaultAsync(decimal version, long accountId, Option<string> thirdPartyAccountId = default, Option<int> limit = default, Option<string> operations = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await BatchAsync(version, accountId, thirdPartyAccountId, limit, operations, file, url, callback, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Batch Analysis Run several types of analysis on an audio or video file in a single API call, instead of calling several operations for the same file..
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="limit">The number of topics to return (optional)</param>
        /// <param name="operations">The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBatchApiResponse"/>&gt;</returns>
        public async Task<IBatchApiResponse> BatchAsync(decimal version, long accountId, Option<string> thirdPartyAccountId = default, Option<int> limit = default, Option<string> operations = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateBatch(thirdPartyAccountId, operations, file, url, callback);

                FormatBatch(ref version, ref accountId, ref thirdPartyAccountId, ref limit, ref operations, ref file, ref url, ref callback);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/batch"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/batch");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    if (thirdPartyAccountId.IsSet)
                        parseQueryStringLocalVar["thirdPartyAccountId"] = ClientUtils.ParameterToString(thirdPartyAccountId.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (operations.IsSet)
                        parseQueryStringLocalVar["operations"] = ClientUtils.ParameterToString(operations.Value);

                    if (file.IsSet)
                        parseQueryStringLocalVar["file"] = ClientUtils.ParameterToString(file.Value);

                    if (url.IsSet)
                        parseQueryStringLocalVar["url"] = ClientUtils.ParameterToString(url.Value);

                    if (callback.IsSet)
                        parseQueryStringLocalVar["callback"] = ClientUtils.ParameterToString(callback.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<BatchApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<BatchApiResponse>();
                        BatchApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/batch", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterBatchDefaultImplementation(apiResponseLocalVar, version, accountId, thirdPartyAccountId, limit, operations, file, url, callback);

                        Events.ExecuteOnBatch(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorBatchDefaultImplementation(e, "/api/{version}/orson/ai/batch", uriBuilderLocalVar.Path, version, accountId, thirdPartyAccountId, limit, operations, file, url, callback);
                Events.ExecuteOnErrorBatch(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="BatchApiResponse"/>
        /// </summary>
        public partial class BatchApiResponse : Org.OpenAPITools.Client.ApiResponse, IBatchApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<BatchApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="BatchApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BatchApiResponse(ILogger<BatchApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="BatchApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BatchApiResponse(ILogger<BatchApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiBatchResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiBatchResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiBatchResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateInstantEpisode(ref decimal version, ref long accountId, ref string data);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        private void ValidateCreateInstantEpisode(string data)
        {
            if (data == null)
                throw new ArgumentNullException(nameof(data));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="data"></param>
        private void AfterCreateInstantEpisodeDefaultImplementation(ICreateInstantEpisodeApiResponse apiResponseLocalVar, decimal version, long accountId, string data)
        {
            bool suppressDefaultLog = false;
            AfterCreateInstantEpisode(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, data);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="data"></param>
        partial void AfterCreateInstantEpisode(ref bool suppressDefaultLog, ICreateInstantEpisodeApiResponse apiResponseLocalVar, decimal version, long accountId, string data);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="data"></param>
        private void OnErrorCreateInstantEpisodeDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string data)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateInstantEpisode(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, data);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="data"></param>
        partial void OnErrorCreateInstantEpisode(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string data);

        /// <summary>
        /// Creates an instant episode Creates an instant episode for a given StoryStrip by providing all necessary inputs, interview recordings, and pictures, kicking off a render immediately.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="data">Request Data String</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInstantEpisodeApiResponse"/>&gt;</returns>
        public async Task<ICreateInstantEpisodeApiResponse?> CreateInstantEpisodeOrDefaultAsync(decimal version, long accountId, string data, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateInstantEpisodeAsync(version, accountId, data, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Creates an instant episode Creates an instant episode for a given StoryStrip by providing all necessary inputs, interview recordings, and pictures, kicking off a render immediately.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="data">Request Data String</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateInstantEpisodeApiResponse"/>&gt;</returns>
        public async Task<ICreateInstantEpisodeApiResponse> CreateInstantEpisodeAsync(decimal version, long accountId, string data, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateInstantEpisode(data);

                FormatCreateInstantEpisode(ref version, ref accountId, ref data);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/stories/episodes/instant"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/stories/episodes/instant");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["data"] = ClientUtils.ParameterToString(data);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateInstantEpisodeApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateInstantEpisodeApiResponse>();
                        CreateInstantEpisodeApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/stories/episodes/instant", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateInstantEpisodeDefaultImplementation(apiResponseLocalVar, version, accountId, data);

                        Events.ExecuteOnCreateInstantEpisode(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateInstantEpisodeDefaultImplementation(e, "/api/{version}/orson/stories/episodes/instant", uriBuilderLocalVar.Path, version, accountId, data);
                Events.ExecuteOnErrorCreateInstantEpisode(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateInstantEpisodeApiResponse"/>
        /// </summary>
        public partial class CreateInstantEpisodeApiResponse : Org.OpenAPITools.Client.ApiResponse, ICreateInstantEpisodeApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateInstantEpisodeApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateInstantEpisodeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateInstantEpisodeApiResponse(ILogger<CreateInstantEpisodeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateInstantEpisodeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateInstantEpisodeApiResponse(ILogger<CreateInstantEpisodeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonEpisodeResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonEpisodeResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonEpisodeResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateVoiceCanvas(ref decimal version, ref long accountId, ref string dimensions, ref Option<string> thirdPartyAccountId, ref Option<string> text, ref Option<System.IO.Stream> file, ref Option<string> url, ref Option<bool> parseFlag, ref Option<bool> fetchFlag, ref Option<string> callback);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="dimensions"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="text"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        /// <returns></returns>
        private void ValidateCreateVoiceCanvas(string dimensions, Option<string> thirdPartyAccountId, Option<string> text, Option<System.IO.Stream> file, Option<string> url, Option<string> callback)
        {
            if (dimensions == null)
                throw new ArgumentNullException(nameof(dimensions));

            if (thirdPartyAccountId.IsSet && thirdPartyAccountId.Value == null)
                throw new ArgumentNullException(nameof(thirdPartyAccountId));

            if (text.IsSet && text.Value == null)
                throw new ArgumentNullException(nameof(text));

            if (file.IsSet && file.Value == null)
                throw new ArgumentNullException(nameof(file));

            if (url.IsSet && url.Value == null)
                throw new ArgumentNullException(nameof(url));

            if (callback.IsSet && callback.Value == null)
                throw new ArgumentNullException(nameof(callback));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="dimensions"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="text"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="parseFlag"></param>
        /// <param name="fetchFlag"></param>
        /// <param name="callback"></param>
        private void AfterCreateVoiceCanvasDefaultImplementation(ICreateVoiceCanvasApiResponse apiResponseLocalVar, decimal version, long accountId, string dimensions, Option<string> thirdPartyAccountId, Option<string> text, Option<System.IO.Stream> file, Option<string> url, Option<bool> parseFlag, Option<bool> fetchFlag, Option<string> callback)
        {
            bool suppressDefaultLog = false;
            AfterCreateVoiceCanvas(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, dimensions, thirdPartyAccountId, text, file, url, parseFlag, fetchFlag, callback);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="dimensions"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="text"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="parseFlag"></param>
        /// <param name="fetchFlag"></param>
        /// <param name="callback"></param>
        partial void AfterCreateVoiceCanvas(ref bool suppressDefaultLog, ICreateVoiceCanvasApiResponse apiResponseLocalVar, decimal version, long accountId, string dimensions, Option<string> thirdPartyAccountId, Option<string> text, Option<System.IO.Stream> file, Option<string> url, Option<bool> parseFlag, Option<bool> fetchFlag, Option<string> callback);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="dimensions"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="text"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="parseFlag"></param>
        /// <param name="fetchFlag"></param>
        /// <param name="callback"></param>
        private void OnErrorCreateVoiceCanvasDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string dimensions, Option<string> thirdPartyAccountId, Option<string> text, Option<System.IO.Stream> file, Option<string> url, Option<bool> parseFlag, Option<bool> fetchFlag, Option<string> callback)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateVoiceCanvas(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, dimensions, thirdPartyAccountId, text, file, url, parseFlag, fetchFlag, callback);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="dimensions"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="text"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="parseFlag"></param>
        /// <param name="fetchFlag"></param>
        /// <param name="callback"></param>
        partial void OnErrorCreateVoiceCanvas(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string dimensions, Option<string> thirdPartyAccountId, Option<string> text, Option<System.IO.Stream> file, Option<string> url, Option<bool> parseFlag, Option<bool> fetchFlag, Option<string> callback);

        /// <summary>
        /// Create VoiceCanvas images Create VoiceCanvas images for provided text, file upload, or file URL
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="dimensions">Enum: \&quot;256x256\&quot; \&quot;512x512\&quot; \&quot;1024x1024\&quot;</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="text">Provide a transcript or previously extracted topics for image generation (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="parseFlag">When false, uses the raw value from text instead of identifying topics to fetch/generate from (optional)</param>
        /// <param name="fetchFlag">When true, fetches images instead of generating them (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateVoiceCanvasApiResponse"/>&gt;</returns>
        public async Task<ICreateVoiceCanvasApiResponse?> CreateVoiceCanvasOrDefaultAsync(decimal version, long accountId, string dimensions, Option<string> thirdPartyAccountId = default, Option<string> text = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<bool> parseFlag = default, Option<bool> fetchFlag = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateVoiceCanvasAsync(version, accountId, dimensions, thirdPartyAccountId, text, file, url, parseFlag, fetchFlag, callback, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create VoiceCanvas images Create VoiceCanvas images for provided text, file upload, or file URL
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="dimensions">Enum: \&quot;256x256\&quot; \&quot;512x512\&quot; \&quot;1024x1024\&quot;</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="text">Provide a transcript or previously extracted topics for image generation (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="parseFlag">When false, uses the raw value from text instead of identifying topics to fetch/generate from (optional)</param>
        /// <param name="fetchFlag">When true, fetches images instead of generating them (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateVoiceCanvasApiResponse"/>&gt;</returns>
        public async Task<ICreateVoiceCanvasApiResponse> CreateVoiceCanvasAsync(decimal version, long accountId, string dimensions, Option<string> thirdPartyAccountId = default, Option<string> text = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<bool> parseFlag = default, Option<bool> fetchFlag = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateVoiceCanvas(dimensions, thirdPartyAccountId, text, file, url, callback);

                FormatCreateVoiceCanvas(ref version, ref accountId, ref dimensions, ref thirdPartyAccountId, ref text, ref file, ref url, ref parseFlag, ref fetchFlag, ref callback);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/voiceCanvas"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/voiceCanvas");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["dimensions"] = ClientUtils.ParameterToString(dimensions);

                    if (thirdPartyAccountId.IsSet)
                        parseQueryStringLocalVar["thirdPartyAccountId"] = ClientUtils.ParameterToString(thirdPartyAccountId.Value);

                    if (text.IsSet)
                        parseQueryStringLocalVar["text"] = ClientUtils.ParameterToString(text.Value);

                    if (file.IsSet)
                        parseQueryStringLocalVar["file"] = ClientUtils.ParameterToString(file.Value);

                    if (url.IsSet)
                        parseQueryStringLocalVar["url"] = ClientUtils.ParameterToString(url.Value);

                    if (parseFlag.IsSet)
                        parseQueryStringLocalVar["parseFlag"] = ClientUtils.ParameterToString(parseFlag.Value);

                    if (fetchFlag.IsSet)
                        parseQueryStringLocalVar["fetchFlag"] = ClientUtils.ParameterToString(fetchFlag.Value);

                    if (callback.IsSet)
                        parseQueryStringLocalVar["callback"] = ClientUtils.ParameterToString(callback.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateVoiceCanvasApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateVoiceCanvasApiResponse>();
                        CreateVoiceCanvasApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/voiceCanvas", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateVoiceCanvasDefaultImplementation(apiResponseLocalVar, version, accountId, dimensions, thirdPartyAccountId, text, file, url, parseFlag, fetchFlag, callback);

                        Events.ExecuteOnCreateVoiceCanvas(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateVoiceCanvasDefaultImplementation(e, "/api/{version}/orson/ai/voiceCanvas", uriBuilderLocalVar.Path, version, accountId, dimensions, thirdPartyAccountId, text, file, url, parseFlag, fetchFlag, callback);
                Events.ExecuteOnErrorCreateVoiceCanvas(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateVoiceCanvasApiResponse"/>
        /// </summary>
        public partial class CreateVoiceCanvasApiResponse : Org.OpenAPITools.Client.ApiResponse, ICreateVoiceCanvasApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateVoiceCanvasApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateVoiceCanvasApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateVoiceCanvasApiResponse(ILogger<CreateVoiceCanvasApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateVoiceCanvasApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateVoiceCanvasApiResponse(ILogger<CreateVoiceCanvasApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiVoiceCanvasResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiVoiceCanvasResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiVoiceCanvasResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatEmotion(ref decimal version, ref long accountId, ref Option<string> thirdPartyAccountId, ref Option<System.IO.Stream> file, ref Option<string> url, ref Option<string> callback);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        /// <returns></returns>
        private void ValidateEmotion(Option<string> thirdPartyAccountId, Option<System.IO.Stream> file, Option<string> url, Option<string> callback)
        {
            if (thirdPartyAccountId.IsSet && thirdPartyAccountId.Value == null)
                throw new ArgumentNullException(nameof(thirdPartyAccountId));

            if (file.IsSet && file.Value == null)
                throw new ArgumentNullException(nameof(file));

            if (url.IsSet && url.Value == null)
                throw new ArgumentNullException(nameof(url));

            if (callback.IsSet && callback.Value == null)
                throw new ArgumentNullException(nameof(callback));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        private void AfterEmotionDefaultImplementation(IEmotionApiResponse apiResponseLocalVar, decimal version, long accountId, Option<string> thirdPartyAccountId, Option<System.IO.Stream> file, Option<string> url, Option<string> callback)
        {
            bool suppressDefaultLog = false;
            AfterEmotion(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, thirdPartyAccountId, file, url, callback);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        partial void AfterEmotion(ref bool suppressDefaultLog, IEmotionApiResponse apiResponseLocalVar, decimal version, long accountId, Option<string> thirdPartyAccountId, Option<System.IO.Stream> file, Option<string> url, Option<string> callback);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        private void OnErrorEmotionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, Option<string> thirdPartyAccountId, Option<System.IO.Stream> file, Option<string> url, Option<string> callback)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorEmotion(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, thirdPartyAccountId, file, url, callback);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        partial void OnErrorEmotion(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, Option<string> thirdPartyAccountId, Option<System.IO.Stream> file, Option<string> url, Option<string> callback);

        /// <summary>
        /// Detect emotions Detects emotions in an audio or video recording.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEmotionApiResponse"/>&gt;</returns>
        public async Task<IEmotionApiResponse?> EmotionOrDefaultAsync(decimal version, long accountId, Option<string> thirdPartyAccountId = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await EmotionAsync(version, accountId, thirdPartyAccountId, file, url, callback, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Detect emotions Detects emotions in an audio or video recording.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEmotionApiResponse"/>&gt;</returns>
        public async Task<IEmotionApiResponse> EmotionAsync(decimal version, long accountId, Option<string> thirdPartyAccountId = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateEmotion(thirdPartyAccountId, file, url, callback);

                FormatEmotion(ref version, ref accountId, ref thirdPartyAccountId, ref file, ref url, ref callback);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/emotion"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/emotion");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    if (thirdPartyAccountId.IsSet)
                        parseQueryStringLocalVar["thirdPartyAccountId"] = ClientUtils.ParameterToString(thirdPartyAccountId.Value);

                    if (file.IsSet)
                        parseQueryStringLocalVar["file"] = ClientUtils.ParameterToString(file.Value);

                    if (url.IsSet)
                        parseQueryStringLocalVar["url"] = ClientUtils.ParameterToString(url.Value);

                    if (callback.IsSet)
                        parseQueryStringLocalVar["callback"] = ClientUtils.ParameterToString(callback.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<EmotionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<EmotionApiResponse>();
                        EmotionApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/emotion", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterEmotionDefaultImplementation(apiResponseLocalVar, version, accountId, thirdPartyAccountId, file, url, callback);

                        Events.ExecuteOnEmotion(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorEmotionDefaultImplementation(e, "/api/{version}/orson/ai/emotion", uriBuilderLocalVar.Path, version, accountId, thirdPartyAccountId, file, url, callback);
                Events.ExecuteOnErrorEmotion(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="EmotionApiResponse"/>
        /// </summary>
        public partial class EmotionApiResponse : Org.OpenAPITools.Client.ApiResponse, IEmotionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<EmotionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="EmotionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EmotionApiResponse(ILogger<EmotionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="EmotionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EmotionApiResponse(ILogger<EmotionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiEmotionsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiEmotionsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiEmotionsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetAddMovieResult(ref decimal version, ref string requestId, ref long accountId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="requestId"></param>
        /// <returns></returns>
        private void ValidateGetAddMovieResult(string requestId)
        {
            if (requestId == null)
                throw new ArgumentNullException(nameof(requestId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        private void AfterGetAddMovieResultDefaultImplementation(IGetAddMovieResultApiResponse apiResponseLocalVar, decimal version, string requestId, long accountId)
        {
            bool suppressDefaultLog = false;
            AfterGetAddMovieResult(ref suppressDefaultLog, apiResponseLocalVar, version, requestId, accountId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        partial void AfterGetAddMovieResult(ref bool suppressDefaultLog, IGetAddMovieResultApiResponse apiResponseLocalVar, decimal version, string requestId, long accountId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        private void OnErrorGetAddMovieResultDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string requestId, long accountId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetAddMovieResult(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, requestId, accountId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        partial void OnErrorGetAddMovieResult(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string requestId, long accountId);

        /// <summary>
        /// Get Add Movie Result Get the result of an in progress Add Movie request from an earlier POST.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAddMovieResultApiResponse"/>&gt;</returns>
        public async Task<IGetAddMovieResultApiResponse?> GetAddMovieResultOrDefaultAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetAddMovieResultAsync(version, requestId, accountId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Add Movie Result Get the result of an in progress Add Movie request from an earlier POST.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAddMovieResultApiResponse"/>&gt;</returns>
        public async Task<IGetAddMovieResultApiResponse> GetAddMovieResultAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetAddMovieResult(requestId);

                FormatGetAddMovieResult(ref version, ref requestId, ref accountId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/addMovie/{requestId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/addMovie/{requestId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BrequestId%7D", Uri.EscapeDataString(requestId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetAddMovieResultApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetAddMovieResultApiResponse>();
                        GetAddMovieResultApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/addMovie/{requestId}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetAddMovieResultDefaultImplementation(apiResponseLocalVar, version, requestId, accountId);

                        Events.ExecuteOnGetAddMovieResult(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetAddMovieResultDefaultImplementation(e, "/api/{version}/orson/ai/addMovie/{requestId}", uriBuilderLocalVar.Path, version, requestId, accountId);
                Events.ExecuteOnErrorGetAddMovieResult(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetAddMovieResultApiResponse"/>
        /// </summary>
        public partial class GetAddMovieResultApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetAddMovieResultApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetAddMovieResultApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetAddMovieResultApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAddMovieResultApiResponse(ILogger<GetAddMovieResultApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetAddMovieResultApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAddMovieResultApiResponse(ILogger<GetAddMovieResultApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiAddMovieResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiAddMovieResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiAddMovieResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetBatch(ref decimal version, ref string requestId, ref long accountId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="requestId"></param>
        /// <returns></returns>
        private void ValidateGetBatch(string requestId)
        {
            if (requestId == null)
                throw new ArgumentNullException(nameof(requestId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        private void AfterGetBatchDefaultImplementation(IGetBatchApiResponse apiResponseLocalVar, decimal version, string requestId, long accountId)
        {
            bool suppressDefaultLog = false;
            AfterGetBatch(ref suppressDefaultLog, apiResponseLocalVar, version, requestId, accountId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        partial void AfterGetBatch(ref bool suppressDefaultLog, IGetBatchApiResponse apiResponseLocalVar, decimal version, string requestId, long accountId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        private void OnErrorGetBatchDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string requestId, long accountId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetBatch(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, requestId, accountId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        partial void OnErrorGetBatch(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string requestId, long accountId);

        /// <summary>
        /// Get Batch Analysis Results Gets the completed Video Batch results, if done, or an error or status update if not.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBatchApiResponse"/>&gt;</returns>
        public async Task<IGetBatchApiResponse?> GetBatchOrDefaultAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetBatchAsync(version, requestId, accountId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Batch Analysis Results Gets the completed Video Batch results, if done, or an error or status update if not.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBatchApiResponse"/>&gt;</returns>
        public async Task<IGetBatchApiResponse> GetBatchAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetBatch(requestId);

                FormatGetBatch(ref version, ref requestId, ref accountId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/batch/{requestId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/batch/{requestId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BrequestId%7D", Uri.EscapeDataString(requestId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetBatchApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetBatchApiResponse>();
                        GetBatchApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/batch/{requestId}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetBatchDefaultImplementation(apiResponseLocalVar, version, requestId, accountId);

                        Events.ExecuteOnGetBatch(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetBatchDefaultImplementation(e, "/api/{version}/orson/ai/batch/{requestId}", uriBuilderLocalVar.Path, version, requestId, accountId);
                Events.ExecuteOnErrorGetBatch(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetBatchApiResponse"/>
        /// </summary>
        public partial class GetBatchApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetBatchApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetBatchApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetBatchApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetBatchApiResponse(ILogger<GetBatchApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetBatchApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetBatchApiResponse(ILogger<GetBatchApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiBatchResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiBatchResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiBatchResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEmotion(ref decimal version, ref string requestId, ref long accountId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="requestId"></param>
        /// <returns></returns>
        private void ValidateGetEmotion(string requestId)
        {
            if (requestId == null)
                throw new ArgumentNullException(nameof(requestId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        private void AfterGetEmotionDefaultImplementation(IGetEmotionApiResponse apiResponseLocalVar, decimal version, string requestId, long accountId)
        {
            bool suppressDefaultLog = false;
            AfterGetEmotion(ref suppressDefaultLog, apiResponseLocalVar, version, requestId, accountId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        partial void AfterGetEmotion(ref bool suppressDefaultLog, IGetEmotionApiResponse apiResponseLocalVar, decimal version, string requestId, long accountId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        private void OnErrorGetEmotionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string requestId, long accountId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEmotion(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, requestId, accountId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        partial void OnErrorGetEmotion(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string requestId, long accountId);

        /// <summary>
        /// Get Emotion Results Checks the Emotion analysis and returns in progress, results, or error.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmotionApiResponse"/>&gt;</returns>
        public async Task<IGetEmotionApiResponse?> GetEmotionOrDefaultAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEmotionAsync(version, requestId, accountId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Emotion Results Checks the Emotion analysis and returns in progress, results, or error.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEmotionApiResponse"/>&gt;</returns>
        public async Task<IGetEmotionApiResponse> GetEmotionAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetEmotion(requestId);

                FormatGetEmotion(ref version, ref requestId, ref accountId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/emotion/{requestId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/emotion/{requestId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BrequestId%7D", Uri.EscapeDataString(requestId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetEmotionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEmotionApiResponse>();
                        GetEmotionApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/emotion/{requestId}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetEmotionDefaultImplementation(apiResponseLocalVar, version, requestId, accountId);

                        Events.ExecuteOnGetEmotion(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEmotionDefaultImplementation(e, "/api/{version}/orson/ai/emotion/{requestId}", uriBuilderLocalVar.Path, version, requestId, accountId);
                Events.ExecuteOnErrorGetEmotion(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEmotionApiResponse"/>
        /// </summary>
        public partial class GetEmotionApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetEmotionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEmotionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEmotionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmotionApiResponse(ILogger<GetEmotionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetEmotionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEmotionApiResponse(ILogger<GetEmotionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiEmotionsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiEmotionsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiEmotionsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetEpisodeStatus(ref decimal version, ref long episodeId, ref long accountId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="episodeId"></param>
        /// <param name="accountId"></param>
        private void AfterGetEpisodeStatusDefaultImplementation(IGetEpisodeStatusApiResponse apiResponseLocalVar, decimal version, long episodeId, long accountId)
        {
            bool suppressDefaultLog = false;
            AfterGetEpisodeStatus(ref suppressDefaultLog, apiResponseLocalVar, version, episodeId, accountId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="episodeId"></param>
        /// <param name="accountId"></param>
        partial void AfterGetEpisodeStatus(ref bool suppressDefaultLog, IGetEpisodeStatusApiResponse apiResponseLocalVar, decimal version, long episodeId, long accountId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="episodeId"></param>
        /// <param name="accountId"></param>
        private void OnErrorGetEpisodeStatusDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long episodeId, long accountId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetEpisodeStatus(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, episodeId, accountId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="episodeId"></param>
        /// <param name="accountId"></param>
        partial void OnErrorGetEpisodeStatus(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long episodeId, long accountId);

        /// <summary>
        /// Check episode status Gets a summary of the episode&#39;s status, including any renders.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="episodeId">Episode ID</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEpisodeStatusApiResponse"/>&gt;</returns>
        public async Task<IGetEpisodeStatusApiResponse?> GetEpisodeStatusOrDefaultAsync(decimal version, long episodeId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetEpisodeStatusAsync(version, episodeId, accountId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Check episode status Gets a summary of the episode&#39;s status, including any renders.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="episodeId">Episode ID</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetEpisodeStatusApiResponse"/>&gt;</returns>
        public async Task<IGetEpisodeStatusApiResponse> GetEpisodeStatusAsync(decimal version, long episodeId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetEpisodeStatus(ref version, ref episodeId, ref accountId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/stories/episodes/{episodeId}/status"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/stories/episodes/{episodeId}/status");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BepisodeId%7D", Uri.EscapeDataString(episodeId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetEpisodeStatusApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetEpisodeStatusApiResponse>();
                        GetEpisodeStatusApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/stories/episodes/{episodeId}/status", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetEpisodeStatusDefaultImplementation(apiResponseLocalVar, version, episodeId, accountId);

                        Events.ExecuteOnGetEpisodeStatus(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetEpisodeStatusDefaultImplementation(e, "/api/{version}/orson/stories/episodes/{episodeId}/status", uriBuilderLocalVar.Path, version, episodeId, accountId);
                Events.ExecuteOnErrorGetEpisodeStatus(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetEpisodeStatusApiResponse"/>
        /// </summary>
        public partial class GetEpisodeStatusApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetEpisodeStatusApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetEpisodeStatusApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetEpisodeStatusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEpisodeStatusApiResponse(ILogger<GetEpisodeStatusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetEpisodeStatusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetEpisodeStatusApiResponse(ILogger<GetEpisodeStatusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonEpisodeResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonEpisodeResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonEpisodeResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetRenderStatus(ref decimal version, ref string renderId, ref long accountId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="renderId"></param>
        /// <returns></returns>
        private void ValidateGetRenderStatus(string renderId)
        {
            if (renderId == null)
                throw new ArgumentNullException(nameof(renderId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="renderId"></param>
        /// <param name="accountId"></param>
        private void AfterGetRenderStatusDefaultImplementation(IGetRenderStatusApiResponse apiResponseLocalVar, decimal version, string renderId, long accountId)
        {
            bool suppressDefaultLog = false;
            AfterGetRenderStatus(ref suppressDefaultLog, apiResponseLocalVar, version, renderId, accountId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="renderId"></param>
        /// <param name="accountId"></param>
        partial void AfterGetRenderStatus(ref bool suppressDefaultLog, IGetRenderStatusApiResponse apiResponseLocalVar, decimal version, string renderId, long accountId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="renderId"></param>
        /// <param name="accountId"></param>
        private void OnErrorGetRenderStatusDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string renderId, long accountId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetRenderStatus(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, renderId, accountId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="renderId"></param>
        /// <param name="accountId"></param>
        partial void OnErrorGetRenderStatus(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string renderId, long accountId);

        /// <summary>
        /// Check episode status Gets a summary of the episode&#39;s status, including any renders.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="renderId">Render ID</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRenderStatusApiResponse"/>&gt;</returns>
        public async Task<IGetRenderStatusApiResponse?> GetRenderStatusOrDefaultAsync(decimal version, string renderId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetRenderStatusAsync(version, renderId, accountId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Check episode status Gets a summary of the episode&#39;s status, including any renders.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="renderId">Render ID</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRenderStatusApiResponse"/>&gt;</returns>
        public async Task<IGetRenderStatusApiResponse> GetRenderStatusAsync(decimal version, string renderId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetRenderStatus(renderId);

                FormatGetRenderStatus(ref version, ref renderId, ref accountId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/stories/renders/{renderId}/status"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/stories/renders/{renderId}/status");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BrenderId%7D", Uri.EscapeDataString(renderId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetRenderStatusApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetRenderStatusApiResponse>();
                        GetRenderStatusApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/stories/renders/{renderId}/status", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetRenderStatusDefaultImplementation(apiResponseLocalVar, version, renderId, accountId);

                        Events.ExecuteOnGetRenderStatus(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetRenderStatusDefaultImplementation(e, "/api/{version}/orson/stories/renders/{renderId}/status", uriBuilderLocalVar.Path, version, renderId, accountId);
                Events.ExecuteOnErrorGetRenderStatus(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetRenderStatusApiResponse"/>
        /// </summary>
        public partial class GetRenderStatusApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetRenderStatusApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetRenderStatusApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetRenderStatusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetRenderStatusApiResponse(ILogger<GetRenderStatusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetRenderStatusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetRenderStatusApiResponse(ILogger<GetRenderStatusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonRenderResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonRenderResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonRenderResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetSTT(ref decimal version, ref string requestId, ref long accountId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="requestId"></param>
        /// <returns></returns>
        private void ValidateGetSTT(string requestId)
        {
            if (requestId == null)
                throw new ArgumentNullException(nameof(requestId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        private void AfterGetSTTDefaultImplementation(IGetSTTApiResponse apiResponseLocalVar, decimal version, string requestId, long accountId)
        {
            bool suppressDefaultLog = false;
            AfterGetSTT(ref suppressDefaultLog, apiResponseLocalVar, version, requestId, accountId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        partial void AfterGetSTT(ref bool suppressDefaultLog, IGetSTTApiResponse apiResponseLocalVar, decimal version, string requestId, long accountId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        private void OnErrorGetSTTDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string requestId, long accountId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetSTT(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, requestId, accountId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        partial void OnErrorGetSTT(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string requestId, long accountId);

        /// <summary>
        /// Get Speach to Text Result The results of the video transcription and optional translation.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSTTApiResponse"/>&gt;</returns>
        public async Task<IGetSTTApiResponse?> GetSTTOrDefaultAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetSTTAsync(version, requestId, accountId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Speach to Text Result The results of the video transcription and optional translation.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSTTApiResponse"/>&gt;</returns>
        public async Task<IGetSTTApiResponse> GetSTTAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetSTT(requestId);

                FormatGetSTT(ref version, ref requestId, ref accountId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/stt/{requestId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/stt/{requestId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BrequestId%7D", Uri.EscapeDataString(requestId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetSTTApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetSTTApiResponse>();
                        GetSTTApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/stt/{requestId}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetSTTDefaultImplementation(apiResponseLocalVar, version, requestId, accountId);

                        Events.ExecuteOnGetSTT(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetSTTDefaultImplementation(e, "/api/{version}/orson/ai/stt/{requestId}", uriBuilderLocalVar.Path, version, requestId, accountId);
                Events.ExecuteOnErrorGetSTT(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetSTTApiResponse"/>
        /// </summary>
        public partial class GetSTTApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetSTTApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetSTTApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetSTTApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSTTApiResponse(ILogger<GetSTTApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetSTTApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSTTApiResponse(ILogger<GetSTTApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiSTTResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiSTTResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiSTTResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetTTS(ref decimal version, ref string requestId, ref long accountId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="requestId"></param>
        /// <returns></returns>
        private void ValidateGetTTS(string requestId)
        {
            if (requestId == null)
                throw new ArgumentNullException(nameof(requestId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        private void AfterGetTTSDefaultImplementation(IGetTTSApiResponse apiResponseLocalVar, decimal version, string requestId, long accountId)
        {
            bool suppressDefaultLog = false;
            AfterGetTTS(ref suppressDefaultLog, apiResponseLocalVar, version, requestId, accountId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        partial void AfterGetTTS(ref bool suppressDefaultLog, IGetTTSApiResponse apiResponseLocalVar, decimal version, string requestId, long accountId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        private void OnErrorGetTTSDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string requestId, long accountId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetTTS(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, requestId, accountId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        partial void OnErrorGetTTS(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string requestId, long accountId);

        /// <summary>
        /// Get Text to Speach Result Check the status of an in progress Text-to-Speech call or download the result.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTTSApiResponse"/>&gt;</returns>
        public async Task<IGetTTSApiResponse?> GetTTSOrDefaultAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetTTSAsync(version, requestId, accountId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Text to Speach Result Check the status of an in progress Text-to-Speech call or download the result.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTTSApiResponse"/>&gt;</returns>
        public async Task<IGetTTSApiResponse> GetTTSAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetTTS(requestId);

                FormatGetTTS(ref version, ref requestId, ref accountId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/tts/{requestId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/tts/{requestId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BrequestId%7D", Uri.EscapeDataString(requestId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetTTSApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetTTSApiResponse>();
                        GetTTSApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/tts/{requestId}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetTTSDefaultImplementation(apiResponseLocalVar, version, requestId, accountId);

                        Events.ExecuteOnGetTTS(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetTTSDefaultImplementation(e, "/api/{version}/orson/ai/tts/{requestId}", uriBuilderLocalVar.Path, version, requestId, accountId);
                Events.ExecuteOnErrorGetTTS(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetTTSApiResponse"/>
        /// </summary>
        public partial class GetTTSApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetTTSApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetTTSApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetTTSApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTTSApiResponse(ILogger<GetTTSApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetTTSApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTTSApiResponse(ILogger<GetTTSApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiTTSResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiTTSResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiTTSResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetTechTune(ref decimal version, ref string requestId, ref long accountId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="requestId"></param>
        /// <returns></returns>
        private void ValidateGetTechTune(string requestId)
        {
            if (requestId == null)
                throw new ArgumentNullException(nameof(requestId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        private void AfterGetTechTuneDefaultImplementation(IGetTechTuneApiResponse apiResponseLocalVar, decimal version, string requestId, long accountId)
        {
            bool suppressDefaultLog = false;
            AfterGetTechTune(ref suppressDefaultLog, apiResponseLocalVar, version, requestId, accountId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        partial void AfterGetTechTune(ref bool suppressDefaultLog, IGetTechTuneApiResponse apiResponseLocalVar, decimal version, string requestId, long accountId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        private void OnErrorGetTechTuneDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string requestId, long accountId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetTechTune(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, requestId, accountId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        partial void OnErrorGetTechTune(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string requestId, long accountId);

        /// <summary>
        /// Get TechTune Results Get a result or continue waiting for a pending request for TechTune analysis.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTechTuneApiResponse"/>&gt;</returns>
        public async Task<IGetTechTuneApiResponse?> GetTechTuneOrDefaultAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetTechTuneAsync(version, requestId, accountId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get TechTune Results Get a result or continue waiting for a pending request for TechTune analysis.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTechTuneApiResponse"/>&gt;</returns>
        public async Task<IGetTechTuneApiResponse> GetTechTuneAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetTechTune(requestId);

                FormatGetTechTune(ref version, ref requestId, ref accountId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/techTune/{requestId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/techTune/{requestId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BrequestId%7D", Uri.EscapeDataString(requestId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetTechTuneApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetTechTuneApiResponse>();
                        GetTechTuneApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/techTune/{requestId}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetTechTuneDefaultImplementation(apiResponseLocalVar, version, requestId, accountId);

                        Events.ExecuteOnGetTechTune(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetTechTuneDefaultImplementation(e, "/api/{version}/orson/ai/techTune/{requestId}", uriBuilderLocalVar.Path, version, requestId, accountId);
                Events.ExecuteOnErrorGetTechTune(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetTechTuneApiResponse"/>
        /// </summary>
        public partial class GetTechTuneApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetTechTuneApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetTechTuneApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetTechTuneApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTechTuneApiResponse(ILogger<GetTechTuneApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetTechTuneApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTechTuneApiResponse(ILogger<GetTechTuneApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiTechTuneResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiTechTuneResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiTechTuneResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetTopics(ref decimal version, ref string requestId, ref long accountId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="requestId"></param>
        /// <returns></returns>
        private void ValidateGetTopics(string requestId)
        {
            if (requestId == null)
                throw new ArgumentNullException(nameof(requestId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        private void AfterGetTopicsDefaultImplementation(IGetTopicsApiResponse apiResponseLocalVar, decimal version, string requestId, long accountId)
        {
            bool suppressDefaultLog = false;
            AfterGetTopics(ref suppressDefaultLog, apiResponseLocalVar, version, requestId, accountId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        partial void AfterGetTopics(ref bool suppressDefaultLog, IGetTopicsApiResponse apiResponseLocalVar, decimal version, string requestId, long accountId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        private void OnErrorGetTopicsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string requestId, long accountId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetTopics(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, requestId, accountId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        partial void OnErrorGetTopics(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string requestId, long accountId);

        /// <summary>
        /// Get Topics Get the result of an in progress Topics Analysis from an earlier POST.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTopicsApiResponse"/>&gt;</returns>
        public async Task<IGetTopicsApiResponse?> GetTopicsOrDefaultAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetTopicsAsync(version, requestId, accountId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Topics Get the result of an in progress Topics Analysis from an earlier POST.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTopicsApiResponse"/>&gt;</returns>
        public async Task<IGetTopicsApiResponse> GetTopicsAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetTopics(requestId);

                FormatGetTopics(ref version, ref requestId, ref accountId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/topics/{requestId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/topics/{requestId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BrequestId%7D", Uri.EscapeDataString(requestId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetTopicsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetTopicsApiResponse>();
                        GetTopicsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/topics/{requestId}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetTopicsDefaultImplementation(apiResponseLocalVar, version, requestId, accountId);

                        Events.ExecuteOnGetTopics(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetTopicsDefaultImplementation(e, "/api/{version}/orson/ai/topics/{requestId}", uriBuilderLocalVar.Path, version, requestId, accountId);
                Events.ExecuteOnErrorGetTopics(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetTopicsApiResponse"/>
        /// </summary>
        public partial class GetTopicsApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetTopicsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetTopicsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetTopicsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTopicsApiResponse(ILogger<GetTopicsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetTopicsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTopicsApiResponse(ILogger<GetTopicsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiTopicsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiTopicsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiTopicsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetVoiceCanvas(ref decimal version, ref string requestId, ref long accountId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="requestId"></param>
        /// <returns></returns>
        private void ValidateGetVoiceCanvas(string requestId)
        {
            if (requestId == null)
                throw new ArgumentNullException(nameof(requestId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        private void AfterGetVoiceCanvasDefaultImplementation(IGetVoiceCanvasApiResponse apiResponseLocalVar, decimal version, string requestId, long accountId)
        {
            bool suppressDefaultLog = false;
            AfterGetVoiceCanvas(ref suppressDefaultLog, apiResponseLocalVar, version, requestId, accountId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        partial void AfterGetVoiceCanvas(ref bool suppressDefaultLog, IGetVoiceCanvasApiResponse apiResponseLocalVar, decimal version, string requestId, long accountId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        private void OnErrorGetVoiceCanvasDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string requestId, long accountId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetVoiceCanvas(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, requestId, accountId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="requestId"></param>
        /// <param name="accountId"></param>
        partial void OnErrorGetVoiceCanvas(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, string requestId, long accountId);

        /// <summary>
        /// Get VoiceCanvas images Get a result or continue waiting for a pending request for VoiceCanvas Images.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetVoiceCanvasApiResponse"/>&gt;</returns>
        public async Task<IGetVoiceCanvasApiResponse?> GetVoiceCanvasOrDefaultAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetVoiceCanvasAsync(version, requestId, accountId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get VoiceCanvas images Get a result or continue waiting for a pending request for VoiceCanvas Images.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="requestId">Orson Request Id</param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetVoiceCanvasApiResponse"/>&gt;</returns>
        public async Task<IGetVoiceCanvasApiResponse> GetVoiceCanvasAsync(decimal version, string requestId, long accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetVoiceCanvas(requestId);

                FormatGetVoiceCanvas(ref version, ref requestId, ref accountId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/voiceCanvas/{requestId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/voiceCanvas/{requestId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BrequestId%7D", Uri.EscapeDataString(requestId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetVoiceCanvasApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetVoiceCanvasApiResponse>();
                        GetVoiceCanvasApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/voiceCanvas/{requestId}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetVoiceCanvasDefaultImplementation(apiResponseLocalVar, version, requestId, accountId);

                        Events.ExecuteOnGetVoiceCanvas(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetVoiceCanvasDefaultImplementation(e, "/api/{version}/orson/ai/voiceCanvas/{requestId}", uriBuilderLocalVar.Path, version, requestId, accountId);
                Events.ExecuteOnErrorGetVoiceCanvas(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetVoiceCanvasApiResponse"/>
        /// </summary>
        public partial class GetVoiceCanvasApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetVoiceCanvasApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetVoiceCanvasApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetVoiceCanvasApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetVoiceCanvasApiResponse(ILogger<GetVoiceCanvasApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetVoiceCanvasApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetVoiceCanvasApiResponse(ILogger<GetVoiceCanvasApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiVoiceCanvasResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiVoiceCanvasResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiVoiceCanvasResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatStartVideoRender(ref decimal version, ref long accountId, ref string data);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        private void ValidateStartVideoRender(string data)
        {
            if (data == null)
                throw new ArgumentNullException(nameof(data));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="data"></param>
        private void AfterStartVideoRenderDefaultImplementation(IStartVideoRenderApiResponse apiResponseLocalVar, decimal version, long accountId, string data)
        {
            bool suppressDefaultLog = false;
            AfterStartVideoRender(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, data);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="data"></param>
        partial void AfterStartVideoRender(ref bool suppressDefaultLog, IStartVideoRenderApiResponse apiResponseLocalVar, decimal version, long accountId, string data);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="data"></param>
        private void OnErrorStartVideoRenderDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string data)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorStartVideoRender(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, data);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="data"></param>
        partial void OnErrorStartVideoRender(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string data);

        /// <summary>
        /// Starts a StoryStitch video render Starts a StoryStitch video render to produce your final video, returning the status details.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="data">Request Data String</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStartVideoRenderApiResponse"/>&gt;</returns>
        public async Task<IStartVideoRenderApiResponse?> StartVideoRenderOrDefaultAsync(decimal version, long accountId, string data, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await StartVideoRenderAsync(version, accountId, data, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Starts a StoryStitch video render Starts a StoryStitch video render to produce your final video, returning the status details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="data">Request Data String</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStartVideoRenderApiResponse"/>&gt;</returns>
        public async Task<IStartVideoRenderApiResponse> StartVideoRenderAsync(decimal version, long accountId, string data, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateStartVideoRender(data);

                FormatStartVideoRender(ref version, ref accountId, ref data);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/stories/renders"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/stories/renders");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["data"] = ClientUtils.ParameterToString(data);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<StartVideoRenderApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<StartVideoRenderApiResponse>();
                        StartVideoRenderApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/stories/renders", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterStartVideoRenderDefaultImplementation(apiResponseLocalVar, version, accountId, data);

                        Events.ExecuteOnStartVideoRender(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorStartVideoRenderDefaultImplementation(e, "/api/{version}/orson/stories/renders", uriBuilderLocalVar.Path, version, accountId, data);
                Events.ExecuteOnErrorStartVideoRender(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="StartVideoRenderApiResponse"/>
        /// </summary>
        public partial class StartVideoRenderApiResponse : Org.OpenAPITools.Client.ApiResponse, IStartVideoRenderApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<StartVideoRenderApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="StartVideoRenderApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public StartVideoRenderApiResponse(ILogger<StartVideoRenderApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="StartVideoRenderApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public StartVideoRenderApiResponse(ILogger<StartVideoRenderApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonRenderResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonRenderResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonRenderResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatStt(ref decimal version, ref long accountId, ref Option<string> thirdPartyAccountId, ref Option<string> sourceLanguage, ref Option<string> targetLanguage, ref Option<System.IO.Stream> file, ref Option<string> url, ref Option<string> callback);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="sourceLanguage"></param>
        /// <param name="targetLanguage"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        /// <returns></returns>
        private void ValidateStt(Option<string> thirdPartyAccountId, Option<string> sourceLanguage, Option<string> targetLanguage, Option<System.IO.Stream> file, Option<string> url, Option<string> callback)
        {
            if (thirdPartyAccountId.IsSet && thirdPartyAccountId.Value == null)
                throw new ArgumentNullException(nameof(thirdPartyAccountId));

            if (sourceLanguage.IsSet && sourceLanguage.Value == null)
                throw new ArgumentNullException(nameof(sourceLanguage));

            if (targetLanguage.IsSet && targetLanguage.Value == null)
                throw new ArgumentNullException(nameof(targetLanguage));

            if (file.IsSet && file.Value == null)
                throw new ArgumentNullException(nameof(file));

            if (url.IsSet && url.Value == null)
                throw new ArgumentNullException(nameof(url));

            if (callback.IsSet && callback.Value == null)
                throw new ArgumentNullException(nameof(callback));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="sourceLanguage"></param>
        /// <param name="targetLanguage"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        private void AfterSttDefaultImplementation(ISttApiResponse apiResponseLocalVar, decimal version, long accountId, Option<string> thirdPartyAccountId, Option<string> sourceLanguage, Option<string> targetLanguage, Option<System.IO.Stream> file, Option<string> url, Option<string> callback)
        {
            bool suppressDefaultLog = false;
            AfterStt(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, thirdPartyAccountId, sourceLanguage, targetLanguage, file, url, callback);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="sourceLanguage"></param>
        /// <param name="targetLanguage"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        partial void AfterStt(ref bool suppressDefaultLog, ISttApiResponse apiResponseLocalVar, decimal version, long accountId, Option<string> thirdPartyAccountId, Option<string> sourceLanguage, Option<string> targetLanguage, Option<System.IO.Stream> file, Option<string> url, Option<string> callback);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="sourceLanguage"></param>
        /// <param name="targetLanguage"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        private void OnErrorSttDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, Option<string> thirdPartyAccountId, Option<string> sourceLanguage, Option<string> targetLanguage, Option<System.IO.Stream> file, Option<string> url, Option<string> callback)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorStt(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, thirdPartyAccountId, sourceLanguage, targetLanguage, file, url, callback);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="sourceLanguage"></param>
        /// <param name="targetLanguage"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        partial void OnErrorStt(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, Option<string> thirdPartyAccountId, Option<string> sourceLanguage, Option<string> targetLanguage, Option<System.IO.Stream> file, Option<string> url, Option<string> callback);

        /// <summary>
        /// Speach to Text Accepts a movie URL or uploaded file and transcribes it. You also have the option to translate it into one of our additional supported languages.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="sourceLanguage">Source Language (optional)</param>
        /// <param name="targetLanguage">Target Language (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISttApiResponse"/>&gt;</returns>
        public async Task<ISttApiResponse?> SttOrDefaultAsync(decimal version, long accountId, Option<string> thirdPartyAccountId = default, Option<string> sourceLanguage = default, Option<string> targetLanguage = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SttAsync(version, accountId, thirdPartyAccountId, sourceLanguage, targetLanguage, file, url, callback, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Speach to Text Accepts a movie URL or uploaded file and transcribes it. You also have the option to translate it into one of our additional supported languages.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="sourceLanguage">Source Language (optional)</param>
        /// <param name="targetLanguage">Target Language (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISttApiResponse"/>&gt;</returns>
        public async Task<ISttApiResponse> SttAsync(decimal version, long accountId, Option<string> thirdPartyAccountId = default, Option<string> sourceLanguage = default, Option<string> targetLanguage = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateStt(thirdPartyAccountId, sourceLanguage, targetLanguage, file, url, callback);

                FormatStt(ref version, ref accountId, ref thirdPartyAccountId, ref sourceLanguage, ref targetLanguage, ref file, ref url, ref callback);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/stt"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/stt");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    if (thirdPartyAccountId.IsSet)
                        parseQueryStringLocalVar["thirdPartyAccountId"] = ClientUtils.ParameterToString(thirdPartyAccountId.Value);

                    if (sourceLanguage.IsSet)
                        parseQueryStringLocalVar["sourceLanguage"] = ClientUtils.ParameterToString(sourceLanguage.Value);

                    if (targetLanguage.IsSet)
                        parseQueryStringLocalVar["targetLanguage"] = ClientUtils.ParameterToString(targetLanguage.Value);

                    if (file.IsSet)
                        parseQueryStringLocalVar["file"] = ClientUtils.ParameterToString(file.Value);

                    if (url.IsSet)
                        parseQueryStringLocalVar["url"] = ClientUtils.ParameterToString(url.Value);

                    if (callback.IsSet)
                        parseQueryStringLocalVar["callback"] = ClientUtils.ParameterToString(callback.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SttApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SttApiResponse>();
                        SttApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/stt", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSttDefaultImplementation(apiResponseLocalVar, version, accountId, thirdPartyAccountId, sourceLanguage, targetLanguage, file, url, callback);

                        Events.ExecuteOnStt(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSttDefaultImplementation(e, "/api/{version}/orson/ai/stt", uriBuilderLocalVar.Path, version, accountId, thirdPartyAccountId, sourceLanguage, targetLanguage, file, url, callback);
                Events.ExecuteOnErrorStt(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SttApiResponse"/>
        /// </summary>
        public partial class SttApiResponse : Org.OpenAPITools.Client.ApiResponse, ISttApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SttApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SttApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SttApiResponse(ILogger<SttApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SttApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SttApiResponse(ILogger<SttApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiSTTResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiSTTResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiSTTResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSummarizeTopics(ref decimal version, ref long accountId, ref Option<string> thirdPartyAccountId, ref Option<string> doc, ref Option<System.IO.Stream> file, ref Option<string> url, ref Option<int> limit, ref Option<int> offset, ref Option<string> callback);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="doc"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        /// <returns></returns>
        private void ValidateSummarizeTopics(Option<string> thirdPartyAccountId, Option<string> doc, Option<System.IO.Stream> file, Option<string> url, Option<string> callback)
        {
            if (thirdPartyAccountId.IsSet && thirdPartyAccountId.Value == null)
                throw new ArgumentNullException(nameof(thirdPartyAccountId));

            if (doc.IsSet && doc.Value == null)
                throw new ArgumentNullException(nameof(doc));

            if (file.IsSet && file.Value == null)
                throw new ArgumentNullException(nameof(file));

            if (url.IsSet && url.Value == null)
                throw new ArgumentNullException(nameof(url));

            if (callback.IsSet && callback.Value == null)
                throw new ArgumentNullException(nameof(callback));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="doc"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="callback"></param>
        private void AfterSummarizeTopicsDefaultImplementation(ISummarizeTopicsApiResponse apiResponseLocalVar, decimal version, long accountId, Option<string> thirdPartyAccountId, Option<string> doc, Option<System.IO.Stream> file, Option<string> url, Option<int> limit, Option<int> offset, Option<string> callback)
        {
            bool suppressDefaultLog = false;
            AfterSummarizeTopics(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, thirdPartyAccountId, doc, file, url, limit, offset, callback);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="doc"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="callback"></param>
        partial void AfterSummarizeTopics(ref bool suppressDefaultLog, ISummarizeTopicsApiResponse apiResponseLocalVar, decimal version, long accountId, Option<string> thirdPartyAccountId, Option<string> doc, Option<System.IO.Stream> file, Option<string> url, Option<int> limit, Option<int> offset, Option<string> callback);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="doc"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="callback"></param>
        private void OnErrorSummarizeTopicsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, Option<string> thirdPartyAccountId, Option<string> doc, Option<System.IO.Stream> file, Option<string> url, Option<int> limit, Option<int> offset, Option<string> callback)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSummarizeTopics(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, thirdPartyAccountId, doc, file, url, limit, offset, callback);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="doc"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="callback"></param>
        partial void OnErrorSummarizeTopics(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, Option<string> thirdPartyAccountId, Option<string> doc, Option<System.IO.Stream> file, Option<string> url, Option<int> limit, Option<int> offset, Option<string> callback);

        /// <summary>
        /// Summarize Topics Takes in a string of text sentences (also known as a document) and returns a list of associated topics and their proximity score.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="doc">The text to get topics for. (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="limit">The number of results to return (optional)</param>
        /// <param name="offset">The starting offset into the total result set to start from (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISummarizeTopicsApiResponse"/>&gt;</returns>
        public async Task<ISummarizeTopicsApiResponse?> SummarizeTopicsOrDefaultAsync(decimal version, long accountId, Option<string> thirdPartyAccountId = default, Option<string> doc = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<int> limit = default, Option<int> offset = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SummarizeTopicsAsync(version, accountId, thirdPartyAccountId, doc, file, url, limit, offset, callback, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Summarize Topics Takes in a string of text sentences (also known as a document) and returns a list of associated topics and their proximity score.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="doc">The text to get topics for. (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="limit">The number of results to return (optional)</param>
        /// <param name="offset">The starting offset into the total result set to start from (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISummarizeTopicsApiResponse"/>&gt;</returns>
        public async Task<ISummarizeTopicsApiResponse> SummarizeTopicsAsync(decimal version, long accountId, Option<string> thirdPartyAccountId = default, Option<string> doc = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<int> limit = default, Option<int> offset = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSummarizeTopics(thirdPartyAccountId, doc, file, url, callback);

                FormatSummarizeTopics(ref version, ref accountId, ref thirdPartyAccountId, ref doc, ref file, ref url, ref limit, ref offset, ref callback);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/topics"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/topics");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    if (thirdPartyAccountId.IsSet)
                        parseQueryStringLocalVar["thirdPartyAccountId"] = ClientUtils.ParameterToString(thirdPartyAccountId.Value);

                    if (doc.IsSet)
                        parseQueryStringLocalVar["doc"] = ClientUtils.ParameterToString(doc.Value);

                    if (file.IsSet)
                        parseQueryStringLocalVar["file"] = ClientUtils.ParameterToString(file.Value);

                    if (url.IsSet)
                        parseQueryStringLocalVar["url"] = ClientUtils.ParameterToString(url.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (offset.IsSet)
                        parseQueryStringLocalVar["offset"] = ClientUtils.ParameterToString(offset.Value);

                    if (callback.IsSet)
                        parseQueryStringLocalVar["callback"] = ClientUtils.ParameterToString(callback.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SummarizeTopicsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SummarizeTopicsApiResponse>();
                        SummarizeTopicsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/topics", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSummarizeTopicsDefaultImplementation(apiResponseLocalVar, version, accountId, thirdPartyAccountId, doc, file, url, limit, offset, callback);

                        Events.ExecuteOnSummarizeTopics(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSummarizeTopicsDefaultImplementation(e, "/api/{version}/orson/ai/topics", uriBuilderLocalVar.Path, version, accountId, thirdPartyAccountId, doc, file, url, limit, offset, callback);
                Events.ExecuteOnErrorSummarizeTopics(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SummarizeTopicsApiResponse"/>
        /// </summary>
        public partial class SummarizeTopicsApiResponse : Org.OpenAPITools.Client.ApiResponse, ISummarizeTopicsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SummarizeTopicsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SummarizeTopicsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SummarizeTopicsApiResponse(ILogger<SummarizeTopicsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SummarizeTopicsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SummarizeTopicsApiResponse(ILogger<SummarizeTopicsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiTopicsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiTopicsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiTopicsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatTechTune(ref decimal version, ref long accountId, ref int numFacesExpected, ref Option<string> thirdPartyAccountId, ref Option<System.IO.Stream> file, ref Option<string> url, ref Option<string> callback);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        /// <returns></returns>
        private void ValidateTechTune(Option<string> thirdPartyAccountId, Option<System.IO.Stream> file, Option<string> url, Option<string> callback)
        {
            if (thirdPartyAccountId.IsSet && thirdPartyAccountId.Value == null)
                throw new ArgumentNullException(nameof(thirdPartyAccountId));

            if (file.IsSet && file.Value == null)
                throw new ArgumentNullException(nameof(file));

            if (url.IsSet && url.Value == null)
                throw new ArgumentNullException(nameof(url));

            if (callback.IsSet && callback.Value == null)
                throw new ArgumentNullException(nameof(callback));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="numFacesExpected"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        private void AfterTechTuneDefaultImplementation(ITechTuneApiResponse apiResponseLocalVar, decimal version, long accountId, int numFacesExpected, Option<string> thirdPartyAccountId, Option<System.IO.Stream> file, Option<string> url, Option<string> callback)
        {
            bool suppressDefaultLog = false;
            AfterTechTune(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, numFacesExpected, thirdPartyAccountId, file, url, callback);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="numFacesExpected"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        partial void AfterTechTune(ref bool suppressDefaultLog, ITechTuneApiResponse apiResponseLocalVar, decimal version, long accountId, int numFacesExpected, Option<string> thirdPartyAccountId, Option<System.IO.Stream> file, Option<string> url, Option<string> callback);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="numFacesExpected"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        private void OnErrorTechTuneDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, int numFacesExpected, Option<string> thirdPartyAccountId, Option<System.IO.Stream> file, Option<string> url, Option<string> callback)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorTechTune(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, numFacesExpected, thirdPartyAccountId, file, url, callback);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="numFacesExpected"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="file"></param>
        /// <param name="url"></param>
        /// <param name="callback"></param>
        partial void OnErrorTechTune(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, int numFacesExpected, Option<string> thirdPartyAccountId, Option<System.IO.Stream> file, Option<string> url, Option<string> callback);

        /// <summary>
        /// Detect Technical Issues Analyses a movie file to detect technical issues, such as too few people in frame.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="numFacesExpected">Number of expected faces</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITechTuneApiResponse"/>&gt;</returns>
        public async Task<ITechTuneApiResponse?> TechTuneOrDefaultAsync(decimal version, long accountId, int numFacesExpected, Option<string> thirdPartyAccountId = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await TechTuneAsync(version, accountId, numFacesExpected, thirdPartyAccountId, file, url, callback, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Detect Technical Issues Analyses a movie file to detect technical issues, such as too few people in frame.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="numFacesExpected">Number of expected faces</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="file">An uploaded recording to analyze (Currently limited to 10MB) (optional)</param>
        /// <param name="url">A recording file to download and analyze (Size limit: 1GB) (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITechTuneApiResponse"/>&gt;</returns>
        public async Task<ITechTuneApiResponse> TechTuneAsync(decimal version, long accountId, int numFacesExpected, Option<string> thirdPartyAccountId = default, Option<System.IO.Stream> file = default, Option<string> url = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateTechTune(thirdPartyAccountId, file, url, callback);

                FormatTechTune(ref version, ref accountId, ref numFacesExpected, ref thirdPartyAccountId, ref file, ref url, ref callback);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/techTune"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/techTune");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["numFacesExpected"] = ClientUtils.ParameterToString(numFacesExpected);

                    if (thirdPartyAccountId.IsSet)
                        parseQueryStringLocalVar["thirdPartyAccountId"] = ClientUtils.ParameterToString(thirdPartyAccountId.Value);

                    if (file.IsSet)
                        parseQueryStringLocalVar["file"] = ClientUtils.ParameterToString(file.Value);

                    if (url.IsSet)
                        parseQueryStringLocalVar["url"] = ClientUtils.ParameterToString(url.Value);

                    if (callback.IsSet)
                        parseQueryStringLocalVar["callback"] = ClientUtils.ParameterToString(callback.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<TechTuneApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<TechTuneApiResponse>();
                        TechTuneApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/techTune", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterTechTuneDefaultImplementation(apiResponseLocalVar, version, accountId, numFacesExpected, thirdPartyAccountId, file, url, callback);

                        Events.ExecuteOnTechTune(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorTechTuneDefaultImplementation(e, "/api/{version}/orson/ai/techTune", uriBuilderLocalVar.Path, version, accountId, numFacesExpected, thirdPartyAccountId, file, url, callback);
                Events.ExecuteOnErrorTechTune(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="TechTuneApiResponse"/>
        /// </summary>
        public partial class TechTuneApiResponse : Org.OpenAPITools.Client.ApiResponse, ITechTuneApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<TechTuneApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="TechTuneApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public TechTuneApiResponse(ILogger<TechTuneApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="TechTuneApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public TechTuneApiResponse(ILogger<TechTuneApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiTechTuneResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiTechTuneResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiTechTuneResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatTts(ref decimal version, ref long accountId, ref string text, ref Option<string> thirdPartyAccountId, ref Option<string> language, ref Option<string> voice, ref Option<string> callback);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="text"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="language"></param>
        /// <param name="voice"></param>
        /// <param name="callback"></param>
        /// <returns></returns>
        private void ValidateTts(string text, Option<string> thirdPartyAccountId, Option<string> language, Option<string> voice, Option<string> callback)
        {
            if (text == null)
                throw new ArgumentNullException(nameof(text));

            if (thirdPartyAccountId.IsSet && thirdPartyAccountId.Value == null)
                throw new ArgumentNullException(nameof(thirdPartyAccountId));

            if (language.IsSet && language.Value == null)
                throw new ArgumentNullException(nameof(language));

            if (voice.IsSet && voice.Value == null)
                throw new ArgumentNullException(nameof(voice));

            if (callback.IsSet && callback.Value == null)
                throw new ArgumentNullException(nameof(callback));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="text"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="language"></param>
        /// <param name="voice"></param>
        /// <param name="callback"></param>
        private void AfterTtsDefaultImplementation(ITtsApiResponse apiResponseLocalVar, decimal version, long accountId, string text, Option<string> thirdPartyAccountId, Option<string> language, Option<string> voice, Option<string> callback)
        {
            bool suppressDefaultLog = false;
            AfterTts(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, text, thirdPartyAccountId, language, voice, callback);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="text"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="language"></param>
        /// <param name="voice"></param>
        /// <param name="callback"></param>
        partial void AfterTts(ref bool suppressDefaultLog, ITtsApiResponse apiResponseLocalVar, decimal version, long accountId, string text, Option<string> thirdPartyAccountId, Option<string> language, Option<string> voice, Option<string> callback);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="text"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="language"></param>
        /// <param name="voice"></param>
        /// <param name="callback"></param>
        private void OnErrorTtsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string text, Option<string> thirdPartyAccountId, Option<string> language, Option<string> voice, Option<string> callback)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorTts(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, text, thirdPartyAccountId, language, voice, callback);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="text"></param>
        /// <param name="thirdPartyAccountId"></param>
        /// <param name="language"></param>
        /// <param name="voice"></param>
        /// <param name="callback"></param>
        partial void OnErrorTts(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string text, Option<string> thirdPartyAccountId, Option<string> language, Option<string> voice, Option<string> callback);

        /// <summary>
        /// Text to Speach Creates an audio file for the given text, with the option of language and voice selection.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="text">Text</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="language">The language to use for the speaker and incoming text (optional)</param>
        /// <param name="voice">A language-specific voice to use, or picks the language default if not provided (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITtsApiResponse"/>&gt;</returns>
        public async Task<ITtsApiResponse?> TtsOrDefaultAsync(decimal version, long accountId, string text, Option<string> thirdPartyAccountId = default, Option<string> language = default, Option<string> voice = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await TtsAsync(version, accountId, text, thirdPartyAccountId, language, voice, callback, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Text to Speach Creates an audio file for the given text, with the option of language and voice selection.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">Sirqul Account Id</param>
        /// <param name="text">Text</param>
        /// <param name="thirdPartyAccountId">A third-party account id that is meaningful to your systems (optional)</param>
        /// <param name="language">The language to use for the speaker and incoming text (optional)</param>
        /// <param name="voice">A language-specific voice to use, or picks the language default if not provided (optional)</param>
        /// <param name="callback">When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ITtsApiResponse"/>&gt;</returns>
        public async Task<ITtsApiResponse> TtsAsync(decimal version, long accountId, string text, Option<string> thirdPartyAccountId = default, Option<string> language = default, Option<string> voice = default, Option<string> callback = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateTts(text, thirdPartyAccountId, language, voice, callback);

                FormatTts(ref version, ref accountId, ref text, ref thirdPartyAccountId, ref language, ref voice, ref callback);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/orson/ai/tts"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/orson/ai/tts");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["text"] = ClientUtils.ParameterToString(text);

                    if (thirdPartyAccountId.IsSet)
                        parseQueryStringLocalVar["thirdPartyAccountId"] = ClientUtils.ParameterToString(thirdPartyAccountId.Value);

                    if (language.IsSet)
                        parseQueryStringLocalVar["language"] = ClientUtils.ParameterToString(language.Value);

                    if (voice.IsSet)
                        parseQueryStringLocalVar["voice"] = ClientUtils.ParameterToString(voice.Value);

                    if (callback.IsSet)
                        parseQueryStringLocalVar["callback"] = ClientUtils.ParameterToString(callback.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<TtsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<TtsApiResponse>();
                        TtsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/orson/ai/tts", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterTtsDefaultImplementation(apiResponseLocalVar, version, accountId, text, thirdPartyAccountId, language, voice, callback);

                        Events.ExecuteOnTts(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorTtsDefaultImplementation(e, "/api/{version}/orson/ai/tts", uriBuilderLocalVar.Path, version, accountId, text, thirdPartyAccountId, language, voice, callback);
                Events.ExecuteOnErrorTts(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="TtsApiResponse"/>
        /// </summary>
        public partial class TtsApiResponse : Org.OpenAPITools.Client.ApiResponse, ITtsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<TtsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="TtsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public TtsApiResponse(ILogger<TtsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="TtsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public TtsApiResponse(ILogger<TtsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.OrsonAiTTSResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.OrsonAiTTSResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.OrsonAiTTSResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
