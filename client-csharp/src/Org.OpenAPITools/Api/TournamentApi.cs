// <auto-generated>
/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Net;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface ITournamentApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        TournamentApiEvents Events { get; }

        /// <summary>
        /// Create Tournament
        /// </summary>
        /// <remarks>
        /// Create a tournament.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="appKey">The appKey the tournament is created for.</param>
        /// <param name="title">The title of the tournament</param>
        /// <param name="costToPlay">The number of tickets required to pay to enter the tournament</param>
        /// <param name="startDate">The date/time to start the tournament</param>
        /// <param name="subType">Custom string client apps can use for searching/filtering tournaments (optional)</param>
        /// <param name="imageAssetId">The asset ID to attach to the tournament (optional)</param>
        /// <param name="secondsBetweenLevels">The number of seconds in between the start of each tournament game/group (optional, default to 600)</param>
        /// <param name="secondsForTieBreaker">The number of seconds to extend the round end time in the case of a tie breaker (optional, default to 600)</param>
        /// <param name="secondsBetweenPacks">The number of seconds in between the start of each tournament round (optional, default to 86400)</param>
        /// <param name="maximumLevelLength">The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional, default to 1800)</param>
        /// <param name="costToPlayType">The type of ticket required to pay (optional)</param>
        /// <param name="minimumToPlay">The minimum number of players required to sign up for the tournament to be played (optional, default to 1)</param>
        /// <param name="startingLimit">The starting number of players for a tournament (filled with AI&#39;s) (optional)</param>
        /// <param name="availableLimit">The maximum number of players for a tournament (currently 128 but not enforced) (optional)</param>
        /// <param name="description">The description of the tournament (optional)</param>
        /// <param name="metaData">External custom client defined data (optional)</param>
        /// <param name="audienceIds">The audiences associated with the tournament (optional)</param>
        /// <param name="active">Activate/deactivate the tournament (optional)</param>
        /// <param name="enableBuyBack">Determines whether to allow players to buy back into a tournament (optional, default to false)</param>
        /// <param name="offerIds">The list of offers to give as a reward beyond the tickets (optional)</param>
        /// <param name="offerAssetId">The artwork ID to attach to the reward tickets offers (optional)</param>
        /// <param name="fixedReward">If set then do not update the ticket reward, auto set to true if offerIds provided (optional, default to false)</param>
        /// <param name="splitReward">Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional, default to ALL)</param>
        /// <param name="allocateTickets">Flag to indicate owner should receive tickets for completed missions (optional)</param>
        /// <param name="tournamentData">A text based string that will be passed into each tournament setup to populate the content (optional)</param>
        /// <param name="missionType">The style of tournament to build, options are: TOURNAMENT, POOLPLAY (optional, default to MULTISTAGE)</param>
        /// <param name="visibility">Sets the visibility flag for the tournament (optional, default to PUBLIC)</param>
        /// <param name="preliminaryGroups">The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional, default to 1)</param>
        /// <param name="preliminaryGroupAdvancements">This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional, default to &quot;1&quot;)</param>
        /// <param name="enableMultipleEntries">This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional, default to false)</param>
        /// <param name="enableMultipleVotes">This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional, default to false)</param>
        /// <param name="featured">This determines whether the tournament is \&quot;featured\&quot; or not (optional, default to false)</param>
        /// <param name="winnerTag">This sets what analytic tag is used when a winner is determined (optional)</param>
        /// <param name="tieTag">This sets what analytic tag is used when a tie has occurred (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTournamentApiResponse"/>&gt;</returns>
        Task<ICreateTournamentApiResponse> CreateTournamentAsync(long accountId, string appKey, string title, int costToPlay, long startDate, Option<string> subType = default, Option<long> imageAssetId = default, Option<int> secondsBetweenLevels = default, Option<int> secondsForTieBreaker = default, Option<int> secondsBetweenPacks = default, Option<int> maximumLevelLength = default, Option<string> costToPlayType = default, Option<int> minimumToPlay = default, Option<int> startingLimit = default, Option<int> availableLimit = default, Option<string> description = default, Option<string> metaData = default, Option<string> audienceIds = default, Option<bool> active = default, Option<bool> enableBuyBack = default, Option<string> offerIds = default, Option<long> offerAssetId = default, Option<bool> fixedReward = default, Option<string> splitReward = default, Option<bool> allocateTickets = default, Option<string> tournamentData = default, Option<string> missionType = default, Option<string> visibility = default, Option<int> preliminaryGroups = default, Option<string> preliminaryGroupAdvancements = default, Option<bool> enableMultipleEntries = default, Option<bool> enableMultipleVotes = default, Option<bool> featured = default, Option<string> winnerTag = default, Option<string> tieTag = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Tournament
        /// </summary>
        /// <remarks>
        /// Create a tournament.
        /// </remarks>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="appKey">The appKey the tournament is created for.</param>
        /// <param name="title">The title of the tournament</param>
        /// <param name="costToPlay">The number of tickets required to pay to enter the tournament</param>
        /// <param name="startDate">The date/time to start the tournament</param>
        /// <param name="subType">Custom string client apps can use for searching/filtering tournaments (optional)</param>
        /// <param name="imageAssetId">The asset ID to attach to the tournament (optional)</param>
        /// <param name="secondsBetweenLevels">The number of seconds in between the start of each tournament game/group (optional, default to 600)</param>
        /// <param name="secondsForTieBreaker">The number of seconds to extend the round end time in the case of a tie breaker (optional, default to 600)</param>
        /// <param name="secondsBetweenPacks">The number of seconds in between the start of each tournament round (optional, default to 86400)</param>
        /// <param name="maximumLevelLength">The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional, default to 1800)</param>
        /// <param name="costToPlayType">The type of ticket required to pay (optional)</param>
        /// <param name="minimumToPlay">The minimum number of players required to sign up for the tournament to be played (optional, default to 1)</param>
        /// <param name="startingLimit">The starting number of players for a tournament (filled with AI&#39;s) (optional)</param>
        /// <param name="availableLimit">The maximum number of players for a tournament (currently 128 but not enforced) (optional)</param>
        /// <param name="description">The description of the tournament (optional)</param>
        /// <param name="metaData">External custom client defined data (optional)</param>
        /// <param name="audienceIds">The audiences associated with the tournament (optional)</param>
        /// <param name="active">Activate/deactivate the tournament (optional)</param>
        /// <param name="enableBuyBack">Determines whether to allow players to buy back into a tournament (optional, default to false)</param>
        /// <param name="offerIds">The list of offers to give as a reward beyond the tickets (optional)</param>
        /// <param name="offerAssetId">The artwork ID to attach to the reward tickets offers (optional)</param>
        /// <param name="fixedReward">If set then do not update the ticket reward, auto set to true if offerIds provided (optional, default to false)</param>
        /// <param name="splitReward">Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional, default to ALL)</param>
        /// <param name="allocateTickets">Flag to indicate owner should receive tickets for completed missions (optional)</param>
        /// <param name="tournamentData">A text based string that will be passed into each tournament setup to populate the content (optional)</param>
        /// <param name="missionType">The style of tournament to build, options are: TOURNAMENT, POOLPLAY (optional, default to MULTISTAGE)</param>
        /// <param name="visibility">Sets the visibility flag for the tournament (optional, default to PUBLIC)</param>
        /// <param name="preliminaryGroups">The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional, default to 1)</param>
        /// <param name="preliminaryGroupAdvancements">This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional, default to &quot;1&quot;)</param>
        /// <param name="enableMultipleEntries">This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional, default to false)</param>
        /// <param name="enableMultipleVotes">This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional, default to false)</param>
        /// <param name="featured">This determines whether the tournament is \&quot;featured\&quot; or not (optional, default to false)</param>
        /// <param name="winnerTag">This sets what analytic tag is used when a winner is determined (optional)</param>
        /// <param name="tieTag">This sets what analytic tag is used when a tie has occurred (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTournamentApiResponse"/>?&gt;</returns>
        Task<ICreateTournamentApiResponse?> CreateTournamentOrDefaultAsync(long accountId, string appKey, string title, int costToPlay, long startDate, Option<string> subType = default, Option<long> imageAssetId = default, Option<int> secondsBetweenLevels = default, Option<int> secondsForTieBreaker = default, Option<int> secondsBetweenPacks = default, Option<int> maximumLevelLength = default, Option<string> costToPlayType = default, Option<int> minimumToPlay = default, Option<int> startingLimit = default, Option<int> availableLimit = default, Option<string> description = default, Option<string> metaData = default, Option<string> audienceIds = default, Option<bool> active = default, Option<bool> enableBuyBack = default, Option<string> offerIds = default, Option<long> offerAssetId = default, Option<bool> fixedReward = default, Option<string> splitReward = default, Option<bool> allocateTickets = default, Option<string> tournamentData = default, Option<string> missionType = default, Option<string> visibility = default, Option<int> preliminaryGroups = default, Option<string> preliminaryGroupAdvancements = default, Option<bool> enableMultipleEntries = default, Option<bool> enableMultipleVotes = default, Option<bool> featured = default, Option<string> winnerTag = default, Option<string> tieTag = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Tournament
        /// </summary>
        /// <remarks>
        /// Delete a tournament.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the id of the logged in user</param>
        /// <param name="missionId">the id of the mission to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTournamentApiResponse"/>&gt;</returns>
        Task<IDeleteTournamentApiResponse> DeleteTournamentAsync(long accountId, long missionId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Tournament
        /// </summary>
        /// <remarks>
        /// Delete a tournament.
        /// </remarks>
        /// <param name="accountId">the id of the logged in user</param>
        /// <param name="missionId">the id of the mission to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTournamentApiResponse"/>?&gt;</returns>
        Task<IDeleteTournamentApiResponse?> DeleteTournamentOrDefaultAsync(long accountId, long missionId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Tournament
        /// </summary>
        /// <remarks>
        /// Get a tournament.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The id of the logged in user</param>
        /// <param name="missionId">The id of the mission to return (either missionId or joinCode is required) (optional)</param>
        /// <param name="joinCode">Optional identifier for getting the tournament (either missionId or joinCode is required) (optional)</param>
        /// <param name="includeScores">Determines which type of scores are returned. Possible values include: ALL, MINE (optional)</param>
        /// <param name="objectPreviewSize">Determines the max number of game objects that will get returned for each game level response (optional, default to 50)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTournamentApiResponse"/>&gt;</returns>
        Task<IGetTournamentApiResponse> GetTournamentAsync(long accountId, Option<long> missionId = default, Option<string> joinCode = default, Option<string> includeScores = default, Option<int> objectPreviewSize = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Tournament
        /// </summary>
        /// <remarks>
        /// Get a tournament.
        /// </remarks>
        /// <param name="accountId">The id of the logged in user</param>
        /// <param name="missionId">The id of the mission to return (either missionId or joinCode is required) (optional)</param>
        /// <param name="joinCode">Optional identifier for getting the tournament (either missionId or joinCode is required) (optional)</param>
        /// <param name="includeScores">Determines which type of scores are returned. Possible values include: ALL, MINE (optional)</param>
        /// <param name="objectPreviewSize">Determines the max number of game objects that will get returned for each game level response (optional, default to 50)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTournamentApiResponse"/>?&gt;</returns>
        Task<IGetTournamentApiResponse?> GetTournamentOrDefaultAsync(long accountId, Option<long> missionId = default, Option<string> joinCode = default, Option<string> includeScores = default, Option<int> objectPreviewSize = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Tournament Objects
        /// </summary>
        /// <remarks>
        /// Search on game objects of tournaments
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the account ID</param>
        /// <param name="gameLevelId">the game level id to filter results by</param>
        /// <param name="sortField">the field to sort by (optional, default to PLAYER_SCORE_COUNT)</param>
        /// <param name="descending">determines whether the sorted list is in descending or ascending order (optional, default to true)</param>
        /// <param name="start">the start index for pagination (optional, default to 0)</param>
        /// <param name="limit">the limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchObjectsApiResponse"/>&gt;</returns>
        Task<ISearchObjectsApiResponse> SearchObjectsAsync(long accountId, long gameLevelId, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Tournament Objects
        /// </summary>
        /// <remarks>
        /// Search on game objects of tournaments
        /// </remarks>
        /// <param name="accountId">the account ID</param>
        /// <param name="gameLevelId">the game level id to filter results by</param>
        /// <param name="sortField">the field to sort by (optional, default to PLAYER_SCORE_COUNT)</param>
        /// <param name="descending">determines whether the sorted list is in descending or ascending order (optional, default to true)</param>
        /// <param name="start">the start index for pagination (optional, default to 0)</param>
        /// <param name="limit">the limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchObjectsApiResponse"/>?&gt;</returns>
        Task<ISearchObjectsApiResponse?> SearchObjectsOrDefaultAsync(long accountId, long gameLevelId, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Tournament Rounds
        /// </summary>
        /// <remarks>
        /// Search for the user&#39;s tournament games.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the account ID</param>
        /// <param name="appKey">the application key</param>
        /// <param name="status">comma separated list of statuses to filter results by (optional, default to &quot;ACCEPTED,ACTIVE&quot;)</param>
        /// <param name="missionType">The style of tournament to search for, options are: TOURNAMENT, POOLPLAY (optional)</param>
        /// <param name="currentOnly">search for games that are flagged current only (optional, default to true)</param>
        /// <param name="visibilities">Filter tournament rounds by the mission visibility flag (optional, default to &quot;PUBLIC&quot;)</param>
        /// <param name="start">the start index for pagination (optional, default to 0)</param>
        /// <param name="limit">the limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchRoundsApiResponse"/>&gt;</returns>
        Task<ISearchRoundsApiResponse> SearchRoundsAsync(long accountId, string appKey, Option<string> status = default, Option<string> missionType = default, Option<bool> currentOnly = default, Option<string> visibilities = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Tournament Rounds
        /// </summary>
        /// <remarks>
        /// Search for the user&#39;s tournament games.
        /// </remarks>
        /// <param name="accountId">the account ID</param>
        /// <param name="appKey">the application key</param>
        /// <param name="status">comma separated list of statuses to filter results by (optional, default to &quot;ACCEPTED,ACTIVE&quot;)</param>
        /// <param name="missionType">The style of tournament to search for, options are: TOURNAMENT, POOLPLAY (optional)</param>
        /// <param name="currentOnly">search for games that are flagged current only (optional, default to true)</param>
        /// <param name="visibilities">Filter tournament rounds by the mission visibility flag (optional, default to &quot;PUBLIC&quot;)</param>
        /// <param name="start">the start index for pagination (optional, default to 0)</param>
        /// <param name="limit">the limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchRoundsApiResponse"/>?&gt;</returns>
        Task<ISearchRoundsApiResponse?> SearchRoundsOrDefaultAsync(long accountId, string appKey, Option<string> status = default, Option<string> missionType = default, Option<bool> currentOnly = default, Option<string> visibilities = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Tournaments
        /// </summary>
        /// <remarks>
        /// Search for tournaments
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="appKey">The application key</param>
        /// <param name="keyword">the keyword to search tournament on (optional)</param>
        /// <param name="subType">filter results by subType (optional)</param>
        /// <param name="includeInactive">whether to include inactives in the search or not (optional, default to false)</param>
        /// <param name="missionTypes">comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (optional, default to &quot;MULTISTAGE,TOURNAMENT,POOLPLAY&quot;)</param>
        /// <param name="filter">filter tournaments by the tournament&#39;s current state (optional, default to UPCOMING)</param>
        /// <param name="sortField">which field to sort on (optional, default to START_DATE)</param>
        /// <param name="descending">Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false. (optional)</param>
        /// <param name="visibility">Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (optional, default to &quot;PUBLIC&quot;)</param>
        /// <param name="start">Start the result set at some index. (optional, default to 0)</param>
        /// <param name="limit">Limit the result to some number (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchTournamentsApiResponse"/>&gt;</returns>
        Task<ISearchTournamentsApiResponse> SearchTournamentsAsync(long accountId, string appKey, Option<string> keyword = default, Option<string> subType = default, Option<bool> includeInactive = default, Option<string> missionTypes = default, Option<string> filter = default, Option<string> sortField = default, Option<bool> descending = default, Option<string> visibility = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Tournaments
        /// </summary>
        /// <remarks>
        /// Search for tournaments
        /// </remarks>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="appKey">The application key</param>
        /// <param name="keyword">the keyword to search tournament on (optional)</param>
        /// <param name="subType">filter results by subType (optional)</param>
        /// <param name="includeInactive">whether to include inactives in the search or not (optional, default to false)</param>
        /// <param name="missionTypes">comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (optional, default to &quot;MULTISTAGE,TOURNAMENT,POOLPLAY&quot;)</param>
        /// <param name="filter">filter tournaments by the tournament&#39;s current state (optional, default to UPCOMING)</param>
        /// <param name="sortField">which field to sort on (optional, default to START_DATE)</param>
        /// <param name="descending">Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false. (optional)</param>
        /// <param name="visibility">Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (optional, default to &quot;PUBLIC&quot;)</param>
        /// <param name="start">Start the result set at some index. (optional, default to 0)</param>
        /// <param name="limit">Limit the result to some number (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchTournamentsApiResponse"/>?&gt;</returns>
        Task<ISearchTournamentsApiResponse?> SearchTournamentsOrDefaultAsync(long accountId, string appKey, Option<string> keyword = default, Option<string> subType = default, Option<bool> includeInactive = default, Option<string> missionTypes = default, Option<string> filter = default, Option<string> sortField = default, Option<bool> descending = default, Option<string> visibility = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Submit Tournament Score
        /// </summary>
        /// <remarks>
        /// Submit an array of scores for a tournament match. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The logged in user account ID.</param>
        /// <param name="appKey">The application key.</param>
        /// <param name="missionId">The missionId to score for</param>
        /// <param name="gameId">The gameId to score for</param>
        /// <param name="packId">The packId to score for</param>
        /// <param name="scores">a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60; </param>
        /// <param name="gameLevelId">The gameLevelId to score for (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISubmitTournamentScoreApiResponse"/>&gt;</returns>
        Task<ISubmitTournamentScoreApiResponse> SubmitTournamentScoreAsync(long accountId, string appKey, long missionId, long gameId, long packId, string scores, Option<long> gameLevelId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Submit Tournament Score
        /// </summary>
        /// <remarks>
        /// Submit an array of scores for a tournament match. 
        /// </remarks>
        /// <param name="accountId">The logged in user account ID.</param>
        /// <param name="appKey">The application key.</param>
        /// <param name="missionId">The missionId to score for</param>
        /// <param name="gameId">The gameId to score for</param>
        /// <param name="packId">The packId to score for</param>
        /// <param name="scores">a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60; </param>
        /// <param name="gameLevelId">The gameLevelId to score for (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISubmitTournamentScoreApiResponse"/>?&gt;</returns>
        Task<ISubmitTournamentScoreApiResponse?> SubmitTournamentScoreOrDefaultAsync(long accountId, string appKey, long missionId, long gameId, long packId, string scores, Option<long> gameLevelId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Submit a vote for a multi-stage album tournament.
        /// </summary>
        /// <remarks>
        /// Submit a vote for a multi-stage album tournament.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="appKey">The application to target</param>
        /// <param name="missionId">The tournament&#39;s primary id</param>
        /// <param name="gameObjectId">The tournament game object the user wants to vote on</param>
        /// <param name="deviceId">The unique id of the device making the request (optional) (optional)</param>
        /// <param name="checkIfDeviceAlreadyVoted">When true, check if the device already voted to prevent duplicate votes from the same device (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISubmitTournamentVoteApiResponse"/>&gt;</returns>
        Task<ISubmitTournamentVoteApiResponse> SubmitTournamentVoteAsync(long accountId, string appKey, long missionId, long gameObjectId, Option<string> deviceId = default, Option<bool> checkIfDeviceAlreadyVoted = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Submit a vote for a multi-stage album tournament.
        /// </summary>
        /// <remarks>
        /// Submit a vote for a multi-stage album tournament.
        /// </remarks>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="appKey">The application to target</param>
        /// <param name="missionId">The tournament&#39;s primary id</param>
        /// <param name="gameObjectId">The tournament game object the user wants to vote on</param>
        /// <param name="deviceId">The unique id of the device making the request (optional) (optional)</param>
        /// <param name="checkIfDeviceAlreadyVoted">When true, check if the device already voted to prevent duplicate votes from the same device (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISubmitTournamentVoteApiResponse"/>?&gt;</returns>
        Task<ISubmitTournamentVoteApiResponse?> SubmitTournamentVoteOrDefaultAsync(long accountId, string appKey, long missionId, long gameObjectId, Option<string> deviceId = default, Option<bool> checkIfDeviceAlreadyVoted = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Substitute Tournament Player
        /// </summary>
        /// <remarks>
        /// Service to replace the user&#39;s opponent in the current level - pack - mission with an AI account.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the id of the logged in user</param>
        /// <param name="missionId">the id of the mission</param>
        /// <param name="packId">the id of the pack</param>
        /// <param name="gameLevelId">the id of the game level</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISubstituteTournamentPlayerApiResponse"/>&gt;</returns>
        Task<ISubstituteTournamentPlayerApiResponse> SubstituteTournamentPlayerAsync(long accountId, long missionId, long packId, long gameLevelId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Substitute Tournament Player
        /// </summary>
        /// <remarks>
        /// Service to replace the user&#39;s opponent in the current level - pack - mission with an AI account.
        /// </remarks>
        /// <param name="accountId">the id of the logged in user</param>
        /// <param name="missionId">the id of the mission</param>
        /// <param name="packId">the id of the pack</param>
        /// <param name="gameLevelId">the id of the game level</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISubstituteTournamentPlayerApiResponse"/>?&gt;</returns>
        Task<ISubstituteTournamentPlayerApiResponse?> SubstituteTournamentPlayerOrDefaultAsync(long accountId, long missionId, long packId, long gameLevelId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Tournament
        /// </summary>
        /// <remarks>
        /// Update a tournament.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="missionId">The mission/tournament to update</param>
        /// <param name="title">The title of the tournament (optional)</param>
        /// <param name="subType">Custom string client apps can use for searching/filtering missions (optional)</param>
        /// <param name="imageAssetId">The asset ID to attach to the tournament (optional)</param>
        /// <param name="secondsBetweenLevels">The number of seconds in between the start of each tournament game (optional)</param>
        /// <param name="secondsForTieBreaker">The number of seconds to extend the round end time in the case of a tie breaker (optional)</param>
        /// <param name="secondsBetweenPacks">The number of seconds in between the start of each tournament round (optional)</param>
        /// <param name="maximumLevelLength">The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional)</param>
        /// <param name="costToPlay">The number of tickets required to pay to enter the tournament (optional)</param>
        /// <param name="costToPlayType">The type of ticket required to pay (optional)</param>
        /// <param name="minimumToPlay">The minimum number of players required to sign up for the tournament to be played (optional)</param>
        /// <param name="startingLimit">The starting number of players for a tournament (filled with AI&#39;s) (optional)</param>
        /// <param name="availableLimit">The maximum number of players for a tournament (currently 128 but not enforced) (optional)</param>
        /// <param name="description">The description of the tournament (optional)</param>
        /// <param name="metaData">External custom client defined data (optional)</param>
        /// <param name="startDate">The date/time to start the tournament (optional)</param>
        /// <param name="audienceIds">The audiences associated with the tournament (optional)</param>
        /// <param name="active">Activate/deactivate the mission (optional)</param>
        /// <param name="enableBuyBack">Determines whether to allow players to buy back into a tournament (optional)</param>
        /// <param name="offerIds">The list of offers to give as a reward beyond the tickets (optional)</param>
        /// <param name="offerAssetId">The artwork ID to attach to the reward offer (optional)</param>
        /// <param name="fixedReward">If set then do not update the ticket reward, auto set to true if offerIds provided (optional)</param>
        /// <param name="splitReward">Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional)</param>
        /// <param name="allocateTickets">Flag to indicate owner should receive tickets for completed missions (optional)</param>
        /// <param name="tournamentData">A text based string that will be passed into each tournament setup to populate the content (optional)</param>
        /// <param name="visibility">Sets the visibility flag for the tournament (optional)</param>
        /// <param name="preliminaryGroups">The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional)</param>
        /// <param name="preliminaryGroupAdvancements">This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional)</param>
        /// <param name="enableMultipleEntries">This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional)</param>
        /// <param name="enableMultipleVotes">This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional)</param>
        /// <param name="featured">This determines whether the tournament is \&quot;featured\&quot; or not (optional)</param>
        /// <param name="winnerTag">This sets what analytic tag is used when a winner is determined (optional)</param>
        /// <param name="tieTag">This sets what analytic tag is used when a winner is determined (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTournamentApiResponse"/>&gt;</returns>
        Task<IUpdateTournamentApiResponse> UpdateTournamentAsync(long accountId, long missionId, Option<string> title = default, Option<string> subType = default, Option<long> imageAssetId = default, Option<int> secondsBetweenLevels = default, Option<int> secondsForTieBreaker = default, Option<int> secondsBetweenPacks = default, Option<int> maximumLevelLength = default, Option<int> costToPlay = default, Option<string> costToPlayType = default, Option<int> minimumToPlay = default, Option<int> startingLimit = default, Option<int> availableLimit = default, Option<string> description = default, Option<string> metaData = default, Option<long> startDate = default, Option<string> audienceIds = default, Option<bool> active = default, Option<bool> enableBuyBack = default, Option<string> offerIds = default, Option<long> offerAssetId = default, Option<bool> fixedReward = default, Option<string> splitReward = default, Option<bool> allocateTickets = default, Option<string> tournamentData = default, Option<string> visibility = default, Option<int> preliminaryGroups = default, Option<string> preliminaryGroupAdvancements = default, Option<bool> enableMultipleEntries = default, Option<bool> enableMultipleVotes = default, Option<bool> featured = default, Option<string> winnerTag = default, Option<string> tieTag = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Tournament
        /// </summary>
        /// <remarks>
        /// Update a tournament.
        /// </remarks>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="missionId">The mission/tournament to update</param>
        /// <param name="title">The title of the tournament (optional)</param>
        /// <param name="subType">Custom string client apps can use for searching/filtering missions (optional)</param>
        /// <param name="imageAssetId">The asset ID to attach to the tournament (optional)</param>
        /// <param name="secondsBetweenLevels">The number of seconds in between the start of each tournament game (optional)</param>
        /// <param name="secondsForTieBreaker">The number of seconds to extend the round end time in the case of a tie breaker (optional)</param>
        /// <param name="secondsBetweenPacks">The number of seconds in between the start of each tournament round (optional)</param>
        /// <param name="maximumLevelLength">The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional)</param>
        /// <param name="costToPlay">The number of tickets required to pay to enter the tournament (optional)</param>
        /// <param name="costToPlayType">The type of ticket required to pay (optional)</param>
        /// <param name="minimumToPlay">The minimum number of players required to sign up for the tournament to be played (optional)</param>
        /// <param name="startingLimit">The starting number of players for a tournament (filled with AI&#39;s) (optional)</param>
        /// <param name="availableLimit">The maximum number of players for a tournament (currently 128 but not enforced) (optional)</param>
        /// <param name="description">The description of the tournament (optional)</param>
        /// <param name="metaData">External custom client defined data (optional)</param>
        /// <param name="startDate">The date/time to start the tournament (optional)</param>
        /// <param name="audienceIds">The audiences associated with the tournament (optional)</param>
        /// <param name="active">Activate/deactivate the mission (optional)</param>
        /// <param name="enableBuyBack">Determines whether to allow players to buy back into a tournament (optional)</param>
        /// <param name="offerIds">The list of offers to give as a reward beyond the tickets (optional)</param>
        /// <param name="offerAssetId">The artwork ID to attach to the reward offer (optional)</param>
        /// <param name="fixedReward">If set then do not update the ticket reward, auto set to true if offerIds provided (optional)</param>
        /// <param name="splitReward">Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional)</param>
        /// <param name="allocateTickets">Flag to indicate owner should receive tickets for completed missions (optional)</param>
        /// <param name="tournamentData">A text based string that will be passed into each tournament setup to populate the content (optional)</param>
        /// <param name="visibility">Sets the visibility flag for the tournament (optional)</param>
        /// <param name="preliminaryGroups">The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional)</param>
        /// <param name="preliminaryGroupAdvancements">This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional)</param>
        /// <param name="enableMultipleEntries">This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional)</param>
        /// <param name="enableMultipleVotes">This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional)</param>
        /// <param name="featured">This determines whether the tournament is \&quot;featured\&quot; or not (optional)</param>
        /// <param name="winnerTag">This sets what analytic tag is used when a winner is determined (optional)</param>
        /// <param name="tieTag">This sets what analytic tag is used when a winner is determined (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTournamentApiResponse"/>?&gt;</returns>
        Task<IUpdateTournamentApiResponse?> UpdateTournamentOrDefaultAsync(long accountId, long missionId, Option<string> title = default, Option<string> subType = default, Option<long> imageAssetId = default, Option<int> secondsBetweenLevels = default, Option<int> secondsForTieBreaker = default, Option<int> secondsBetweenPacks = default, Option<int> maximumLevelLength = default, Option<int> costToPlay = default, Option<string> costToPlayType = default, Option<int> minimumToPlay = default, Option<int> startingLimit = default, Option<int> availableLimit = default, Option<string> description = default, Option<string> metaData = default, Option<long> startDate = default, Option<string> audienceIds = default, Option<bool> active = default, Option<bool> enableBuyBack = default, Option<string> offerIds = default, Option<long> offerAssetId = default, Option<bool> fixedReward = default, Option<string> splitReward = default, Option<bool> allocateTickets = default, Option<string> tournamentData = default, Option<string> visibility = default, Option<int> preliminaryGroups = default, Option<string> preliminaryGroupAdvancements = default, Option<bool> enableMultipleEntries = default, Option<bool> enableMultipleVotes = default, Option<bool> featured = default, Option<string> winnerTag = default, Option<string> tieTag = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICreateTournamentApiResponse"/>
    /// </summary>
    public interface ICreateTournamentApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TournamentResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteTournamentApiResponse"/>
    /// </summary>
    public interface IDeleteTournamentApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetTournamentApiResponse"/>
    /// </summary>
    public interface IGetTournamentApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TournamentResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchObjectsApiResponse"/>
    /// </summary>
    public interface ISearchObjectsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchRoundsApiResponse"/>
    /// </summary>
    public interface ISearchRoundsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchTournamentsApiResponse"/>
    /// </summary>
    public interface ISearchTournamentsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.MissionShortResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISubmitTournamentScoreApiResponse"/>
    /// </summary>
    public interface ISubmitTournamentScoreApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISubmitTournamentVoteApiResponse"/>
    /// </summary>
    public interface ISubmitTournamentVoteApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISubstituteTournamentPlayerApiResponse"/>
    /// </summary>
    public interface ISubstituteTournamentPlayerApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateTournamentApiResponse"/>
    /// </summary>
    public interface IUpdateTournamentApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TournamentResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class TournamentApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateTournament;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateTournament;

        internal void ExecuteOnCreateTournament(TournamentApi.CreateTournamentApiResponse apiResponse)
        {
            OnCreateTournament?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateTournament(Exception exception)
        {
            OnErrorCreateTournament?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteTournament;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteTournament;

        internal void ExecuteOnDeleteTournament(TournamentApi.DeleteTournamentApiResponse apiResponse)
        {
            OnDeleteTournament?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteTournament(Exception exception)
        {
            OnErrorDeleteTournament?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetTournament;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetTournament;

        internal void ExecuteOnGetTournament(TournamentApi.GetTournamentApiResponse apiResponse)
        {
            OnGetTournament?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetTournament(Exception exception)
        {
            OnErrorGetTournament?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchObjects;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchObjects;

        internal void ExecuteOnSearchObjects(TournamentApi.SearchObjectsApiResponse apiResponse)
        {
            OnSearchObjects?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchObjects(Exception exception)
        {
            OnErrorSearchObjects?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchRounds;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchRounds;

        internal void ExecuteOnSearchRounds(TournamentApi.SearchRoundsApiResponse apiResponse)
        {
            OnSearchRounds?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchRounds(Exception exception)
        {
            OnErrorSearchRounds?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchTournaments;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchTournaments;

        internal void ExecuteOnSearchTournaments(TournamentApi.SearchTournamentsApiResponse apiResponse)
        {
            OnSearchTournaments?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchTournaments(Exception exception)
        {
            OnErrorSearchTournaments?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSubmitTournamentScore;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSubmitTournamentScore;

        internal void ExecuteOnSubmitTournamentScore(TournamentApi.SubmitTournamentScoreApiResponse apiResponse)
        {
            OnSubmitTournamentScore?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSubmitTournamentScore(Exception exception)
        {
            OnErrorSubmitTournamentScore?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSubmitTournamentVote;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSubmitTournamentVote;

        internal void ExecuteOnSubmitTournamentVote(TournamentApi.SubmitTournamentVoteApiResponse apiResponse)
        {
            OnSubmitTournamentVote?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSubmitTournamentVote(Exception exception)
        {
            OnErrorSubmitTournamentVote?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSubstituteTournamentPlayer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSubstituteTournamentPlayer;

        internal void ExecuteOnSubstituteTournamentPlayer(TournamentApi.SubstituteTournamentPlayerApiResponse apiResponse)
        {
            OnSubstituteTournamentPlayer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSubstituteTournamentPlayer(Exception exception)
        {
            OnErrorSubstituteTournamentPlayer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateTournament;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateTournament;

        internal void ExecuteOnUpdateTournament(TournamentApi.UpdateTournamentApiResponse apiResponse)
        {
            OnUpdateTournament?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateTournament(Exception exception)
        {
            OnErrorUpdateTournament?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class TournamentApi : ITournamentApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<TournamentApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public TournamentApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="TournamentApi"/> class.
        /// </summary>
        /// <returns></returns>
        public TournamentApi(ILogger<TournamentApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, TournamentApiEvents tournamentApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<TournamentApi>();
            HttpClient = httpClient;
            Events = tournamentApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatCreateTournament(ref long accountId, ref string appKey, ref string title, ref int costToPlay, ref long startDate, ref Option<string> subType, ref Option<long> imageAssetId, ref Option<int> secondsBetweenLevels, ref Option<int> secondsForTieBreaker, ref Option<int> secondsBetweenPacks, ref Option<int> maximumLevelLength, ref Option<string> costToPlayType, ref Option<int> minimumToPlay, ref Option<int> startingLimit, ref Option<int> availableLimit, ref Option<string> description, ref Option<string> metaData, ref Option<string> audienceIds, ref Option<bool> active, ref Option<bool> enableBuyBack, ref Option<string> offerIds, ref Option<long> offerAssetId, ref Option<bool> fixedReward, ref Option<string> splitReward, ref Option<bool> allocateTickets, ref Option<string> tournamentData, ref Option<string> missionType, ref Option<string> visibility, ref Option<int> preliminaryGroups, ref Option<string> preliminaryGroupAdvancements, ref Option<bool> enableMultipleEntries, ref Option<bool> enableMultipleVotes, ref Option<bool> featured, ref Option<string> winnerTag, ref Option<string> tieTag);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="appKey"></param>
        /// <param name="title"></param>
        /// <param name="subType"></param>
        /// <param name="costToPlayType"></param>
        /// <param name="description"></param>
        /// <param name="metaData"></param>
        /// <param name="audienceIds"></param>
        /// <param name="offerIds"></param>
        /// <param name="splitReward"></param>
        /// <param name="tournamentData"></param>
        /// <param name="missionType"></param>
        /// <param name="visibility"></param>
        /// <param name="preliminaryGroupAdvancements"></param>
        /// <param name="winnerTag"></param>
        /// <param name="tieTag"></param>
        /// <returns></returns>
        private void ValidateCreateTournament(string appKey, string title, Option<string> subType, Option<string> costToPlayType, Option<string> description, Option<string> metaData, Option<string> audienceIds, Option<string> offerIds, Option<string> splitReward, Option<string> tournamentData, Option<string> missionType, Option<string> visibility, Option<string> preliminaryGroupAdvancements, Option<string> winnerTag, Option<string> tieTag)
        {
            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));

            if (title == null)
                throw new ArgumentNullException(nameof(title));

            if (subType.IsSet && subType.Value == null)
                throw new ArgumentNullException(nameof(subType));

            if (costToPlayType.IsSet && costToPlayType.Value == null)
                throw new ArgumentNullException(nameof(costToPlayType));

            if (description.IsSet && description.Value == null)
                throw new ArgumentNullException(nameof(description));

            if (metaData.IsSet && metaData.Value == null)
                throw new ArgumentNullException(nameof(metaData));

            if (audienceIds.IsSet && audienceIds.Value == null)
                throw new ArgumentNullException(nameof(audienceIds));

            if (offerIds.IsSet && offerIds.Value == null)
                throw new ArgumentNullException(nameof(offerIds));

            if (splitReward.IsSet && splitReward.Value == null)
                throw new ArgumentNullException(nameof(splitReward));

            if (tournamentData.IsSet && tournamentData.Value == null)
                throw new ArgumentNullException(nameof(tournamentData));

            if (missionType.IsSet && missionType.Value == null)
                throw new ArgumentNullException(nameof(missionType));

            if (visibility.IsSet && visibility.Value == null)
                throw new ArgumentNullException(nameof(visibility));

            if (preliminaryGroupAdvancements.IsSet && preliminaryGroupAdvancements.Value == null)
                throw new ArgumentNullException(nameof(preliminaryGroupAdvancements));

            if (winnerTag.IsSet && winnerTag.Value == null)
                throw new ArgumentNullException(nameof(winnerTag));

            if (tieTag.IsSet && tieTag.Value == null)
                throw new ArgumentNullException(nameof(tieTag));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="title"></param>
        /// <param name="costToPlay"></param>
        /// <param name="startDate"></param>
        /// <param name="subType"></param>
        /// <param name="imageAssetId"></param>
        /// <param name="secondsBetweenLevels"></param>
        /// <param name="secondsForTieBreaker"></param>
        /// <param name="secondsBetweenPacks"></param>
        /// <param name="maximumLevelLength"></param>
        /// <param name="costToPlayType"></param>
        /// <param name="minimumToPlay"></param>
        /// <param name="startingLimit"></param>
        /// <param name="availableLimit"></param>
        /// <param name="description"></param>
        /// <param name="metaData"></param>
        /// <param name="audienceIds"></param>
        /// <param name="active"></param>
        /// <param name="enableBuyBack"></param>
        /// <param name="offerIds"></param>
        /// <param name="offerAssetId"></param>
        /// <param name="fixedReward"></param>
        /// <param name="splitReward"></param>
        /// <param name="allocateTickets"></param>
        /// <param name="tournamentData"></param>
        /// <param name="missionType"></param>
        /// <param name="visibility"></param>
        /// <param name="preliminaryGroups"></param>
        /// <param name="preliminaryGroupAdvancements"></param>
        /// <param name="enableMultipleEntries"></param>
        /// <param name="enableMultipleVotes"></param>
        /// <param name="featured"></param>
        /// <param name="winnerTag"></param>
        /// <param name="tieTag"></param>
        private void AfterCreateTournamentDefaultImplementation(ICreateTournamentApiResponse apiResponseLocalVar, long accountId, string appKey, string title, int costToPlay, long startDate, Option<string> subType, Option<long> imageAssetId, Option<int> secondsBetweenLevels, Option<int> secondsForTieBreaker, Option<int> secondsBetweenPacks, Option<int> maximumLevelLength, Option<string> costToPlayType, Option<int> minimumToPlay, Option<int> startingLimit, Option<int> availableLimit, Option<string> description, Option<string> metaData, Option<string> audienceIds, Option<bool> active, Option<bool> enableBuyBack, Option<string> offerIds, Option<long> offerAssetId, Option<bool> fixedReward, Option<string> splitReward, Option<bool> allocateTickets, Option<string> tournamentData, Option<string> missionType, Option<string> visibility, Option<int> preliminaryGroups, Option<string> preliminaryGroupAdvancements, Option<bool> enableMultipleEntries, Option<bool> enableMultipleVotes, Option<bool> featured, Option<string> winnerTag, Option<string> tieTag)
        {
            bool suppressDefaultLog = false;
            AfterCreateTournament(ref suppressDefaultLog, apiResponseLocalVar, accountId, appKey, title, costToPlay, startDate, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, missionType, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="title"></param>
        /// <param name="costToPlay"></param>
        /// <param name="startDate"></param>
        /// <param name="subType"></param>
        /// <param name="imageAssetId"></param>
        /// <param name="secondsBetweenLevels"></param>
        /// <param name="secondsForTieBreaker"></param>
        /// <param name="secondsBetweenPacks"></param>
        /// <param name="maximumLevelLength"></param>
        /// <param name="costToPlayType"></param>
        /// <param name="minimumToPlay"></param>
        /// <param name="startingLimit"></param>
        /// <param name="availableLimit"></param>
        /// <param name="description"></param>
        /// <param name="metaData"></param>
        /// <param name="audienceIds"></param>
        /// <param name="active"></param>
        /// <param name="enableBuyBack"></param>
        /// <param name="offerIds"></param>
        /// <param name="offerAssetId"></param>
        /// <param name="fixedReward"></param>
        /// <param name="splitReward"></param>
        /// <param name="allocateTickets"></param>
        /// <param name="tournamentData"></param>
        /// <param name="missionType"></param>
        /// <param name="visibility"></param>
        /// <param name="preliminaryGroups"></param>
        /// <param name="preliminaryGroupAdvancements"></param>
        /// <param name="enableMultipleEntries"></param>
        /// <param name="enableMultipleVotes"></param>
        /// <param name="featured"></param>
        /// <param name="winnerTag"></param>
        /// <param name="tieTag"></param>
        partial void AfterCreateTournament(ref bool suppressDefaultLog, ICreateTournamentApiResponse apiResponseLocalVar, long accountId, string appKey, string title, int costToPlay, long startDate, Option<string> subType, Option<long> imageAssetId, Option<int> secondsBetweenLevels, Option<int> secondsForTieBreaker, Option<int> secondsBetweenPacks, Option<int> maximumLevelLength, Option<string> costToPlayType, Option<int> minimumToPlay, Option<int> startingLimit, Option<int> availableLimit, Option<string> description, Option<string> metaData, Option<string> audienceIds, Option<bool> active, Option<bool> enableBuyBack, Option<string> offerIds, Option<long> offerAssetId, Option<bool> fixedReward, Option<string> splitReward, Option<bool> allocateTickets, Option<string> tournamentData, Option<string> missionType, Option<string> visibility, Option<int> preliminaryGroups, Option<string> preliminaryGroupAdvancements, Option<bool> enableMultipleEntries, Option<bool> enableMultipleVotes, Option<bool> featured, Option<string> winnerTag, Option<string> tieTag);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="title"></param>
        /// <param name="costToPlay"></param>
        /// <param name="startDate"></param>
        /// <param name="subType"></param>
        /// <param name="imageAssetId"></param>
        /// <param name="secondsBetweenLevels"></param>
        /// <param name="secondsForTieBreaker"></param>
        /// <param name="secondsBetweenPacks"></param>
        /// <param name="maximumLevelLength"></param>
        /// <param name="costToPlayType"></param>
        /// <param name="minimumToPlay"></param>
        /// <param name="startingLimit"></param>
        /// <param name="availableLimit"></param>
        /// <param name="description"></param>
        /// <param name="metaData"></param>
        /// <param name="audienceIds"></param>
        /// <param name="active"></param>
        /// <param name="enableBuyBack"></param>
        /// <param name="offerIds"></param>
        /// <param name="offerAssetId"></param>
        /// <param name="fixedReward"></param>
        /// <param name="splitReward"></param>
        /// <param name="allocateTickets"></param>
        /// <param name="tournamentData"></param>
        /// <param name="missionType"></param>
        /// <param name="visibility"></param>
        /// <param name="preliminaryGroups"></param>
        /// <param name="preliminaryGroupAdvancements"></param>
        /// <param name="enableMultipleEntries"></param>
        /// <param name="enableMultipleVotes"></param>
        /// <param name="featured"></param>
        /// <param name="winnerTag"></param>
        /// <param name="tieTag"></param>
        private void OnErrorCreateTournamentDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string appKey, string title, int costToPlay, long startDate, Option<string> subType, Option<long> imageAssetId, Option<int> secondsBetweenLevels, Option<int> secondsForTieBreaker, Option<int> secondsBetweenPacks, Option<int> maximumLevelLength, Option<string> costToPlayType, Option<int> minimumToPlay, Option<int> startingLimit, Option<int> availableLimit, Option<string> description, Option<string> metaData, Option<string> audienceIds, Option<bool> active, Option<bool> enableBuyBack, Option<string> offerIds, Option<long> offerAssetId, Option<bool> fixedReward, Option<string> splitReward, Option<bool> allocateTickets, Option<string> tournamentData, Option<string> missionType, Option<string> visibility, Option<int> preliminaryGroups, Option<string> preliminaryGroupAdvancements, Option<bool> enableMultipleEntries, Option<bool> enableMultipleVotes, Option<bool> featured, Option<string> winnerTag, Option<string> tieTag)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateTournament(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, appKey, title, costToPlay, startDate, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, missionType, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="title"></param>
        /// <param name="costToPlay"></param>
        /// <param name="startDate"></param>
        /// <param name="subType"></param>
        /// <param name="imageAssetId"></param>
        /// <param name="secondsBetweenLevels"></param>
        /// <param name="secondsForTieBreaker"></param>
        /// <param name="secondsBetweenPacks"></param>
        /// <param name="maximumLevelLength"></param>
        /// <param name="costToPlayType"></param>
        /// <param name="minimumToPlay"></param>
        /// <param name="startingLimit"></param>
        /// <param name="availableLimit"></param>
        /// <param name="description"></param>
        /// <param name="metaData"></param>
        /// <param name="audienceIds"></param>
        /// <param name="active"></param>
        /// <param name="enableBuyBack"></param>
        /// <param name="offerIds"></param>
        /// <param name="offerAssetId"></param>
        /// <param name="fixedReward"></param>
        /// <param name="splitReward"></param>
        /// <param name="allocateTickets"></param>
        /// <param name="tournamentData"></param>
        /// <param name="missionType"></param>
        /// <param name="visibility"></param>
        /// <param name="preliminaryGroups"></param>
        /// <param name="preliminaryGroupAdvancements"></param>
        /// <param name="enableMultipleEntries"></param>
        /// <param name="enableMultipleVotes"></param>
        /// <param name="featured"></param>
        /// <param name="winnerTag"></param>
        /// <param name="tieTag"></param>
        partial void OnErrorCreateTournament(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string appKey, string title, int costToPlay, long startDate, Option<string> subType, Option<long> imageAssetId, Option<int> secondsBetweenLevels, Option<int> secondsForTieBreaker, Option<int> secondsBetweenPacks, Option<int> maximumLevelLength, Option<string> costToPlayType, Option<int> minimumToPlay, Option<int> startingLimit, Option<int> availableLimit, Option<string> description, Option<string> metaData, Option<string> audienceIds, Option<bool> active, Option<bool> enableBuyBack, Option<string> offerIds, Option<long> offerAssetId, Option<bool> fixedReward, Option<string> splitReward, Option<bool> allocateTickets, Option<string> tournamentData, Option<string> missionType, Option<string> visibility, Option<int> preliminaryGroups, Option<string> preliminaryGroupAdvancements, Option<bool> enableMultipleEntries, Option<bool> enableMultipleVotes, Option<bool> featured, Option<string> winnerTag, Option<string> tieTag);

        /// <summary>
        /// Create Tournament Create a tournament.
        /// </summary>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="appKey">The appKey the tournament is created for.</param>
        /// <param name="title">The title of the tournament</param>
        /// <param name="costToPlay">The number of tickets required to pay to enter the tournament</param>
        /// <param name="startDate">The date/time to start the tournament</param>
        /// <param name="subType">Custom string client apps can use for searching/filtering tournaments (optional)</param>
        /// <param name="imageAssetId">The asset ID to attach to the tournament (optional)</param>
        /// <param name="secondsBetweenLevels">The number of seconds in between the start of each tournament game/group (optional, default to 600)</param>
        /// <param name="secondsForTieBreaker">The number of seconds to extend the round end time in the case of a tie breaker (optional, default to 600)</param>
        /// <param name="secondsBetweenPacks">The number of seconds in between the start of each tournament round (optional, default to 86400)</param>
        /// <param name="maximumLevelLength">The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional, default to 1800)</param>
        /// <param name="costToPlayType">The type of ticket required to pay (optional)</param>
        /// <param name="minimumToPlay">The minimum number of players required to sign up for the tournament to be played (optional, default to 1)</param>
        /// <param name="startingLimit">The starting number of players for a tournament (filled with AI&#39;s) (optional)</param>
        /// <param name="availableLimit">The maximum number of players for a tournament (currently 128 but not enforced) (optional)</param>
        /// <param name="description">The description of the tournament (optional)</param>
        /// <param name="metaData">External custom client defined data (optional)</param>
        /// <param name="audienceIds">The audiences associated with the tournament (optional)</param>
        /// <param name="active">Activate/deactivate the tournament (optional)</param>
        /// <param name="enableBuyBack">Determines whether to allow players to buy back into a tournament (optional, default to false)</param>
        /// <param name="offerIds">The list of offers to give as a reward beyond the tickets (optional)</param>
        /// <param name="offerAssetId">The artwork ID to attach to the reward tickets offers (optional)</param>
        /// <param name="fixedReward">If set then do not update the ticket reward, auto set to true if offerIds provided (optional, default to false)</param>
        /// <param name="splitReward">Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional, default to ALL)</param>
        /// <param name="allocateTickets">Flag to indicate owner should receive tickets for completed missions (optional)</param>
        /// <param name="tournamentData">A text based string that will be passed into each tournament setup to populate the content (optional)</param>
        /// <param name="missionType">The style of tournament to build, options are: TOURNAMENT, POOLPLAY (optional, default to MULTISTAGE)</param>
        /// <param name="visibility">Sets the visibility flag for the tournament (optional, default to PUBLIC)</param>
        /// <param name="preliminaryGroups">The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional, default to 1)</param>
        /// <param name="preliminaryGroupAdvancements">This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional, default to &quot;1&quot;)</param>
        /// <param name="enableMultipleEntries">This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional, default to false)</param>
        /// <param name="enableMultipleVotes">This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional, default to false)</param>
        /// <param name="featured">This determines whether the tournament is \&quot;featured\&quot; or not (optional, default to false)</param>
        /// <param name="winnerTag">This sets what analytic tag is used when a winner is determined (optional)</param>
        /// <param name="tieTag">This sets what analytic tag is used when a tie has occurred (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTournamentApiResponse"/>&gt;</returns>
        public async Task<ICreateTournamentApiResponse?> CreateTournamentOrDefaultAsync(long accountId, string appKey, string title, int costToPlay, long startDate, Option<string> subType = default, Option<long> imageAssetId = default, Option<int> secondsBetweenLevels = default, Option<int> secondsForTieBreaker = default, Option<int> secondsBetweenPacks = default, Option<int> maximumLevelLength = default, Option<string> costToPlayType = default, Option<int> minimumToPlay = default, Option<int> startingLimit = default, Option<int> availableLimit = default, Option<string> description = default, Option<string> metaData = default, Option<string> audienceIds = default, Option<bool> active = default, Option<bool> enableBuyBack = default, Option<string> offerIds = default, Option<long> offerAssetId = default, Option<bool> fixedReward = default, Option<string> splitReward = default, Option<bool> allocateTickets = default, Option<string> tournamentData = default, Option<string> missionType = default, Option<string> visibility = default, Option<int> preliminaryGroups = default, Option<string> preliminaryGroupAdvancements = default, Option<bool> enableMultipleEntries = default, Option<bool> enableMultipleVotes = default, Option<bool> featured = default, Option<string> winnerTag = default, Option<string> tieTag = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateTournamentAsync(accountId, appKey, title, costToPlay, startDate, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, missionType, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create Tournament Create a tournament.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="appKey">The appKey the tournament is created for.</param>
        /// <param name="title">The title of the tournament</param>
        /// <param name="costToPlay">The number of tickets required to pay to enter the tournament</param>
        /// <param name="startDate">The date/time to start the tournament</param>
        /// <param name="subType">Custom string client apps can use for searching/filtering tournaments (optional)</param>
        /// <param name="imageAssetId">The asset ID to attach to the tournament (optional)</param>
        /// <param name="secondsBetweenLevels">The number of seconds in between the start of each tournament game/group (optional, default to 600)</param>
        /// <param name="secondsForTieBreaker">The number of seconds to extend the round end time in the case of a tie breaker (optional, default to 600)</param>
        /// <param name="secondsBetweenPacks">The number of seconds in between the start of each tournament round (optional, default to 86400)</param>
        /// <param name="maximumLevelLength">The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional, default to 1800)</param>
        /// <param name="costToPlayType">The type of ticket required to pay (optional)</param>
        /// <param name="minimumToPlay">The minimum number of players required to sign up for the tournament to be played (optional, default to 1)</param>
        /// <param name="startingLimit">The starting number of players for a tournament (filled with AI&#39;s) (optional)</param>
        /// <param name="availableLimit">The maximum number of players for a tournament (currently 128 but not enforced) (optional)</param>
        /// <param name="description">The description of the tournament (optional)</param>
        /// <param name="metaData">External custom client defined data (optional)</param>
        /// <param name="audienceIds">The audiences associated with the tournament (optional)</param>
        /// <param name="active">Activate/deactivate the tournament (optional)</param>
        /// <param name="enableBuyBack">Determines whether to allow players to buy back into a tournament (optional, default to false)</param>
        /// <param name="offerIds">The list of offers to give as a reward beyond the tickets (optional)</param>
        /// <param name="offerAssetId">The artwork ID to attach to the reward tickets offers (optional)</param>
        /// <param name="fixedReward">If set then do not update the ticket reward, auto set to true if offerIds provided (optional, default to false)</param>
        /// <param name="splitReward">Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional, default to ALL)</param>
        /// <param name="allocateTickets">Flag to indicate owner should receive tickets for completed missions (optional)</param>
        /// <param name="tournamentData">A text based string that will be passed into each tournament setup to populate the content (optional)</param>
        /// <param name="missionType">The style of tournament to build, options are: TOURNAMENT, POOLPLAY (optional, default to MULTISTAGE)</param>
        /// <param name="visibility">Sets the visibility flag for the tournament (optional, default to PUBLIC)</param>
        /// <param name="preliminaryGroups">The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional, default to 1)</param>
        /// <param name="preliminaryGroupAdvancements">This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional, default to &quot;1&quot;)</param>
        /// <param name="enableMultipleEntries">This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional, default to false)</param>
        /// <param name="enableMultipleVotes">This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional, default to false)</param>
        /// <param name="featured">This determines whether the tournament is \&quot;featured\&quot; or not (optional, default to false)</param>
        /// <param name="winnerTag">This sets what analytic tag is used when a winner is determined (optional)</param>
        /// <param name="tieTag">This sets what analytic tag is used when a tie has occurred (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTournamentApiResponse"/>&gt;</returns>
        public async Task<ICreateTournamentApiResponse> CreateTournamentAsync(long accountId, string appKey, string title, int costToPlay, long startDate, Option<string> subType = default, Option<long> imageAssetId = default, Option<int> secondsBetweenLevels = default, Option<int> secondsForTieBreaker = default, Option<int> secondsBetweenPacks = default, Option<int> maximumLevelLength = default, Option<string> costToPlayType = default, Option<int> minimumToPlay = default, Option<int> startingLimit = default, Option<int> availableLimit = default, Option<string> description = default, Option<string> metaData = default, Option<string> audienceIds = default, Option<bool> active = default, Option<bool> enableBuyBack = default, Option<string> offerIds = default, Option<long> offerAssetId = default, Option<bool> fixedReward = default, Option<string> splitReward = default, Option<bool> allocateTickets = default, Option<string> tournamentData = default, Option<string> missionType = default, Option<string> visibility = default, Option<int> preliminaryGroups = default, Option<string> preliminaryGroupAdvancements = default, Option<bool> enableMultipleEntries = default, Option<bool> enableMultipleVotes = default, Option<bool> featured = default, Option<string> winnerTag = default, Option<string> tieTag = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateTournament(appKey, title, subType, costToPlayType, description, metaData, audienceIds, offerIds, splitReward, tournamentData, missionType, visibility, preliminaryGroupAdvancements, winnerTag, tieTag);

                FormatCreateTournament(ref accountId, ref appKey, ref title, ref costToPlay, ref startDate, ref subType, ref imageAssetId, ref secondsBetweenLevels, ref secondsForTieBreaker, ref secondsBetweenPacks, ref maximumLevelLength, ref costToPlayType, ref minimumToPlay, ref startingLimit, ref availableLimit, ref description, ref metaData, ref audienceIds, ref active, ref enableBuyBack, ref offerIds, ref offerAssetId, ref fixedReward, ref splitReward, ref allocateTickets, ref tournamentData, ref missionType, ref visibility, ref preliminaryGroups, ref preliminaryGroupAdvancements, ref enableMultipleEntries, ref enableMultipleVotes, ref featured, ref winnerTag, ref tieTag);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/tournament/create"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/tournament/create");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey);
                    parseQueryStringLocalVar["title"] = ClientUtils.ParameterToString(title);
                    parseQueryStringLocalVar["costToPlay"] = ClientUtils.ParameterToString(costToPlay);
                    parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate);

                    if (subType.IsSet)
                        parseQueryStringLocalVar["subType"] = ClientUtils.ParameterToString(subType.Value);

                    if (imageAssetId.IsSet)
                        parseQueryStringLocalVar["imageAssetId"] = ClientUtils.ParameterToString(imageAssetId.Value);

                    if (secondsBetweenLevels.IsSet)
                        parseQueryStringLocalVar["secondsBetweenLevels"] = ClientUtils.ParameterToString(secondsBetweenLevels.Value);

                    if (secondsForTieBreaker.IsSet)
                        parseQueryStringLocalVar["secondsForTieBreaker"] = ClientUtils.ParameterToString(secondsForTieBreaker.Value);

                    if (secondsBetweenPacks.IsSet)
                        parseQueryStringLocalVar["secondsBetweenPacks"] = ClientUtils.ParameterToString(secondsBetweenPacks.Value);

                    if (maximumLevelLength.IsSet)
                        parseQueryStringLocalVar["maximumLevelLength"] = ClientUtils.ParameterToString(maximumLevelLength.Value);

                    if (costToPlayType.IsSet)
                        parseQueryStringLocalVar["costToPlayType"] = ClientUtils.ParameterToString(costToPlayType.Value);

                    if (minimumToPlay.IsSet)
                        parseQueryStringLocalVar["minimumToPlay"] = ClientUtils.ParameterToString(minimumToPlay.Value);

                    if (startingLimit.IsSet)
                        parseQueryStringLocalVar["startingLimit"] = ClientUtils.ParameterToString(startingLimit.Value);

                    if (availableLimit.IsSet)
                        parseQueryStringLocalVar["availableLimit"] = ClientUtils.ParameterToString(availableLimit.Value);

                    if (description.IsSet)
                        parseQueryStringLocalVar["description"] = ClientUtils.ParameterToString(description.Value);

                    if (metaData.IsSet)
                        parseQueryStringLocalVar["metaData"] = ClientUtils.ParameterToString(metaData.Value);

                    if (audienceIds.IsSet)
                        parseQueryStringLocalVar["audienceIds"] = ClientUtils.ParameterToString(audienceIds.Value);

                    if (active.IsSet)
                        parseQueryStringLocalVar["active"] = ClientUtils.ParameterToString(active.Value);

                    if (enableBuyBack.IsSet)
                        parseQueryStringLocalVar["enableBuyBack"] = ClientUtils.ParameterToString(enableBuyBack.Value);

                    if (offerIds.IsSet)
                        parseQueryStringLocalVar["offerIds"] = ClientUtils.ParameterToString(offerIds.Value);

                    if (offerAssetId.IsSet)
                        parseQueryStringLocalVar["offerAssetId"] = ClientUtils.ParameterToString(offerAssetId.Value);

                    if (fixedReward.IsSet)
                        parseQueryStringLocalVar["fixedReward"] = ClientUtils.ParameterToString(fixedReward.Value);

                    if (splitReward.IsSet)
                        parseQueryStringLocalVar["splitReward"] = ClientUtils.ParameterToString(splitReward.Value);

                    if (allocateTickets.IsSet)
                        parseQueryStringLocalVar["allocateTickets"] = ClientUtils.ParameterToString(allocateTickets.Value);

                    if (tournamentData.IsSet)
                        parseQueryStringLocalVar["tournamentData"] = ClientUtils.ParameterToString(tournamentData.Value);

                    if (missionType.IsSet)
                        parseQueryStringLocalVar["missionType"] = ClientUtils.ParameterToString(missionType.Value);

                    if (visibility.IsSet)
                        parseQueryStringLocalVar["visibility"] = ClientUtils.ParameterToString(visibility.Value);

                    if (preliminaryGroups.IsSet)
                        parseQueryStringLocalVar["preliminaryGroups"] = ClientUtils.ParameterToString(preliminaryGroups.Value);

                    if (preliminaryGroupAdvancements.IsSet)
                        parseQueryStringLocalVar["preliminaryGroupAdvancements"] = ClientUtils.ParameterToString(preliminaryGroupAdvancements.Value);

                    if (enableMultipleEntries.IsSet)
                        parseQueryStringLocalVar["enableMultipleEntries"] = ClientUtils.ParameterToString(enableMultipleEntries.Value);

                    if (enableMultipleVotes.IsSet)
                        parseQueryStringLocalVar["enableMultipleVotes"] = ClientUtils.ParameterToString(enableMultipleVotes.Value);

                    if (featured.IsSet)
                        parseQueryStringLocalVar["featured"] = ClientUtils.ParameterToString(featured.Value);

                    if (winnerTag.IsSet)
                        parseQueryStringLocalVar["winnerTag"] = ClientUtils.ParameterToString(winnerTag.Value);

                    if (tieTag.IsSet)
                        parseQueryStringLocalVar["tieTag"] = ClientUtils.ParameterToString(tieTag.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateTournamentApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateTournamentApiResponse>();
                        CreateTournamentApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/tournament/create", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateTournamentDefaultImplementation(apiResponseLocalVar, accountId, appKey, title, costToPlay, startDate, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, missionType, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag);

                        Events.ExecuteOnCreateTournament(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateTournamentDefaultImplementation(e, "/tournament/create", uriBuilderLocalVar.Path, accountId, appKey, title, costToPlay, startDate, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, missionType, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag);
                Events.ExecuteOnErrorCreateTournament(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateTournamentApiResponse"/>
        /// </summary>
        public partial class CreateTournamentApiResponse : Org.OpenAPITools.Client.ApiResponse, ICreateTournamentApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateTournamentApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateTournamentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateTournamentApiResponse(ILogger<CreateTournamentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateTournamentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateTournamentApiResponse(ILogger<CreateTournamentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TournamentResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TournamentResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TournamentResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteTournament(ref long accountId, ref long missionId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="missionId"></param>
        private void AfterDeleteTournamentDefaultImplementation(IDeleteTournamentApiResponse apiResponseLocalVar, long accountId, long missionId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteTournament(ref suppressDefaultLog, apiResponseLocalVar, accountId, missionId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="missionId"></param>
        partial void AfterDeleteTournament(ref bool suppressDefaultLog, IDeleteTournamentApiResponse apiResponseLocalVar, long accountId, long missionId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="missionId"></param>
        private void OnErrorDeleteTournamentDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long missionId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteTournament(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, missionId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="missionId"></param>
        partial void OnErrorDeleteTournament(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long missionId);

        /// <summary>
        /// Delete Tournament Delete a tournament.
        /// </summary>
        /// <param name="accountId">the id of the logged in user</param>
        /// <param name="missionId">the id of the mission to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTournamentApiResponse"/>&gt;</returns>
        public async Task<IDeleteTournamentApiResponse?> DeleteTournamentOrDefaultAsync(long accountId, long missionId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteTournamentAsync(accountId, missionId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete Tournament Delete a tournament.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the id of the logged in user</param>
        /// <param name="missionId">the id of the mission to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTournamentApiResponse"/>&gt;</returns>
        public async Task<IDeleteTournamentApiResponse> DeleteTournamentAsync(long accountId, long missionId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeleteTournament(ref accountId, ref missionId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/tournament/delete"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/tournament/delete");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["missionId"] = ClientUtils.ParameterToString(missionId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DeleteTournamentApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteTournamentApiResponse>();
                        DeleteTournamentApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/tournament/delete", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDeleteTournamentDefaultImplementation(apiResponseLocalVar, accountId, missionId);

                        Events.ExecuteOnDeleteTournament(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteTournamentDefaultImplementation(e, "/tournament/delete", uriBuilderLocalVar.Path, accountId, missionId);
                Events.ExecuteOnErrorDeleteTournament(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteTournamentApiResponse"/>
        /// </summary>
        public partial class DeleteTournamentApiResponse : Org.OpenAPITools.Client.ApiResponse, IDeleteTournamentApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteTournamentApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteTournamentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteTournamentApiResponse(ILogger<DeleteTournamentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DeleteTournamentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteTournamentApiResponse(ILogger<DeleteTournamentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetTournament(ref long accountId, ref Option<long> missionId, ref Option<string> joinCode, ref Option<string> includeScores, ref Option<int> objectPreviewSize);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="joinCode"></param>
        /// <param name="includeScores"></param>
        /// <returns></returns>
        private void ValidateGetTournament(Option<string> joinCode, Option<string> includeScores)
        {
            if (joinCode.IsSet && joinCode.Value == null)
                throw new ArgumentNullException(nameof(joinCode));

            if (includeScores.IsSet && includeScores.Value == null)
                throw new ArgumentNullException(nameof(includeScores));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="missionId"></param>
        /// <param name="joinCode"></param>
        /// <param name="includeScores"></param>
        /// <param name="objectPreviewSize"></param>
        private void AfterGetTournamentDefaultImplementation(IGetTournamentApiResponse apiResponseLocalVar, long accountId, Option<long> missionId, Option<string> joinCode, Option<string> includeScores, Option<int> objectPreviewSize)
        {
            bool suppressDefaultLog = false;
            AfterGetTournament(ref suppressDefaultLog, apiResponseLocalVar, accountId, missionId, joinCode, includeScores, objectPreviewSize);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="missionId"></param>
        /// <param name="joinCode"></param>
        /// <param name="includeScores"></param>
        /// <param name="objectPreviewSize"></param>
        partial void AfterGetTournament(ref bool suppressDefaultLog, IGetTournamentApiResponse apiResponseLocalVar, long accountId, Option<long> missionId, Option<string> joinCode, Option<string> includeScores, Option<int> objectPreviewSize);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="missionId"></param>
        /// <param name="joinCode"></param>
        /// <param name="includeScores"></param>
        /// <param name="objectPreviewSize"></param>
        private void OnErrorGetTournamentDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, Option<long> missionId, Option<string> joinCode, Option<string> includeScores, Option<int> objectPreviewSize)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetTournament(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, missionId, joinCode, includeScores, objectPreviewSize);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="missionId"></param>
        /// <param name="joinCode"></param>
        /// <param name="includeScores"></param>
        /// <param name="objectPreviewSize"></param>
        partial void OnErrorGetTournament(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, Option<long> missionId, Option<string> joinCode, Option<string> includeScores, Option<int> objectPreviewSize);

        /// <summary>
        /// Get Tournament Get a tournament.
        /// </summary>
        /// <param name="accountId">The id of the logged in user</param>
        /// <param name="missionId">The id of the mission to return (either missionId or joinCode is required) (optional)</param>
        /// <param name="joinCode">Optional identifier for getting the tournament (either missionId or joinCode is required) (optional)</param>
        /// <param name="includeScores">Determines which type of scores are returned. Possible values include: ALL, MINE (optional)</param>
        /// <param name="objectPreviewSize">Determines the max number of game objects that will get returned for each game level response (optional, default to 50)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTournamentApiResponse"/>&gt;</returns>
        public async Task<IGetTournamentApiResponse?> GetTournamentOrDefaultAsync(long accountId, Option<long> missionId = default, Option<string> joinCode = default, Option<string> includeScores = default, Option<int> objectPreviewSize = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetTournamentAsync(accountId, missionId, joinCode, includeScores, objectPreviewSize, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Tournament Get a tournament.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The id of the logged in user</param>
        /// <param name="missionId">The id of the mission to return (either missionId or joinCode is required) (optional)</param>
        /// <param name="joinCode">Optional identifier for getting the tournament (either missionId or joinCode is required) (optional)</param>
        /// <param name="includeScores">Determines which type of scores are returned. Possible values include: ALL, MINE (optional)</param>
        /// <param name="objectPreviewSize">Determines the max number of game objects that will get returned for each game level response (optional, default to 50)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTournamentApiResponse"/>&gt;</returns>
        public async Task<IGetTournamentApiResponse> GetTournamentAsync(long accountId, Option<long> missionId = default, Option<string> joinCode = default, Option<string> includeScores = default, Option<int> objectPreviewSize = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetTournament(joinCode, includeScores);

                FormatGetTournament(ref accountId, ref missionId, ref joinCode, ref includeScores, ref objectPreviewSize);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/tournament/get"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/tournament/get");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    if (missionId.IsSet)
                        parseQueryStringLocalVar["missionId"] = ClientUtils.ParameterToString(missionId.Value);

                    if (joinCode.IsSet)
                        parseQueryStringLocalVar["joinCode"] = ClientUtils.ParameterToString(joinCode.Value);

                    if (includeScores.IsSet)
                        parseQueryStringLocalVar["includeScores"] = ClientUtils.ParameterToString(includeScores.Value);

                    if (objectPreviewSize.IsSet)
                        parseQueryStringLocalVar["objectPreviewSize"] = ClientUtils.ParameterToString(objectPreviewSize.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetTournamentApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetTournamentApiResponse>();
                        GetTournamentApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/tournament/get", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetTournamentDefaultImplementation(apiResponseLocalVar, accountId, missionId, joinCode, includeScores, objectPreviewSize);

                        Events.ExecuteOnGetTournament(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetTournamentDefaultImplementation(e, "/tournament/get", uriBuilderLocalVar.Path, accountId, missionId, joinCode, includeScores, objectPreviewSize);
                Events.ExecuteOnErrorGetTournament(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetTournamentApiResponse"/>
        /// </summary>
        public partial class GetTournamentApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetTournamentApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetTournamentApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetTournamentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTournamentApiResponse(ILogger<GetTournamentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetTournamentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTournamentApiResponse(ILogger<GetTournamentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TournamentResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TournamentResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TournamentResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchObjects(ref long accountId, ref long gameLevelId, ref Option<string> sortField, ref Option<bool> descending, ref Option<int> start, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sortField"></param>
        /// <returns></returns>
        private void ValidateSearchObjects(Option<string> sortField)
        {
            if (sortField.IsSet && sortField.Value == null)
                throw new ArgumentNullException(nameof(sortField));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="gameLevelId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void AfterSearchObjectsDefaultImplementation(ISearchObjectsApiResponse apiResponseLocalVar, long accountId, long gameLevelId, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterSearchObjects(ref suppressDefaultLog, apiResponseLocalVar, accountId, gameLevelId, sortField, descending, start, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="gameLevelId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void AfterSearchObjects(ref bool suppressDefaultLog, ISearchObjectsApiResponse apiResponseLocalVar, long accountId, long gameLevelId, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="gameLevelId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void OnErrorSearchObjectsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long gameLevelId, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchObjects(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, gameLevelId, sortField, descending, start, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="gameLevelId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void OnErrorSearchObjects(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long gameLevelId, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit);

        /// <summary>
        /// Search Tournament Objects Search on game objects of tournaments
        /// </summary>
        /// <param name="accountId">the account ID</param>
        /// <param name="gameLevelId">the game level id to filter results by</param>
        /// <param name="sortField">the field to sort by (optional, default to PLAYER_SCORE_COUNT)</param>
        /// <param name="descending">determines whether the sorted list is in descending or ascending order (optional, default to true)</param>
        /// <param name="start">the start index for pagination (optional, default to 0)</param>
        /// <param name="limit">the limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchObjectsApiResponse"/>&gt;</returns>
        public async Task<ISearchObjectsApiResponse?> SearchObjectsOrDefaultAsync(long accountId, long gameLevelId, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchObjectsAsync(accountId, gameLevelId, sortField, descending, start, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Tournament Objects Search on game objects of tournaments
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the account ID</param>
        /// <param name="gameLevelId">the game level id to filter results by</param>
        /// <param name="sortField">the field to sort by (optional, default to PLAYER_SCORE_COUNT)</param>
        /// <param name="descending">determines whether the sorted list is in descending or ascending order (optional, default to true)</param>
        /// <param name="start">the start index for pagination (optional, default to 0)</param>
        /// <param name="limit">the limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchObjectsApiResponse"/>&gt;</returns>
        public async Task<ISearchObjectsApiResponse> SearchObjectsAsync(long accountId, long gameLevelId, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchObjects(sortField);

                FormatSearchObjects(ref accountId, ref gameLevelId, ref sortField, ref descending, ref start, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/tournament/object/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/tournament/object/search");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["gameLevelId"] = ClientUtils.ParameterToString(gameLevelId);

                    if (sortField.IsSet)
                        parseQueryStringLocalVar["sortField"] = ClientUtils.ParameterToString(sortField.Value);

                    if (descending.IsSet)
                        parseQueryStringLocalVar["descending"] = ClientUtils.ParameterToString(descending.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchObjectsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchObjectsApiResponse>();
                        SearchObjectsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/tournament/object/search", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchObjectsDefaultImplementation(apiResponseLocalVar, accountId, gameLevelId, sortField, descending, start, limit);

                        Events.ExecuteOnSearchObjects(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchObjectsDefaultImplementation(e, "/tournament/object/search", uriBuilderLocalVar.Path, accountId, gameLevelId, sortField, descending, start, limit);
                Events.ExecuteOnErrorSearchObjects(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchObjectsApiResponse"/>
        /// </summary>
        public partial class SearchObjectsApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchObjectsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchObjectsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchObjectsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchObjectsApiResponse(ILogger<SearchObjectsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchObjectsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchObjectsApiResponse(ILogger<SearchObjectsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchRounds(ref long accountId, ref string appKey, ref Option<string> status, ref Option<string> missionType, ref Option<bool> currentOnly, ref Option<string> visibilities, ref Option<int> start, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="appKey"></param>
        /// <param name="status"></param>
        /// <param name="missionType"></param>
        /// <param name="visibilities"></param>
        /// <returns></returns>
        private void ValidateSearchRounds(string appKey, Option<string> status, Option<string> missionType, Option<string> visibilities)
        {
            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));

            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status));

            if (missionType.IsSet && missionType.Value == null)
                throw new ArgumentNullException(nameof(missionType));

            if (visibilities.IsSet && visibilities.Value == null)
                throw new ArgumentNullException(nameof(visibilities));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="status"></param>
        /// <param name="missionType"></param>
        /// <param name="currentOnly"></param>
        /// <param name="visibilities"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void AfterSearchRoundsDefaultImplementation(ISearchRoundsApiResponse apiResponseLocalVar, long accountId, string appKey, Option<string> status, Option<string> missionType, Option<bool> currentOnly, Option<string> visibilities, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterSearchRounds(ref suppressDefaultLog, apiResponseLocalVar, accountId, appKey, status, missionType, currentOnly, visibilities, start, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="status"></param>
        /// <param name="missionType"></param>
        /// <param name="currentOnly"></param>
        /// <param name="visibilities"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void AfterSearchRounds(ref bool suppressDefaultLog, ISearchRoundsApiResponse apiResponseLocalVar, long accountId, string appKey, Option<string> status, Option<string> missionType, Option<bool> currentOnly, Option<string> visibilities, Option<int> start, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="status"></param>
        /// <param name="missionType"></param>
        /// <param name="currentOnly"></param>
        /// <param name="visibilities"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void OnErrorSearchRoundsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string appKey, Option<string> status, Option<string> missionType, Option<bool> currentOnly, Option<string> visibilities, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchRounds(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, appKey, status, missionType, currentOnly, visibilities, start, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="status"></param>
        /// <param name="missionType"></param>
        /// <param name="currentOnly"></param>
        /// <param name="visibilities"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void OnErrorSearchRounds(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string appKey, Option<string> status, Option<string> missionType, Option<bool> currentOnly, Option<string> visibilities, Option<int> start, Option<int> limit);

        /// <summary>
        /// Search Tournament Rounds Search for the user&#39;s tournament games.
        /// </summary>
        /// <param name="accountId">the account ID</param>
        /// <param name="appKey">the application key</param>
        /// <param name="status">comma separated list of statuses to filter results by (optional, default to &quot;ACCEPTED,ACTIVE&quot;)</param>
        /// <param name="missionType">The style of tournament to search for, options are: TOURNAMENT, POOLPLAY (optional)</param>
        /// <param name="currentOnly">search for games that are flagged current only (optional, default to true)</param>
        /// <param name="visibilities">Filter tournament rounds by the mission visibility flag (optional, default to &quot;PUBLIC&quot;)</param>
        /// <param name="start">the start index for pagination (optional, default to 0)</param>
        /// <param name="limit">the limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchRoundsApiResponse"/>&gt;</returns>
        public async Task<ISearchRoundsApiResponse?> SearchRoundsOrDefaultAsync(long accountId, string appKey, Option<string> status = default, Option<string> missionType = default, Option<bool> currentOnly = default, Option<string> visibilities = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchRoundsAsync(accountId, appKey, status, missionType, currentOnly, visibilities, start, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Tournament Rounds Search for the user&#39;s tournament games.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the account ID</param>
        /// <param name="appKey">the application key</param>
        /// <param name="status">comma separated list of statuses to filter results by (optional, default to &quot;ACCEPTED,ACTIVE&quot;)</param>
        /// <param name="missionType">The style of tournament to search for, options are: TOURNAMENT, POOLPLAY (optional)</param>
        /// <param name="currentOnly">search for games that are flagged current only (optional, default to true)</param>
        /// <param name="visibilities">Filter tournament rounds by the mission visibility flag (optional, default to &quot;PUBLIC&quot;)</param>
        /// <param name="start">the start index for pagination (optional, default to 0)</param>
        /// <param name="limit">the limit for pagination (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchRoundsApiResponse"/>&gt;</returns>
        public async Task<ISearchRoundsApiResponse> SearchRoundsAsync(long accountId, string appKey, Option<string> status = default, Option<string> missionType = default, Option<bool> currentOnly = default, Option<string> visibilities = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchRounds(appKey, status, missionType, visibilities);

                FormatSearchRounds(ref accountId, ref appKey, ref status, ref missionType, ref currentOnly, ref visibilities, ref start, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/tournament/round/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/tournament/round/search");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey);

                    if (status.IsSet)
                        parseQueryStringLocalVar["status"] = ClientUtils.ParameterToString(status.Value);

                    if (missionType.IsSet)
                        parseQueryStringLocalVar["missionType"] = ClientUtils.ParameterToString(missionType.Value);

                    if (currentOnly.IsSet)
                        parseQueryStringLocalVar["currentOnly"] = ClientUtils.ParameterToString(currentOnly.Value);

                    if (visibilities.IsSet)
                        parseQueryStringLocalVar["visibilities"] = ClientUtils.ParameterToString(visibilities.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchRoundsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchRoundsApiResponse>();
                        SearchRoundsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/tournament/round/search", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchRoundsDefaultImplementation(apiResponseLocalVar, accountId, appKey, status, missionType, currentOnly, visibilities, start, limit);

                        Events.ExecuteOnSearchRounds(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchRoundsDefaultImplementation(e, "/tournament/round/search", uriBuilderLocalVar.Path, accountId, appKey, status, missionType, currentOnly, visibilities, start, limit);
                Events.ExecuteOnErrorSearchRounds(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchRoundsApiResponse"/>
        /// </summary>
        public partial class SearchRoundsApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchRoundsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchRoundsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchRoundsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchRoundsApiResponse(ILogger<SearchRoundsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchRoundsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchRoundsApiResponse(ILogger<SearchRoundsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchTournaments(ref long accountId, ref string appKey, ref Option<string> keyword, ref Option<string> subType, ref Option<bool> includeInactive, ref Option<string> missionTypes, ref Option<string> filter, ref Option<string> sortField, ref Option<bool> descending, ref Option<string> visibility, ref Option<int> start, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="appKey"></param>
        /// <param name="keyword"></param>
        /// <param name="subType"></param>
        /// <param name="missionTypes"></param>
        /// <param name="filter"></param>
        /// <param name="sortField"></param>
        /// <param name="visibility"></param>
        /// <returns></returns>
        private void ValidateSearchTournaments(string appKey, Option<string> keyword, Option<string> subType, Option<string> missionTypes, Option<string> filter, Option<string> sortField, Option<string> visibility)
        {
            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));

            if (keyword.IsSet && keyword.Value == null)
                throw new ArgumentNullException(nameof(keyword));

            if (subType.IsSet && subType.Value == null)
                throw new ArgumentNullException(nameof(subType));

            if (missionTypes.IsSet && missionTypes.Value == null)
                throw new ArgumentNullException(nameof(missionTypes));

            if (filter.IsSet && filter.Value == null)
                throw new ArgumentNullException(nameof(filter));

            if (sortField.IsSet && sortField.Value == null)
                throw new ArgumentNullException(nameof(sortField));

            if (visibility.IsSet && visibility.Value == null)
                throw new ArgumentNullException(nameof(visibility));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="keyword"></param>
        /// <param name="subType"></param>
        /// <param name="includeInactive"></param>
        /// <param name="missionTypes"></param>
        /// <param name="filter"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="visibility"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void AfterSearchTournamentsDefaultImplementation(ISearchTournamentsApiResponse apiResponseLocalVar, long accountId, string appKey, Option<string> keyword, Option<string> subType, Option<bool> includeInactive, Option<string> missionTypes, Option<string> filter, Option<string> sortField, Option<bool> descending, Option<string> visibility, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterSearchTournaments(ref suppressDefaultLog, apiResponseLocalVar, accountId, appKey, keyword, subType, includeInactive, missionTypes, filter, sortField, descending, visibility, start, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="keyword"></param>
        /// <param name="subType"></param>
        /// <param name="includeInactive"></param>
        /// <param name="missionTypes"></param>
        /// <param name="filter"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="visibility"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void AfterSearchTournaments(ref bool suppressDefaultLog, ISearchTournamentsApiResponse apiResponseLocalVar, long accountId, string appKey, Option<string> keyword, Option<string> subType, Option<bool> includeInactive, Option<string> missionTypes, Option<string> filter, Option<string> sortField, Option<bool> descending, Option<string> visibility, Option<int> start, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="keyword"></param>
        /// <param name="subType"></param>
        /// <param name="includeInactive"></param>
        /// <param name="missionTypes"></param>
        /// <param name="filter"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="visibility"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        private void OnErrorSearchTournamentsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string appKey, Option<string> keyword, Option<string> subType, Option<bool> includeInactive, Option<string> missionTypes, Option<string> filter, Option<string> sortField, Option<bool> descending, Option<string> visibility, Option<int> start, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchTournaments(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, appKey, keyword, subType, includeInactive, missionTypes, filter, sortField, descending, visibility, start, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="keyword"></param>
        /// <param name="subType"></param>
        /// <param name="includeInactive"></param>
        /// <param name="missionTypes"></param>
        /// <param name="filter"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="visibility"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        partial void OnErrorSearchTournaments(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string appKey, Option<string> keyword, Option<string> subType, Option<bool> includeInactive, Option<string> missionTypes, Option<string> filter, Option<string> sortField, Option<bool> descending, Option<string> visibility, Option<int> start, Option<int> limit);

        /// <summary>
        /// Search Tournaments Search for tournaments
        /// </summary>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="appKey">The application key</param>
        /// <param name="keyword">the keyword to search tournament on (optional)</param>
        /// <param name="subType">filter results by subType (optional)</param>
        /// <param name="includeInactive">whether to include inactives in the search or not (optional, default to false)</param>
        /// <param name="missionTypes">comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (optional, default to &quot;MULTISTAGE,TOURNAMENT,POOLPLAY&quot;)</param>
        /// <param name="filter">filter tournaments by the tournament&#39;s current state (optional, default to UPCOMING)</param>
        /// <param name="sortField">which field to sort on (optional, default to START_DATE)</param>
        /// <param name="descending">Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false. (optional)</param>
        /// <param name="visibility">Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (optional, default to &quot;PUBLIC&quot;)</param>
        /// <param name="start">Start the result set at some index. (optional, default to 0)</param>
        /// <param name="limit">Limit the result to some number (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchTournamentsApiResponse"/>&gt;</returns>
        public async Task<ISearchTournamentsApiResponse?> SearchTournamentsOrDefaultAsync(long accountId, string appKey, Option<string> keyword = default, Option<string> subType = default, Option<bool> includeInactive = default, Option<string> missionTypes = default, Option<string> filter = default, Option<string> sortField = default, Option<bool> descending = default, Option<string> visibility = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchTournamentsAsync(accountId, appKey, keyword, subType, includeInactive, missionTypes, filter, sortField, descending, visibility, start, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Tournaments Search for tournaments
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="appKey">The application key</param>
        /// <param name="keyword">the keyword to search tournament on (optional)</param>
        /// <param name="subType">filter results by subType (optional)</param>
        /// <param name="includeInactive">whether to include inactives in the search or not (optional, default to false)</param>
        /// <param name="missionTypes">comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (optional, default to &quot;MULTISTAGE,TOURNAMENT,POOLPLAY&quot;)</param>
        /// <param name="filter">filter tournaments by the tournament&#39;s current state (optional, default to UPCOMING)</param>
        /// <param name="sortField">which field to sort on (optional, default to START_DATE)</param>
        /// <param name="descending">Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false. (optional)</param>
        /// <param name="visibility">Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (optional, default to &quot;PUBLIC&quot;)</param>
        /// <param name="start">Start the result set at some index. (optional, default to 0)</param>
        /// <param name="limit">Limit the result to some number (optional, default to 20)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchTournamentsApiResponse"/>&gt;</returns>
        public async Task<ISearchTournamentsApiResponse> SearchTournamentsAsync(long accountId, string appKey, Option<string> keyword = default, Option<string> subType = default, Option<bool> includeInactive = default, Option<string> missionTypes = default, Option<string> filter = default, Option<string> sortField = default, Option<bool> descending = default, Option<string> visibility = default, Option<int> start = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchTournaments(appKey, keyword, subType, missionTypes, filter, sortField, visibility);

                FormatSearchTournaments(ref accountId, ref appKey, ref keyword, ref subType, ref includeInactive, ref missionTypes, ref filter, ref sortField, ref descending, ref visibility, ref start, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/tournament/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/tournament/search");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey);

                    if (keyword.IsSet)
                        parseQueryStringLocalVar["keyword"] = ClientUtils.ParameterToString(keyword.Value);

                    if (subType.IsSet)
                        parseQueryStringLocalVar["subType"] = ClientUtils.ParameterToString(subType.Value);

                    if (includeInactive.IsSet)
                        parseQueryStringLocalVar["includeInactive"] = ClientUtils.ParameterToString(includeInactive.Value);

                    if (missionTypes.IsSet)
                        parseQueryStringLocalVar["missionTypes"] = ClientUtils.ParameterToString(missionTypes.Value);

                    if (filter.IsSet)
                        parseQueryStringLocalVar["filter"] = ClientUtils.ParameterToString(filter.Value);

                    if (sortField.IsSet)
                        parseQueryStringLocalVar["sortField"] = ClientUtils.ParameterToString(sortField.Value);

                    if (descending.IsSet)
                        parseQueryStringLocalVar["descending"] = ClientUtils.ParameterToString(descending.Value);

                    if (visibility.IsSet)
                        parseQueryStringLocalVar["visibility"] = ClientUtils.ParameterToString(visibility.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchTournamentsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchTournamentsApiResponse>();
                        SearchTournamentsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/tournament/search", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchTournamentsDefaultImplementation(apiResponseLocalVar, accountId, appKey, keyword, subType, includeInactive, missionTypes, filter, sortField, descending, visibility, start, limit);

                        Events.ExecuteOnSearchTournaments(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchTournamentsDefaultImplementation(e, "/tournament/search", uriBuilderLocalVar.Path, accountId, appKey, keyword, subType, includeInactive, missionTypes, filter, sortField, descending, visibility, start, limit);
                Events.ExecuteOnErrorSearchTournaments(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchTournamentsApiResponse"/>
        /// </summary>
        public partial class SearchTournamentsApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchTournamentsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchTournamentsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchTournamentsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchTournamentsApiResponse(ILogger<SearchTournamentsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchTournamentsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchTournamentsApiResponse(ILogger<SearchTournamentsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.MissionShortResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.MissionShortResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.MissionShortResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSubmitTournamentScore(ref long accountId, ref string appKey, ref long missionId, ref long gameId, ref long packId, ref string scores, ref Option<long> gameLevelId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="appKey"></param>
        /// <param name="scores"></param>
        /// <returns></returns>
        private void ValidateSubmitTournamentScore(string appKey, string scores)
        {
            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));

            if (scores == null)
                throw new ArgumentNullException(nameof(scores));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="missionId"></param>
        /// <param name="gameId"></param>
        /// <param name="packId"></param>
        /// <param name="scores"></param>
        /// <param name="gameLevelId"></param>
        private void AfterSubmitTournamentScoreDefaultImplementation(ISubmitTournamentScoreApiResponse apiResponseLocalVar, long accountId, string appKey, long missionId, long gameId, long packId, string scores, Option<long> gameLevelId)
        {
            bool suppressDefaultLog = false;
            AfterSubmitTournamentScore(ref suppressDefaultLog, apiResponseLocalVar, accountId, appKey, missionId, gameId, packId, scores, gameLevelId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="missionId"></param>
        /// <param name="gameId"></param>
        /// <param name="packId"></param>
        /// <param name="scores"></param>
        /// <param name="gameLevelId"></param>
        partial void AfterSubmitTournamentScore(ref bool suppressDefaultLog, ISubmitTournamentScoreApiResponse apiResponseLocalVar, long accountId, string appKey, long missionId, long gameId, long packId, string scores, Option<long> gameLevelId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="missionId"></param>
        /// <param name="gameId"></param>
        /// <param name="packId"></param>
        /// <param name="scores"></param>
        /// <param name="gameLevelId"></param>
        private void OnErrorSubmitTournamentScoreDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string appKey, long missionId, long gameId, long packId, string scores, Option<long> gameLevelId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSubmitTournamentScore(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, appKey, missionId, gameId, packId, scores, gameLevelId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="missionId"></param>
        /// <param name="gameId"></param>
        /// <param name="packId"></param>
        /// <param name="scores"></param>
        /// <param name="gameLevelId"></param>
        partial void OnErrorSubmitTournamentScore(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string appKey, long missionId, long gameId, long packId, string scores, Option<long> gameLevelId);

        /// <summary>
        /// Submit Tournament Score Submit an array of scores for a tournament match. 
        /// </summary>
        /// <param name="accountId">The logged in user account ID.</param>
        /// <param name="appKey">The application key.</param>
        /// <param name="missionId">The missionId to score for</param>
        /// <param name="gameId">The gameId to score for</param>
        /// <param name="packId">The packId to score for</param>
        /// <param name="scores">a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60; </param>
        /// <param name="gameLevelId">The gameLevelId to score for (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISubmitTournamentScoreApiResponse"/>&gt;</returns>
        public async Task<ISubmitTournamentScoreApiResponse?> SubmitTournamentScoreOrDefaultAsync(long accountId, string appKey, long missionId, long gameId, long packId, string scores, Option<long> gameLevelId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SubmitTournamentScoreAsync(accountId, appKey, missionId, gameId, packId, scores, gameLevelId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Submit Tournament Score Submit an array of scores for a tournament match. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The logged in user account ID.</param>
        /// <param name="appKey">The application key.</param>
        /// <param name="missionId">The missionId to score for</param>
        /// <param name="gameId">The gameId to score for</param>
        /// <param name="packId">The packId to score for</param>
        /// <param name="scores">a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60; </param>
        /// <param name="gameLevelId">The gameLevelId to score for (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISubmitTournamentScoreApiResponse"/>&gt;</returns>
        public async Task<ISubmitTournamentScoreApiResponse> SubmitTournamentScoreAsync(long accountId, string appKey, long missionId, long gameId, long packId, string scores, Option<long> gameLevelId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSubmitTournamentScore(appKey, scores);

                FormatSubmitTournamentScore(ref accountId, ref appKey, ref missionId, ref gameId, ref packId, ref scores, ref gameLevelId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/tournament/score"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/tournament/score");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey);
                    parseQueryStringLocalVar["missionId"] = ClientUtils.ParameterToString(missionId);
                    parseQueryStringLocalVar["gameId"] = ClientUtils.ParameterToString(gameId);
                    parseQueryStringLocalVar["packId"] = ClientUtils.ParameterToString(packId);
                    parseQueryStringLocalVar["scores"] = ClientUtils.ParameterToString(scores);

                    if (gameLevelId.IsSet)
                        parseQueryStringLocalVar["gameLevelId"] = ClientUtils.ParameterToString(gameLevelId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SubmitTournamentScoreApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SubmitTournamentScoreApiResponse>();
                        SubmitTournamentScoreApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/tournament/score", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSubmitTournamentScoreDefaultImplementation(apiResponseLocalVar, accountId, appKey, missionId, gameId, packId, scores, gameLevelId);

                        Events.ExecuteOnSubmitTournamentScore(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSubmitTournamentScoreDefaultImplementation(e, "/tournament/score", uriBuilderLocalVar.Path, accountId, appKey, missionId, gameId, packId, scores, gameLevelId);
                Events.ExecuteOnErrorSubmitTournamentScore(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SubmitTournamentScoreApiResponse"/>
        /// </summary>
        public partial class SubmitTournamentScoreApiResponse : Org.OpenAPITools.Client.ApiResponse, ISubmitTournamentScoreApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SubmitTournamentScoreApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SubmitTournamentScoreApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SubmitTournamentScoreApiResponse(ILogger<SubmitTournamentScoreApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SubmitTournamentScoreApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SubmitTournamentScoreApiResponse(ILogger<SubmitTournamentScoreApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSubmitTournamentVote(ref long accountId, ref string appKey, ref long missionId, ref long gameObjectId, ref Option<string> deviceId, ref Option<bool> checkIfDeviceAlreadyVoted);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="appKey"></param>
        /// <param name="deviceId"></param>
        /// <returns></returns>
        private void ValidateSubmitTournamentVote(string appKey, Option<string> deviceId)
        {
            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));

            if (deviceId.IsSet && deviceId.Value == null)
                throw new ArgumentNullException(nameof(deviceId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="missionId"></param>
        /// <param name="gameObjectId"></param>
        /// <param name="deviceId"></param>
        /// <param name="checkIfDeviceAlreadyVoted"></param>
        private void AfterSubmitTournamentVoteDefaultImplementation(ISubmitTournamentVoteApiResponse apiResponseLocalVar, long accountId, string appKey, long missionId, long gameObjectId, Option<string> deviceId, Option<bool> checkIfDeviceAlreadyVoted)
        {
            bool suppressDefaultLog = false;
            AfterSubmitTournamentVote(ref suppressDefaultLog, apiResponseLocalVar, accountId, appKey, missionId, gameObjectId, deviceId, checkIfDeviceAlreadyVoted);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="missionId"></param>
        /// <param name="gameObjectId"></param>
        /// <param name="deviceId"></param>
        /// <param name="checkIfDeviceAlreadyVoted"></param>
        partial void AfterSubmitTournamentVote(ref bool suppressDefaultLog, ISubmitTournamentVoteApiResponse apiResponseLocalVar, long accountId, string appKey, long missionId, long gameObjectId, Option<string> deviceId, Option<bool> checkIfDeviceAlreadyVoted);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="missionId"></param>
        /// <param name="gameObjectId"></param>
        /// <param name="deviceId"></param>
        /// <param name="checkIfDeviceAlreadyVoted"></param>
        private void OnErrorSubmitTournamentVoteDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string appKey, long missionId, long gameObjectId, Option<string> deviceId, Option<bool> checkIfDeviceAlreadyVoted)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSubmitTournamentVote(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, appKey, missionId, gameObjectId, deviceId, checkIfDeviceAlreadyVoted);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="missionId"></param>
        /// <param name="gameObjectId"></param>
        /// <param name="deviceId"></param>
        /// <param name="checkIfDeviceAlreadyVoted"></param>
        partial void OnErrorSubmitTournamentVote(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string appKey, long missionId, long gameObjectId, Option<string> deviceId, Option<bool> checkIfDeviceAlreadyVoted);

        /// <summary>
        /// Submit a vote for a multi-stage album tournament. Submit a vote for a multi-stage album tournament.
        /// </summary>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="appKey">The application to target</param>
        /// <param name="missionId">The tournament&#39;s primary id</param>
        /// <param name="gameObjectId">The tournament game object the user wants to vote on</param>
        /// <param name="deviceId">The unique id of the device making the request (optional) (optional)</param>
        /// <param name="checkIfDeviceAlreadyVoted">When true, check if the device already voted to prevent duplicate votes from the same device (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISubmitTournamentVoteApiResponse"/>&gt;</returns>
        public async Task<ISubmitTournamentVoteApiResponse?> SubmitTournamentVoteOrDefaultAsync(long accountId, string appKey, long missionId, long gameObjectId, Option<string> deviceId = default, Option<bool> checkIfDeviceAlreadyVoted = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SubmitTournamentVoteAsync(accountId, appKey, missionId, gameObjectId, deviceId, checkIfDeviceAlreadyVoted, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Submit a vote for a multi-stage album tournament. Submit a vote for a multi-stage album tournament.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="appKey">The application to target</param>
        /// <param name="missionId">The tournament&#39;s primary id</param>
        /// <param name="gameObjectId">The tournament game object the user wants to vote on</param>
        /// <param name="deviceId">The unique id of the device making the request (optional) (optional)</param>
        /// <param name="checkIfDeviceAlreadyVoted">When true, check if the device already voted to prevent duplicate votes from the same device (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISubmitTournamentVoteApiResponse"/>&gt;</returns>
        public async Task<ISubmitTournamentVoteApiResponse> SubmitTournamentVoteAsync(long accountId, string appKey, long missionId, long gameObjectId, Option<string> deviceId = default, Option<bool> checkIfDeviceAlreadyVoted = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSubmitTournamentVote(appKey, deviceId);

                FormatSubmitTournamentVote(ref accountId, ref appKey, ref missionId, ref gameObjectId, ref deviceId, ref checkIfDeviceAlreadyVoted);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/tournament/vote"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/tournament/vote");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey);
                    parseQueryStringLocalVar["missionId"] = ClientUtils.ParameterToString(missionId);
                    parseQueryStringLocalVar["gameObjectId"] = ClientUtils.ParameterToString(gameObjectId);

                    if (deviceId.IsSet)
                        parseQueryStringLocalVar["deviceId"] = ClientUtils.ParameterToString(deviceId.Value);

                    if (checkIfDeviceAlreadyVoted.IsSet)
                        parseQueryStringLocalVar["checkIfDeviceAlreadyVoted"] = ClientUtils.ParameterToString(checkIfDeviceAlreadyVoted.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SubmitTournamentVoteApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SubmitTournamentVoteApiResponse>();
                        SubmitTournamentVoteApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/tournament/vote", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSubmitTournamentVoteDefaultImplementation(apiResponseLocalVar, accountId, appKey, missionId, gameObjectId, deviceId, checkIfDeviceAlreadyVoted);

                        Events.ExecuteOnSubmitTournamentVote(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSubmitTournamentVoteDefaultImplementation(e, "/tournament/vote", uriBuilderLocalVar.Path, accountId, appKey, missionId, gameObjectId, deviceId, checkIfDeviceAlreadyVoted);
                Events.ExecuteOnErrorSubmitTournamentVote(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SubmitTournamentVoteApiResponse"/>
        /// </summary>
        public partial class SubmitTournamentVoteApiResponse : Org.OpenAPITools.Client.ApiResponse, ISubmitTournamentVoteApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SubmitTournamentVoteApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SubmitTournamentVoteApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SubmitTournamentVoteApiResponse(ILogger<SubmitTournamentVoteApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SubmitTournamentVoteApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SubmitTournamentVoteApiResponse(ILogger<SubmitTournamentVoteApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSubstituteTournamentPlayer(ref long accountId, ref long missionId, ref long packId, ref long gameLevelId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="missionId"></param>
        /// <param name="packId"></param>
        /// <param name="gameLevelId"></param>
        private void AfterSubstituteTournamentPlayerDefaultImplementation(ISubstituteTournamentPlayerApiResponse apiResponseLocalVar, long accountId, long missionId, long packId, long gameLevelId)
        {
            bool suppressDefaultLog = false;
            AfterSubstituteTournamentPlayer(ref suppressDefaultLog, apiResponseLocalVar, accountId, missionId, packId, gameLevelId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="missionId"></param>
        /// <param name="packId"></param>
        /// <param name="gameLevelId"></param>
        partial void AfterSubstituteTournamentPlayer(ref bool suppressDefaultLog, ISubstituteTournamentPlayerApiResponse apiResponseLocalVar, long accountId, long missionId, long packId, long gameLevelId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="missionId"></param>
        /// <param name="packId"></param>
        /// <param name="gameLevelId"></param>
        private void OnErrorSubstituteTournamentPlayerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long missionId, long packId, long gameLevelId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSubstituteTournamentPlayer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, missionId, packId, gameLevelId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="missionId"></param>
        /// <param name="packId"></param>
        /// <param name="gameLevelId"></param>
        partial void OnErrorSubstituteTournamentPlayer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long missionId, long packId, long gameLevelId);

        /// <summary>
        /// Substitute Tournament Player Service to replace the user&#39;s opponent in the current level - pack - mission with an AI account.
        /// </summary>
        /// <param name="accountId">the id of the logged in user</param>
        /// <param name="missionId">the id of the mission</param>
        /// <param name="packId">the id of the pack</param>
        /// <param name="gameLevelId">the id of the game level</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISubstituteTournamentPlayerApiResponse"/>&gt;</returns>
        public async Task<ISubstituteTournamentPlayerApiResponse?> SubstituteTournamentPlayerOrDefaultAsync(long accountId, long missionId, long packId, long gameLevelId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SubstituteTournamentPlayerAsync(accountId, missionId, packId, gameLevelId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Substitute Tournament Player Service to replace the user&#39;s opponent in the current level - pack - mission with an AI account.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">the id of the logged in user</param>
        /// <param name="missionId">the id of the mission</param>
        /// <param name="packId">the id of the pack</param>
        /// <param name="gameLevelId">the id of the game level</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISubstituteTournamentPlayerApiResponse"/>&gt;</returns>
        public async Task<ISubstituteTournamentPlayerApiResponse> SubstituteTournamentPlayerAsync(long accountId, long missionId, long packId, long gameLevelId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatSubstituteTournamentPlayer(ref accountId, ref missionId, ref packId, ref gameLevelId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/tournament/substitute"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/tournament/substitute");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["missionId"] = ClientUtils.ParameterToString(missionId);
                    parseQueryStringLocalVar["packId"] = ClientUtils.ParameterToString(packId);
                    parseQueryStringLocalVar["gameLevelId"] = ClientUtils.ParameterToString(gameLevelId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SubstituteTournamentPlayerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SubstituteTournamentPlayerApiResponse>();
                        SubstituteTournamentPlayerApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/tournament/substitute", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSubstituteTournamentPlayerDefaultImplementation(apiResponseLocalVar, accountId, missionId, packId, gameLevelId);

                        Events.ExecuteOnSubstituteTournamentPlayer(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSubstituteTournamentPlayerDefaultImplementation(e, "/tournament/substitute", uriBuilderLocalVar.Path, accountId, missionId, packId, gameLevelId);
                Events.ExecuteOnErrorSubstituteTournamentPlayer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SubstituteTournamentPlayerApiResponse"/>
        /// </summary>
        public partial class SubstituteTournamentPlayerApiResponse : Org.OpenAPITools.Client.ApiResponse, ISubstituteTournamentPlayerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SubstituteTournamentPlayerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SubstituteTournamentPlayerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SubstituteTournamentPlayerApiResponse(ILogger<SubstituteTournamentPlayerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SubstituteTournamentPlayerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SubstituteTournamentPlayerApiResponse(ILogger<SubstituteTournamentPlayerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateTournament(ref long accountId, ref long missionId, ref Option<string> title, ref Option<string> subType, ref Option<long> imageAssetId, ref Option<int> secondsBetweenLevels, ref Option<int> secondsForTieBreaker, ref Option<int> secondsBetweenPacks, ref Option<int> maximumLevelLength, ref Option<int> costToPlay, ref Option<string> costToPlayType, ref Option<int> minimumToPlay, ref Option<int> startingLimit, ref Option<int> availableLimit, ref Option<string> description, ref Option<string> metaData, ref Option<long> startDate, ref Option<string> audienceIds, ref Option<bool> active, ref Option<bool> enableBuyBack, ref Option<string> offerIds, ref Option<long> offerAssetId, ref Option<bool> fixedReward, ref Option<string> splitReward, ref Option<bool> allocateTickets, ref Option<string> tournamentData, ref Option<string> visibility, ref Option<int> preliminaryGroups, ref Option<string> preliminaryGroupAdvancements, ref Option<bool> enableMultipleEntries, ref Option<bool> enableMultipleVotes, ref Option<bool> featured, ref Option<string> winnerTag, ref Option<string> tieTag);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="title"></param>
        /// <param name="subType"></param>
        /// <param name="costToPlayType"></param>
        /// <param name="description"></param>
        /// <param name="metaData"></param>
        /// <param name="audienceIds"></param>
        /// <param name="offerIds"></param>
        /// <param name="splitReward"></param>
        /// <param name="tournamentData"></param>
        /// <param name="visibility"></param>
        /// <param name="preliminaryGroupAdvancements"></param>
        /// <param name="winnerTag"></param>
        /// <param name="tieTag"></param>
        /// <returns></returns>
        private void ValidateUpdateTournament(Option<string> title, Option<string> subType, Option<string> costToPlayType, Option<string> description, Option<string> metaData, Option<string> audienceIds, Option<string> offerIds, Option<string> splitReward, Option<string> tournamentData, Option<string> visibility, Option<string> preliminaryGroupAdvancements, Option<string> winnerTag, Option<string> tieTag)
        {
            if (title.IsSet && title.Value == null)
                throw new ArgumentNullException(nameof(title));

            if (subType.IsSet && subType.Value == null)
                throw new ArgumentNullException(nameof(subType));

            if (costToPlayType.IsSet && costToPlayType.Value == null)
                throw new ArgumentNullException(nameof(costToPlayType));

            if (description.IsSet && description.Value == null)
                throw new ArgumentNullException(nameof(description));

            if (metaData.IsSet && metaData.Value == null)
                throw new ArgumentNullException(nameof(metaData));

            if (audienceIds.IsSet && audienceIds.Value == null)
                throw new ArgumentNullException(nameof(audienceIds));

            if (offerIds.IsSet && offerIds.Value == null)
                throw new ArgumentNullException(nameof(offerIds));

            if (splitReward.IsSet && splitReward.Value == null)
                throw new ArgumentNullException(nameof(splitReward));

            if (tournamentData.IsSet && tournamentData.Value == null)
                throw new ArgumentNullException(nameof(tournamentData));

            if (visibility.IsSet && visibility.Value == null)
                throw new ArgumentNullException(nameof(visibility));

            if (preliminaryGroupAdvancements.IsSet && preliminaryGroupAdvancements.Value == null)
                throw new ArgumentNullException(nameof(preliminaryGroupAdvancements));

            if (winnerTag.IsSet && winnerTag.Value == null)
                throw new ArgumentNullException(nameof(winnerTag));

            if (tieTag.IsSet && tieTag.Value == null)
                throw new ArgumentNullException(nameof(tieTag));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="missionId"></param>
        /// <param name="title"></param>
        /// <param name="subType"></param>
        /// <param name="imageAssetId"></param>
        /// <param name="secondsBetweenLevels"></param>
        /// <param name="secondsForTieBreaker"></param>
        /// <param name="secondsBetweenPacks"></param>
        /// <param name="maximumLevelLength"></param>
        /// <param name="costToPlay"></param>
        /// <param name="costToPlayType"></param>
        /// <param name="minimumToPlay"></param>
        /// <param name="startingLimit"></param>
        /// <param name="availableLimit"></param>
        /// <param name="description"></param>
        /// <param name="metaData"></param>
        /// <param name="startDate"></param>
        /// <param name="audienceIds"></param>
        /// <param name="active"></param>
        /// <param name="enableBuyBack"></param>
        /// <param name="offerIds"></param>
        /// <param name="offerAssetId"></param>
        /// <param name="fixedReward"></param>
        /// <param name="splitReward"></param>
        /// <param name="allocateTickets"></param>
        /// <param name="tournamentData"></param>
        /// <param name="visibility"></param>
        /// <param name="preliminaryGroups"></param>
        /// <param name="preliminaryGroupAdvancements"></param>
        /// <param name="enableMultipleEntries"></param>
        /// <param name="enableMultipleVotes"></param>
        /// <param name="featured"></param>
        /// <param name="winnerTag"></param>
        /// <param name="tieTag"></param>
        private void AfterUpdateTournamentDefaultImplementation(IUpdateTournamentApiResponse apiResponseLocalVar, long accountId, long missionId, Option<string> title, Option<string> subType, Option<long> imageAssetId, Option<int> secondsBetweenLevels, Option<int> secondsForTieBreaker, Option<int> secondsBetweenPacks, Option<int> maximumLevelLength, Option<int> costToPlay, Option<string> costToPlayType, Option<int> minimumToPlay, Option<int> startingLimit, Option<int> availableLimit, Option<string> description, Option<string> metaData, Option<long> startDate, Option<string> audienceIds, Option<bool> active, Option<bool> enableBuyBack, Option<string> offerIds, Option<long> offerAssetId, Option<bool> fixedReward, Option<string> splitReward, Option<bool> allocateTickets, Option<string> tournamentData, Option<string> visibility, Option<int> preliminaryGroups, Option<string> preliminaryGroupAdvancements, Option<bool> enableMultipleEntries, Option<bool> enableMultipleVotes, Option<bool> featured, Option<string> winnerTag, Option<string> tieTag)
        {
            bool suppressDefaultLog = false;
            AfterUpdateTournament(ref suppressDefaultLog, apiResponseLocalVar, accountId, missionId, title, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlay, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, startDate, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="missionId"></param>
        /// <param name="title"></param>
        /// <param name="subType"></param>
        /// <param name="imageAssetId"></param>
        /// <param name="secondsBetweenLevels"></param>
        /// <param name="secondsForTieBreaker"></param>
        /// <param name="secondsBetweenPacks"></param>
        /// <param name="maximumLevelLength"></param>
        /// <param name="costToPlay"></param>
        /// <param name="costToPlayType"></param>
        /// <param name="minimumToPlay"></param>
        /// <param name="startingLimit"></param>
        /// <param name="availableLimit"></param>
        /// <param name="description"></param>
        /// <param name="metaData"></param>
        /// <param name="startDate"></param>
        /// <param name="audienceIds"></param>
        /// <param name="active"></param>
        /// <param name="enableBuyBack"></param>
        /// <param name="offerIds"></param>
        /// <param name="offerAssetId"></param>
        /// <param name="fixedReward"></param>
        /// <param name="splitReward"></param>
        /// <param name="allocateTickets"></param>
        /// <param name="tournamentData"></param>
        /// <param name="visibility"></param>
        /// <param name="preliminaryGroups"></param>
        /// <param name="preliminaryGroupAdvancements"></param>
        /// <param name="enableMultipleEntries"></param>
        /// <param name="enableMultipleVotes"></param>
        /// <param name="featured"></param>
        /// <param name="winnerTag"></param>
        /// <param name="tieTag"></param>
        partial void AfterUpdateTournament(ref bool suppressDefaultLog, IUpdateTournamentApiResponse apiResponseLocalVar, long accountId, long missionId, Option<string> title, Option<string> subType, Option<long> imageAssetId, Option<int> secondsBetweenLevels, Option<int> secondsForTieBreaker, Option<int> secondsBetweenPacks, Option<int> maximumLevelLength, Option<int> costToPlay, Option<string> costToPlayType, Option<int> minimumToPlay, Option<int> startingLimit, Option<int> availableLimit, Option<string> description, Option<string> metaData, Option<long> startDate, Option<string> audienceIds, Option<bool> active, Option<bool> enableBuyBack, Option<string> offerIds, Option<long> offerAssetId, Option<bool> fixedReward, Option<string> splitReward, Option<bool> allocateTickets, Option<string> tournamentData, Option<string> visibility, Option<int> preliminaryGroups, Option<string> preliminaryGroupAdvancements, Option<bool> enableMultipleEntries, Option<bool> enableMultipleVotes, Option<bool> featured, Option<string> winnerTag, Option<string> tieTag);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="missionId"></param>
        /// <param name="title"></param>
        /// <param name="subType"></param>
        /// <param name="imageAssetId"></param>
        /// <param name="secondsBetweenLevels"></param>
        /// <param name="secondsForTieBreaker"></param>
        /// <param name="secondsBetweenPacks"></param>
        /// <param name="maximumLevelLength"></param>
        /// <param name="costToPlay"></param>
        /// <param name="costToPlayType"></param>
        /// <param name="minimumToPlay"></param>
        /// <param name="startingLimit"></param>
        /// <param name="availableLimit"></param>
        /// <param name="description"></param>
        /// <param name="metaData"></param>
        /// <param name="startDate"></param>
        /// <param name="audienceIds"></param>
        /// <param name="active"></param>
        /// <param name="enableBuyBack"></param>
        /// <param name="offerIds"></param>
        /// <param name="offerAssetId"></param>
        /// <param name="fixedReward"></param>
        /// <param name="splitReward"></param>
        /// <param name="allocateTickets"></param>
        /// <param name="tournamentData"></param>
        /// <param name="visibility"></param>
        /// <param name="preliminaryGroups"></param>
        /// <param name="preliminaryGroupAdvancements"></param>
        /// <param name="enableMultipleEntries"></param>
        /// <param name="enableMultipleVotes"></param>
        /// <param name="featured"></param>
        /// <param name="winnerTag"></param>
        /// <param name="tieTag"></param>
        private void OnErrorUpdateTournamentDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long missionId, Option<string> title, Option<string> subType, Option<long> imageAssetId, Option<int> secondsBetweenLevels, Option<int> secondsForTieBreaker, Option<int> secondsBetweenPacks, Option<int> maximumLevelLength, Option<int> costToPlay, Option<string> costToPlayType, Option<int> minimumToPlay, Option<int> startingLimit, Option<int> availableLimit, Option<string> description, Option<string> metaData, Option<long> startDate, Option<string> audienceIds, Option<bool> active, Option<bool> enableBuyBack, Option<string> offerIds, Option<long> offerAssetId, Option<bool> fixedReward, Option<string> splitReward, Option<bool> allocateTickets, Option<string> tournamentData, Option<string> visibility, Option<int> preliminaryGroups, Option<string> preliminaryGroupAdvancements, Option<bool> enableMultipleEntries, Option<bool> enableMultipleVotes, Option<bool> featured, Option<string> winnerTag, Option<string> tieTag)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateTournament(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, missionId, title, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlay, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, startDate, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="missionId"></param>
        /// <param name="title"></param>
        /// <param name="subType"></param>
        /// <param name="imageAssetId"></param>
        /// <param name="secondsBetweenLevels"></param>
        /// <param name="secondsForTieBreaker"></param>
        /// <param name="secondsBetweenPacks"></param>
        /// <param name="maximumLevelLength"></param>
        /// <param name="costToPlay"></param>
        /// <param name="costToPlayType"></param>
        /// <param name="minimumToPlay"></param>
        /// <param name="startingLimit"></param>
        /// <param name="availableLimit"></param>
        /// <param name="description"></param>
        /// <param name="metaData"></param>
        /// <param name="startDate"></param>
        /// <param name="audienceIds"></param>
        /// <param name="active"></param>
        /// <param name="enableBuyBack"></param>
        /// <param name="offerIds"></param>
        /// <param name="offerAssetId"></param>
        /// <param name="fixedReward"></param>
        /// <param name="splitReward"></param>
        /// <param name="allocateTickets"></param>
        /// <param name="tournamentData"></param>
        /// <param name="visibility"></param>
        /// <param name="preliminaryGroups"></param>
        /// <param name="preliminaryGroupAdvancements"></param>
        /// <param name="enableMultipleEntries"></param>
        /// <param name="enableMultipleVotes"></param>
        /// <param name="featured"></param>
        /// <param name="winnerTag"></param>
        /// <param name="tieTag"></param>
        partial void OnErrorUpdateTournament(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, long missionId, Option<string> title, Option<string> subType, Option<long> imageAssetId, Option<int> secondsBetweenLevels, Option<int> secondsForTieBreaker, Option<int> secondsBetweenPacks, Option<int> maximumLevelLength, Option<int> costToPlay, Option<string> costToPlayType, Option<int> minimumToPlay, Option<int> startingLimit, Option<int> availableLimit, Option<string> description, Option<string> metaData, Option<long> startDate, Option<string> audienceIds, Option<bool> active, Option<bool> enableBuyBack, Option<string> offerIds, Option<long> offerAssetId, Option<bool> fixedReward, Option<string> splitReward, Option<bool> allocateTickets, Option<string> tournamentData, Option<string> visibility, Option<int> preliminaryGroups, Option<string> preliminaryGroupAdvancements, Option<bool> enableMultipleEntries, Option<bool> enableMultipleVotes, Option<bool> featured, Option<string> winnerTag, Option<string> tieTag);

        /// <summary>
        /// Update Tournament Update a tournament.
        /// </summary>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="missionId">The mission/tournament to update</param>
        /// <param name="title">The title of the tournament (optional)</param>
        /// <param name="subType">Custom string client apps can use for searching/filtering missions (optional)</param>
        /// <param name="imageAssetId">The asset ID to attach to the tournament (optional)</param>
        /// <param name="secondsBetweenLevels">The number of seconds in between the start of each tournament game (optional)</param>
        /// <param name="secondsForTieBreaker">The number of seconds to extend the round end time in the case of a tie breaker (optional)</param>
        /// <param name="secondsBetweenPacks">The number of seconds in between the start of each tournament round (optional)</param>
        /// <param name="maximumLevelLength">The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional)</param>
        /// <param name="costToPlay">The number of tickets required to pay to enter the tournament (optional)</param>
        /// <param name="costToPlayType">The type of ticket required to pay (optional)</param>
        /// <param name="minimumToPlay">The minimum number of players required to sign up for the tournament to be played (optional)</param>
        /// <param name="startingLimit">The starting number of players for a tournament (filled with AI&#39;s) (optional)</param>
        /// <param name="availableLimit">The maximum number of players for a tournament (currently 128 but not enforced) (optional)</param>
        /// <param name="description">The description of the tournament (optional)</param>
        /// <param name="metaData">External custom client defined data (optional)</param>
        /// <param name="startDate">The date/time to start the tournament (optional)</param>
        /// <param name="audienceIds">The audiences associated with the tournament (optional)</param>
        /// <param name="active">Activate/deactivate the mission (optional)</param>
        /// <param name="enableBuyBack">Determines whether to allow players to buy back into a tournament (optional)</param>
        /// <param name="offerIds">The list of offers to give as a reward beyond the tickets (optional)</param>
        /// <param name="offerAssetId">The artwork ID to attach to the reward offer (optional)</param>
        /// <param name="fixedReward">If set then do not update the ticket reward, auto set to true if offerIds provided (optional)</param>
        /// <param name="splitReward">Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional)</param>
        /// <param name="allocateTickets">Flag to indicate owner should receive tickets for completed missions (optional)</param>
        /// <param name="tournamentData">A text based string that will be passed into each tournament setup to populate the content (optional)</param>
        /// <param name="visibility">Sets the visibility flag for the tournament (optional)</param>
        /// <param name="preliminaryGroups">The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional)</param>
        /// <param name="preliminaryGroupAdvancements">This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional)</param>
        /// <param name="enableMultipleEntries">This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional)</param>
        /// <param name="enableMultipleVotes">This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional)</param>
        /// <param name="featured">This determines whether the tournament is \&quot;featured\&quot; or not (optional)</param>
        /// <param name="winnerTag">This sets what analytic tag is used when a winner is determined (optional)</param>
        /// <param name="tieTag">This sets what analytic tag is used when a winner is determined (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTournamentApiResponse"/>&gt;</returns>
        public async Task<IUpdateTournamentApiResponse?> UpdateTournamentOrDefaultAsync(long accountId, long missionId, Option<string> title = default, Option<string> subType = default, Option<long> imageAssetId = default, Option<int> secondsBetweenLevels = default, Option<int> secondsForTieBreaker = default, Option<int> secondsBetweenPacks = default, Option<int> maximumLevelLength = default, Option<int> costToPlay = default, Option<string> costToPlayType = default, Option<int> minimumToPlay = default, Option<int> startingLimit = default, Option<int> availableLimit = default, Option<string> description = default, Option<string> metaData = default, Option<long> startDate = default, Option<string> audienceIds = default, Option<bool> active = default, Option<bool> enableBuyBack = default, Option<string> offerIds = default, Option<long> offerAssetId = default, Option<bool> fixedReward = default, Option<string> splitReward = default, Option<bool> allocateTickets = default, Option<string> tournamentData = default, Option<string> visibility = default, Option<int> preliminaryGroups = default, Option<string> preliminaryGroupAdvancements = default, Option<bool> enableMultipleEntries = default, Option<bool> enableMultipleVotes = default, Option<bool> featured = default, Option<string> winnerTag = default, Option<string> tieTag = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateTournamentAsync(accountId, missionId, title, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlay, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, startDate, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update Tournament Update a tournament.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="missionId">The mission/tournament to update</param>
        /// <param name="title">The title of the tournament (optional)</param>
        /// <param name="subType">Custom string client apps can use for searching/filtering missions (optional)</param>
        /// <param name="imageAssetId">The asset ID to attach to the tournament (optional)</param>
        /// <param name="secondsBetweenLevels">The number of seconds in between the start of each tournament game (optional)</param>
        /// <param name="secondsForTieBreaker">The number of seconds to extend the round end time in the case of a tie breaker (optional)</param>
        /// <param name="secondsBetweenPacks">The number of seconds in between the start of each tournament round (optional)</param>
        /// <param name="maximumLevelLength">The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional)</param>
        /// <param name="costToPlay">The number of tickets required to pay to enter the tournament (optional)</param>
        /// <param name="costToPlayType">The type of ticket required to pay (optional)</param>
        /// <param name="minimumToPlay">The minimum number of players required to sign up for the tournament to be played (optional)</param>
        /// <param name="startingLimit">The starting number of players for a tournament (filled with AI&#39;s) (optional)</param>
        /// <param name="availableLimit">The maximum number of players for a tournament (currently 128 but not enforced) (optional)</param>
        /// <param name="description">The description of the tournament (optional)</param>
        /// <param name="metaData">External custom client defined data (optional)</param>
        /// <param name="startDate">The date/time to start the tournament (optional)</param>
        /// <param name="audienceIds">The audiences associated with the tournament (optional)</param>
        /// <param name="active">Activate/deactivate the mission (optional)</param>
        /// <param name="enableBuyBack">Determines whether to allow players to buy back into a tournament (optional)</param>
        /// <param name="offerIds">The list of offers to give as a reward beyond the tickets (optional)</param>
        /// <param name="offerAssetId">The artwork ID to attach to the reward offer (optional)</param>
        /// <param name="fixedReward">If set then do not update the ticket reward, auto set to true if offerIds provided (optional)</param>
        /// <param name="splitReward">Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional)</param>
        /// <param name="allocateTickets">Flag to indicate owner should receive tickets for completed missions (optional)</param>
        /// <param name="tournamentData">A text based string that will be passed into each tournament setup to populate the content (optional)</param>
        /// <param name="visibility">Sets the visibility flag for the tournament (optional)</param>
        /// <param name="preliminaryGroups">The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional)</param>
        /// <param name="preliminaryGroupAdvancements">This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional)</param>
        /// <param name="enableMultipleEntries">This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional)</param>
        /// <param name="enableMultipleVotes">This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional)</param>
        /// <param name="featured">This determines whether the tournament is \&quot;featured\&quot; or not (optional)</param>
        /// <param name="winnerTag">This sets what analytic tag is used when a winner is determined (optional)</param>
        /// <param name="tieTag">This sets what analytic tag is used when a winner is determined (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTournamentApiResponse"/>&gt;</returns>
        public async Task<IUpdateTournamentApiResponse> UpdateTournamentAsync(long accountId, long missionId, Option<string> title = default, Option<string> subType = default, Option<long> imageAssetId = default, Option<int> secondsBetweenLevels = default, Option<int> secondsForTieBreaker = default, Option<int> secondsBetweenPacks = default, Option<int> maximumLevelLength = default, Option<int> costToPlay = default, Option<string> costToPlayType = default, Option<int> minimumToPlay = default, Option<int> startingLimit = default, Option<int> availableLimit = default, Option<string> description = default, Option<string> metaData = default, Option<long> startDate = default, Option<string> audienceIds = default, Option<bool> active = default, Option<bool> enableBuyBack = default, Option<string> offerIds = default, Option<long> offerAssetId = default, Option<bool> fixedReward = default, Option<string> splitReward = default, Option<bool> allocateTickets = default, Option<string> tournamentData = default, Option<string> visibility = default, Option<int> preliminaryGroups = default, Option<string> preliminaryGroupAdvancements = default, Option<bool> enableMultipleEntries = default, Option<bool> enableMultipleVotes = default, Option<bool> featured = default, Option<string> winnerTag = default, Option<string> tieTag = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateTournament(title, subType, costToPlayType, description, metaData, audienceIds, offerIds, splitReward, tournamentData, visibility, preliminaryGroupAdvancements, winnerTag, tieTag);

                FormatUpdateTournament(ref accountId, ref missionId, ref title, ref subType, ref imageAssetId, ref secondsBetweenLevels, ref secondsForTieBreaker, ref secondsBetweenPacks, ref maximumLevelLength, ref costToPlay, ref costToPlayType, ref minimumToPlay, ref startingLimit, ref availableLimit, ref description, ref metaData, ref startDate, ref audienceIds, ref active, ref enableBuyBack, ref offerIds, ref offerAssetId, ref fixedReward, ref splitReward, ref allocateTickets, ref tournamentData, ref visibility, ref preliminaryGroups, ref preliminaryGroupAdvancements, ref enableMultipleEntries, ref enableMultipleVotes, ref featured, ref winnerTag, ref tieTag);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/tournament/update"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/tournament/update");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["missionId"] = ClientUtils.ParameterToString(missionId);

                    if (title.IsSet)
                        parseQueryStringLocalVar["title"] = ClientUtils.ParameterToString(title.Value);

                    if (subType.IsSet)
                        parseQueryStringLocalVar["subType"] = ClientUtils.ParameterToString(subType.Value);

                    if (imageAssetId.IsSet)
                        parseQueryStringLocalVar["imageAssetId"] = ClientUtils.ParameterToString(imageAssetId.Value);

                    if (secondsBetweenLevels.IsSet)
                        parseQueryStringLocalVar["secondsBetweenLevels"] = ClientUtils.ParameterToString(secondsBetweenLevels.Value);

                    if (secondsForTieBreaker.IsSet)
                        parseQueryStringLocalVar["secondsForTieBreaker"] = ClientUtils.ParameterToString(secondsForTieBreaker.Value);

                    if (secondsBetweenPacks.IsSet)
                        parseQueryStringLocalVar["secondsBetweenPacks"] = ClientUtils.ParameterToString(secondsBetweenPacks.Value);

                    if (maximumLevelLength.IsSet)
                        parseQueryStringLocalVar["maximumLevelLength"] = ClientUtils.ParameterToString(maximumLevelLength.Value);

                    if (costToPlay.IsSet)
                        parseQueryStringLocalVar["costToPlay"] = ClientUtils.ParameterToString(costToPlay.Value);

                    if (costToPlayType.IsSet)
                        parseQueryStringLocalVar["costToPlayType"] = ClientUtils.ParameterToString(costToPlayType.Value);

                    if (minimumToPlay.IsSet)
                        parseQueryStringLocalVar["minimumToPlay"] = ClientUtils.ParameterToString(minimumToPlay.Value);

                    if (startingLimit.IsSet)
                        parseQueryStringLocalVar["startingLimit"] = ClientUtils.ParameterToString(startingLimit.Value);

                    if (availableLimit.IsSet)
                        parseQueryStringLocalVar["availableLimit"] = ClientUtils.ParameterToString(availableLimit.Value);

                    if (description.IsSet)
                        parseQueryStringLocalVar["description"] = ClientUtils.ParameterToString(description.Value);

                    if (metaData.IsSet)
                        parseQueryStringLocalVar["metaData"] = ClientUtils.ParameterToString(metaData.Value);

                    if (startDate.IsSet)
                        parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate.Value);

                    if (audienceIds.IsSet)
                        parseQueryStringLocalVar["audienceIds"] = ClientUtils.ParameterToString(audienceIds.Value);

                    if (active.IsSet)
                        parseQueryStringLocalVar["active"] = ClientUtils.ParameterToString(active.Value);

                    if (enableBuyBack.IsSet)
                        parseQueryStringLocalVar["enableBuyBack"] = ClientUtils.ParameterToString(enableBuyBack.Value);

                    if (offerIds.IsSet)
                        parseQueryStringLocalVar["offerIds"] = ClientUtils.ParameterToString(offerIds.Value);

                    if (offerAssetId.IsSet)
                        parseQueryStringLocalVar["offerAssetId"] = ClientUtils.ParameterToString(offerAssetId.Value);

                    if (fixedReward.IsSet)
                        parseQueryStringLocalVar["fixedReward"] = ClientUtils.ParameterToString(fixedReward.Value);

                    if (splitReward.IsSet)
                        parseQueryStringLocalVar["splitReward"] = ClientUtils.ParameterToString(splitReward.Value);

                    if (allocateTickets.IsSet)
                        parseQueryStringLocalVar["allocateTickets"] = ClientUtils.ParameterToString(allocateTickets.Value);

                    if (tournamentData.IsSet)
                        parseQueryStringLocalVar["tournamentData"] = ClientUtils.ParameterToString(tournamentData.Value);

                    if (visibility.IsSet)
                        parseQueryStringLocalVar["visibility"] = ClientUtils.ParameterToString(visibility.Value);

                    if (preliminaryGroups.IsSet)
                        parseQueryStringLocalVar["preliminaryGroups"] = ClientUtils.ParameterToString(preliminaryGroups.Value);

                    if (preliminaryGroupAdvancements.IsSet)
                        parseQueryStringLocalVar["preliminaryGroupAdvancements"] = ClientUtils.ParameterToString(preliminaryGroupAdvancements.Value);

                    if (enableMultipleEntries.IsSet)
                        parseQueryStringLocalVar["enableMultipleEntries"] = ClientUtils.ParameterToString(enableMultipleEntries.Value);

                    if (enableMultipleVotes.IsSet)
                        parseQueryStringLocalVar["enableMultipleVotes"] = ClientUtils.ParameterToString(enableMultipleVotes.Value);

                    if (featured.IsSet)
                        parseQueryStringLocalVar["featured"] = ClientUtils.ParameterToString(featured.Value);

                    if (winnerTag.IsSet)
                        parseQueryStringLocalVar["winnerTag"] = ClientUtils.ParameterToString(winnerTag.Value);

                    if (tieTag.IsSet)
                        parseQueryStringLocalVar["tieTag"] = ClientUtils.ParameterToString(tieTag.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UpdateTournamentApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateTournamentApiResponse>();
                        UpdateTournamentApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/tournament/update", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUpdateTournamentDefaultImplementation(apiResponseLocalVar, accountId, missionId, title, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlay, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, startDate, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag);

                        Events.ExecuteOnUpdateTournament(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateTournamentDefaultImplementation(e, "/tournament/update", uriBuilderLocalVar.Path, accountId, missionId, title, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlay, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, startDate, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag);
                Events.ExecuteOnErrorUpdateTournament(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateTournamentApiResponse"/>
        /// </summary>
        public partial class UpdateTournamentApiResponse : Org.OpenAPITools.Client.ApiResponse, IUpdateTournamentApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateTournamentApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateTournamentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateTournamentApiResponse(ILogger<UpdateTournamentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UpdateTournamentApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateTournamentApiResponse(ILogger<UpdateTournamentApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TournamentResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TournamentResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TournamentResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
