// <auto-generated>
/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Net;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IPackApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        PackApiEvents Events { get; }

        /// <summary>
        /// Create Pack
        /// </summary>
        /// <remarks>
        /// Create a pack.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="title">The title of the pack</param>
        /// <param name="packOrder">The order of the pack</param>
        /// <param name="price">The price in tickets to purchase this pack</param>
        /// <param name="highest">The scoring is highest is best</param>
        /// <param name="allocateTickets">Flag to indicate owner should receive tickets for completed packs</param>
        /// <param name="ticketCount">The number of tickets to reward</param>
        /// <param name="description">The description of the pack (optional)</param>
        /// <param name="searchTags">The tags for searching the pack, comma separated (optional)</param>
        /// <param name="active">Activate/deactivate the pack (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">The application key used to identify the application (optional)</param>
        /// <param name="packType">The type of the pack (optional)</param>
        /// <param name="sequenceType">The type of game sequence of the pack (optional)</param>
        /// <param name="backgroundId">The background asset id of the pack (optional)</param>
        /// <param name="imageId">The image asset id of the pack (optional)</param>
        /// <param name="startDate">The date/time to start the pack, send 0 to unset (optional)</param>
        /// <param name="endDate">The date/time to end the pack, send 0 to unset (optional)</param>
        /// <param name="authorOverride"> (optional)</param>
        /// <param name="priceType">the type of ticket required to purchase this pack (optional)</param>
        /// <param name="gameLevelIds">the game level ids to include in the pack, comma separated (optional)</param>
        /// <param name="inGame"> (optional)</param>
        /// <param name="ticketType">The type of ticket to reward, null means default type (optional)</param>
        /// <param name="points">The number of points to award for completing a pack (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreatePackApiResponse"/>&gt;</returns>
        Task<ICreatePackApiResponse> CreatePackAsync(decimal version, long accountId, string title, long packOrder, int price, bool highest, bool allocateTickets, long ticketCount, Option<string> description = default, Option<string> searchTags = default, Option<bool> active = default, Option<string> gameType = default, Option<string> appKey = default, Option<string> packType = default, Option<string> sequenceType = default, Option<long> backgroundId = default, Option<long> imageId = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> authorOverride = default, Option<string> priceType = default, Option<string> gameLevelIds = default, Option<bool> inGame = default, Option<string> ticketType = default, Option<long> points = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Pack
        /// </summary>
        /// <remarks>
        /// Create a pack.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="title">The title of the pack</param>
        /// <param name="packOrder">The order of the pack</param>
        /// <param name="price">The price in tickets to purchase this pack</param>
        /// <param name="highest">The scoring is highest is best</param>
        /// <param name="allocateTickets">Flag to indicate owner should receive tickets for completed packs</param>
        /// <param name="ticketCount">The number of tickets to reward</param>
        /// <param name="description">The description of the pack (optional)</param>
        /// <param name="searchTags">The tags for searching the pack, comma separated (optional)</param>
        /// <param name="active">Activate/deactivate the pack (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">The application key used to identify the application (optional)</param>
        /// <param name="packType">The type of the pack (optional)</param>
        /// <param name="sequenceType">The type of game sequence of the pack (optional)</param>
        /// <param name="backgroundId">The background asset id of the pack (optional)</param>
        /// <param name="imageId">The image asset id of the pack (optional)</param>
        /// <param name="startDate">The date/time to start the pack, send 0 to unset (optional)</param>
        /// <param name="endDate">The date/time to end the pack, send 0 to unset (optional)</param>
        /// <param name="authorOverride"> (optional)</param>
        /// <param name="priceType">the type of ticket required to purchase this pack (optional)</param>
        /// <param name="gameLevelIds">the game level ids to include in the pack, comma separated (optional)</param>
        /// <param name="inGame"> (optional)</param>
        /// <param name="ticketType">The type of ticket to reward, null means default type (optional)</param>
        /// <param name="points">The number of points to award for completing a pack (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreatePackApiResponse"/>?&gt;</returns>
        Task<ICreatePackApiResponse?> CreatePackOrDefaultAsync(decimal version, long accountId, string title, long packOrder, int price, bool highest, bool allocateTickets, long ticketCount, Option<string> description = default, Option<string> searchTags = default, Option<bool> active = default, Option<string> gameType = default, Option<string> appKey = default, Option<string> packType = default, Option<string> sequenceType = default, Option<long> backgroundId = default, Option<long> imageId = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> authorOverride = default, Option<string> priceType = default, Option<string> gameLevelIds = default, Option<bool> inGame = default, Option<string> ticketType = default, Option<long> points = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Pack
        /// </summary>
        /// <remarks>
        /// Delete a pack.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">the id of the logged in user</param>
        /// <param name="packId">the id of the pack to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeletePackApiResponse"/>&gt;</returns>
        Task<IDeletePackApiResponse> DeletePackAsync(decimal version, long accountId, long packId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Pack
        /// </summary>
        /// <remarks>
        /// Delete a pack.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">the id of the logged in user</param>
        /// <param name="packId">the id of the pack to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeletePackApiResponse"/>?&gt;</returns>
        Task<IDeletePackApiResponse?> DeletePackOrDefaultAsync(decimal version, long accountId, long packId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Pack
        /// </summary>
        /// <remarks>
        /// Get a pack.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="packId">The id of the pack to return.</param>
        /// <param name="includeGameData">If true include the game level data, otherwise don&#39;t. default is false.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPackApiResponse"/>&gt;</returns>
        Task<IGetPackApiResponse> GetPackAsync(decimal version, long accountId, long packId, bool includeGameData, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Pack
        /// </summary>
        /// <remarks>
        /// Get a pack.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="packId">The id of the pack to return.</param>
        /// <param name="includeGameData">If true include the game level data, otherwise don&#39;t. default is false.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPackApiResponse"/>?&gt;</returns>
        Task<IGetPackApiResponse?> GetPackOrDefaultAsync(decimal version, long accountId, long packId, bool includeGameData, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Packs
        /// </summary>
        /// <remarks>
        /// Search on packs.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="sortField">The field to sort by. Possible values include: TITLE, DESCRIPTION, CREATED, UPDATED</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order</param>
        /// <param name="keyword">Keyword search on the pack name (optional)</param>
        /// <param name="packType">Filters results on pack type (optional)</param>
        /// <param name="start">Start the result set at some index. (optional)</param>
        /// <param name="limit">Limit the result to some number. (optional)</param>
        /// <param name="includeGameData">Determines whether to include game data in the results (optional)</param>
        /// <param name="includeInactive">Determines whether to include inactive results (optional)</param>
        /// <param name="appKey">The application to filter results on (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPacksApiResponse"/>&gt;</returns>
        Task<ISearchPacksApiResponse> SearchPacksAsync(decimal version, long accountId, string sortField, bool descending, Option<string> keyword = default, Option<string> packType = default, Option<int> start = default, Option<int> limit = default, Option<bool> includeGameData = default, Option<bool> includeInactive = default, Option<string> appKey = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Packs
        /// </summary>
        /// <remarks>
        /// Search on packs.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="sortField">The field to sort by. Possible values include: TITLE, DESCRIPTION, CREATED, UPDATED</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order</param>
        /// <param name="keyword">Keyword search on the pack name (optional)</param>
        /// <param name="packType">Filters results on pack type (optional)</param>
        /// <param name="start">Start the result set at some index. (optional)</param>
        /// <param name="limit">Limit the result to some number. (optional)</param>
        /// <param name="includeGameData">Determines whether to include game data in the results (optional)</param>
        /// <param name="includeInactive">Determines whether to include inactive results (optional)</param>
        /// <param name="appKey">The application to filter results on (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPacksApiResponse"/>?&gt;</returns>
        Task<ISearchPacksApiResponse?> SearchPacksOrDefaultAsync(decimal version, long accountId, string sortField, bool descending, Option<string> keyword = default, Option<string> packType = default, Option<int> start = default, Option<int> limit = default, Option<bool> includeGameData = default, Option<bool> includeInactive = default, Option<string> appKey = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Pack
        /// </summary>
        /// <remarks>
        /// Update a pack.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="packId">The id of the pack to update.</param>
        /// <param name="allocateTickets">Flag to indicate owner should receive tickets for completed packs</param>
        /// <param name="ticketCount">The number of tickets to reward</param>
        /// <param name="title">The title of the pack (optional)</param>
        /// <param name="description">The description of the pack (optional)</param>
        /// <param name="searchTags">The tags for searching the pack, comma separated (optional)</param>
        /// <param name="active">Activate/deactivate the pack (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">The application key used to identify the application (optional)</param>
        /// <param name="packType">The type of the pack (optional)</param>
        /// <param name="packOrder">The order of the pack (optional)</param>
        /// <param name="sequenceType">The type of game sequence of the pack (optional)</param>
        /// <param name="backgroundId">The background asset id of the pack (optional)</param>
        /// <param name="imageId">The image asset id of the pack (optional)</param>
        /// <param name="startDate">The date/time to start the pack, send 0 to unset (optional)</param>
        /// <param name="endDate">The date/time to end the pack, send 0 to unset (optional)</param>
        /// <param name="authorOverride"> (optional)</param>
        /// <param name="price">The price in tickets to purchase this pack (optional)</param>
        /// <param name="priceType">the type of ticket required to purchase this pack (optional)</param>
        /// <param name="gameLevelIds">the game level ids to include in the pack, comma separated (optional)</param>
        /// <param name="inGame"> (optional)</param>
        /// <param name="highest">The scoring is highest is best (optional)</param>
        /// <param name="ticketType">The type of ticket to reward, null means default type (optional)</param>
        /// <param name="points">The number of points to award for completing a pack (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdatePackApiResponse"/>&gt;</returns>
        Task<IUpdatePackApiResponse> UpdatePackAsync(decimal version, long accountId, long packId, bool allocateTickets, long ticketCount, Option<string> title = default, Option<string> description = default, Option<string> searchTags = default, Option<bool> active = default, Option<string> gameType = default, Option<string> appKey = default, Option<string> packType = default, Option<long> packOrder = default, Option<string> sequenceType = default, Option<long> backgroundId = default, Option<long> imageId = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> authorOverride = default, Option<int> price = default, Option<string> priceType = default, Option<string> gameLevelIds = default, Option<bool> inGame = default, Option<bool> highest = default, Option<string> ticketType = default, Option<long> points = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Pack
        /// </summary>
        /// <remarks>
        /// Update a pack.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="packId">The id of the pack to update.</param>
        /// <param name="allocateTickets">Flag to indicate owner should receive tickets for completed packs</param>
        /// <param name="ticketCount">The number of tickets to reward</param>
        /// <param name="title">The title of the pack (optional)</param>
        /// <param name="description">The description of the pack (optional)</param>
        /// <param name="searchTags">The tags for searching the pack, comma separated (optional)</param>
        /// <param name="active">Activate/deactivate the pack (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">The application key used to identify the application (optional)</param>
        /// <param name="packType">The type of the pack (optional)</param>
        /// <param name="packOrder">The order of the pack (optional)</param>
        /// <param name="sequenceType">The type of game sequence of the pack (optional)</param>
        /// <param name="backgroundId">The background asset id of the pack (optional)</param>
        /// <param name="imageId">The image asset id of the pack (optional)</param>
        /// <param name="startDate">The date/time to start the pack, send 0 to unset (optional)</param>
        /// <param name="endDate">The date/time to end the pack, send 0 to unset (optional)</param>
        /// <param name="authorOverride"> (optional)</param>
        /// <param name="price">The price in tickets to purchase this pack (optional)</param>
        /// <param name="priceType">the type of ticket required to purchase this pack (optional)</param>
        /// <param name="gameLevelIds">the game level ids to include in the pack, comma separated (optional)</param>
        /// <param name="inGame"> (optional)</param>
        /// <param name="highest">The scoring is highest is best (optional)</param>
        /// <param name="ticketType">The type of ticket to reward, null means default type (optional)</param>
        /// <param name="points">The number of points to award for completing a pack (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdatePackApiResponse"/>?&gt;</returns>
        Task<IUpdatePackApiResponse?> UpdatePackOrDefaultAsync(decimal version, long accountId, long packId, bool allocateTickets, long ticketCount, Option<string> title = default, Option<string> description = default, Option<string> searchTags = default, Option<bool> active = default, Option<string> gameType = default, Option<string> appKey = default, Option<string> packType = default, Option<long> packOrder = default, Option<string> sequenceType = default, Option<long> backgroundId = default, Option<long> imageId = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> authorOverride = default, Option<int> price = default, Option<string> priceType = default, Option<string> gameLevelIds = default, Option<bool> inGame = default, Option<bool> highest = default, Option<string> ticketType = default, Option<long> points = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICreatePackApiResponse"/>
    /// </summary>
    public interface ICreatePackApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.PackResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IDeletePackApiResponse"/>
    /// </summary>
    public interface IDeletePackApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetPackApiResponse"/>
    /// </summary>
    public interface IGetPackApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.PackResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchPacksApiResponse"/>
    /// </summary>
    public interface ISearchPacksApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<PackResponse>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUpdatePackApiResponse"/>
    /// </summary>
    public interface IUpdatePackApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.PackResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class PackApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreatePack;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreatePack;

        internal void ExecuteOnCreatePack(PackApi.CreatePackApiResponse apiResponse)
        {
            OnCreatePack?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreatePack(Exception exception)
        {
            OnErrorCreatePack?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeletePack;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeletePack;

        internal void ExecuteOnDeletePack(PackApi.DeletePackApiResponse apiResponse)
        {
            OnDeletePack?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeletePack(Exception exception)
        {
            OnErrorDeletePack?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetPack;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetPack;

        internal void ExecuteOnGetPack(PackApi.GetPackApiResponse apiResponse)
        {
            OnGetPack?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetPack(Exception exception)
        {
            OnErrorGetPack?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchPacks;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchPacks;

        internal void ExecuteOnSearchPacks(PackApi.SearchPacksApiResponse apiResponse)
        {
            OnSearchPacks?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchPacks(Exception exception)
        {
            OnErrorSearchPacks?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdatePack;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdatePack;

        internal void ExecuteOnUpdatePack(PackApi.UpdatePackApiResponse apiResponse)
        {
            OnUpdatePack?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdatePack(Exception exception)
        {
            OnErrorUpdatePack?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class PackApi : IPackApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<PackApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public PackApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="PackApi"/> class.
        /// </summary>
        /// <returns></returns>
        public PackApi(ILogger<PackApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, PackApiEvents packApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<PackApi>();
            HttpClient = httpClient;
            Events = packApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatCreatePack(ref decimal version, ref long accountId, ref string title, ref long packOrder, ref int price, ref bool highest, ref bool allocateTickets, ref long ticketCount, ref Option<string> description, ref Option<string> searchTags, ref Option<bool> active, ref Option<string> gameType, ref Option<string> appKey, ref Option<string> packType, ref Option<string> sequenceType, ref Option<long> backgroundId, ref Option<long> imageId, ref Option<long> startDate, ref Option<long> endDate, ref Option<string> authorOverride, ref Option<string> priceType, ref Option<string> gameLevelIds, ref Option<bool> inGame, ref Option<string> ticketType, ref Option<long> points);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="title"></param>
        /// <param name="description"></param>
        /// <param name="searchTags"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="packType"></param>
        /// <param name="sequenceType"></param>
        /// <param name="authorOverride"></param>
        /// <param name="priceType"></param>
        /// <param name="gameLevelIds"></param>
        /// <param name="ticketType"></param>
        /// <returns></returns>
        private void ValidateCreatePack(string title, Option<string> description, Option<string> searchTags, Option<string> gameType, Option<string> appKey, Option<string> packType, Option<string> sequenceType, Option<string> authorOverride, Option<string> priceType, Option<string> gameLevelIds, Option<string> ticketType)
        {
            if (title == null)
                throw new ArgumentNullException(nameof(title));

            if (description.IsSet && description.Value == null)
                throw new ArgumentNullException(nameof(description));

            if (searchTags.IsSet && searchTags.Value == null)
                throw new ArgumentNullException(nameof(searchTags));

            if (gameType.IsSet && gameType.Value == null)
                throw new ArgumentNullException(nameof(gameType));

            if (appKey.IsSet && appKey.Value == null)
                throw new ArgumentNullException(nameof(appKey));

            if (packType.IsSet && packType.Value == null)
                throw new ArgumentNullException(nameof(packType));

            if (sequenceType.IsSet && sequenceType.Value == null)
                throw new ArgumentNullException(nameof(sequenceType));

            if (authorOverride.IsSet && authorOverride.Value == null)
                throw new ArgumentNullException(nameof(authorOverride));

            if (priceType.IsSet && priceType.Value == null)
                throw new ArgumentNullException(nameof(priceType));

            if (gameLevelIds.IsSet && gameLevelIds.Value == null)
                throw new ArgumentNullException(nameof(gameLevelIds));

            if (ticketType.IsSet && ticketType.Value == null)
                throw new ArgumentNullException(nameof(ticketType));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="title"></param>
        /// <param name="packOrder"></param>
        /// <param name="price"></param>
        /// <param name="highest"></param>
        /// <param name="allocateTickets"></param>
        /// <param name="ticketCount"></param>
        /// <param name="description"></param>
        /// <param name="searchTags"></param>
        /// <param name="active"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="packType"></param>
        /// <param name="sequenceType"></param>
        /// <param name="backgroundId"></param>
        /// <param name="imageId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="authorOverride"></param>
        /// <param name="priceType"></param>
        /// <param name="gameLevelIds"></param>
        /// <param name="inGame"></param>
        /// <param name="ticketType"></param>
        /// <param name="points"></param>
        private void AfterCreatePackDefaultImplementation(ICreatePackApiResponse apiResponseLocalVar, decimal version, long accountId, string title, long packOrder, int price, bool highest, bool allocateTickets, long ticketCount, Option<string> description, Option<string> searchTags, Option<bool> active, Option<string> gameType, Option<string> appKey, Option<string> packType, Option<string> sequenceType, Option<long> backgroundId, Option<long> imageId, Option<long> startDate, Option<long> endDate, Option<string> authorOverride, Option<string> priceType, Option<string> gameLevelIds, Option<bool> inGame, Option<string> ticketType, Option<long> points)
        {
            bool suppressDefaultLog = false;
            AfterCreatePack(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, title, packOrder, price, highest, allocateTickets, ticketCount, description, searchTags, active, gameType, appKey, packType, sequenceType, backgroundId, imageId, startDate, endDate, authorOverride, priceType, gameLevelIds, inGame, ticketType, points);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="title"></param>
        /// <param name="packOrder"></param>
        /// <param name="price"></param>
        /// <param name="highest"></param>
        /// <param name="allocateTickets"></param>
        /// <param name="ticketCount"></param>
        /// <param name="description"></param>
        /// <param name="searchTags"></param>
        /// <param name="active"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="packType"></param>
        /// <param name="sequenceType"></param>
        /// <param name="backgroundId"></param>
        /// <param name="imageId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="authorOverride"></param>
        /// <param name="priceType"></param>
        /// <param name="gameLevelIds"></param>
        /// <param name="inGame"></param>
        /// <param name="ticketType"></param>
        /// <param name="points"></param>
        partial void AfterCreatePack(ref bool suppressDefaultLog, ICreatePackApiResponse apiResponseLocalVar, decimal version, long accountId, string title, long packOrder, int price, bool highest, bool allocateTickets, long ticketCount, Option<string> description, Option<string> searchTags, Option<bool> active, Option<string> gameType, Option<string> appKey, Option<string> packType, Option<string> sequenceType, Option<long> backgroundId, Option<long> imageId, Option<long> startDate, Option<long> endDate, Option<string> authorOverride, Option<string> priceType, Option<string> gameLevelIds, Option<bool> inGame, Option<string> ticketType, Option<long> points);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="title"></param>
        /// <param name="packOrder"></param>
        /// <param name="price"></param>
        /// <param name="highest"></param>
        /// <param name="allocateTickets"></param>
        /// <param name="ticketCount"></param>
        /// <param name="description"></param>
        /// <param name="searchTags"></param>
        /// <param name="active"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="packType"></param>
        /// <param name="sequenceType"></param>
        /// <param name="backgroundId"></param>
        /// <param name="imageId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="authorOverride"></param>
        /// <param name="priceType"></param>
        /// <param name="gameLevelIds"></param>
        /// <param name="inGame"></param>
        /// <param name="ticketType"></param>
        /// <param name="points"></param>
        private void OnErrorCreatePackDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string title, long packOrder, int price, bool highest, bool allocateTickets, long ticketCount, Option<string> description, Option<string> searchTags, Option<bool> active, Option<string> gameType, Option<string> appKey, Option<string> packType, Option<string> sequenceType, Option<long> backgroundId, Option<long> imageId, Option<long> startDate, Option<long> endDate, Option<string> authorOverride, Option<string> priceType, Option<string> gameLevelIds, Option<bool> inGame, Option<string> ticketType, Option<long> points)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreatePack(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, title, packOrder, price, highest, allocateTickets, ticketCount, description, searchTags, active, gameType, appKey, packType, sequenceType, backgroundId, imageId, startDate, endDate, authorOverride, priceType, gameLevelIds, inGame, ticketType, points);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="title"></param>
        /// <param name="packOrder"></param>
        /// <param name="price"></param>
        /// <param name="highest"></param>
        /// <param name="allocateTickets"></param>
        /// <param name="ticketCount"></param>
        /// <param name="description"></param>
        /// <param name="searchTags"></param>
        /// <param name="active"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="packType"></param>
        /// <param name="sequenceType"></param>
        /// <param name="backgroundId"></param>
        /// <param name="imageId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="authorOverride"></param>
        /// <param name="priceType"></param>
        /// <param name="gameLevelIds"></param>
        /// <param name="inGame"></param>
        /// <param name="ticketType"></param>
        /// <param name="points"></param>
        partial void OnErrorCreatePack(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string title, long packOrder, int price, bool highest, bool allocateTickets, long ticketCount, Option<string> description, Option<string> searchTags, Option<bool> active, Option<string> gameType, Option<string> appKey, Option<string> packType, Option<string> sequenceType, Option<long> backgroundId, Option<long> imageId, Option<long> startDate, Option<long> endDate, Option<string> authorOverride, Option<string> priceType, Option<string> gameLevelIds, Option<bool> inGame, Option<string> ticketType, Option<long> points);

        /// <summary>
        /// Create Pack Create a pack.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="title">The title of the pack</param>
        /// <param name="packOrder">The order of the pack</param>
        /// <param name="price">The price in tickets to purchase this pack</param>
        /// <param name="highest">The scoring is highest is best</param>
        /// <param name="allocateTickets">Flag to indicate owner should receive tickets for completed packs</param>
        /// <param name="ticketCount">The number of tickets to reward</param>
        /// <param name="description">The description of the pack (optional)</param>
        /// <param name="searchTags">The tags for searching the pack, comma separated (optional)</param>
        /// <param name="active">Activate/deactivate the pack (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">The application key used to identify the application (optional)</param>
        /// <param name="packType">The type of the pack (optional)</param>
        /// <param name="sequenceType">The type of game sequence of the pack (optional)</param>
        /// <param name="backgroundId">The background asset id of the pack (optional)</param>
        /// <param name="imageId">The image asset id of the pack (optional)</param>
        /// <param name="startDate">The date/time to start the pack, send 0 to unset (optional)</param>
        /// <param name="endDate">The date/time to end the pack, send 0 to unset (optional)</param>
        /// <param name="authorOverride"> (optional)</param>
        /// <param name="priceType">the type of ticket required to purchase this pack (optional)</param>
        /// <param name="gameLevelIds">the game level ids to include in the pack, comma separated (optional)</param>
        /// <param name="inGame"> (optional)</param>
        /// <param name="ticketType">The type of ticket to reward, null means default type (optional)</param>
        /// <param name="points">The number of points to award for completing a pack (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreatePackApiResponse"/>&gt;</returns>
        public async Task<ICreatePackApiResponse?> CreatePackOrDefaultAsync(decimal version, long accountId, string title, long packOrder, int price, bool highest, bool allocateTickets, long ticketCount, Option<string> description = default, Option<string> searchTags = default, Option<bool> active = default, Option<string> gameType = default, Option<string> appKey = default, Option<string> packType = default, Option<string> sequenceType = default, Option<long> backgroundId = default, Option<long> imageId = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> authorOverride = default, Option<string> priceType = default, Option<string> gameLevelIds = default, Option<bool> inGame = default, Option<string> ticketType = default, Option<long> points = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreatePackAsync(version, accountId, title, packOrder, price, highest, allocateTickets, ticketCount, description, searchTags, active, gameType, appKey, packType, sequenceType, backgroundId, imageId, startDate, endDate, authorOverride, priceType, gameLevelIds, inGame, ticketType, points, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create Pack Create a pack.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="title">The title of the pack</param>
        /// <param name="packOrder">The order of the pack</param>
        /// <param name="price">The price in tickets to purchase this pack</param>
        /// <param name="highest">The scoring is highest is best</param>
        /// <param name="allocateTickets">Flag to indicate owner should receive tickets for completed packs</param>
        /// <param name="ticketCount">The number of tickets to reward</param>
        /// <param name="description">The description of the pack (optional)</param>
        /// <param name="searchTags">The tags for searching the pack, comma separated (optional)</param>
        /// <param name="active">Activate/deactivate the pack (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">The application key used to identify the application (optional)</param>
        /// <param name="packType">The type of the pack (optional)</param>
        /// <param name="sequenceType">The type of game sequence of the pack (optional)</param>
        /// <param name="backgroundId">The background asset id of the pack (optional)</param>
        /// <param name="imageId">The image asset id of the pack (optional)</param>
        /// <param name="startDate">The date/time to start the pack, send 0 to unset (optional)</param>
        /// <param name="endDate">The date/time to end the pack, send 0 to unset (optional)</param>
        /// <param name="authorOverride"> (optional)</param>
        /// <param name="priceType">the type of ticket required to purchase this pack (optional)</param>
        /// <param name="gameLevelIds">the game level ids to include in the pack, comma separated (optional)</param>
        /// <param name="inGame"> (optional)</param>
        /// <param name="ticketType">The type of ticket to reward, null means default type (optional)</param>
        /// <param name="points">The number of points to award for completing a pack (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreatePackApiResponse"/>&gt;</returns>
        public async Task<ICreatePackApiResponse> CreatePackAsync(decimal version, long accountId, string title, long packOrder, int price, bool highest, bool allocateTickets, long ticketCount, Option<string> description = default, Option<string> searchTags = default, Option<bool> active = default, Option<string> gameType = default, Option<string> appKey = default, Option<string> packType = default, Option<string> sequenceType = default, Option<long> backgroundId = default, Option<long> imageId = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> authorOverride = default, Option<string> priceType = default, Option<string> gameLevelIds = default, Option<bool> inGame = default, Option<string> ticketType = default, Option<long> points = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreatePack(title, description, searchTags, gameType, appKey, packType, sequenceType, authorOverride, priceType, gameLevelIds, ticketType);

                FormatCreatePack(ref version, ref accountId, ref title, ref packOrder, ref price, ref highest, ref allocateTickets, ref ticketCount, ref description, ref searchTags, ref active, ref gameType, ref appKey, ref packType, ref sequenceType, ref backgroundId, ref imageId, ref startDate, ref endDate, ref authorOverride, ref priceType, ref gameLevelIds, ref inGame, ref ticketType, ref points);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/pack/create"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/pack/create");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["title"] = ClientUtils.ParameterToString(title);
                    parseQueryStringLocalVar["packOrder"] = ClientUtils.ParameterToString(packOrder);
                    parseQueryStringLocalVar["price"] = ClientUtils.ParameterToString(price);
                    parseQueryStringLocalVar["highest"] = ClientUtils.ParameterToString(highest);
                    parseQueryStringLocalVar["allocateTickets"] = ClientUtils.ParameterToString(allocateTickets);
                    parseQueryStringLocalVar["ticketCount"] = ClientUtils.ParameterToString(ticketCount);

                    if (description.IsSet)
                        parseQueryStringLocalVar["description"] = ClientUtils.ParameterToString(description.Value);

                    if (searchTags.IsSet)
                        parseQueryStringLocalVar["searchTags"] = ClientUtils.ParameterToString(searchTags.Value);

                    if (active.IsSet)
                        parseQueryStringLocalVar["active"] = ClientUtils.ParameterToString(active.Value);

                    if (gameType.IsSet)
                        parseQueryStringLocalVar["gameType"] = ClientUtils.ParameterToString(gameType.Value);

                    if (appKey.IsSet)
                        parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey.Value);

                    if (packType.IsSet)
                        parseQueryStringLocalVar["packType"] = ClientUtils.ParameterToString(packType.Value);

                    if (sequenceType.IsSet)
                        parseQueryStringLocalVar["sequenceType"] = ClientUtils.ParameterToString(sequenceType.Value);

                    if (backgroundId.IsSet)
                        parseQueryStringLocalVar["backgroundId"] = ClientUtils.ParameterToString(backgroundId.Value);

                    if (imageId.IsSet)
                        parseQueryStringLocalVar["imageId"] = ClientUtils.ParameterToString(imageId.Value);

                    if (startDate.IsSet)
                        parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate.Value);

                    if (endDate.IsSet)
                        parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate.Value);

                    if (authorOverride.IsSet)
                        parseQueryStringLocalVar["authorOverride"] = ClientUtils.ParameterToString(authorOverride.Value);

                    if (priceType.IsSet)
                        parseQueryStringLocalVar["priceType"] = ClientUtils.ParameterToString(priceType.Value);

                    if (gameLevelIds.IsSet)
                        parseQueryStringLocalVar["gameLevelIds"] = ClientUtils.ParameterToString(gameLevelIds.Value);

                    if (inGame.IsSet)
                        parseQueryStringLocalVar["inGame"] = ClientUtils.ParameterToString(inGame.Value);

                    if (ticketType.IsSet)
                        parseQueryStringLocalVar["ticketType"] = ClientUtils.ParameterToString(ticketType.Value);

                    if (points.IsSet)
                        parseQueryStringLocalVar["points"] = ClientUtils.ParameterToString(points.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreatePackApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreatePackApiResponse>();
                        CreatePackApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/pack/create", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreatePackDefaultImplementation(apiResponseLocalVar, version, accountId, title, packOrder, price, highest, allocateTickets, ticketCount, description, searchTags, active, gameType, appKey, packType, sequenceType, backgroundId, imageId, startDate, endDate, authorOverride, priceType, gameLevelIds, inGame, ticketType, points);

                        Events.ExecuteOnCreatePack(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreatePackDefaultImplementation(e, "/api/{version}/pack/create", uriBuilderLocalVar.Path, version, accountId, title, packOrder, price, highest, allocateTickets, ticketCount, description, searchTags, active, gameType, appKey, packType, sequenceType, backgroundId, imageId, startDate, endDate, authorOverride, priceType, gameLevelIds, inGame, ticketType, points);
                Events.ExecuteOnErrorCreatePack(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreatePackApiResponse"/>
        /// </summary>
        public partial class CreatePackApiResponse : Org.OpenAPITools.Client.ApiResponse, ICreatePackApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreatePackApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreatePackApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreatePackApiResponse(ILogger<CreatePackApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreatePackApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreatePackApiResponse(ILogger<CreatePackApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.PackResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.PackResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.PackResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeletePack(ref decimal version, ref long accountId, ref long packId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="packId"></param>
        private void AfterDeletePackDefaultImplementation(IDeletePackApiResponse apiResponseLocalVar, decimal version, long accountId, long packId)
        {
            bool suppressDefaultLog = false;
            AfterDeletePack(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, packId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="packId"></param>
        partial void AfterDeletePack(ref bool suppressDefaultLog, IDeletePackApiResponse apiResponseLocalVar, decimal version, long accountId, long packId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="packId"></param>
        private void OnErrorDeletePackDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, long packId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeletePack(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, packId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="packId"></param>
        partial void OnErrorDeletePack(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, long packId);

        /// <summary>
        /// Delete Pack Delete a pack.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">the id of the logged in user</param>
        /// <param name="packId">the id of the pack to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeletePackApiResponse"/>&gt;</returns>
        public async Task<IDeletePackApiResponse?> DeletePackOrDefaultAsync(decimal version, long accountId, long packId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeletePackAsync(version, accountId, packId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete Pack Delete a pack.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">the id of the logged in user</param>
        /// <param name="packId">the id of the pack to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeletePackApiResponse"/>&gt;</returns>
        public async Task<IDeletePackApiResponse> DeletePackAsync(decimal version, long accountId, long packId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeletePack(ref version, ref accountId, ref packId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/pack/delete"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/pack/delete");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["packId"] = ClientUtils.ParameterToString(packId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DeletePackApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeletePackApiResponse>();
                        DeletePackApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/pack/delete", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDeletePackDefaultImplementation(apiResponseLocalVar, version, accountId, packId);

                        Events.ExecuteOnDeletePack(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeletePackDefaultImplementation(e, "/api/{version}/pack/delete", uriBuilderLocalVar.Path, version, accountId, packId);
                Events.ExecuteOnErrorDeletePack(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeletePackApiResponse"/>
        /// </summary>
        public partial class DeletePackApiResponse : Org.OpenAPITools.Client.ApiResponse, IDeletePackApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeletePackApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeletePackApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeletePackApiResponse(ILogger<DeletePackApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DeletePackApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeletePackApiResponse(ILogger<DeletePackApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetPack(ref decimal version, ref long accountId, ref long packId, ref bool includeGameData);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="packId"></param>
        /// <param name="includeGameData"></param>
        private void AfterGetPackDefaultImplementation(IGetPackApiResponse apiResponseLocalVar, decimal version, long accountId, long packId, bool includeGameData)
        {
            bool suppressDefaultLog = false;
            AfterGetPack(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, packId, includeGameData);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="packId"></param>
        /// <param name="includeGameData"></param>
        partial void AfterGetPack(ref bool suppressDefaultLog, IGetPackApiResponse apiResponseLocalVar, decimal version, long accountId, long packId, bool includeGameData);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="packId"></param>
        /// <param name="includeGameData"></param>
        private void OnErrorGetPackDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, long packId, bool includeGameData)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetPack(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, packId, includeGameData);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="packId"></param>
        /// <param name="includeGameData"></param>
        partial void OnErrorGetPack(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, long packId, bool includeGameData);

        /// <summary>
        /// Get Pack Get a pack.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="packId">The id of the pack to return.</param>
        /// <param name="includeGameData">If true include the game level data, otherwise don&#39;t. default is false.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPackApiResponse"/>&gt;</returns>
        public async Task<IGetPackApiResponse?> GetPackOrDefaultAsync(decimal version, long accountId, long packId, bool includeGameData, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetPackAsync(version, accountId, packId, includeGameData, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Pack Get a pack.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="packId">The id of the pack to return.</param>
        /// <param name="includeGameData">If true include the game level data, otherwise don&#39;t. default is false.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPackApiResponse"/>&gt;</returns>
        public async Task<IGetPackApiResponse> GetPackAsync(decimal version, long accountId, long packId, bool includeGameData, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetPack(ref version, ref accountId, ref packId, ref includeGameData);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/pack/get"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/pack/get");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["packId"] = ClientUtils.ParameterToString(packId);
                    parseQueryStringLocalVar["includeGameData"] = ClientUtils.ParameterToString(includeGameData);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetPackApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetPackApiResponse>();
                        GetPackApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/pack/get", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetPackDefaultImplementation(apiResponseLocalVar, version, accountId, packId, includeGameData);

                        Events.ExecuteOnGetPack(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetPackDefaultImplementation(e, "/api/{version}/pack/get", uriBuilderLocalVar.Path, version, accountId, packId, includeGameData);
                Events.ExecuteOnErrorGetPack(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetPackApiResponse"/>
        /// </summary>
        public partial class GetPackApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetPackApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetPackApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetPackApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetPackApiResponse(ILogger<GetPackApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetPackApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetPackApiResponse(ILogger<GetPackApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.PackResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.PackResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.PackResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchPacks(ref decimal version, ref long accountId, ref string sortField, ref bool descending, ref Option<string> keyword, ref Option<string> packType, ref Option<int> start, ref Option<int> limit, ref Option<bool> includeGameData, ref Option<bool> includeInactive, ref Option<string> appKey);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sortField"></param>
        /// <param name="keyword"></param>
        /// <param name="packType"></param>
        /// <param name="appKey"></param>
        /// <returns></returns>
        private void ValidateSearchPacks(string sortField, Option<string> keyword, Option<string> packType, Option<string> appKey)
        {
            if (sortField == null)
                throw new ArgumentNullException(nameof(sortField));

            if (keyword.IsSet && keyword.Value == null)
                throw new ArgumentNullException(nameof(keyword));

            if (packType.IsSet && packType.Value == null)
                throw new ArgumentNullException(nameof(packType));

            if (appKey.IsSet && appKey.Value == null)
                throw new ArgumentNullException(nameof(appKey));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="keyword"></param>
        /// <param name="packType"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="includeGameData"></param>
        /// <param name="includeInactive"></param>
        /// <param name="appKey"></param>
        private void AfterSearchPacksDefaultImplementation(ISearchPacksApiResponse apiResponseLocalVar, decimal version, long accountId, string sortField, bool descending, Option<string> keyword, Option<string> packType, Option<int> start, Option<int> limit, Option<bool> includeGameData, Option<bool> includeInactive, Option<string> appKey)
        {
            bool suppressDefaultLog = false;
            AfterSearchPacks(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, sortField, descending, keyword, packType, start, limit, includeGameData, includeInactive, appKey);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="keyword"></param>
        /// <param name="packType"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="includeGameData"></param>
        /// <param name="includeInactive"></param>
        /// <param name="appKey"></param>
        partial void AfterSearchPacks(ref bool suppressDefaultLog, ISearchPacksApiResponse apiResponseLocalVar, decimal version, long accountId, string sortField, bool descending, Option<string> keyword, Option<string> packType, Option<int> start, Option<int> limit, Option<bool> includeGameData, Option<bool> includeInactive, Option<string> appKey);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="keyword"></param>
        /// <param name="packType"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="includeGameData"></param>
        /// <param name="includeInactive"></param>
        /// <param name="appKey"></param>
        private void OnErrorSearchPacksDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string sortField, bool descending, Option<string> keyword, Option<string> packType, Option<int> start, Option<int> limit, Option<bool> includeGameData, Option<bool> includeInactive, Option<string> appKey)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchPacks(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, sortField, descending, keyword, packType, start, limit, includeGameData, includeInactive, appKey);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="keyword"></param>
        /// <param name="packType"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="includeGameData"></param>
        /// <param name="includeInactive"></param>
        /// <param name="appKey"></param>
        partial void OnErrorSearchPacks(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string sortField, bool descending, Option<string> keyword, Option<string> packType, Option<int> start, Option<int> limit, Option<bool> includeGameData, Option<bool> includeInactive, Option<string> appKey);

        /// <summary>
        /// Search Packs Search on packs.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="sortField">The field to sort by. Possible values include: TITLE, DESCRIPTION, CREATED, UPDATED</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order</param>
        /// <param name="keyword">Keyword search on the pack name (optional)</param>
        /// <param name="packType">Filters results on pack type (optional)</param>
        /// <param name="start">Start the result set at some index. (optional)</param>
        /// <param name="limit">Limit the result to some number. (optional)</param>
        /// <param name="includeGameData">Determines whether to include game data in the results (optional)</param>
        /// <param name="includeInactive">Determines whether to include inactive results (optional)</param>
        /// <param name="appKey">The application to filter results on (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPacksApiResponse"/>&gt;</returns>
        public async Task<ISearchPacksApiResponse?> SearchPacksOrDefaultAsync(decimal version, long accountId, string sortField, bool descending, Option<string> keyword = default, Option<string> packType = default, Option<int> start = default, Option<int> limit = default, Option<bool> includeGameData = default, Option<bool> includeInactive = default, Option<string> appKey = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchPacksAsync(version, accountId, sortField, descending, keyword, packType, start, limit, includeGameData, includeInactive, appKey, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Packs Search on packs.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="sortField">The field to sort by. Possible values include: TITLE, DESCRIPTION, CREATED, UPDATED</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order</param>
        /// <param name="keyword">Keyword search on the pack name (optional)</param>
        /// <param name="packType">Filters results on pack type (optional)</param>
        /// <param name="start">Start the result set at some index. (optional)</param>
        /// <param name="limit">Limit the result to some number. (optional)</param>
        /// <param name="includeGameData">Determines whether to include game data in the results (optional)</param>
        /// <param name="includeInactive">Determines whether to include inactive results (optional)</param>
        /// <param name="appKey">The application to filter results on (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchPacksApiResponse"/>&gt;</returns>
        public async Task<ISearchPacksApiResponse> SearchPacksAsync(decimal version, long accountId, string sortField, bool descending, Option<string> keyword = default, Option<string> packType = default, Option<int> start = default, Option<int> limit = default, Option<bool> includeGameData = default, Option<bool> includeInactive = default, Option<string> appKey = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchPacks(sortField, keyword, packType, appKey);

                FormatSearchPacks(ref version, ref accountId, ref sortField, ref descending, ref keyword, ref packType, ref start, ref limit, ref includeGameData, ref includeInactive, ref appKey);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/pack/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/pack/search");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["sortField"] = ClientUtils.ParameterToString(sortField);
                    parseQueryStringLocalVar["descending"] = ClientUtils.ParameterToString(descending);

                    if (keyword.IsSet)
                        parseQueryStringLocalVar["keyword"] = ClientUtils.ParameterToString(keyword.Value);

                    if (packType.IsSet)
                        parseQueryStringLocalVar["packType"] = ClientUtils.ParameterToString(packType.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (includeGameData.IsSet)
                        parseQueryStringLocalVar["includeGameData"] = ClientUtils.ParameterToString(includeGameData.Value);

                    if (includeInactive.IsSet)
                        parseQueryStringLocalVar["includeInactive"] = ClientUtils.ParameterToString(includeInactive.Value);

                    if (appKey.IsSet)
                        parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchPacksApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchPacksApiResponse>();
                        SearchPacksApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/pack/search", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchPacksDefaultImplementation(apiResponseLocalVar, version, accountId, sortField, descending, keyword, packType, start, limit, includeGameData, includeInactive, appKey);

                        Events.ExecuteOnSearchPacks(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchPacksDefaultImplementation(e, "/api/{version}/pack/search", uriBuilderLocalVar.Path, version, accountId, sortField, descending, keyword, packType, start, limit, includeGameData, includeInactive, appKey);
                Events.ExecuteOnErrorSearchPacks(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchPacksApiResponse"/>
        /// </summary>
        public partial class SearchPacksApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchPacksApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchPacksApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchPacksApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchPacksApiResponse(ILogger<SearchPacksApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchPacksApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchPacksApiResponse(ILogger<SearchPacksApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<PackResponse>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<PackResponse>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<PackResponse>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdatePack(ref decimal version, ref long accountId, ref long packId, ref bool allocateTickets, ref long ticketCount, ref Option<string> title, ref Option<string> description, ref Option<string> searchTags, ref Option<bool> active, ref Option<string> gameType, ref Option<string> appKey, ref Option<string> packType, ref Option<long> packOrder, ref Option<string> sequenceType, ref Option<long> backgroundId, ref Option<long> imageId, ref Option<long> startDate, ref Option<long> endDate, ref Option<string> authorOverride, ref Option<int> price, ref Option<string> priceType, ref Option<string> gameLevelIds, ref Option<bool> inGame, ref Option<bool> highest, ref Option<string> ticketType, ref Option<long> points);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="title"></param>
        /// <param name="description"></param>
        /// <param name="searchTags"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="packType"></param>
        /// <param name="sequenceType"></param>
        /// <param name="authorOverride"></param>
        /// <param name="priceType"></param>
        /// <param name="gameLevelIds"></param>
        /// <param name="ticketType"></param>
        /// <returns></returns>
        private void ValidateUpdatePack(Option<string> title, Option<string> description, Option<string> searchTags, Option<string> gameType, Option<string> appKey, Option<string> packType, Option<string> sequenceType, Option<string> authorOverride, Option<string> priceType, Option<string> gameLevelIds, Option<string> ticketType)
        {
            if (title.IsSet && title.Value == null)
                throw new ArgumentNullException(nameof(title));

            if (description.IsSet && description.Value == null)
                throw new ArgumentNullException(nameof(description));

            if (searchTags.IsSet && searchTags.Value == null)
                throw new ArgumentNullException(nameof(searchTags));

            if (gameType.IsSet && gameType.Value == null)
                throw new ArgumentNullException(nameof(gameType));

            if (appKey.IsSet && appKey.Value == null)
                throw new ArgumentNullException(nameof(appKey));

            if (packType.IsSet && packType.Value == null)
                throw new ArgumentNullException(nameof(packType));

            if (sequenceType.IsSet && sequenceType.Value == null)
                throw new ArgumentNullException(nameof(sequenceType));

            if (authorOverride.IsSet && authorOverride.Value == null)
                throw new ArgumentNullException(nameof(authorOverride));

            if (priceType.IsSet && priceType.Value == null)
                throw new ArgumentNullException(nameof(priceType));

            if (gameLevelIds.IsSet && gameLevelIds.Value == null)
                throw new ArgumentNullException(nameof(gameLevelIds));

            if (ticketType.IsSet && ticketType.Value == null)
                throw new ArgumentNullException(nameof(ticketType));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="packId"></param>
        /// <param name="allocateTickets"></param>
        /// <param name="ticketCount"></param>
        /// <param name="title"></param>
        /// <param name="description"></param>
        /// <param name="searchTags"></param>
        /// <param name="active"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="packType"></param>
        /// <param name="packOrder"></param>
        /// <param name="sequenceType"></param>
        /// <param name="backgroundId"></param>
        /// <param name="imageId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="authorOverride"></param>
        /// <param name="price"></param>
        /// <param name="priceType"></param>
        /// <param name="gameLevelIds"></param>
        /// <param name="inGame"></param>
        /// <param name="highest"></param>
        /// <param name="ticketType"></param>
        /// <param name="points"></param>
        private void AfterUpdatePackDefaultImplementation(IUpdatePackApiResponse apiResponseLocalVar, decimal version, long accountId, long packId, bool allocateTickets, long ticketCount, Option<string> title, Option<string> description, Option<string> searchTags, Option<bool> active, Option<string> gameType, Option<string> appKey, Option<string> packType, Option<long> packOrder, Option<string> sequenceType, Option<long> backgroundId, Option<long> imageId, Option<long> startDate, Option<long> endDate, Option<string> authorOverride, Option<int> price, Option<string> priceType, Option<string> gameLevelIds, Option<bool> inGame, Option<bool> highest, Option<string> ticketType, Option<long> points)
        {
            bool suppressDefaultLog = false;
            AfterUpdatePack(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, packId, allocateTickets, ticketCount, title, description, searchTags, active, gameType, appKey, packType, packOrder, sequenceType, backgroundId, imageId, startDate, endDate, authorOverride, price, priceType, gameLevelIds, inGame, highest, ticketType, points);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="packId"></param>
        /// <param name="allocateTickets"></param>
        /// <param name="ticketCount"></param>
        /// <param name="title"></param>
        /// <param name="description"></param>
        /// <param name="searchTags"></param>
        /// <param name="active"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="packType"></param>
        /// <param name="packOrder"></param>
        /// <param name="sequenceType"></param>
        /// <param name="backgroundId"></param>
        /// <param name="imageId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="authorOverride"></param>
        /// <param name="price"></param>
        /// <param name="priceType"></param>
        /// <param name="gameLevelIds"></param>
        /// <param name="inGame"></param>
        /// <param name="highest"></param>
        /// <param name="ticketType"></param>
        /// <param name="points"></param>
        partial void AfterUpdatePack(ref bool suppressDefaultLog, IUpdatePackApiResponse apiResponseLocalVar, decimal version, long accountId, long packId, bool allocateTickets, long ticketCount, Option<string> title, Option<string> description, Option<string> searchTags, Option<bool> active, Option<string> gameType, Option<string> appKey, Option<string> packType, Option<long> packOrder, Option<string> sequenceType, Option<long> backgroundId, Option<long> imageId, Option<long> startDate, Option<long> endDate, Option<string> authorOverride, Option<int> price, Option<string> priceType, Option<string> gameLevelIds, Option<bool> inGame, Option<bool> highest, Option<string> ticketType, Option<long> points);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="packId"></param>
        /// <param name="allocateTickets"></param>
        /// <param name="ticketCount"></param>
        /// <param name="title"></param>
        /// <param name="description"></param>
        /// <param name="searchTags"></param>
        /// <param name="active"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="packType"></param>
        /// <param name="packOrder"></param>
        /// <param name="sequenceType"></param>
        /// <param name="backgroundId"></param>
        /// <param name="imageId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="authorOverride"></param>
        /// <param name="price"></param>
        /// <param name="priceType"></param>
        /// <param name="gameLevelIds"></param>
        /// <param name="inGame"></param>
        /// <param name="highest"></param>
        /// <param name="ticketType"></param>
        /// <param name="points"></param>
        private void OnErrorUpdatePackDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, long packId, bool allocateTickets, long ticketCount, Option<string> title, Option<string> description, Option<string> searchTags, Option<bool> active, Option<string> gameType, Option<string> appKey, Option<string> packType, Option<long> packOrder, Option<string> sequenceType, Option<long> backgroundId, Option<long> imageId, Option<long> startDate, Option<long> endDate, Option<string> authorOverride, Option<int> price, Option<string> priceType, Option<string> gameLevelIds, Option<bool> inGame, Option<bool> highest, Option<string> ticketType, Option<long> points)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdatePack(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, packId, allocateTickets, ticketCount, title, description, searchTags, active, gameType, appKey, packType, packOrder, sequenceType, backgroundId, imageId, startDate, endDate, authorOverride, price, priceType, gameLevelIds, inGame, highest, ticketType, points);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="packId"></param>
        /// <param name="allocateTickets"></param>
        /// <param name="ticketCount"></param>
        /// <param name="title"></param>
        /// <param name="description"></param>
        /// <param name="searchTags"></param>
        /// <param name="active"></param>
        /// <param name="gameType"></param>
        /// <param name="appKey"></param>
        /// <param name="packType"></param>
        /// <param name="packOrder"></param>
        /// <param name="sequenceType"></param>
        /// <param name="backgroundId"></param>
        /// <param name="imageId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="authorOverride"></param>
        /// <param name="price"></param>
        /// <param name="priceType"></param>
        /// <param name="gameLevelIds"></param>
        /// <param name="inGame"></param>
        /// <param name="highest"></param>
        /// <param name="ticketType"></param>
        /// <param name="points"></param>
        partial void OnErrorUpdatePack(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, long packId, bool allocateTickets, long ticketCount, Option<string> title, Option<string> description, Option<string> searchTags, Option<bool> active, Option<string> gameType, Option<string> appKey, Option<string> packType, Option<long> packOrder, Option<string> sequenceType, Option<long> backgroundId, Option<long> imageId, Option<long> startDate, Option<long> endDate, Option<string> authorOverride, Option<int> price, Option<string> priceType, Option<string> gameLevelIds, Option<bool> inGame, Option<bool> highest, Option<string> ticketType, Option<long> points);

        /// <summary>
        /// Update Pack Update a pack.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="packId">The id of the pack to update.</param>
        /// <param name="allocateTickets">Flag to indicate owner should receive tickets for completed packs</param>
        /// <param name="ticketCount">The number of tickets to reward</param>
        /// <param name="title">The title of the pack (optional)</param>
        /// <param name="description">The description of the pack (optional)</param>
        /// <param name="searchTags">The tags for searching the pack, comma separated (optional)</param>
        /// <param name="active">Activate/deactivate the pack (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">The application key used to identify the application (optional)</param>
        /// <param name="packType">The type of the pack (optional)</param>
        /// <param name="packOrder">The order of the pack (optional)</param>
        /// <param name="sequenceType">The type of game sequence of the pack (optional)</param>
        /// <param name="backgroundId">The background asset id of the pack (optional)</param>
        /// <param name="imageId">The image asset id of the pack (optional)</param>
        /// <param name="startDate">The date/time to start the pack, send 0 to unset (optional)</param>
        /// <param name="endDate">The date/time to end the pack, send 0 to unset (optional)</param>
        /// <param name="authorOverride"> (optional)</param>
        /// <param name="price">The price in tickets to purchase this pack (optional)</param>
        /// <param name="priceType">the type of ticket required to purchase this pack (optional)</param>
        /// <param name="gameLevelIds">the game level ids to include in the pack, comma separated (optional)</param>
        /// <param name="inGame"> (optional)</param>
        /// <param name="highest">The scoring is highest is best (optional)</param>
        /// <param name="ticketType">The type of ticket to reward, null means default type (optional)</param>
        /// <param name="points">The number of points to award for completing a pack (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdatePackApiResponse"/>&gt;</returns>
        public async Task<IUpdatePackApiResponse?> UpdatePackOrDefaultAsync(decimal version, long accountId, long packId, bool allocateTickets, long ticketCount, Option<string> title = default, Option<string> description = default, Option<string> searchTags = default, Option<bool> active = default, Option<string> gameType = default, Option<string> appKey = default, Option<string> packType = default, Option<long> packOrder = default, Option<string> sequenceType = default, Option<long> backgroundId = default, Option<long> imageId = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> authorOverride = default, Option<int> price = default, Option<string> priceType = default, Option<string> gameLevelIds = default, Option<bool> inGame = default, Option<bool> highest = default, Option<string> ticketType = default, Option<long> points = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdatePackAsync(version, accountId, packId, allocateTickets, ticketCount, title, description, searchTags, active, gameType, appKey, packType, packOrder, sequenceType, backgroundId, imageId, startDate, endDate, authorOverride, price, priceType, gameLevelIds, inGame, highest, ticketType, points, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update Pack Update a pack.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="packId">The id of the pack to update.</param>
        /// <param name="allocateTickets">Flag to indicate owner should receive tickets for completed packs</param>
        /// <param name="ticketCount">The number of tickets to reward</param>
        /// <param name="title">The title of the pack (optional)</param>
        /// <param name="description">The description of the pack (optional)</param>
        /// <param name="searchTags">The tags for searching the pack, comma separated (optional)</param>
        /// <param name="active">Activate/deactivate the pack (optional)</param>
        /// <param name="gameType">This parameter is deprecated. (optional)</param>
        /// <param name="appKey">The application key used to identify the application (optional)</param>
        /// <param name="packType">The type of the pack (optional)</param>
        /// <param name="packOrder">The order of the pack (optional)</param>
        /// <param name="sequenceType">The type of game sequence of the pack (optional)</param>
        /// <param name="backgroundId">The background asset id of the pack (optional)</param>
        /// <param name="imageId">The image asset id of the pack (optional)</param>
        /// <param name="startDate">The date/time to start the pack, send 0 to unset (optional)</param>
        /// <param name="endDate">The date/time to end the pack, send 0 to unset (optional)</param>
        /// <param name="authorOverride"> (optional)</param>
        /// <param name="price">The price in tickets to purchase this pack (optional)</param>
        /// <param name="priceType">the type of ticket required to purchase this pack (optional)</param>
        /// <param name="gameLevelIds">the game level ids to include in the pack, comma separated (optional)</param>
        /// <param name="inGame"> (optional)</param>
        /// <param name="highest">The scoring is highest is best (optional)</param>
        /// <param name="ticketType">The type of ticket to reward, null means default type (optional)</param>
        /// <param name="points">The number of points to award for completing a pack (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdatePackApiResponse"/>&gt;</returns>
        public async Task<IUpdatePackApiResponse> UpdatePackAsync(decimal version, long accountId, long packId, bool allocateTickets, long ticketCount, Option<string> title = default, Option<string> description = default, Option<string> searchTags = default, Option<bool> active = default, Option<string> gameType = default, Option<string> appKey = default, Option<string> packType = default, Option<long> packOrder = default, Option<string> sequenceType = default, Option<long> backgroundId = default, Option<long> imageId = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> authorOverride = default, Option<int> price = default, Option<string> priceType = default, Option<string> gameLevelIds = default, Option<bool> inGame = default, Option<bool> highest = default, Option<string> ticketType = default, Option<long> points = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdatePack(title, description, searchTags, gameType, appKey, packType, sequenceType, authorOverride, priceType, gameLevelIds, ticketType);

                FormatUpdatePack(ref version, ref accountId, ref packId, ref allocateTickets, ref ticketCount, ref title, ref description, ref searchTags, ref active, ref gameType, ref appKey, ref packType, ref packOrder, ref sequenceType, ref backgroundId, ref imageId, ref startDate, ref endDate, ref authorOverride, ref price, ref priceType, ref gameLevelIds, ref inGame, ref highest, ref ticketType, ref points);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/pack/update"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/pack/update");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["packId"] = ClientUtils.ParameterToString(packId);
                    parseQueryStringLocalVar["allocateTickets"] = ClientUtils.ParameterToString(allocateTickets);
                    parseQueryStringLocalVar["ticketCount"] = ClientUtils.ParameterToString(ticketCount);

                    if (title.IsSet)
                        parseQueryStringLocalVar["title"] = ClientUtils.ParameterToString(title.Value);

                    if (description.IsSet)
                        parseQueryStringLocalVar["description"] = ClientUtils.ParameterToString(description.Value);

                    if (searchTags.IsSet)
                        parseQueryStringLocalVar["searchTags"] = ClientUtils.ParameterToString(searchTags.Value);

                    if (active.IsSet)
                        parseQueryStringLocalVar["active"] = ClientUtils.ParameterToString(active.Value);

                    if (gameType.IsSet)
                        parseQueryStringLocalVar["gameType"] = ClientUtils.ParameterToString(gameType.Value);

                    if (appKey.IsSet)
                        parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey.Value);

                    if (packType.IsSet)
                        parseQueryStringLocalVar["packType"] = ClientUtils.ParameterToString(packType.Value);

                    if (packOrder.IsSet)
                        parseQueryStringLocalVar["packOrder"] = ClientUtils.ParameterToString(packOrder.Value);

                    if (sequenceType.IsSet)
                        parseQueryStringLocalVar["sequenceType"] = ClientUtils.ParameterToString(sequenceType.Value);

                    if (backgroundId.IsSet)
                        parseQueryStringLocalVar["backgroundId"] = ClientUtils.ParameterToString(backgroundId.Value);

                    if (imageId.IsSet)
                        parseQueryStringLocalVar["imageId"] = ClientUtils.ParameterToString(imageId.Value);

                    if (startDate.IsSet)
                        parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate.Value);

                    if (endDate.IsSet)
                        parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate.Value);

                    if (authorOverride.IsSet)
                        parseQueryStringLocalVar["authorOverride"] = ClientUtils.ParameterToString(authorOverride.Value);

                    if (price.IsSet)
                        parseQueryStringLocalVar["price"] = ClientUtils.ParameterToString(price.Value);

                    if (priceType.IsSet)
                        parseQueryStringLocalVar["priceType"] = ClientUtils.ParameterToString(priceType.Value);

                    if (gameLevelIds.IsSet)
                        parseQueryStringLocalVar["gameLevelIds"] = ClientUtils.ParameterToString(gameLevelIds.Value);

                    if (inGame.IsSet)
                        parseQueryStringLocalVar["inGame"] = ClientUtils.ParameterToString(inGame.Value);

                    if (highest.IsSet)
                        parseQueryStringLocalVar["highest"] = ClientUtils.ParameterToString(highest.Value);

                    if (ticketType.IsSet)
                        parseQueryStringLocalVar["ticketType"] = ClientUtils.ParameterToString(ticketType.Value);

                    if (points.IsSet)
                        parseQueryStringLocalVar["points"] = ClientUtils.ParameterToString(points.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UpdatePackApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdatePackApiResponse>();
                        UpdatePackApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/pack/update", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUpdatePackDefaultImplementation(apiResponseLocalVar, version, accountId, packId, allocateTickets, ticketCount, title, description, searchTags, active, gameType, appKey, packType, packOrder, sequenceType, backgroundId, imageId, startDate, endDate, authorOverride, price, priceType, gameLevelIds, inGame, highest, ticketType, points);

                        Events.ExecuteOnUpdatePack(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdatePackDefaultImplementation(e, "/api/{version}/pack/update", uriBuilderLocalVar.Path, version, accountId, packId, allocateTickets, ticketCount, title, description, searchTags, active, gameType, appKey, packType, packOrder, sequenceType, backgroundId, imageId, startDate, endDate, authorOverride, price, priceType, gameLevelIds, inGame, highest, ticketType, points);
                Events.ExecuteOnErrorUpdatePack(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdatePackApiResponse"/>
        /// </summary>
        public partial class UpdatePackApiResponse : Org.OpenAPITools.Client.ApiResponse, IUpdatePackApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdatePackApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdatePackApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdatePackApiResponse(ILogger<UpdatePackApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UpdatePackApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdatePackApiResponse(ILogger<UpdatePackApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.PackResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.PackResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.PackResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
