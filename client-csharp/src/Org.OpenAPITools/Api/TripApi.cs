// <auto-generated>
/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Net;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface ITripApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        TripApiEvents Events { get; }

        /// <summary>
        /// Create Trip
        /// </summary>
        /// <remarks>
        /// Create a new trip
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTripApiResponse"/>&gt;</returns>
        Task<ICreateTripApiResponse> CreateTripAsync(Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Trip
        /// </summary>
        /// <remarks>
        /// Create a new trip
        /// </remarks>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTripApiResponse"/>?&gt;</returns>
        Task<ICreateTripApiResponse?> CreateTripOrDefaultAsync(Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Trip
        /// </summary>
        /// <remarks>
        /// Delete an existing trip
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteApiResponse"/>&gt;</returns>
        Task<IDeleteApiResponse> DeleteAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Trip
        /// </summary>
        /// <remarks>
        /// Delete an existing trip
        /// </remarks>
        /// <param name="id">the id of the trip to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteApiResponse"/>?&gt;</returns>
        Task<IDeleteApiResponse?> DeleteOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set Trip Preference Driver
        /// </summary>
        /// <remarks>
        /// Update trip preference to drive, also create a route and assign the trip to the route
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip</param>
        /// <param name="recurrence">the frequency of the trip (e.g. weekly, until 2018-08-09)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDriveTripApiResponse"/>&gt;</returns>
        Task<IDriveTripApiResponse> DriveTripAsync(long id, bool recurrence, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set Trip Preference Driver
        /// </summary>
        /// <remarks>
        /// Update trip preference to drive, also create a route and assign the trip to the route
        /// </remarks>
        /// <param name="id">the id of the trip</param>
        /// <param name="recurrence">the frequency of the trip (e.g. weekly, until 2018-08-09)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDriveTripApiResponse"/>?&gt;</returns>
        Task<IDriveTripApiResponse?> DriveTripOrDefaultAsync(long id, bool recurrence, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set Trip Preference Flexible
        /// </summary>
        /// <remarks>
        /// Update trip preference to flexible.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip</param>
        /// <param name="recurrence">the frequency of the trip (e.g. weekly, until 2018-08-09)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFlexibleTripApiResponse"/>&gt;</returns>
        Task<IFlexibleTripApiResponse> FlexibleTripAsync(long id, bool recurrence, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set Trip Preference Flexible
        /// </summary>
        /// <remarks>
        /// Update trip preference to flexible.
        /// </remarks>
        /// <param name="id">the id of the trip</param>
        /// <param name="recurrence">the frequency of the trip (e.g. weekly, until 2018-08-09)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFlexibleTripApiResponse"/>?&gt;</returns>
        Task<IFlexibleTripApiResponse?> FlexibleTripOrDefaultAsync(long id, bool recurrence, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Trip
        /// </summary>
        /// <remarks>
        /// Get an existing trip
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTripApiResponse"/>&gt;</returns>
        Task<IGetTripApiResponse> GetTripAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Trip
        /// </summary>
        /// <remarks>
        /// Get an existing trip
        /// </remarks>
        /// <param name="id">the id of the trip to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTripApiResponse"/>?&gt;</returns>
        Task<IGetTripApiResponse?> GetTripOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Trip Matches
        /// </summary>
        /// <remarks>
        /// Get matching trips of specific trip
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id The id of the trip to search for matches for</param>
        /// <param name="sortField">The field to sort by</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order</param>
        /// <param name="start">The start index for pagination</param>
        /// <param name="limit">The limit for pagination</param>
        /// <param name="activeOnly">Return only active results</param>
        /// <param name="matchedHasRoute">Only return matchings that already have route assigned (optional)</param>
        /// <param name="matchedHasDriver">Only return matchings that already have driver assigned (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTripMatchesApiResponse"/>&gt;</returns>
        Task<IGetTripMatchesApiResponse> GetTripMatchesAsync(long id, string sortField, bool descending, int start, int limit, bool activeOnly, Option<bool> matchedHasRoute = default, Option<bool> matchedHasDriver = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Trip Matches
        /// </summary>
        /// <remarks>
        /// Get matching trips of specific trip
        /// </remarks>
        /// <param name="id">The id The id of the trip to search for matches for</param>
        /// <param name="sortField">The field to sort by</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order</param>
        /// <param name="start">The start index for pagination</param>
        /// <param name="limit">The limit for pagination</param>
        /// <param name="activeOnly">Return only active results</param>
        /// <param name="matchedHasRoute">Only return matchings that already have route assigned (optional)</param>
        /// <param name="matchedHasDriver">Only return matchings that already have driver assigned (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTripMatchesApiResponse"/>?&gt;</returns>
        Task<IGetTripMatchesApiResponse?> GetTripMatchesOrDefaultAsync(long id, string sortField, bool descending, int start, int limit, bool activeOnly, Option<bool> matchedHasRoute = default, Option<bool> matchedHasDriver = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Process Trip Matches
        /// </summary>
        /// <remarks>
        /// Process trip matching, assign trips with no route to matched trips with route.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startDate">The lower bound date to process matchings (optional)</param>
        /// <param name="endDate">The upper bound date to process matchings (optional)</param>
        /// <param name="tripId">the id of the trip to process (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IProcessTripMatchesApiResponse"/>&gt;</returns>
        Task<IProcessTripMatchesApiResponse> ProcessTripMatchesAsync(Option<long> startDate = default, Option<long> endDate = default, Option<long> tripId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Process Trip Matches
        /// </summary>
        /// <remarks>
        /// Process trip matching, assign trips with no route to matched trips with route.
        /// </remarks>
        /// <param name="startDate">The lower bound date to process matchings (optional)</param>
        /// <param name="endDate">The upper bound date to process matchings (optional)</param>
        /// <param name="tripId">the id of the trip to process (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IProcessTripMatchesApiResponse"/>?&gt;</returns>
        Task<IProcessTripMatchesApiResponse?> ProcessTripMatchesOrDefaultAsync(Option<long> startDate = default, Option<long> endDate = default, Option<long> tripId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set Trip Preference Rider
        /// </summary>
        /// <remarks>
        /// Update trip preference to ride.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip</param>
        /// <param name="recurrence">the frequency of the trip (e.g. weekly, until 2018-08-09)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRideApiResponse"/>&gt;</returns>
        Task<IRideApiResponse> RideAsync(long id, bool recurrence, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set Trip Preference Rider
        /// </summary>
        /// <remarks>
        /// Update trip preference to ride.
        /// </remarks>
        /// <param name="id">the id of the trip</param>
        /// <param name="recurrence">the frequency of the trip (e.g. weekly, until 2018-08-09)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRideApiResponse"/>?&gt;</returns>
        Task<IRideApiResponse?> RideOrDefaultAsync(long id, bool recurrence, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Trips
        /// </summary>
        /// <remarks>
        /// Search for trips
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The owner of the trips</param>
        /// <param name="sortField">The field to sort by</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order</param>
        /// <param name="start">The start index for pagination</param>
        /// <param name="limit">The limit for pagination</param>
        /// <param name="activeOnly">Return only active results</param>
        /// <param name="startDate">The lower bound limit of time (optional)</param>
        /// <param name="endDate">The upper bound limit of time (optional)</param>
        /// <param name="hasNotifications">whether to search on trips that have notifications or not (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchApiResponse"/>&gt;</returns>
        Task<ISearchApiResponse> SearchAsync(long accountId, string sortField, bool descending, int start, int limit, bool activeOnly, Option<long> startDate = default, Option<long> endDate = default, Option<bool> hasNotifications = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Trips
        /// </summary>
        /// <remarks>
        /// Search for trips
        /// </remarks>
        /// <param name="accountId">The owner of the trips</param>
        /// <param name="sortField">The field to sort by</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order</param>
        /// <param name="start">The start index for pagination</param>
        /// <param name="limit">The limit for pagination</param>
        /// <param name="activeOnly">Return only active results</param>
        /// <param name="startDate">The lower bound limit of time (optional)</param>
        /// <param name="endDate">The upper bound limit of time (optional)</param>
        /// <param name="hasNotifications">whether to search on trips that have notifications or not (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchApiResponse"/>?&gt;</returns>
        Task<ISearchApiResponse?> SearchOrDefaultAsync(long accountId, string sortField, bool descending, int start, int limit, bool activeOnly, Option<long> startDate = default, Option<long> endDate = default, Option<bool> hasNotifications = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Trips
        /// </summary>
        /// <remarks>
        /// Search for trips with matching information.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The owner of the trips</param>
        /// <param name="sortField">The field to sort by</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order</param>
        /// <param name="start">The start index for pagination</param>
        /// <param name="limit">The limit for pagination</param>
        /// <param name="activeOnly">Return only active results</param>
        /// <param name="startDate">The lower bound limit of time (optional)</param>
        /// <param name="endDate">The upper bound limit of time (optional)</param>
        /// <param name="matchedHasRoute">Only return matchings that already have route assigned (optional)</param>
        /// <param name="matchedHasDriver">Only return matchings that already have driver assigned (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchTripsApiResponse"/>&gt;</returns>
        Task<ISearchTripsApiResponse> SearchTripsAsync(long accountId, string sortField, bool descending, int start, int limit, bool activeOnly, Option<long> startDate = default, Option<long> endDate = default, Option<bool> matchedHasRoute = default, Option<bool> matchedHasDriver = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Trips
        /// </summary>
        /// <remarks>
        /// Search for trips with matching information.
        /// </remarks>
        /// <param name="accountId">The owner of the trips</param>
        /// <param name="sortField">The field to sort by</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order</param>
        /// <param name="start">The start index for pagination</param>
        /// <param name="limit">The limit for pagination</param>
        /// <param name="activeOnly">Return only active results</param>
        /// <param name="startDate">The lower bound limit of time (optional)</param>
        /// <param name="endDate">The upper bound limit of time (optional)</param>
        /// <param name="matchedHasRoute">Only return matchings that already have route assigned (optional)</param>
        /// <param name="matchedHasDriver">Only return matchings that already have driver assigned (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchTripsApiResponse"/>?&gt;</returns>
        Task<ISearchTripsApiResponse?> SearchTripsOrDefaultAsync(long accountId, string sortField, bool descending, int start, int limit, bool activeOnly, Option<long> startDate = default, Option<long> endDate = default, Option<bool> matchedHasRoute = default, Option<bool> matchedHasDriver = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Trip Locations
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip to update locations for</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateLocationsApiResponse"/>&gt;</returns>
        Task<IUpdateLocationsApiResponse> UpdateLocationsAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Trip Locations
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id">the id of the trip to update locations for</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateLocationsApiResponse"/>?&gt;</returns>
        Task<IUpdateLocationsApiResponse?> UpdateLocationsOrDefaultAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Recurrence Locations
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateRecurrenceLocationsApiResponse"/>&gt;</returns>
        Task<IUpdateRecurrenceLocationsApiResponse> UpdateRecurrenceLocationsAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Recurrence Locations
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id">the id of the trip</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateRecurrenceLocationsApiResponse"/>?&gt;</returns>
        Task<IUpdateRecurrenceLocationsApiResponse?> UpdateRecurrenceLocationsOrDefaultAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Recurrence Shipments
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateRecurrenceShipmentsApiResponse"/>&gt;</returns>
        Task<IUpdateRecurrenceShipmentsApiResponse> UpdateRecurrenceShipmentsAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Recurrence Shipments
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id">the id of the trip</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateRecurrenceShipmentsApiResponse"/>?&gt;</returns>
        Task<IUpdateRecurrenceShipmentsApiResponse?> UpdateRecurrenceShipmentsOrDefaultAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Trip Shipments
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip shipments to update</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateShipmentsApiResponse"/>&gt;</returns>
        Task<IUpdateShipmentsApiResponse> UpdateShipmentsAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Trip Shipments
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id">the id of the trip shipments to update</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateShipmentsApiResponse"/>?&gt;</returns>
        Task<IUpdateShipmentsApiResponse?> UpdateShipmentsOrDefaultAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Trip
        /// </summary>
        /// <remarks>
        /// Update an existing trip. Does not support recurring trip update.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip to update</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTripApiResponse"/>&gt;</returns>
        Task<IUpdateTripApiResponse> UpdateTripAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Trip
        /// </summary>
        /// <remarks>
        /// Update an existing trip. Does not support recurring trip update.
        /// </remarks>
        /// <param name="id">the id of the trip to update</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTripApiResponse"/>?&gt;</returns>
        Task<IUpdateTripApiResponse?> UpdateTripOrDefaultAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Trip Notifications
        /// </summary>
        /// <remarks>
        /// Update the trip notifications
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip</param>
        /// <param name="notifications">the notifications to update on the trip (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTripNotificationsApiResponse"/>&gt;</returns>
        Task<IUpdateTripNotificationsApiResponse> UpdateTripNotificationsAsync(long id, Option<string> notifications = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Trip Notifications
        /// </summary>
        /// <remarks>
        /// Update the trip notifications
        /// </remarks>
        /// <param name="id">the id of the trip</param>
        /// <param name="notifications">the notifications to update on the trip (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTripNotificationsApiResponse"/>?&gt;</returns>
        Task<IUpdateTripNotificationsApiResponse?> UpdateTripNotificationsOrDefaultAsync(long id, Option<string> notifications = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICreateTripApiResponse"/>
    /// </summary>
    public interface ICreateTripApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.Trip?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteApiResponse"/>
    /// </summary>
    public interface IDeleteApiResponse : Org.OpenAPITools.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IDriveTripApiResponse"/>
    /// </summary>
    public interface IDriveTripApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.Trip?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IFlexibleTripApiResponse"/>
    /// </summary>
    public interface IFlexibleTripApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.Trip?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetTripApiResponse"/>
    /// </summary>
    public interface IGetTripApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.Trip?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetTripMatchesApiResponse"/>
    /// </summary>
    public interface IGetTripMatchesApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<Trip>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IProcessTripMatchesApiResponse"/>
    /// </summary>
    public interface IProcessTripMatchesApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<Trip>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IRideApiResponse"/>
    /// </summary>
    public interface IRideApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.Trip?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchApiResponse"/>
    /// </summary>
    public interface ISearchApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<Trip>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchTripsApiResponse"/>
    /// </summary>
    public interface ISearchTripsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<Trip>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateLocationsApiResponse"/>
    /// </summary>
    public interface IUpdateLocationsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.Trip?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateRecurrenceLocationsApiResponse"/>
    /// </summary>
    public interface IUpdateRecurrenceLocationsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<Trip>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateRecurrenceShipmentsApiResponse"/>
    /// </summary>
    public interface IUpdateRecurrenceShipmentsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<List<Trip>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateShipmentsApiResponse"/>
    /// </summary>
    public interface IUpdateShipmentsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.Trip?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateTripApiResponse"/>
    /// </summary>
    public interface IUpdateTripApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.Trip?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateTripNotificationsApiResponse"/>
    /// </summary>
    public interface IUpdateTripNotificationsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.Trip?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class TripApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateTrip;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateTrip;

        internal void ExecuteOnCreateTrip(TripApi.CreateTripApiResponse apiResponse)
        {
            OnCreateTrip?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateTrip(Exception exception)
        {
            OnErrorCreateTrip?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDelete;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDelete;

        internal void ExecuteOnDelete(TripApi.DeleteApiResponse apiResponse)
        {
            OnDelete?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDelete(Exception exception)
        {
            OnErrorDelete?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDriveTrip;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDriveTrip;

        internal void ExecuteOnDriveTrip(TripApi.DriveTripApiResponse apiResponse)
        {
            OnDriveTrip?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDriveTrip(Exception exception)
        {
            OnErrorDriveTrip?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnFlexibleTrip;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorFlexibleTrip;

        internal void ExecuteOnFlexibleTrip(TripApi.FlexibleTripApiResponse apiResponse)
        {
            OnFlexibleTrip?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorFlexibleTrip(Exception exception)
        {
            OnErrorFlexibleTrip?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetTrip;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetTrip;

        internal void ExecuteOnGetTrip(TripApi.GetTripApiResponse apiResponse)
        {
            OnGetTrip?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetTrip(Exception exception)
        {
            OnErrorGetTrip?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetTripMatches;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetTripMatches;

        internal void ExecuteOnGetTripMatches(TripApi.GetTripMatchesApiResponse apiResponse)
        {
            OnGetTripMatches?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetTripMatches(Exception exception)
        {
            OnErrorGetTripMatches?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnProcessTripMatches;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorProcessTripMatches;

        internal void ExecuteOnProcessTripMatches(TripApi.ProcessTripMatchesApiResponse apiResponse)
        {
            OnProcessTripMatches?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorProcessTripMatches(Exception exception)
        {
            OnErrorProcessTripMatches?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRide;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRide;

        internal void ExecuteOnRide(TripApi.RideApiResponse apiResponse)
        {
            OnRide?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRide(Exception exception)
        {
            OnErrorRide?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearch;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearch;

        internal void ExecuteOnSearch(TripApi.SearchApiResponse apiResponse)
        {
            OnSearch?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearch(Exception exception)
        {
            OnErrorSearch?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchTrips;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchTrips;

        internal void ExecuteOnSearchTrips(TripApi.SearchTripsApiResponse apiResponse)
        {
            OnSearchTrips?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchTrips(Exception exception)
        {
            OnErrorSearchTrips?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateLocations;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateLocations;

        internal void ExecuteOnUpdateLocations(TripApi.UpdateLocationsApiResponse apiResponse)
        {
            OnUpdateLocations?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateLocations(Exception exception)
        {
            OnErrorUpdateLocations?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateRecurrenceLocations;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateRecurrenceLocations;

        internal void ExecuteOnUpdateRecurrenceLocations(TripApi.UpdateRecurrenceLocationsApiResponse apiResponse)
        {
            OnUpdateRecurrenceLocations?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateRecurrenceLocations(Exception exception)
        {
            OnErrorUpdateRecurrenceLocations?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateRecurrenceShipments;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateRecurrenceShipments;

        internal void ExecuteOnUpdateRecurrenceShipments(TripApi.UpdateRecurrenceShipmentsApiResponse apiResponse)
        {
            OnUpdateRecurrenceShipments?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateRecurrenceShipments(Exception exception)
        {
            OnErrorUpdateRecurrenceShipments?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateShipments;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateShipments;

        internal void ExecuteOnUpdateShipments(TripApi.UpdateShipmentsApiResponse apiResponse)
        {
            OnUpdateShipments?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateShipments(Exception exception)
        {
            OnErrorUpdateShipments?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateTrip;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateTrip;

        internal void ExecuteOnUpdateTrip(TripApi.UpdateTripApiResponse apiResponse)
        {
            OnUpdateTrip?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateTrip(Exception exception)
        {
            OnErrorUpdateTrip?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateTripNotifications;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateTripNotifications;

        internal void ExecuteOnUpdateTripNotifications(TripApi.UpdateTripNotificationsApiResponse apiResponse)
        {
            OnUpdateTripNotifications?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateTripNotifications(Exception exception)
        {
            OnErrorUpdateTripNotifications?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class TripApi : ITripApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<TripApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public TripApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="TripApi"/> class.
        /// </summary>
        /// <returns></returns>
        public TripApi(ILogger<TripApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, TripApiEvents tripApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<TripApi>();
            HttpClient = httpClient;
            Events = tripApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatCreateTrip(Option<Trip> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateCreateTrip(Option<Trip> body)
        {
            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="body"></param>
        private void AfterCreateTripDefaultImplementation(ICreateTripApiResponse apiResponseLocalVar, Option<Trip> body)
        {
            bool suppressDefaultLog = false;
            AfterCreateTrip(ref suppressDefaultLog, apiResponseLocalVar, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="body"></param>
        partial void AfterCreateTrip(ref bool suppressDefaultLog, ICreateTripApiResponse apiResponseLocalVar, Option<Trip> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="body"></param>
        private void OnErrorCreateTripDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Trip> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateTrip(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="body"></param>
        partial void OnErrorCreateTrip(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Trip> body);

        /// <summary>
        /// Create Trip Create a new trip
        /// </summary>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTripApiResponse"/>&gt;</returns>
        public async Task<ICreateTripApiResponse?> CreateTripOrDefaultAsync(Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateTripAsync(body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create Trip Create a new trip
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTripApiResponse"/>&gt;</returns>
        public async Task<ICreateTripApiResponse> CreateTripAsync(Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateTrip(body);

                FormatCreateTrip(body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/trip"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/trip");

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateTripApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateTripApiResponse>();
                        CreateTripApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/trip", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateTripDefaultImplementation(apiResponseLocalVar, body);

                        Events.ExecuteOnCreateTrip(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateTripDefaultImplementation(e, "/trip", uriBuilderLocalVar.Path, body);
                Events.ExecuteOnErrorCreateTrip(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateTripApiResponse"/>
        /// </summary>
        public partial class CreateTripApiResponse : Org.OpenAPITools.Client.ApiResponse, ICreateTripApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateTripApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateTripApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateTripApiResponse(ILogger<CreateTripApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateTripApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateTripApiResponse(ILogger<CreateTripApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.Trip? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.Trip>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.Trip? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDelete(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterDeleteDefaultImplementation(IDeleteApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterDelete(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterDelete(ref bool suppressDefaultLog, IDeleteApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorDeleteDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDelete(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorDelete(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Delete Trip Delete an existing trip
        /// </summary>
        /// <param name="id">the id of the trip to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteApiResponse"/>&gt;</returns>
        public async Task<IDeleteApiResponse?> DeleteOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete Trip Delete an existing trip
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip to delete</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteApiResponse"/>&gt;</returns>
        public async Task<IDeleteApiResponse> DeleteAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDelete(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/trip/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/trip/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DeleteApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteApiResponse>();
                        DeleteApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/trip/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDeleteDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnDelete(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteDefaultImplementation(e, "/trip/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorDelete(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteApiResponse"/>
        /// </summary>
        public partial class DeleteApiResponse : Org.OpenAPITools.Client.ApiResponse, IDeleteApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteApiResponse(ILogger<DeleteApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DeleteApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteApiResponse(ILogger<DeleteApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => true;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDriveTrip(ref long id, ref bool recurrence);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="recurrence"></param>
        private void AfterDriveTripDefaultImplementation(IDriveTripApiResponse apiResponseLocalVar, long id, bool recurrence)
        {
            bool suppressDefaultLog = false;
            AfterDriveTrip(ref suppressDefaultLog, apiResponseLocalVar, id, recurrence);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="recurrence"></param>
        partial void AfterDriveTrip(ref bool suppressDefaultLog, IDriveTripApiResponse apiResponseLocalVar, long id, bool recurrence);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="recurrence"></param>
        private void OnErrorDriveTripDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, bool recurrence)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDriveTrip(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, recurrence);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="recurrence"></param>
        partial void OnErrorDriveTrip(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, bool recurrence);

        /// <summary>
        /// Set Trip Preference Driver Update trip preference to drive, also create a route and assign the trip to the route
        /// </summary>
        /// <param name="id">the id of the trip</param>
        /// <param name="recurrence">the frequency of the trip (e.g. weekly, until 2018-08-09)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDriveTripApiResponse"/>&gt;</returns>
        public async Task<IDriveTripApiResponse?> DriveTripOrDefaultAsync(long id, bool recurrence, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DriveTripAsync(id, recurrence, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Set Trip Preference Driver Update trip preference to drive, also create a route and assign the trip to the route
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip</param>
        /// <param name="recurrence">the frequency of the trip (e.g. weekly, until 2018-08-09)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDriveTripApiResponse"/>&gt;</returns>
        public async Task<IDriveTripApiResponse> DriveTripAsync(long id, bool recurrence, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDriveTrip(ref id, ref recurrence);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/trip/{id}/drive"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/trip/{id}/drive");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["recurrence"] = ClientUtils.ParameterToString(recurrence);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DriveTripApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DriveTripApiResponse>();
                        DriveTripApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/trip/{id}/drive", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDriveTripDefaultImplementation(apiResponseLocalVar, id, recurrence);

                        Events.ExecuteOnDriveTrip(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDriveTripDefaultImplementation(e, "/trip/{id}/drive", uriBuilderLocalVar.Path, id, recurrence);
                Events.ExecuteOnErrorDriveTrip(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DriveTripApiResponse"/>
        /// </summary>
        public partial class DriveTripApiResponse : Org.OpenAPITools.Client.ApiResponse, IDriveTripApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DriveTripApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DriveTripApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DriveTripApiResponse(ILogger<DriveTripApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DriveTripApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DriveTripApiResponse(ILogger<DriveTripApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.Trip? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.Trip>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.Trip? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatFlexibleTrip(ref long id, ref bool recurrence);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="recurrence"></param>
        private void AfterFlexibleTripDefaultImplementation(IFlexibleTripApiResponse apiResponseLocalVar, long id, bool recurrence)
        {
            bool suppressDefaultLog = false;
            AfterFlexibleTrip(ref suppressDefaultLog, apiResponseLocalVar, id, recurrence);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="recurrence"></param>
        partial void AfterFlexibleTrip(ref bool suppressDefaultLog, IFlexibleTripApiResponse apiResponseLocalVar, long id, bool recurrence);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="recurrence"></param>
        private void OnErrorFlexibleTripDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, bool recurrence)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorFlexibleTrip(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, recurrence);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="recurrence"></param>
        partial void OnErrorFlexibleTrip(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, bool recurrence);

        /// <summary>
        /// Set Trip Preference Flexible Update trip preference to flexible.
        /// </summary>
        /// <param name="id">the id of the trip</param>
        /// <param name="recurrence">the frequency of the trip (e.g. weekly, until 2018-08-09)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFlexibleTripApiResponse"/>&gt;</returns>
        public async Task<IFlexibleTripApiResponse?> FlexibleTripOrDefaultAsync(long id, bool recurrence, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await FlexibleTripAsync(id, recurrence, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Set Trip Preference Flexible Update trip preference to flexible.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip</param>
        /// <param name="recurrence">the frequency of the trip (e.g. weekly, until 2018-08-09)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IFlexibleTripApiResponse"/>&gt;</returns>
        public async Task<IFlexibleTripApiResponse> FlexibleTripAsync(long id, bool recurrence, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatFlexibleTrip(ref id, ref recurrence);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/trip/{id}/flexible"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/trip/{id}/flexible");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["recurrence"] = ClientUtils.ParameterToString(recurrence);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<FlexibleTripApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<FlexibleTripApiResponse>();
                        FlexibleTripApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/trip/{id}/flexible", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterFlexibleTripDefaultImplementation(apiResponseLocalVar, id, recurrence);

                        Events.ExecuteOnFlexibleTrip(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorFlexibleTripDefaultImplementation(e, "/trip/{id}/flexible", uriBuilderLocalVar.Path, id, recurrence);
                Events.ExecuteOnErrorFlexibleTrip(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="FlexibleTripApiResponse"/>
        /// </summary>
        public partial class FlexibleTripApiResponse : Org.OpenAPITools.Client.ApiResponse, IFlexibleTripApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<FlexibleTripApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="FlexibleTripApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FlexibleTripApiResponse(ILogger<FlexibleTripApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="FlexibleTripApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public FlexibleTripApiResponse(ILogger<FlexibleTripApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.Trip? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.Trip>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.Trip? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetTrip(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterGetTripDefaultImplementation(IGetTripApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterGetTrip(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterGetTrip(ref bool suppressDefaultLog, IGetTripApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorGetTripDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetTrip(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorGetTrip(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Get Trip Get an existing trip
        /// </summary>
        /// <param name="id">the id of the trip to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTripApiResponse"/>&gt;</returns>
        public async Task<IGetTripApiResponse?> GetTripOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetTripAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Trip Get an existing trip
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTripApiResponse"/>&gt;</returns>
        public async Task<IGetTripApiResponse> GetTripAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetTrip(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/trip/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/trip/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetTripApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetTripApiResponse>();
                        GetTripApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/trip/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetTripDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnGetTrip(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetTripDefaultImplementation(e, "/trip/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorGetTrip(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetTripApiResponse"/>
        /// </summary>
        public partial class GetTripApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetTripApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetTripApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetTripApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTripApiResponse(ILogger<GetTripApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetTripApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTripApiResponse(ILogger<GetTripApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.Trip? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.Trip>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.Trip? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetTripMatches(ref long id, ref string sortField, ref bool descending, ref int start, ref int limit, ref bool activeOnly, ref Option<bool> matchedHasRoute, ref Option<bool> matchedHasDriver);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sortField"></param>
        /// <returns></returns>
        private void ValidateGetTripMatches(string sortField)
        {
            if (sortField == null)
                throw new ArgumentNullException(nameof(sortField));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        /// <param name="matchedHasRoute"></param>
        /// <param name="matchedHasDriver"></param>
        private void AfterGetTripMatchesDefaultImplementation(IGetTripMatchesApiResponse apiResponseLocalVar, long id, string sortField, bool descending, int start, int limit, bool activeOnly, Option<bool> matchedHasRoute, Option<bool> matchedHasDriver)
        {
            bool suppressDefaultLog = false;
            AfterGetTripMatches(ref suppressDefaultLog, apiResponseLocalVar, id, sortField, descending, start, limit, activeOnly, matchedHasRoute, matchedHasDriver);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        /// <param name="matchedHasRoute"></param>
        /// <param name="matchedHasDriver"></param>
        partial void AfterGetTripMatches(ref bool suppressDefaultLog, IGetTripMatchesApiResponse apiResponseLocalVar, long id, string sortField, bool descending, int start, int limit, bool activeOnly, Option<bool> matchedHasRoute, Option<bool> matchedHasDriver);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        /// <param name="matchedHasRoute"></param>
        /// <param name="matchedHasDriver"></param>
        private void OnErrorGetTripMatchesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, string sortField, bool descending, int start, int limit, bool activeOnly, Option<bool> matchedHasRoute, Option<bool> matchedHasDriver)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetTripMatches(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, sortField, descending, start, limit, activeOnly, matchedHasRoute, matchedHasDriver);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        /// <param name="matchedHasRoute"></param>
        /// <param name="matchedHasDriver"></param>
        partial void OnErrorGetTripMatches(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, string sortField, bool descending, int start, int limit, bool activeOnly, Option<bool> matchedHasRoute, Option<bool> matchedHasDriver);

        /// <summary>
        /// Get Trip Matches Get matching trips of specific trip
        /// </summary>
        /// <param name="id">The id The id of the trip to search for matches for</param>
        /// <param name="sortField">The field to sort by</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order</param>
        /// <param name="start">The start index for pagination</param>
        /// <param name="limit">The limit for pagination</param>
        /// <param name="activeOnly">Return only active results</param>
        /// <param name="matchedHasRoute">Only return matchings that already have route assigned (optional)</param>
        /// <param name="matchedHasDriver">Only return matchings that already have driver assigned (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTripMatchesApiResponse"/>&gt;</returns>
        public async Task<IGetTripMatchesApiResponse?> GetTripMatchesOrDefaultAsync(long id, string sortField, bool descending, int start, int limit, bool activeOnly, Option<bool> matchedHasRoute = default, Option<bool> matchedHasDriver = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetTripMatchesAsync(id, sortField, descending, start, limit, activeOnly, matchedHasRoute, matchedHasDriver, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Trip Matches Get matching trips of specific trip
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id The id of the trip to search for matches for</param>
        /// <param name="sortField">The field to sort by</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order</param>
        /// <param name="start">The start index for pagination</param>
        /// <param name="limit">The limit for pagination</param>
        /// <param name="activeOnly">Return only active results</param>
        /// <param name="matchedHasRoute">Only return matchings that already have route assigned (optional)</param>
        /// <param name="matchedHasDriver">Only return matchings that already have driver assigned (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTripMatchesApiResponse"/>&gt;</returns>
        public async Task<IGetTripMatchesApiResponse> GetTripMatchesAsync(long id, string sortField, bool descending, int start, int limit, bool activeOnly, Option<bool> matchedHasRoute = default, Option<bool> matchedHasDriver = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetTripMatches(sortField);

                FormatGetTripMatches(ref id, ref sortField, ref descending, ref start, ref limit, ref activeOnly, ref matchedHasRoute, ref matchedHasDriver);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/trip/{id}/match"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/trip/{id}/match");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["sortField"] = ClientUtils.ParameterToString(sortField);
                    parseQueryStringLocalVar["descending"] = ClientUtils.ParameterToString(descending);
                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit);
                    parseQueryStringLocalVar["activeOnly"] = ClientUtils.ParameterToString(activeOnly);

                    if (matchedHasRoute.IsSet)
                        parseQueryStringLocalVar["matchedHasRoute"] = ClientUtils.ParameterToString(matchedHasRoute.Value);

                    if (matchedHasDriver.IsSet)
                        parseQueryStringLocalVar["matchedHasDriver"] = ClientUtils.ParameterToString(matchedHasDriver.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetTripMatchesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetTripMatchesApiResponse>();
                        GetTripMatchesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/trip/{id}/match", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetTripMatchesDefaultImplementation(apiResponseLocalVar, id, sortField, descending, start, limit, activeOnly, matchedHasRoute, matchedHasDriver);

                        Events.ExecuteOnGetTripMatches(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetTripMatchesDefaultImplementation(e, "/trip/{id}/match", uriBuilderLocalVar.Path, id, sortField, descending, start, limit, activeOnly, matchedHasRoute, matchedHasDriver);
                Events.ExecuteOnErrorGetTripMatches(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetTripMatchesApiResponse"/>
        /// </summary>
        public partial class GetTripMatchesApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetTripMatchesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetTripMatchesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetTripMatchesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTripMatchesApiResponse(ILogger<GetTripMatchesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetTripMatchesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTripMatchesApiResponse(ILogger<GetTripMatchesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<Trip>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<Trip>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<Trip>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatProcessTripMatches(ref Option<long> startDate, ref Option<long> endDate, ref Option<long> tripId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="tripId"></param>
        private void AfterProcessTripMatchesDefaultImplementation(IProcessTripMatchesApiResponse apiResponseLocalVar, Option<long> startDate, Option<long> endDate, Option<long> tripId)
        {
            bool suppressDefaultLog = false;
            AfterProcessTripMatches(ref suppressDefaultLog, apiResponseLocalVar, startDate, endDate, tripId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="tripId"></param>
        partial void AfterProcessTripMatches(ref bool suppressDefaultLog, IProcessTripMatchesApiResponse apiResponseLocalVar, Option<long> startDate, Option<long> endDate, Option<long> tripId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="tripId"></param>
        private void OnErrorProcessTripMatchesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> startDate, Option<long> endDate, Option<long> tripId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorProcessTripMatches(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, startDate, endDate, tripId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="tripId"></param>
        partial void OnErrorProcessTripMatches(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> startDate, Option<long> endDate, Option<long> tripId);

        /// <summary>
        /// Process Trip Matches Process trip matching, assign trips with no route to matched trips with route.
        /// </summary>
        /// <param name="startDate">The lower bound date to process matchings (optional)</param>
        /// <param name="endDate">The upper bound date to process matchings (optional)</param>
        /// <param name="tripId">the id of the trip to process (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IProcessTripMatchesApiResponse"/>&gt;</returns>
        public async Task<IProcessTripMatchesApiResponse?> ProcessTripMatchesOrDefaultAsync(Option<long> startDate = default, Option<long> endDate = default, Option<long> tripId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ProcessTripMatchesAsync(startDate, endDate, tripId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Process Trip Matches Process trip matching, assign trips with no route to matched trips with route.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startDate">The lower bound date to process matchings (optional)</param>
        /// <param name="endDate">The upper bound date to process matchings (optional)</param>
        /// <param name="tripId">the id of the trip to process (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IProcessTripMatchesApiResponse"/>&gt;</returns>
        public async Task<IProcessTripMatchesApiResponse> ProcessTripMatchesAsync(Option<long> startDate = default, Option<long> endDate = default, Option<long> tripId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatProcessTripMatches(ref startDate, ref endDate, ref tripId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/trip/match/process"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/trip/match/process");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (startDate.IsSet)
                        parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate.Value);

                    if (endDate.IsSet)
                        parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate.Value);

                    if (tripId.IsSet)
                        parseQueryStringLocalVar["tripId"] = ClientUtils.ParameterToString(tripId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ProcessTripMatchesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ProcessTripMatchesApiResponse>();
                        ProcessTripMatchesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/trip/match/process", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterProcessTripMatchesDefaultImplementation(apiResponseLocalVar, startDate, endDate, tripId);

                        Events.ExecuteOnProcessTripMatches(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorProcessTripMatchesDefaultImplementation(e, "/trip/match/process", uriBuilderLocalVar.Path, startDate, endDate, tripId);
                Events.ExecuteOnErrorProcessTripMatches(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ProcessTripMatchesApiResponse"/>
        /// </summary>
        public partial class ProcessTripMatchesApiResponse : Org.OpenAPITools.Client.ApiResponse, IProcessTripMatchesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ProcessTripMatchesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ProcessTripMatchesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ProcessTripMatchesApiResponse(ILogger<ProcessTripMatchesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ProcessTripMatchesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ProcessTripMatchesApiResponse(ILogger<ProcessTripMatchesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<Trip>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<Trip>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<Trip>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRide(ref long id, ref bool recurrence);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="recurrence"></param>
        private void AfterRideDefaultImplementation(IRideApiResponse apiResponseLocalVar, long id, bool recurrence)
        {
            bool suppressDefaultLog = false;
            AfterRide(ref suppressDefaultLog, apiResponseLocalVar, id, recurrence);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="recurrence"></param>
        partial void AfterRide(ref bool suppressDefaultLog, IRideApiResponse apiResponseLocalVar, long id, bool recurrence);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="recurrence"></param>
        private void OnErrorRideDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, bool recurrence)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorRide(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, recurrence);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="recurrence"></param>
        partial void OnErrorRide(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, bool recurrence);

        /// <summary>
        /// Set Trip Preference Rider Update trip preference to ride.
        /// </summary>
        /// <param name="id">the id of the trip</param>
        /// <param name="recurrence">the frequency of the trip (e.g. weekly, until 2018-08-09)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRideApiResponse"/>&gt;</returns>
        public async Task<IRideApiResponse?> RideOrDefaultAsync(long id, bool recurrence, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RideAsync(id, recurrence, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Set Trip Preference Rider Update trip preference to ride.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip</param>
        /// <param name="recurrence">the frequency of the trip (e.g. weekly, until 2018-08-09)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRideApiResponse"/>&gt;</returns>
        public async Task<IRideApiResponse> RideAsync(long id, bool recurrence, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatRide(ref id, ref recurrence);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/trip/{id}/ride"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/trip/{id}/ride");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["recurrence"] = ClientUtils.ParameterToString(recurrence);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<RideApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RideApiResponse>();
                        RideApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/trip/{id}/ride", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterRideDefaultImplementation(apiResponseLocalVar, id, recurrence);

                        Events.ExecuteOnRide(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRideDefaultImplementation(e, "/trip/{id}/ride", uriBuilderLocalVar.Path, id, recurrence);
                Events.ExecuteOnErrorRide(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RideApiResponse"/>
        /// </summary>
        public partial class RideApiResponse : Org.OpenAPITools.Client.ApiResponse, IRideApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RideApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RideApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RideApiResponse(ILogger<RideApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="RideApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RideApiResponse(ILogger<RideApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.Trip? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.Trip>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.Trip? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearch(ref long accountId, ref string sortField, ref bool descending, ref int start, ref int limit, ref bool activeOnly, ref Option<long> startDate, ref Option<long> endDate, ref Option<bool> hasNotifications);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sortField"></param>
        /// <returns></returns>
        private void ValidateSearch(string sortField)
        {
            if (sortField == null)
                throw new ArgumentNullException(nameof(sortField));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="hasNotifications"></param>
        private void AfterSearchDefaultImplementation(ISearchApiResponse apiResponseLocalVar, long accountId, string sortField, bool descending, int start, int limit, bool activeOnly, Option<long> startDate, Option<long> endDate, Option<bool> hasNotifications)
        {
            bool suppressDefaultLog = false;
            AfterSearch(ref suppressDefaultLog, apiResponseLocalVar, accountId, sortField, descending, start, limit, activeOnly, startDate, endDate, hasNotifications);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="hasNotifications"></param>
        partial void AfterSearch(ref bool suppressDefaultLog, ISearchApiResponse apiResponseLocalVar, long accountId, string sortField, bool descending, int start, int limit, bool activeOnly, Option<long> startDate, Option<long> endDate, Option<bool> hasNotifications);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="hasNotifications"></param>
        private void OnErrorSearchDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string sortField, bool descending, int start, int limit, bool activeOnly, Option<long> startDate, Option<long> endDate, Option<bool> hasNotifications)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearch(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, sortField, descending, start, limit, activeOnly, startDate, endDate, hasNotifications);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="hasNotifications"></param>
        partial void OnErrorSearch(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string sortField, bool descending, int start, int limit, bool activeOnly, Option<long> startDate, Option<long> endDate, Option<bool> hasNotifications);

        /// <summary>
        /// Search Trips Search for trips
        /// </summary>
        /// <param name="accountId">The owner of the trips</param>
        /// <param name="sortField">The field to sort by</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order</param>
        /// <param name="start">The start index for pagination</param>
        /// <param name="limit">The limit for pagination</param>
        /// <param name="activeOnly">Return only active results</param>
        /// <param name="startDate">The lower bound limit of time (optional)</param>
        /// <param name="endDate">The upper bound limit of time (optional)</param>
        /// <param name="hasNotifications">whether to search on trips that have notifications or not (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchApiResponse"/>&gt;</returns>
        public async Task<ISearchApiResponse?> SearchOrDefaultAsync(long accountId, string sortField, bool descending, int start, int limit, bool activeOnly, Option<long> startDate = default, Option<long> endDate = default, Option<bool> hasNotifications = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchAsync(accountId, sortField, descending, start, limit, activeOnly, startDate, endDate, hasNotifications, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Trips Search for trips
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The owner of the trips</param>
        /// <param name="sortField">The field to sort by</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order</param>
        /// <param name="start">The start index for pagination</param>
        /// <param name="limit">The limit for pagination</param>
        /// <param name="activeOnly">Return only active results</param>
        /// <param name="startDate">The lower bound limit of time (optional)</param>
        /// <param name="endDate">The upper bound limit of time (optional)</param>
        /// <param name="hasNotifications">whether to search on trips that have notifications or not (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchApiResponse"/>&gt;</returns>
        public async Task<ISearchApiResponse> SearchAsync(long accountId, string sortField, bool descending, int start, int limit, bool activeOnly, Option<long> startDate = default, Option<long> endDate = default, Option<bool> hasNotifications = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearch(sortField);

                FormatSearch(ref accountId, ref sortField, ref descending, ref start, ref limit, ref activeOnly, ref startDate, ref endDate, ref hasNotifications);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/trip"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/trip");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["sortField"] = ClientUtils.ParameterToString(sortField);
                    parseQueryStringLocalVar["descending"] = ClientUtils.ParameterToString(descending);
                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit);
                    parseQueryStringLocalVar["activeOnly"] = ClientUtils.ParameterToString(activeOnly);

                    if (startDate.IsSet)
                        parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate.Value);

                    if (endDate.IsSet)
                        parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate.Value);

                    if (hasNotifications.IsSet)
                        parseQueryStringLocalVar["hasNotifications"] = ClientUtils.ParameterToString(hasNotifications.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchApiResponse>();
                        SearchApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/trip", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchDefaultImplementation(apiResponseLocalVar, accountId, sortField, descending, start, limit, activeOnly, startDate, endDate, hasNotifications);

                        Events.ExecuteOnSearch(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchDefaultImplementation(e, "/trip", uriBuilderLocalVar.Path, accountId, sortField, descending, start, limit, activeOnly, startDate, endDate, hasNotifications);
                Events.ExecuteOnErrorSearch(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchApiResponse"/>
        /// </summary>
        public partial class SearchApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchApiResponse(ILogger<SearchApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchApiResponse(ILogger<SearchApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<Trip>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<Trip>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<Trip>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchTrips(ref long accountId, ref string sortField, ref bool descending, ref int start, ref int limit, ref bool activeOnly, ref Option<long> startDate, ref Option<long> endDate, ref Option<bool> matchedHasRoute, ref Option<bool> matchedHasDriver);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sortField"></param>
        /// <returns></returns>
        private void ValidateSearchTrips(string sortField)
        {
            if (sortField == null)
                throw new ArgumentNullException(nameof(sortField));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="matchedHasRoute"></param>
        /// <param name="matchedHasDriver"></param>
        private void AfterSearchTripsDefaultImplementation(ISearchTripsApiResponse apiResponseLocalVar, long accountId, string sortField, bool descending, int start, int limit, bool activeOnly, Option<long> startDate, Option<long> endDate, Option<bool> matchedHasRoute, Option<bool> matchedHasDriver)
        {
            bool suppressDefaultLog = false;
            AfterSearchTrips(ref suppressDefaultLog, apiResponseLocalVar, accountId, sortField, descending, start, limit, activeOnly, startDate, endDate, matchedHasRoute, matchedHasDriver);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="matchedHasRoute"></param>
        /// <param name="matchedHasDriver"></param>
        partial void AfterSearchTrips(ref bool suppressDefaultLog, ISearchTripsApiResponse apiResponseLocalVar, long accountId, string sortField, bool descending, int start, int limit, bool activeOnly, Option<long> startDate, Option<long> endDate, Option<bool> matchedHasRoute, Option<bool> matchedHasDriver);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="matchedHasRoute"></param>
        /// <param name="matchedHasDriver"></param>
        private void OnErrorSearchTripsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string sortField, bool descending, int start, int limit, bool activeOnly, Option<long> startDate, Option<long> endDate, Option<bool> matchedHasRoute, Option<bool> matchedHasDriver)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchTrips(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, sortField, descending, start, limit, activeOnly, startDate, endDate, matchedHasRoute, matchedHasDriver);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="matchedHasRoute"></param>
        /// <param name="matchedHasDriver"></param>
        partial void OnErrorSearchTrips(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long accountId, string sortField, bool descending, int start, int limit, bool activeOnly, Option<long> startDate, Option<long> endDate, Option<bool> matchedHasRoute, Option<bool> matchedHasDriver);

        /// <summary>
        /// Search Trips Search for trips with matching information.
        /// </summary>
        /// <param name="accountId">The owner of the trips</param>
        /// <param name="sortField">The field to sort by</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order</param>
        /// <param name="start">The start index for pagination</param>
        /// <param name="limit">The limit for pagination</param>
        /// <param name="activeOnly">Return only active results</param>
        /// <param name="startDate">The lower bound limit of time (optional)</param>
        /// <param name="endDate">The upper bound limit of time (optional)</param>
        /// <param name="matchedHasRoute">Only return matchings that already have route assigned (optional)</param>
        /// <param name="matchedHasDriver">Only return matchings that already have driver assigned (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchTripsApiResponse"/>&gt;</returns>
        public async Task<ISearchTripsApiResponse?> SearchTripsOrDefaultAsync(long accountId, string sortField, bool descending, int start, int limit, bool activeOnly, Option<long> startDate = default, Option<long> endDate = default, Option<bool> matchedHasRoute = default, Option<bool> matchedHasDriver = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchTripsAsync(accountId, sortField, descending, start, limit, activeOnly, startDate, endDate, matchedHasRoute, matchedHasDriver, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Trips Search for trips with matching information.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The owner of the trips</param>
        /// <param name="sortField">The field to sort by</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order</param>
        /// <param name="start">The start index for pagination</param>
        /// <param name="limit">The limit for pagination</param>
        /// <param name="activeOnly">Return only active results</param>
        /// <param name="startDate">The lower bound limit of time (optional)</param>
        /// <param name="endDate">The upper bound limit of time (optional)</param>
        /// <param name="matchedHasRoute">Only return matchings that already have route assigned (optional)</param>
        /// <param name="matchedHasDriver">Only return matchings that already have driver assigned (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchTripsApiResponse"/>&gt;</returns>
        public async Task<ISearchTripsApiResponse> SearchTripsAsync(long accountId, string sortField, bool descending, int start, int limit, bool activeOnly, Option<long> startDate = default, Option<long> endDate = default, Option<bool> matchedHasRoute = default, Option<bool> matchedHasDriver = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchTrips(sortField);

                FormatSearchTrips(ref accountId, ref sortField, ref descending, ref start, ref limit, ref activeOnly, ref startDate, ref endDate, ref matchedHasRoute, ref matchedHasDriver);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/trip/match"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/trip/match");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["sortField"] = ClientUtils.ParameterToString(sortField);
                    parseQueryStringLocalVar["descending"] = ClientUtils.ParameterToString(descending);
                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit);
                    parseQueryStringLocalVar["activeOnly"] = ClientUtils.ParameterToString(activeOnly);

                    if (startDate.IsSet)
                        parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate.Value);

                    if (endDate.IsSet)
                        parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate.Value);

                    if (matchedHasRoute.IsSet)
                        parseQueryStringLocalVar["matchedHasRoute"] = ClientUtils.ParameterToString(matchedHasRoute.Value);

                    if (matchedHasDriver.IsSet)
                        parseQueryStringLocalVar["matchedHasDriver"] = ClientUtils.ParameterToString(matchedHasDriver.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchTripsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchTripsApiResponse>();
                        SearchTripsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/trip/match", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchTripsDefaultImplementation(apiResponseLocalVar, accountId, sortField, descending, start, limit, activeOnly, startDate, endDate, matchedHasRoute, matchedHasDriver);

                        Events.ExecuteOnSearchTrips(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchTripsDefaultImplementation(e, "/trip/match", uriBuilderLocalVar.Path, accountId, sortField, descending, start, limit, activeOnly, startDate, endDate, matchedHasRoute, matchedHasDriver);
                Events.ExecuteOnErrorSearchTrips(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchTripsApiResponse"/>
        /// </summary>
        public partial class SearchTripsApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchTripsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchTripsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchTripsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchTripsApiResponse(ILogger<SearchTripsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchTripsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchTripsApiResponse(ILogger<SearchTripsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<Trip>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<Trip>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<Trip>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateLocations(ref long id, Option<Trip> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateUpdateLocations(Option<Trip> body)
        {
            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        private void AfterUpdateLocationsDefaultImplementation(IUpdateLocationsApiResponse apiResponseLocalVar, long id, Option<Trip> body)
        {
            bool suppressDefaultLog = false;
            AfterUpdateLocations(ref suppressDefaultLog, apiResponseLocalVar, id, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        partial void AfterUpdateLocations(ref bool suppressDefaultLog, IUpdateLocationsApiResponse apiResponseLocalVar, long id, Option<Trip> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        private void OnErrorUpdateLocationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<Trip> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateLocations(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        partial void OnErrorUpdateLocations(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<Trip> body);

        /// <summary>
        /// Update Trip Locations 
        /// </summary>
        /// <param name="id">the id of the trip to update locations for</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateLocationsApiResponse"/>&gt;</returns>
        public async Task<IUpdateLocationsApiResponse?> UpdateLocationsOrDefaultAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateLocationsAsync(id, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update Trip Locations 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip to update locations for</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateLocationsApiResponse"/>&gt;</returns>
        public async Task<IUpdateLocationsApiResponse> UpdateLocationsAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateLocations(body);

                FormatUpdateLocations(ref id, body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/trip/{id}/locations"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/trip/{id}/locations");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UpdateLocationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateLocationsApiResponse>();
                        UpdateLocationsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/trip/{id}/locations", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUpdateLocationsDefaultImplementation(apiResponseLocalVar, id, body);

                        Events.ExecuteOnUpdateLocations(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateLocationsDefaultImplementation(e, "/trip/{id}/locations", uriBuilderLocalVar.Path, id, body);
                Events.ExecuteOnErrorUpdateLocations(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateLocationsApiResponse"/>
        /// </summary>
        public partial class UpdateLocationsApiResponse : Org.OpenAPITools.Client.ApiResponse, IUpdateLocationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateLocationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateLocationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateLocationsApiResponse(ILogger<UpdateLocationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UpdateLocationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateLocationsApiResponse(ILogger<UpdateLocationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.Trip? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.Trip>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.Trip? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateRecurrenceLocations(ref long id, Option<Trip> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateUpdateRecurrenceLocations(Option<Trip> body)
        {
            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        private void AfterUpdateRecurrenceLocationsDefaultImplementation(IUpdateRecurrenceLocationsApiResponse apiResponseLocalVar, long id, Option<Trip> body)
        {
            bool suppressDefaultLog = false;
            AfterUpdateRecurrenceLocations(ref suppressDefaultLog, apiResponseLocalVar, id, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        partial void AfterUpdateRecurrenceLocations(ref bool suppressDefaultLog, IUpdateRecurrenceLocationsApiResponse apiResponseLocalVar, long id, Option<Trip> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        private void OnErrorUpdateRecurrenceLocationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<Trip> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateRecurrenceLocations(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        partial void OnErrorUpdateRecurrenceLocations(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<Trip> body);

        /// <summary>
        /// Update Recurrence Locations 
        /// </summary>
        /// <param name="id">the id of the trip</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateRecurrenceLocationsApiResponse"/>&gt;</returns>
        public async Task<IUpdateRecurrenceLocationsApiResponse?> UpdateRecurrenceLocationsOrDefaultAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateRecurrenceLocationsAsync(id, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update Recurrence Locations 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateRecurrenceLocationsApiResponse"/>&gt;</returns>
        public async Task<IUpdateRecurrenceLocationsApiResponse> UpdateRecurrenceLocationsAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateRecurrenceLocations(body);

                FormatUpdateRecurrenceLocations(ref id, body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/trip/{id}/locations/recurrence"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/trip/{id}/locations/recurrence");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UpdateRecurrenceLocationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateRecurrenceLocationsApiResponse>();
                        UpdateRecurrenceLocationsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/trip/{id}/locations/recurrence", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUpdateRecurrenceLocationsDefaultImplementation(apiResponseLocalVar, id, body);

                        Events.ExecuteOnUpdateRecurrenceLocations(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateRecurrenceLocationsDefaultImplementation(e, "/trip/{id}/locations/recurrence", uriBuilderLocalVar.Path, id, body);
                Events.ExecuteOnErrorUpdateRecurrenceLocations(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateRecurrenceLocationsApiResponse"/>
        /// </summary>
        public partial class UpdateRecurrenceLocationsApiResponse : Org.OpenAPITools.Client.ApiResponse, IUpdateRecurrenceLocationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateRecurrenceLocationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateRecurrenceLocationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateRecurrenceLocationsApiResponse(ILogger<UpdateRecurrenceLocationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UpdateRecurrenceLocationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateRecurrenceLocationsApiResponse(ILogger<UpdateRecurrenceLocationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<Trip>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<Trip>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<Trip>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateRecurrenceShipments(ref long id, Option<Trip> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateUpdateRecurrenceShipments(Option<Trip> body)
        {
            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        private void AfterUpdateRecurrenceShipmentsDefaultImplementation(IUpdateRecurrenceShipmentsApiResponse apiResponseLocalVar, long id, Option<Trip> body)
        {
            bool suppressDefaultLog = false;
            AfterUpdateRecurrenceShipments(ref suppressDefaultLog, apiResponseLocalVar, id, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        partial void AfterUpdateRecurrenceShipments(ref bool suppressDefaultLog, IUpdateRecurrenceShipmentsApiResponse apiResponseLocalVar, long id, Option<Trip> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        private void OnErrorUpdateRecurrenceShipmentsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<Trip> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateRecurrenceShipments(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        partial void OnErrorUpdateRecurrenceShipments(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<Trip> body);

        /// <summary>
        /// Update Recurrence Shipments 
        /// </summary>
        /// <param name="id">the id of the trip</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateRecurrenceShipmentsApiResponse"/>&gt;</returns>
        public async Task<IUpdateRecurrenceShipmentsApiResponse?> UpdateRecurrenceShipmentsOrDefaultAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateRecurrenceShipmentsAsync(id, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update Recurrence Shipments 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateRecurrenceShipmentsApiResponse"/>&gt;</returns>
        public async Task<IUpdateRecurrenceShipmentsApiResponse> UpdateRecurrenceShipmentsAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateRecurrenceShipments(body);

                FormatUpdateRecurrenceShipments(ref id, body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/trip/{id}/shipments/recurrence"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/trip/{id}/shipments/recurrence");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UpdateRecurrenceShipmentsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateRecurrenceShipmentsApiResponse>();
                        UpdateRecurrenceShipmentsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/trip/{id}/shipments/recurrence", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUpdateRecurrenceShipmentsDefaultImplementation(apiResponseLocalVar, id, body);

                        Events.ExecuteOnUpdateRecurrenceShipments(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateRecurrenceShipmentsDefaultImplementation(e, "/trip/{id}/shipments/recurrence", uriBuilderLocalVar.Path, id, body);
                Events.ExecuteOnErrorUpdateRecurrenceShipments(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateRecurrenceShipmentsApiResponse"/>
        /// </summary>
        public partial class UpdateRecurrenceShipmentsApiResponse : Org.OpenAPITools.Client.ApiResponse, IUpdateRecurrenceShipmentsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateRecurrenceShipmentsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateRecurrenceShipmentsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateRecurrenceShipmentsApiResponse(ILogger<UpdateRecurrenceShipmentsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UpdateRecurrenceShipmentsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateRecurrenceShipmentsApiResponse(ILogger<UpdateRecurrenceShipmentsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<Trip>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<Trip>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<Trip>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateShipments(ref long id, Option<Trip> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateUpdateShipments(Option<Trip> body)
        {
            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        private void AfterUpdateShipmentsDefaultImplementation(IUpdateShipmentsApiResponse apiResponseLocalVar, long id, Option<Trip> body)
        {
            bool suppressDefaultLog = false;
            AfterUpdateShipments(ref suppressDefaultLog, apiResponseLocalVar, id, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        partial void AfterUpdateShipments(ref bool suppressDefaultLog, IUpdateShipmentsApiResponse apiResponseLocalVar, long id, Option<Trip> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        private void OnErrorUpdateShipmentsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<Trip> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateShipments(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        partial void OnErrorUpdateShipments(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<Trip> body);

        /// <summary>
        /// Update Trip Shipments 
        /// </summary>
        /// <param name="id">the id of the trip shipments to update</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateShipmentsApiResponse"/>&gt;</returns>
        public async Task<IUpdateShipmentsApiResponse?> UpdateShipmentsOrDefaultAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateShipmentsAsync(id, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update Trip Shipments 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip shipments to update</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateShipmentsApiResponse"/>&gt;</returns>
        public async Task<IUpdateShipmentsApiResponse> UpdateShipmentsAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateShipments(body);

                FormatUpdateShipments(ref id, body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/trip/{id}/shipments"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/trip/{id}/shipments");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UpdateShipmentsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateShipmentsApiResponse>();
                        UpdateShipmentsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/trip/{id}/shipments", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUpdateShipmentsDefaultImplementation(apiResponseLocalVar, id, body);

                        Events.ExecuteOnUpdateShipments(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateShipmentsDefaultImplementation(e, "/trip/{id}/shipments", uriBuilderLocalVar.Path, id, body);
                Events.ExecuteOnErrorUpdateShipments(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateShipmentsApiResponse"/>
        /// </summary>
        public partial class UpdateShipmentsApiResponse : Org.OpenAPITools.Client.ApiResponse, IUpdateShipmentsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateShipmentsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateShipmentsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateShipmentsApiResponse(ILogger<UpdateShipmentsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UpdateShipmentsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateShipmentsApiResponse(ILogger<UpdateShipmentsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.Trip? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.Trip>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.Trip? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateTrip(ref long id, Option<Trip> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateUpdateTrip(Option<Trip> body)
        {
            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        private void AfterUpdateTripDefaultImplementation(IUpdateTripApiResponse apiResponseLocalVar, long id, Option<Trip> body)
        {
            bool suppressDefaultLog = false;
            AfterUpdateTrip(ref suppressDefaultLog, apiResponseLocalVar, id, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        partial void AfterUpdateTrip(ref bool suppressDefaultLog, IUpdateTripApiResponse apiResponseLocalVar, long id, Option<Trip> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        private void OnErrorUpdateTripDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<Trip> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateTrip(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        partial void OnErrorUpdateTrip(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<Trip> body);

        /// <summary>
        /// Update Trip Update an existing trip. Does not support recurring trip update.
        /// </summary>
        /// <param name="id">the id of the trip to update</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTripApiResponse"/>&gt;</returns>
        public async Task<IUpdateTripApiResponse?> UpdateTripOrDefaultAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateTripAsync(id, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update Trip Update an existing trip. Does not support recurring trip update.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip to update</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTripApiResponse"/>&gt;</returns>
        public async Task<IUpdateTripApiResponse> UpdateTripAsync(long id, Option<Trip> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateTrip(body);

                FormatUpdateTrip(ref id, body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/trip/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/trip/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UpdateTripApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateTripApiResponse>();
                        UpdateTripApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/trip/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUpdateTripDefaultImplementation(apiResponseLocalVar, id, body);

                        Events.ExecuteOnUpdateTrip(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateTripDefaultImplementation(e, "/trip/{id}", uriBuilderLocalVar.Path, id, body);
                Events.ExecuteOnErrorUpdateTrip(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateTripApiResponse"/>
        /// </summary>
        public partial class UpdateTripApiResponse : Org.OpenAPITools.Client.ApiResponse, IUpdateTripApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateTripApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateTripApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateTripApiResponse(ILogger<UpdateTripApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UpdateTripApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateTripApiResponse(ILogger<UpdateTripApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.Trip? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.Trip>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.Trip? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateTripNotifications(ref long id, ref Option<string> notifications);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="notifications"></param>
        /// <returns></returns>
        private void ValidateUpdateTripNotifications(Option<string> notifications)
        {
            if (notifications.IsSet && notifications.Value == null)
                throw new ArgumentNullException(nameof(notifications));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="notifications"></param>
        private void AfterUpdateTripNotificationsDefaultImplementation(IUpdateTripNotificationsApiResponse apiResponseLocalVar, long id, Option<string> notifications)
        {
            bool suppressDefaultLog = false;
            AfterUpdateTripNotifications(ref suppressDefaultLog, apiResponseLocalVar, id, notifications);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="notifications"></param>
        partial void AfterUpdateTripNotifications(ref bool suppressDefaultLog, IUpdateTripNotificationsApiResponse apiResponseLocalVar, long id, Option<string> notifications);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="notifications"></param>
        private void OnErrorUpdateTripNotificationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<string> notifications)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateTripNotifications(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, notifications);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="notifications"></param>
        partial void OnErrorUpdateTripNotifications(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<string> notifications);

        /// <summary>
        /// Trip Notifications Update the trip notifications
        /// </summary>
        /// <param name="id">the id of the trip</param>
        /// <param name="notifications">the notifications to update on the trip (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTripNotificationsApiResponse"/>&gt;</returns>
        public async Task<IUpdateTripNotificationsApiResponse?> UpdateTripNotificationsOrDefaultAsync(long id, Option<string> notifications = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateTripNotificationsAsync(id, notifications, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Trip Notifications Update the trip notifications
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">the id of the trip</param>
        /// <param name="notifications">the notifications to update on the trip (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTripNotificationsApiResponse"/>&gt;</returns>
        public async Task<IUpdateTripNotificationsApiResponse> UpdateTripNotificationsAsync(long id, Option<string> notifications = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateTripNotifications(notifications);

                FormatUpdateTripNotifications(ref id, ref notifications);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/trip/notifications"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/trip/notifications");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id);

                    if (notifications.IsSet)
                        parseQueryStringLocalVar["notifications"] = ClientUtils.ParameterToString(notifications.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UpdateTripNotificationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateTripNotificationsApiResponse>();
                        UpdateTripNotificationsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/trip/notifications", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUpdateTripNotificationsDefaultImplementation(apiResponseLocalVar, id, notifications);

                        Events.ExecuteOnUpdateTripNotifications(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateTripNotificationsDefaultImplementation(e, "/trip/notifications", uriBuilderLocalVar.Path, id, notifications);
                Events.ExecuteOnErrorUpdateTripNotifications(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateTripNotificationsApiResponse"/>
        /// </summary>
        public partial class UpdateTripNotificationsApiResponse : Org.OpenAPITools.Client.ApiResponse, IUpdateTripNotificationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateTripNotificationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateTripNotificationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateTripNotificationsApiResponse(ILogger<UpdateTripNotificationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UpdateTripNotificationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateTripNotificationsApiResponse(ILogger<UpdateTripNotificationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.Trip? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.Trip>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.Trip? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
