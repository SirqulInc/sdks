// <auto-generated>
/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Net;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IScheduledNotificationApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ScheduledNotificationApiEvents Events { get; }

        /// <summary>
        /// Create Scheduled Notification
        /// </summary>
        /// <remarks>
        /// This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="name">The name of the scheduled notification</param>
        /// <param name="type">The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages</param>
        /// <param name="message">The message to send</param>
        /// <param name="contentId">The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="contentName">The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="contentType">The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="parentId">The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="parentType">The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="appKey">The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)</param>
        /// <param name="groupingId">Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)</param>
        /// <param name="connectionGroupIds">The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)</param>
        /// <param name="connectionAccountIds">The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)</param>
        /// <param name="audienceId">This parameter is deprecated. The audience used to generate the list of recipients (optional)</param>
        /// <param name="audienceIds">The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)</param>
        /// <param name="albumIds">The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)</param>
        /// <param name="reportId">The report used to generate the the list of recipients (optional)</param>
        /// <param name="reportParams">The parameters to supply to the report used to generate the the list of recipients (optional)</param>
        /// <param name="endpointURL">The URL for making an HTTP call (optional)</param>
        /// <param name="payload">The parameters for making an HTTP call (optional)</param>
        /// <param name="scheduledDate">The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)</param>
        /// <param name="startDate">The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)</param>
        /// <param name="endDate">The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)</param>
        /// <param name="cronExpression">The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)</param>
        /// <param name="cronType">The cron expression type: UNIX, CRON4J, QUARTZ (optional)</param>
        /// <param name="metaData">Additional metadata for the scheduled notification (optional)</param>
        /// <param name="conditionalInput">Json input representing conditional logic that has to be met before running the scheduled notification (optional)</param>
        /// <param name="templateType">This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)</param>
        /// <param name="visibility">Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)</param>
        /// <param name="active">Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;. (optional)</param>
        /// <param name="sendNow"> (optional)</param>
        /// <param name="eventType">Sets the event type for the notification (optional, default to &quot;CUSTOM&quot;)</param>
        /// <param name="deepLinkURI">The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)</param>
        /// <param name="sendToAll">Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateScheduledNotificationApiResponse"/>&gt;</returns>
        Task<ICreateScheduledNotificationApiResponse> CreateScheduledNotificationAsync(decimal version, long accountId, string name, string type, string message, Option<long> contentId = default, Option<string> contentName = default, Option<string> contentType = default, Option<long> parentId = default, Option<string> parentType = default, Option<string> appKey = default, Option<string> groupingId = default, Option<string> connectionGroupIds = default, Option<string> connectionAccountIds = default, Option<long> audienceId = default, Option<string> audienceIds = default, Option<string> albumIds = default, Option<long> reportId = default, Option<string> reportParams = default, Option<string> endpointURL = default, Option<string> payload = default, Option<long> scheduledDate = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> cronExpression = default, Option<string> cronType = default, Option<string> metaData = default, Option<string> conditionalInput = default, Option<string> templateType = default, Option<string> visibility = default, Option<bool> active = default, Option<bool> sendNow = default, Option<string> eventType = default, Option<string> deepLinkURI = default, Option<bool> sendToAll = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Scheduled Notification
        /// </summary>
        /// <remarks>
        /// This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="name">The name of the scheduled notification</param>
        /// <param name="type">The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages</param>
        /// <param name="message">The message to send</param>
        /// <param name="contentId">The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="contentName">The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="contentType">The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="parentId">The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="parentType">The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="appKey">The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)</param>
        /// <param name="groupingId">Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)</param>
        /// <param name="connectionGroupIds">The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)</param>
        /// <param name="connectionAccountIds">The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)</param>
        /// <param name="audienceId">This parameter is deprecated. The audience used to generate the list of recipients (optional)</param>
        /// <param name="audienceIds">The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)</param>
        /// <param name="albumIds">The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)</param>
        /// <param name="reportId">The report used to generate the the list of recipients (optional)</param>
        /// <param name="reportParams">The parameters to supply to the report used to generate the the list of recipients (optional)</param>
        /// <param name="endpointURL">The URL for making an HTTP call (optional)</param>
        /// <param name="payload">The parameters for making an HTTP call (optional)</param>
        /// <param name="scheduledDate">The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)</param>
        /// <param name="startDate">The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)</param>
        /// <param name="endDate">The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)</param>
        /// <param name="cronExpression">The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)</param>
        /// <param name="cronType">The cron expression type: UNIX, CRON4J, QUARTZ (optional)</param>
        /// <param name="metaData">Additional metadata for the scheduled notification (optional)</param>
        /// <param name="conditionalInput">Json input representing conditional logic that has to be met before running the scheduled notification (optional)</param>
        /// <param name="templateType">This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)</param>
        /// <param name="visibility">Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)</param>
        /// <param name="active">Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;. (optional)</param>
        /// <param name="sendNow"> (optional)</param>
        /// <param name="eventType">Sets the event type for the notification (optional, default to &quot;CUSTOM&quot;)</param>
        /// <param name="deepLinkURI">The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)</param>
        /// <param name="sendToAll">Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateScheduledNotificationApiResponse"/>?&gt;</returns>
        Task<ICreateScheduledNotificationApiResponse?> CreateScheduledNotificationOrDefaultAsync(decimal version, long accountId, string name, string type, string message, Option<long> contentId = default, Option<string> contentName = default, Option<string> contentType = default, Option<long> parentId = default, Option<string> parentType = default, Option<string> appKey = default, Option<string> groupingId = default, Option<string> connectionGroupIds = default, Option<string> connectionAccountIds = default, Option<long> audienceId = default, Option<string> audienceIds = default, Option<string> albumIds = default, Option<long> reportId = default, Option<string> reportParams = default, Option<string> endpointURL = default, Option<string> payload = default, Option<long> scheduledDate = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> cronExpression = default, Option<string> cronType = default, Option<string> metaData = default, Option<string> conditionalInput = default, Option<string> templateType = default, Option<string> visibility = default, Option<bool> active = default, Option<bool> sendNow = default, Option<string> eventType = default, Option<string> deepLinkURI = default, Option<bool> sendToAll = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Scheduled Notification
        /// </summary>
        /// <remarks>
        /// This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">the id of the logged in user</param>
        /// <param name="scheduledNotificationId">the id of the scheduled notification to delete</param>
        /// <param name="deleteByGroupingId">If set to true, also deletes Scheduled Notifications under the same account with the same groupingId. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteScheduledNotificationApiResponse"/>&gt;</returns>
        Task<IDeleteScheduledNotificationApiResponse> DeleteScheduledNotificationAsync(decimal version, long accountId, long scheduledNotificationId, Option<bool> deleteByGroupingId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete Scheduled Notification
        /// </summary>
        /// <remarks>
        /// This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">the id of the logged in user</param>
        /// <param name="scheduledNotificationId">the id of the scheduled notification to delete</param>
        /// <param name="deleteByGroupingId">If set to true, also deletes Scheduled Notifications under the same account with the same groupingId. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteScheduledNotificationApiResponse"/>?&gt;</returns>
        Task<IDeleteScheduledNotificationApiResponse?> DeleteScheduledNotificationOrDefaultAsync(decimal version, long accountId, long scheduledNotificationId, Option<bool> deleteByGroupingId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Scheduled Notification
        /// </summary>
        /// <remarks>
        /// Get a ScheduledNotification
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">the id of the account logged in</param>
        /// <param name="scheduledNotificationId">the id of the scheduled notification to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetScheduledNotificationApiResponse"/>&gt;</returns>
        Task<IGetScheduledNotificationApiResponse> GetScheduledNotificationAsync(decimal version, long accountId, long scheduledNotificationId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Scheduled Notification
        /// </summary>
        /// <remarks>
        /// Get a ScheduledNotification
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">the id of the account logged in</param>
        /// <param name="scheduledNotificationId">the id of the scheduled notification to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetScheduledNotificationApiResponse"/>?&gt;</returns>
        Task<IGetScheduledNotificationApiResponse?> GetScheduledNotificationOrDefaultAsync(decimal version, long accountId, long scheduledNotificationId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Generate Schedule Notifications
        /// </summary>
        /// <remarks>
        /// Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="appKey">The application to target</param>
        /// <param name="reportName">The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail</param>
        /// <param name="message">The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in</param>
        /// <param name="offset">Time in munites before the event starts to notify recipients</param>
        /// <param name="recipientReportId">The report id used to generate the recipient list</param>
        /// <param name="reportParams">The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)</param>
        /// <param name="type">The type of scheduled notification; supported values are: MOBILE_NOTIFICATION (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IScheduleNotificationListingsApiResponse"/>&gt;</returns>
        Task<IScheduleNotificationListingsApiResponse> ScheduleNotificationListingsAsync(decimal version, long accountId, string appKey, string reportName, string message, int offset, long recipientReportId, Option<string> reportParams = default, Option<string> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Generate Schedule Notifications
        /// </summary>
        /// <remarks>
        /// Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="appKey">The application to target</param>
        /// <param name="reportName">The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail</param>
        /// <param name="message">The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in</param>
        /// <param name="offset">Time in munites before the event starts to notify recipients</param>
        /// <param name="recipientReportId">The report id used to generate the recipient list</param>
        /// <param name="reportParams">The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)</param>
        /// <param name="type">The type of scheduled notification; supported values are: MOBILE_NOTIFICATION (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IScheduleNotificationListingsApiResponse"/>?&gt;</returns>
        Task<IScheduleNotificationListingsApiResponse?> ScheduleNotificationListingsOrDefaultAsync(decimal version, long accountId, string appKey, string reportName, string message, int offset, long recipientReportId, Option<string> reportParams = default, Option<string> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Scheduled Notifications
        /// </summary>
        /// <remarks>
        /// This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="groupingId">Filter results by a grouping identifier defined by the client (optional)</param>
        /// <param name="audienceId">Filter results by audience (optional)</param>
        /// <param name="filter">a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications. (optional)</param>
        /// <param name="types">Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION (optional)</param>
        /// <param name="contentIds">search using content IDs (optional)</param>
        /// <param name="contentTypes">search using content types (optional)</param>
        /// <param name="parentIds">search using parent IDs (optional)</param>
        /// <param name="parentTypes">search using parent types (optional)</param>
        /// <param name="statuses">Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending (optional)</param>
        /// <param name="templateTypes"> (optional)</param>
        /// <param name="appKey">Filter the list by a specific application (optional)</param>
        /// <param name="keyword">Keyword search on the scheduled notification names. (optional)</param>
        /// <param name="sortField">The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date (optional)</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order (optional)</param>
        /// <param name="start">Start the result set at some index. (optional)</param>
        /// <param name="limit">Limit the result to some number. (optional)</param>
        /// <param name="activeOnly">Determines whether to return only active results (optional)</param>
        /// <param name="groupByGroupingId">Determines whether to group results with the same groupingId together. (optional)</param>
        /// <param name="returnAudienceAccountCount">If true, include audience account counts in the response (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchScheduledNotificationsApiResponse"/>&gt;</returns>
        Task<ISearchScheduledNotificationsApiResponse> SearchScheduledNotificationsAsync(decimal version, long accountId, Option<string> groupingId = default, Option<long> audienceId = default, Option<string> filter = default, Option<string> types = default, Option<string> contentIds = default, Option<string> contentTypes = default, Option<string> parentIds = default, Option<string> parentTypes = default, Option<string> statuses = default, Option<string> templateTypes = default, Option<string> appKey = default, Option<string> keyword = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, Option<bool> activeOnly = default, Option<bool> groupByGroupingId = default, Option<bool> returnAudienceAccountCount = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Scheduled Notifications
        /// </summary>
        /// <remarks>
        /// This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="groupingId">Filter results by a grouping identifier defined by the client (optional)</param>
        /// <param name="audienceId">Filter results by audience (optional)</param>
        /// <param name="filter">a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications. (optional)</param>
        /// <param name="types">Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION (optional)</param>
        /// <param name="contentIds">search using content IDs (optional)</param>
        /// <param name="contentTypes">search using content types (optional)</param>
        /// <param name="parentIds">search using parent IDs (optional)</param>
        /// <param name="parentTypes">search using parent types (optional)</param>
        /// <param name="statuses">Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending (optional)</param>
        /// <param name="templateTypes"> (optional)</param>
        /// <param name="appKey">Filter the list by a specific application (optional)</param>
        /// <param name="keyword">Keyword search on the scheduled notification names. (optional)</param>
        /// <param name="sortField">The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date (optional)</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order (optional)</param>
        /// <param name="start">Start the result set at some index. (optional)</param>
        /// <param name="limit">Limit the result to some number. (optional)</param>
        /// <param name="activeOnly">Determines whether to return only active results (optional)</param>
        /// <param name="groupByGroupingId">Determines whether to group results with the same groupingId together. (optional)</param>
        /// <param name="returnAudienceAccountCount">If true, include audience account counts in the response (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchScheduledNotificationsApiResponse"/>?&gt;</returns>
        Task<ISearchScheduledNotificationsApiResponse?> SearchScheduledNotificationsOrDefaultAsync(decimal version, long accountId, Option<string> groupingId = default, Option<long> audienceId = default, Option<string> filter = default, Option<string> types = default, Option<string> contentIds = default, Option<string> contentTypes = default, Option<string> parentIds = default, Option<string> parentTypes = default, Option<string> statuses = default, Option<string> templateTypes = default, Option<string> appKey = default, Option<string> keyword = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, Option<bool> activeOnly = default, Option<bool> groupByGroupingId = default, Option<bool> returnAudienceAccountCount = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Scheduled Notification
        /// </summary>
        /// <remarks>
        /// This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="scheduledNotificationId">The id of scheduled notification to update</param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="name">The name of the scheduled notification (optional)</param>
        /// <param name="type">The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (optional)</param>
        /// <param name="message">The message to send (optional)</param>
        /// <param name="payload">The parameters for making an HTTP call (optional)</param>
        /// <param name="contentId">The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="contentName">The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="contentType">The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="parentId">The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="parentType">The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="appKey">The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)</param>
        /// <param name="groupingId">Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)</param>
        /// <param name="connectionGroupIds">The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)</param>
        /// <param name="connectionAccountIds">The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)</param>
        /// <param name="audienceId">This parameter is deprecated. The audience used to generate the list of recipients (optional)</param>
        /// <param name="audienceIds">The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)</param>
        /// <param name="albumIds">The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)</param>
        /// <param name="reportId">The report used to generate the the list of recipients (optional)</param>
        /// <param name="reportParams">The parameters to supply to the report used to generate the the list of recipients (optional)</param>
        /// <param name="endpointURL">The URL for making an HTTP call (optional)</param>
        /// <param name="scheduledDate">The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)</param>
        /// <param name="startDate">The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)</param>
        /// <param name="endDate">The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)</param>
        /// <param name="cronExpression">The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)</param>
        /// <param name="cronType">The cron expression type: UNIX, CRON4J, QUARTZ (optional)</param>
        /// <param name="metaData">Additional metadata for the scheduled notification (optional)</param>
        /// <param name="conditionalInput">Json input representing conditional logic that has to be met before running the scheduled notification (optional)</param>
        /// <param name="templateType">This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)</param>
        /// <param name="visibility">Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)</param>
        /// <param name="active">Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. (optional)</param>
        /// <param name="errorMessage">the error message associated with the scheduled notification (optional)</param>
        /// <param name="status">the status of the scheduled notification (optional)</param>
        /// <param name="updateByGroupingId">also updates ScheduledNotifications with the same groupingId and account (optional)</param>
        /// <param name="sendNow">whether to send the scheduled notification now or not (optional)</param>
        /// <param name="eventType">Sets the event type for the notification (optional, default to &quot;CUSTOM&quot;)</param>
        /// <param name="deepLinkURI">The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)</param>
        /// <param name="sendToAll">Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateScheduledNotificationApiResponse"/>&gt;</returns>
        Task<IUpdateScheduledNotificationApiResponse> UpdateScheduledNotificationAsync(decimal version, long scheduledNotificationId, long accountId, Option<string> name = default, Option<string> type = default, Option<string> message = default, Option<string> payload = default, Option<long> contentId = default, Option<string> contentName = default, Option<string> contentType = default, Option<long> parentId = default, Option<string> parentType = default, Option<string> appKey = default, Option<string> groupingId = default, Option<string> connectionGroupIds = default, Option<string> connectionAccountIds = default, Option<long> audienceId = default, Option<string> audienceIds = default, Option<string> albumIds = default, Option<long> reportId = default, Option<string> reportParams = default, Option<string> endpointURL = default, Option<long> scheduledDate = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> cronExpression = default, Option<string> cronType = default, Option<string> metaData = default, Option<string> conditionalInput = default, Option<string> templateType = default, Option<string> visibility = default, Option<bool> active = default, Option<string> errorMessage = default, Option<string> status = default, Option<bool> updateByGroupingId = default, Option<bool> sendNow = default, Option<string> eventType = default, Option<string> deepLinkURI = default, Option<bool> sendToAll = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Scheduled Notification
        /// </summary>
        /// <remarks>
        /// This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.
        /// </remarks>
        /// <param name="version"></param>
        /// <param name="scheduledNotificationId">The id of scheduled notification to update</param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="name">The name of the scheduled notification (optional)</param>
        /// <param name="type">The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (optional)</param>
        /// <param name="message">The message to send (optional)</param>
        /// <param name="payload">The parameters for making an HTTP call (optional)</param>
        /// <param name="contentId">The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="contentName">The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="contentType">The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="parentId">The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="parentType">The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="appKey">The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)</param>
        /// <param name="groupingId">Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)</param>
        /// <param name="connectionGroupIds">The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)</param>
        /// <param name="connectionAccountIds">The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)</param>
        /// <param name="audienceId">This parameter is deprecated. The audience used to generate the list of recipients (optional)</param>
        /// <param name="audienceIds">The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)</param>
        /// <param name="albumIds">The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)</param>
        /// <param name="reportId">The report used to generate the the list of recipients (optional)</param>
        /// <param name="reportParams">The parameters to supply to the report used to generate the the list of recipients (optional)</param>
        /// <param name="endpointURL">The URL for making an HTTP call (optional)</param>
        /// <param name="scheduledDate">The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)</param>
        /// <param name="startDate">The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)</param>
        /// <param name="endDate">The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)</param>
        /// <param name="cronExpression">The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)</param>
        /// <param name="cronType">The cron expression type: UNIX, CRON4J, QUARTZ (optional)</param>
        /// <param name="metaData">Additional metadata for the scheduled notification (optional)</param>
        /// <param name="conditionalInput">Json input representing conditional logic that has to be met before running the scheduled notification (optional)</param>
        /// <param name="templateType">This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)</param>
        /// <param name="visibility">Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)</param>
        /// <param name="active">Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. (optional)</param>
        /// <param name="errorMessage">the error message associated with the scheduled notification (optional)</param>
        /// <param name="status">the status of the scheduled notification (optional)</param>
        /// <param name="updateByGroupingId">also updates ScheduledNotifications with the same groupingId and account (optional)</param>
        /// <param name="sendNow">whether to send the scheduled notification now or not (optional)</param>
        /// <param name="eventType">Sets the event type for the notification (optional, default to &quot;CUSTOM&quot;)</param>
        /// <param name="deepLinkURI">The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)</param>
        /// <param name="sendToAll">Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateScheduledNotificationApiResponse"/>?&gt;</returns>
        Task<IUpdateScheduledNotificationApiResponse?> UpdateScheduledNotificationOrDefaultAsync(decimal version, long scheduledNotificationId, long accountId, Option<string> name = default, Option<string> type = default, Option<string> message = default, Option<string> payload = default, Option<long> contentId = default, Option<string> contentName = default, Option<string> contentType = default, Option<long> parentId = default, Option<string> parentType = default, Option<string> appKey = default, Option<string> groupingId = default, Option<string> connectionGroupIds = default, Option<string> connectionAccountIds = default, Option<long> audienceId = default, Option<string> audienceIds = default, Option<string> albumIds = default, Option<long> reportId = default, Option<string> reportParams = default, Option<string> endpointURL = default, Option<long> scheduledDate = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> cronExpression = default, Option<string> cronType = default, Option<string> metaData = default, Option<string> conditionalInput = default, Option<string> templateType = default, Option<string> visibility = default, Option<bool> active = default, Option<string> errorMessage = default, Option<string> status = default, Option<bool> updateByGroupingId = default, Option<bool> sendNow = default, Option<string> eventType = default, Option<string> deepLinkURI = default, Option<bool> sendToAll = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICreateScheduledNotificationApiResponse"/>
    /// </summary>
    public interface ICreateScheduledNotificationApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ScheduledNotificationFullResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteScheduledNotificationApiResponse"/>
    /// </summary>
    public interface IDeleteScheduledNotificationApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ScheduledNotificationFullResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetScheduledNotificationApiResponse"/>
    /// </summary>
    public interface IGetScheduledNotificationApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ScheduledNotificationFullResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IScheduleNotificationListingsApiResponse"/>
    /// </summary>
    public interface IScheduleNotificationListingsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.SirqulResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISearchScheduledNotificationsApiResponse"/>
    /// </summary>
    public interface ISearchScheduledNotificationsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ScheduledNotificationFullResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateScheduledNotificationApiResponse"/>
    /// </summary>
    public interface IUpdateScheduledNotificationApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ScheduledNotificationFullResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ScheduledNotificationApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateScheduledNotification;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateScheduledNotification;

        internal void ExecuteOnCreateScheduledNotification(ScheduledNotificationApi.CreateScheduledNotificationApiResponse apiResponse)
        {
            OnCreateScheduledNotification?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateScheduledNotification(Exception exception)
        {
            OnErrorCreateScheduledNotification?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteScheduledNotification;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteScheduledNotification;

        internal void ExecuteOnDeleteScheduledNotification(ScheduledNotificationApi.DeleteScheduledNotificationApiResponse apiResponse)
        {
            OnDeleteScheduledNotification?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteScheduledNotification(Exception exception)
        {
            OnErrorDeleteScheduledNotification?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetScheduledNotification;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetScheduledNotification;

        internal void ExecuteOnGetScheduledNotification(ScheduledNotificationApi.GetScheduledNotificationApiResponse apiResponse)
        {
            OnGetScheduledNotification?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetScheduledNotification(Exception exception)
        {
            OnErrorGetScheduledNotification?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnScheduleNotificationListings;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorScheduleNotificationListings;

        internal void ExecuteOnScheduleNotificationListings(ScheduledNotificationApi.ScheduleNotificationListingsApiResponse apiResponse)
        {
            OnScheduleNotificationListings?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorScheduleNotificationListings(Exception exception)
        {
            OnErrorScheduleNotificationListings?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchScheduledNotifications;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchScheduledNotifications;

        internal void ExecuteOnSearchScheduledNotifications(ScheduledNotificationApi.SearchScheduledNotificationsApiResponse apiResponse)
        {
            OnSearchScheduledNotifications?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchScheduledNotifications(Exception exception)
        {
            OnErrorSearchScheduledNotifications?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateScheduledNotification;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateScheduledNotification;

        internal void ExecuteOnUpdateScheduledNotification(ScheduledNotificationApi.UpdateScheduledNotificationApiResponse apiResponse)
        {
            OnUpdateScheduledNotification?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateScheduledNotification(Exception exception)
        {
            OnErrorUpdateScheduledNotification?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ScheduledNotificationApi : IScheduledNotificationApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ScheduledNotificationApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ScheduledNotificationApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ScheduledNotificationApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ScheduledNotificationApi(ILogger<ScheduledNotificationApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ScheduledNotificationApiEvents scheduledNotificationApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ScheduledNotificationApi>();
            HttpClient = httpClient;
            Events = scheduledNotificationApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatCreateScheduledNotification(ref decimal version, ref long accountId, ref string name, ref string type, ref string message, ref Option<long> contentId, ref Option<string> contentName, ref Option<string> contentType, ref Option<long> parentId, ref Option<string> parentType, ref Option<string> appKey, ref Option<string> groupingId, ref Option<string> connectionGroupIds, ref Option<string> connectionAccountIds, ref Option<long> audienceId, ref Option<string> audienceIds, ref Option<string> albumIds, ref Option<long> reportId, ref Option<string> reportParams, ref Option<string> endpointURL, ref Option<string> payload, ref Option<long> scheduledDate, ref Option<long> startDate, ref Option<long> endDate, ref Option<string> cronExpression, ref Option<string> cronType, ref Option<string> metaData, ref Option<string> conditionalInput, ref Option<string> templateType, ref Option<string> visibility, ref Option<bool> active, ref Option<bool> sendNow, ref Option<string> eventType, ref Option<string> deepLinkURI, ref Option<bool> sendToAll);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="name"></param>
        /// <param name="type"></param>
        /// <param name="message"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentType"></param>
        /// <param name="appKey"></param>
        /// <param name="groupingId"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="audienceIds"></param>
        /// <param name="albumIds"></param>
        /// <param name="reportParams"></param>
        /// <param name="endpointURL"></param>
        /// <param name="payload"></param>
        /// <param name="cronExpression"></param>
        /// <param name="cronType"></param>
        /// <param name="metaData"></param>
        /// <param name="conditionalInput"></param>
        /// <param name="templateType"></param>
        /// <param name="visibility"></param>
        /// <param name="eventType"></param>
        /// <param name="deepLinkURI"></param>
        /// <returns></returns>
        private void ValidateCreateScheduledNotification(string name, string type, string message, Option<string> contentName, Option<string> contentType, Option<string> parentType, Option<string> appKey, Option<string> groupingId, Option<string> connectionGroupIds, Option<string> connectionAccountIds, Option<string> audienceIds, Option<string> albumIds, Option<string> reportParams, Option<string> endpointURL, Option<string> payload, Option<string> cronExpression, Option<string> cronType, Option<string> metaData, Option<string> conditionalInput, Option<string> templateType, Option<string> visibility, Option<string> eventType, Option<string> deepLinkURI)
        {
            if (name == null)
                throw new ArgumentNullException(nameof(name));

            if (type == null)
                throw new ArgumentNullException(nameof(type));

            if (message == null)
                throw new ArgumentNullException(nameof(message));

            if (contentName.IsSet && contentName.Value == null)
                throw new ArgumentNullException(nameof(contentName));

            if (contentType.IsSet && contentType.Value == null)
                throw new ArgumentNullException(nameof(contentType));

            if (parentType.IsSet && parentType.Value == null)
                throw new ArgumentNullException(nameof(parentType));

            if (appKey.IsSet && appKey.Value == null)
                throw new ArgumentNullException(nameof(appKey));

            if (groupingId.IsSet && groupingId.Value == null)
                throw new ArgumentNullException(nameof(groupingId));

            if (connectionGroupIds.IsSet && connectionGroupIds.Value == null)
                throw new ArgumentNullException(nameof(connectionGroupIds));

            if (connectionAccountIds.IsSet && connectionAccountIds.Value == null)
                throw new ArgumentNullException(nameof(connectionAccountIds));

            if (audienceIds.IsSet && audienceIds.Value == null)
                throw new ArgumentNullException(nameof(audienceIds));

            if (albumIds.IsSet && albumIds.Value == null)
                throw new ArgumentNullException(nameof(albumIds));

            if (reportParams.IsSet && reportParams.Value == null)
                throw new ArgumentNullException(nameof(reportParams));

            if (endpointURL.IsSet && endpointURL.Value == null)
                throw new ArgumentNullException(nameof(endpointURL));

            if (payload.IsSet && payload.Value == null)
                throw new ArgumentNullException(nameof(payload));

            if (cronExpression.IsSet && cronExpression.Value == null)
                throw new ArgumentNullException(nameof(cronExpression));

            if (cronType.IsSet && cronType.Value == null)
                throw new ArgumentNullException(nameof(cronType));

            if (metaData.IsSet && metaData.Value == null)
                throw new ArgumentNullException(nameof(metaData));

            if (conditionalInput.IsSet && conditionalInput.Value == null)
                throw new ArgumentNullException(nameof(conditionalInput));

            if (templateType.IsSet && templateType.Value == null)
                throw new ArgumentNullException(nameof(templateType));

            if (visibility.IsSet && visibility.Value == null)
                throw new ArgumentNullException(nameof(visibility));

            if (eventType.IsSet && eventType.Value == null)
                throw new ArgumentNullException(nameof(eventType));

            if (deepLinkURI.IsSet && deepLinkURI.Value == null)
                throw new ArgumentNullException(nameof(deepLinkURI));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="name"></param>
        /// <param name="type"></param>
        /// <param name="message"></param>
        /// <param name="contentId"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentId"></param>
        /// <param name="parentType"></param>
        /// <param name="appKey"></param>
        /// <param name="groupingId"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="audienceId"></param>
        /// <param name="audienceIds"></param>
        /// <param name="albumIds"></param>
        /// <param name="reportId"></param>
        /// <param name="reportParams"></param>
        /// <param name="endpointURL"></param>
        /// <param name="payload"></param>
        /// <param name="scheduledDate"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="cronExpression"></param>
        /// <param name="cronType"></param>
        /// <param name="metaData"></param>
        /// <param name="conditionalInput"></param>
        /// <param name="templateType"></param>
        /// <param name="visibility"></param>
        /// <param name="active"></param>
        /// <param name="sendNow"></param>
        /// <param name="eventType"></param>
        /// <param name="deepLinkURI"></param>
        /// <param name="sendToAll"></param>
        private void AfterCreateScheduledNotificationDefaultImplementation(ICreateScheduledNotificationApiResponse apiResponseLocalVar, decimal version, long accountId, string name, string type, string message, Option<long> contentId, Option<string> contentName, Option<string> contentType, Option<long> parentId, Option<string> parentType, Option<string> appKey, Option<string> groupingId, Option<string> connectionGroupIds, Option<string> connectionAccountIds, Option<long> audienceId, Option<string> audienceIds, Option<string> albumIds, Option<long> reportId, Option<string> reportParams, Option<string> endpointURL, Option<string> payload, Option<long> scheduledDate, Option<long> startDate, Option<long> endDate, Option<string> cronExpression, Option<string> cronType, Option<string> metaData, Option<string> conditionalInput, Option<string> templateType, Option<string> visibility, Option<bool> active, Option<bool> sendNow, Option<string> eventType, Option<string> deepLinkURI, Option<bool> sendToAll)
        {
            bool suppressDefaultLog = false;
            AfterCreateScheduledNotification(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, name, type, message, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, payload, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, sendNow, eventType, deepLinkURI, sendToAll);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="name"></param>
        /// <param name="type"></param>
        /// <param name="message"></param>
        /// <param name="contentId"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentId"></param>
        /// <param name="parentType"></param>
        /// <param name="appKey"></param>
        /// <param name="groupingId"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="audienceId"></param>
        /// <param name="audienceIds"></param>
        /// <param name="albumIds"></param>
        /// <param name="reportId"></param>
        /// <param name="reportParams"></param>
        /// <param name="endpointURL"></param>
        /// <param name="payload"></param>
        /// <param name="scheduledDate"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="cronExpression"></param>
        /// <param name="cronType"></param>
        /// <param name="metaData"></param>
        /// <param name="conditionalInput"></param>
        /// <param name="templateType"></param>
        /// <param name="visibility"></param>
        /// <param name="active"></param>
        /// <param name="sendNow"></param>
        /// <param name="eventType"></param>
        /// <param name="deepLinkURI"></param>
        /// <param name="sendToAll"></param>
        partial void AfterCreateScheduledNotification(ref bool suppressDefaultLog, ICreateScheduledNotificationApiResponse apiResponseLocalVar, decimal version, long accountId, string name, string type, string message, Option<long> contentId, Option<string> contentName, Option<string> contentType, Option<long> parentId, Option<string> parentType, Option<string> appKey, Option<string> groupingId, Option<string> connectionGroupIds, Option<string> connectionAccountIds, Option<long> audienceId, Option<string> audienceIds, Option<string> albumIds, Option<long> reportId, Option<string> reportParams, Option<string> endpointURL, Option<string> payload, Option<long> scheduledDate, Option<long> startDate, Option<long> endDate, Option<string> cronExpression, Option<string> cronType, Option<string> metaData, Option<string> conditionalInput, Option<string> templateType, Option<string> visibility, Option<bool> active, Option<bool> sendNow, Option<string> eventType, Option<string> deepLinkURI, Option<bool> sendToAll);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="name"></param>
        /// <param name="type"></param>
        /// <param name="message"></param>
        /// <param name="contentId"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentId"></param>
        /// <param name="parentType"></param>
        /// <param name="appKey"></param>
        /// <param name="groupingId"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="audienceId"></param>
        /// <param name="audienceIds"></param>
        /// <param name="albumIds"></param>
        /// <param name="reportId"></param>
        /// <param name="reportParams"></param>
        /// <param name="endpointURL"></param>
        /// <param name="payload"></param>
        /// <param name="scheduledDate"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="cronExpression"></param>
        /// <param name="cronType"></param>
        /// <param name="metaData"></param>
        /// <param name="conditionalInput"></param>
        /// <param name="templateType"></param>
        /// <param name="visibility"></param>
        /// <param name="active"></param>
        /// <param name="sendNow"></param>
        /// <param name="eventType"></param>
        /// <param name="deepLinkURI"></param>
        /// <param name="sendToAll"></param>
        private void OnErrorCreateScheduledNotificationDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string name, string type, string message, Option<long> contentId, Option<string> contentName, Option<string> contentType, Option<long> parentId, Option<string> parentType, Option<string> appKey, Option<string> groupingId, Option<string> connectionGroupIds, Option<string> connectionAccountIds, Option<long> audienceId, Option<string> audienceIds, Option<string> albumIds, Option<long> reportId, Option<string> reportParams, Option<string> endpointURL, Option<string> payload, Option<long> scheduledDate, Option<long> startDate, Option<long> endDate, Option<string> cronExpression, Option<string> cronType, Option<string> metaData, Option<string> conditionalInput, Option<string> templateType, Option<string> visibility, Option<bool> active, Option<bool> sendNow, Option<string> eventType, Option<string> deepLinkURI, Option<bool> sendToAll)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateScheduledNotification(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, name, type, message, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, payload, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, sendNow, eventType, deepLinkURI, sendToAll);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="name"></param>
        /// <param name="type"></param>
        /// <param name="message"></param>
        /// <param name="contentId"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentId"></param>
        /// <param name="parentType"></param>
        /// <param name="appKey"></param>
        /// <param name="groupingId"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="audienceId"></param>
        /// <param name="audienceIds"></param>
        /// <param name="albumIds"></param>
        /// <param name="reportId"></param>
        /// <param name="reportParams"></param>
        /// <param name="endpointURL"></param>
        /// <param name="payload"></param>
        /// <param name="scheduledDate"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="cronExpression"></param>
        /// <param name="cronType"></param>
        /// <param name="metaData"></param>
        /// <param name="conditionalInput"></param>
        /// <param name="templateType"></param>
        /// <param name="visibility"></param>
        /// <param name="active"></param>
        /// <param name="sendNow"></param>
        /// <param name="eventType"></param>
        /// <param name="deepLinkURI"></param>
        /// <param name="sendToAll"></param>
        partial void OnErrorCreateScheduledNotification(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string name, string type, string message, Option<long> contentId, Option<string> contentName, Option<string> contentType, Option<long> parentId, Option<string> parentType, Option<string> appKey, Option<string> groupingId, Option<string> connectionGroupIds, Option<string> connectionAccountIds, Option<long> audienceId, Option<string> audienceIds, Option<string> albumIds, Option<long> reportId, Option<string> reportParams, Option<string> endpointURL, Option<string> payload, Option<long> scheduledDate, Option<long> startDate, Option<long> endDate, Option<string> cronExpression, Option<string> cronType, Option<string> metaData, Option<string> conditionalInput, Option<string> templateType, Option<string> visibility, Option<bool> active, Option<bool> sendNow, Option<string> eventType, Option<string> deepLinkURI, Option<bool> sendToAll);

        /// <summary>
        /// Create Scheduled Notification This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="name">The name of the scheduled notification</param>
        /// <param name="type">The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages</param>
        /// <param name="message">The message to send</param>
        /// <param name="contentId">The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="contentName">The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="contentType">The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="parentId">The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="parentType">The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="appKey">The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)</param>
        /// <param name="groupingId">Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)</param>
        /// <param name="connectionGroupIds">The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)</param>
        /// <param name="connectionAccountIds">The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)</param>
        /// <param name="audienceId">This parameter is deprecated. The audience used to generate the list of recipients (optional)</param>
        /// <param name="audienceIds">The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)</param>
        /// <param name="albumIds">The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)</param>
        /// <param name="reportId">The report used to generate the the list of recipients (optional)</param>
        /// <param name="reportParams">The parameters to supply to the report used to generate the the list of recipients (optional)</param>
        /// <param name="endpointURL">The URL for making an HTTP call (optional)</param>
        /// <param name="payload">The parameters for making an HTTP call (optional)</param>
        /// <param name="scheduledDate">The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)</param>
        /// <param name="startDate">The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)</param>
        /// <param name="endDate">The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)</param>
        /// <param name="cronExpression">The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)</param>
        /// <param name="cronType">The cron expression type: UNIX, CRON4J, QUARTZ (optional)</param>
        /// <param name="metaData">Additional metadata for the scheduled notification (optional)</param>
        /// <param name="conditionalInput">Json input representing conditional logic that has to be met before running the scheduled notification (optional)</param>
        /// <param name="templateType">This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)</param>
        /// <param name="visibility">Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)</param>
        /// <param name="active">Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;. (optional)</param>
        /// <param name="sendNow"> (optional)</param>
        /// <param name="eventType">Sets the event type for the notification (optional, default to &quot;CUSTOM&quot;)</param>
        /// <param name="deepLinkURI">The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)</param>
        /// <param name="sendToAll">Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateScheduledNotificationApiResponse"/>&gt;</returns>
        public async Task<ICreateScheduledNotificationApiResponse?> CreateScheduledNotificationOrDefaultAsync(decimal version, long accountId, string name, string type, string message, Option<long> contentId = default, Option<string> contentName = default, Option<string> contentType = default, Option<long> parentId = default, Option<string> parentType = default, Option<string> appKey = default, Option<string> groupingId = default, Option<string> connectionGroupIds = default, Option<string> connectionAccountIds = default, Option<long> audienceId = default, Option<string> audienceIds = default, Option<string> albumIds = default, Option<long> reportId = default, Option<string> reportParams = default, Option<string> endpointURL = default, Option<string> payload = default, Option<long> scheduledDate = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> cronExpression = default, Option<string> cronType = default, Option<string> metaData = default, Option<string> conditionalInput = default, Option<string> templateType = default, Option<string> visibility = default, Option<bool> active = default, Option<bool> sendNow = default, Option<string> eventType = default, Option<string> deepLinkURI = default, Option<bool> sendToAll = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateScheduledNotificationAsync(version, accountId, name, type, message, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, payload, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, sendNow, eventType, deepLinkURI, sendToAll, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create Scheduled Notification This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="name">The name of the scheduled notification</param>
        /// <param name="type">The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages</param>
        /// <param name="message">The message to send</param>
        /// <param name="contentId">The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="contentName">The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="contentType">The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="parentId">The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="parentType">The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="appKey">The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)</param>
        /// <param name="groupingId">Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)</param>
        /// <param name="connectionGroupIds">The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)</param>
        /// <param name="connectionAccountIds">The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)</param>
        /// <param name="audienceId">This parameter is deprecated. The audience used to generate the list of recipients (optional)</param>
        /// <param name="audienceIds">The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)</param>
        /// <param name="albumIds">The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)</param>
        /// <param name="reportId">The report used to generate the the list of recipients (optional)</param>
        /// <param name="reportParams">The parameters to supply to the report used to generate the the list of recipients (optional)</param>
        /// <param name="endpointURL">The URL for making an HTTP call (optional)</param>
        /// <param name="payload">The parameters for making an HTTP call (optional)</param>
        /// <param name="scheduledDate">The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)</param>
        /// <param name="startDate">The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)</param>
        /// <param name="endDate">The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)</param>
        /// <param name="cronExpression">The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)</param>
        /// <param name="cronType">The cron expression type: UNIX, CRON4J, QUARTZ (optional)</param>
        /// <param name="metaData">Additional metadata for the scheduled notification (optional)</param>
        /// <param name="conditionalInput">Json input representing conditional logic that has to be met before running the scheduled notification (optional)</param>
        /// <param name="templateType">This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)</param>
        /// <param name="visibility">Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)</param>
        /// <param name="active">Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;. (optional)</param>
        /// <param name="sendNow"> (optional)</param>
        /// <param name="eventType">Sets the event type for the notification (optional, default to &quot;CUSTOM&quot;)</param>
        /// <param name="deepLinkURI">The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)</param>
        /// <param name="sendToAll">Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateScheduledNotificationApiResponse"/>&gt;</returns>
        public async Task<ICreateScheduledNotificationApiResponse> CreateScheduledNotificationAsync(decimal version, long accountId, string name, string type, string message, Option<long> contentId = default, Option<string> contentName = default, Option<string> contentType = default, Option<long> parentId = default, Option<string> parentType = default, Option<string> appKey = default, Option<string> groupingId = default, Option<string> connectionGroupIds = default, Option<string> connectionAccountIds = default, Option<long> audienceId = default, Option<string> audienceIds = default, Option<string> albumIds = default, Option<long> reportId = default, Option<string> reportParams = default, Option<string> endpointURL = default, Option<string> payload = default, Option<long> scheduledDate = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> cronExpression = default, Option<string> cronType = default, Option<string> metaData = default, Option<string> conditionalInput = default, Option<string> templateType = default, Option<string> visibility = default, Option<bool> active = default, Option<bool> sendNow = default, Option<string> eventType = default, Option<string> deepLinkURI = default, Option<bool> sendToAll = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateScheduledNotification(name, type, message, contentName, contentType, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceIds, albumIds, reportParams, endpointURL, payload, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, eventType, deepLinkURI);

                FormatCreateScheduledNotification(ref version, ref accountId, ref name, ref type, ref message, ref contentId, ref contentName, ref contentType, ref parentId, ref parentType, ref appKey, ref groupingId, ref connectionGroupIds, ref connectionAccountIds, ref audienceId, ref audienceIds, ref albumIds, ref reportId, ref reportParams, ref endpointURL, ref payload, ref scheduledDate, ref startDate, ref endDate, ref cronExpression, ref cronType, ref metaData, ref conditionalInput, ref templateType, ref visibility, ref active, ref sendNow, ref eventType, ref deepLinkURI, ref sendToAll);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/notification/schedule/create"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/notification/schedule/create");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["name"] = ClientUtils.ParameterToString(name);
                    parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type);
                    parseQueryStringLocalVar["message"] = ClientUtils.ParameterToString(message);

                    if (contentId.IsSet)
                        parseQueryStringLocalVar["contentId"] = ClientUtils.ParameterToString(contentId.Value);

                    if (contentName.IsSet)
                        parseQueryStringLocalVar["contentName"] = ClientUtils.ParameterToString(contentName.Value);

                    if (contentType.IsSet)
                        parseQueryStringLocalVar["contentType"] = ClientUtils.ParameterToString(contentType.Value);

                    if (parentId.IsSet)
                        parseQueryStringLocalVar["parentId"] = ClientUtils.ParameterToString(parentId.Value);

                    if (parentType.IsSet)
                        parseQueryStringLocalVar["parentType"] = ClientUtils.ParameterToString(parentType.Value);

                    if (appKey.IsSet)
                        parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey.Value);

                    if (groupingId.IsSet)
                        parseQueryStringLocalVar["groupingId"] = ClientUtils.ParameterToString(groupingId.Value);

                    if (connectionGroupIds.IsSet)
                        parseQueryStringLocalVar["connectionGroupIds"] = ClientUtils.ParameterToString(connectionGroupIds.Value);

                    if (connectionAccountIds.IsSet)
                        parseQueryStringLocalVar["connectionAccountIds"] = ClientUtils.ParameterToString(connectionAccountIds.Value);

                    if (audienceId.IsSet)
                        parseQueryStringLocalVar["audienceId"] = ClientUtils.ParameterToString(audienceId.Value);

                    if (audienceIds.IsSet)
                        parseQueryStringLocalVar["audienceIds"] = ClientUtils.ParameterToString(audienceIds.Value);

                    if (albumIds.IsSet)
                        parseQueryStringLocalVar["albumIds"] = ClientUtils.ParameterToString(albumIds.Value);

                    if (reportId.IsSet)
                        parseQueryStringLocalVar["reportId"] = ClientUtils.ParameterToString(reportId.Value);

                    if (reportParams.IsSet)
                        parseQueryStringLocalVar["reportParams"] = ClientUtils.ParameterToString(reportParams.Value);

                    if (endpointURL.IsSet)
                        parseQueryStringLocalVar["endpointURL"] = ClientUtils.ParameterToString(endpointURL.Value);

                    if (payload.IsSet)
                        parseQueryStringLocalVar["payload"] = ClientUtils.ParameterToString(payload.Value);

                    if (scheduledDate.IsSet)
                        parseQueryStringLocalVar["scheduledDate"] = ClientUtils.ParameterToString(scheduledDate.Value);

                    if (startDate.IsSet)
                        parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate.Value);

                    if (endDate.IsSet)
                        parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate.Value);

                    if (cronExpression.IsSet)
                        parseQueryStringLocalVar["cronExpression"] = ClientUtils.ParameterToString(cronExpression.Value);

                    if (cronType.IsSet)
                        parseQueryStringLocalVar["cronType"] = ClientUtils.ParameterToString(cronType.Value);

                    if (metaData.IsSet)
                        parseQueryStringLocalVar["metaData"] = ClientUtils.ParameterToString(metaData.Value);

                    if (conditionalInput.IsSet)
                        parseQueryStringLocalVar["conditionalInput"] = ClientUtils.ParameterToString(conditionalInput.Value);

                    if (templateType.IsSet)
                        parseQueryStringLocalVar["templateType"] = ClientUtils.ParameterToString(templateType.Value);

                    if (visibility.IsSet)
                        parseQueryStringLocalVar["visibility"] = ClientUtils.ParameterToString(visibility.Value);

                    if (active.IsSet)
                        parseQueryStringLocalVar["active"] = ClientUtils.ParameterToString(active.Value);

                    if (sendNow.IsSet)
                        parseQueryStringLocalVar["sendNow"] = ClientUtils.ParameterToString(sendNow.Value);

                    if (eventType.IsSet)
                        parseQueryStringLocalVar["eventType"] = ClientUtils.ParameterToString(eventType.Value);

                    if (deepLinkURI.IsSet)
                        parseQueryStringLocalVar["deepLinkURI"] = ClientUtils.ParameterToString(deepLinkURI.Value);

                    if (sendToAll.IsSet)
                        parseQueryStringLocalVar["sendToAll"] = ClientUtils.ParameterToString(sendToAll.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateScheduledNotificationApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateScheduledNotificationApiResponse>();
                        CreateScheduledNotificationApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/notification/schedule/create", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateScheduledNotificationDefaultImplementation(apiResponseLocalVar, version, accountId, name, type, message, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, payload, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, sendNow, eventType, deepLinkURI, sendToAll);

                        Events.ExecuteOnCreateScheduledNotification(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateScheduledNotificationDefaultImplementation(e, "/api/{version}/notification/schedule/create", uriBuilderLocalVar.Path, version, accountId, name, type, message, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, payload, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, sendNow, eventType, deepLinkURI, sendToAll);
                Events.ExecuteOnErrorCreateScheduledNotification(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateScheduledNotificationApiResponse"/>
        /// </summary>
        public partial class CreateScheduledNotificationApiResponse : Org.OpenAPITools.Client.ApiResponse, ICreateScheduledNotificationApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateScheduledNotificationApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateScheduledNotificationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateScheduledNotificationApiResponse(ILogger<CreateScheduledNotificationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateScheduledNotificationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateScheduledNotificationApiResponse(ILogger<CreateScheduledNotificationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ScheduledNotificationFullResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ScheduledNotificationFullResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ScheduledNotificationFullResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteScheduledNotification(ref decimal version, ref long accountId, ref long scheduledNotificationId, ref Option<bool> deleteByGroupingId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="scheduledNotificationId"></param>
        /// <param name="deleteByGroupingId"></param>
        private void AfterDeleteScheduledNotificationDefaultImplementation(IDeleteScheduledNotificationApiResponse apiResponseLocalVar, decimal version, long accountId, long scheduledNotificationId, Option<bool> deleteByGroupingId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteScheduledNotification(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, scheduledNotificationId, deleteByGroupingId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="scheduledNotificationId"></param>
        /// <param name="deleteByGroupingId"></param>
        partial void AfterDeleteScheduledNotification(ref bool suppressDefaultLog, IDeleteScheduledNotificationApiResponse apiResponseLocalVar, decimal version, long accountId, long scheduledNotificationId, Option<bool> deleteByGroupingId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="scheduledNotificationId"></param>
        /// <param name="deleteByGroupingId"></param>
        private void OnErrorDeleteScheduledNotificationDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, long scheduledNotificationId, Option<bool> deleteByGroupingId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteScheduledNotification(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, scheduledNotificationId, deleteByGroupingId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="scheduledNotificationId"></param>
        /// <param name="deleteByGroupingId"></param>
        partial void OnErrorDeleteScheduledNotification(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, long scheduledNotificationId, Option<bool> deleteByGroupingId);

        /// <summary>
        /// Delete Scheduled Notification This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">the id of the logged in user</param>
        /// <param name="scheduledNotificationId">the id of the scheduled notification to delete</param>
        /// <param name="deleteByGroupingId">If set to true, also deletes Scheduled Notifications under the same account with the same groupingId. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteScheduledNotificationApiResponse"/>&gt;</returns>
        public async Task<IDeleteScheduledNotificationApiResponse?> DeleteScheduledNotificationOrDefaultAsync(decimal version, long accountId, long scheduledNotificationId, Option<bool> deleteByGroupingId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteScheduledNotificationAsync(version, accountId, scheduledNotificationId, deleteByGroupingId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete Scheduled Notification This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">the id of the logged in user</param>
        /// <param name="scheduledNotificationId">the id of the scheduled notification to delete</param>
        /// <param name="deleteByGroupingId">If set to true, also deletes Scheduled Notifications under the same account with the same groupingId. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteScheduledNotificationApiResponse"/>&gt;</returns>
        public async Task<IDeleteScheduledNotificationApiResponse> DeleteScheduledNotificationAsync(decimal version, long accountId, long scheduledNotificationId, Option<bool> deleteByGroupingId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeleteScheduledNotification(ref version, ref accountId, ref scheduledNotificationId, ref deleteByGroupingId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/notification/schedule/delete"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/notification/schedule/delete");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["scheduledNotificationId"] = ClientUtils.ParameterToString(scheduledNotificationId);

                    if (deleteByGroupingId.IsSet)
                        parseQueryStringLocalVar["deleteByGroupingId"] = ClientUtils.ParameterToString(deleteByGroupingId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DeleteScheduledNotificationApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteScheduledNotificationApiResponse>();
                        DeleteScheduledNotificationApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/notification/schedule/delete", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDeleteScheduledNotificationDefaultImplementation(apiResponseLocalVar, version, accountId, scheduledNotificationId, deleteByGroupingId);

                        Events.ExecuteOnDeleteScheduledNotification(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteScheduledNotificationDefaultImplementation(e, "/api/{version}/notification/schedule/delete", uriBuilderLocalVar.Path, version, accountId, scheduledNotificationId, deleteByGroupingId);
                Events.ExecuteOnErrorDeleteScheduledNotification(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteScheduledNotificationApiResponse"/>
        /// </summary>
        public partial class DeleteScheduledNotificationApiResponse : Org.OpenAPITools.Client.ApiResponse, IDeleteScheduledNotificationApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteScheduledNotificationApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteScheduledNotificationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteScheduledNotificationApiResponse(ILogger<DeleteScheduledNotificationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DeleteScheduledNotificationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteScheduledNotificationApiResponse(ILogger<DeleteScheduledNotificationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ScheduledNotificationFullResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ScheduledNotificationFullResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ScheduledNotificationFullResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetScheduledNotification(ref decimal version, ref long accountId, ref long scheduledNotificationId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="scheduledNotificationId"></param>
        private void AfterGetScheduledNotificationDefaultImplementation(IGetScheduledNotificationApiResponse apiResponseLocalVar, decimal version, long accountId, long scheduledNotificationId)
        {
            bool suppressDefaultLog = false;
            AfterGetScheduledNotification(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, scheduledNotificationId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="scheduledNotificationId"></param>
        partial void AfterGetScheduledNotification(ref bool suppressDefaultLog, IGetScheduledNotificationApiResponse apiResponseLocalVar, decimal version, long accountId, long scheduledNotificationId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="scheduledNotificationId"></param>
        private void OnErrorGetScheduledNotificationDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, long scheduledNotificationId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetScheduledNotification(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, scheduledNotificationId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="scheduledNotificationId"></param>
        partial void OnErrorGetScheduledNotification(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, long scheduledNotificationId);

        /// <summary>
        /// Get Scheduled Notification Get a ScheduledNotification
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">the id of the account logged in</param>
        /// <param name="scheduledNotificationId">the id of the scheduled notification to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetScheduledNotificationApiResponse"/>&gt;</returns>
        public async Task<IGetScheduledNotificationApiResponse?> GetScheduledNotificationOrDefaultAsync(decimal version, long accountId, long scheduledNotificationId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetScheduledNotificationAsync(version, accountId, scheduledNotificationId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Scheduled Notification Get a ScheduledNotification
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">the id of the account logged in</param>
        /// <param name="scheduledNotificationId">the id of the scheduled notification to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetScheduledNotificationApiResponse"/>&gt;</returns>
        public async Task<IGetScheduledNotificationApiResponse> GetScheduledNotificationAsync(decimal version, long accountId, long scheduledNotificationId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetScheduledNotification(ref version, ref accountId, ref scheduledNotificationId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/notification/schedule/get"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/notification/schedule/get");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["scheduledNotificationId"] = ClientUtils.ParameterToString(scheduledNotificationId);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetScheduledNotificationApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetScheduledNotificationApiResponse>();
                        GetScheduledNotificationApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/notification/schedule/get", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetScheduledNotificationDefaultImplementation(apiResponseLocalVar, version, accountId, scheduledNotificationId);

                        Events.ExecuteOnGetScheduledNotification(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetScheduledNotificationDefaultImplementation(e, "/api/{version}/notification/schedule/get", uriBuilderLocalVar.Path, version, accountId, scheduledNotificationId);
                Events.ExecuteOnErrorGetScheduledNotification(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetScheduledNotificationApiResponse"/>
        /// </summary>
        public partial class GetScheduledNotificationApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetScheduledNotificationApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetScheduledNotificationApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetScheduledNotificationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetScheduledNotificationApiResponse(ILogger<GetScheduledNotificationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetScheduledNotificationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetScheduledNotificationApiResponse(ILogger<GetScheduledNotificationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ScheduledNotificationFullResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ScheduledNotificationFullResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ScheduledNotificationFullResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatScheduleNotificationListings(ref decimal version, ref long accountId, ref string appKey, ref string reportName, ref string message, ref int offset, ref long recipientReportId, ref Option<string> reportParams, ref Option<string> type);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="appKey"></param>
        /// <param name="reportName"></param>
        /// <param name="message"></param>
        /// <param name="reportParams"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        private void ValidateScheduleNotificationListings(string appKey, string reportName, string message, Option<string> reportParams, Option<string> type)
        {
            if (appKey == null)
                throw new ArgumentNullException(nameof(appKey));

            if (reportName == null)
                throw new ArgumentNullException(nameof(reportName));

            if (message == null)
                throw new ArgumentNullException(nameof(message));

            if (reportParams.IsSet && reportParams.Value == null)
                throw new ArgumentNullException(nameof(reportParams));

            if (type.IsSet && type.Value == null)
                throw new ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="reportName"></param>
        /// <param name="message"></param>
        /// <param name="offset"></param>
        /// <param name="recipientReportId"></param>
        /// <param name="reportParams"></param>
        /// <param name="type"></param>
        private void AfterScheduleNotificationListingsDefaultImplementation(IScheduleNotificationListingsApiResponse apiResponseLocalVar, decimal version, long accountId, string appKey, string reportName, string message, int offset, long recipientReportId, Option<string> reportParams, Option<string> type)
        {
            bool suppressDefaultLog = false;
            AfterScheduleNotificationListings(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, appKey, reportName, message, offset, recipientReportId, reportParams, type);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="reportName"></param>
        /// <param name="message"></param>
        /// <param name="offset"></param>
        /// <param name="recipientReportId"></param>
        /// <param name="reportParams"></param>
        /// <param name="type"></param>
        partial void AfterScheduleNotificationListings(ref bool suppressDefaultLog, IScheduleNotificationListingsApiResponse apiResponseLocalVar, decimal version, long accountId, string appKey, string reportName, string message, int offset, long recipientReportId, Option<string> reportParams, Option<string> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="reportName"></param>
        /// <param name="message"></param>
        /// <param name="offset"></param>
        /// <param name="recipientReportId"></param>
        /// <param name="reportParams"></param>
        /// <param name="type"></param>
        private void OnErrorScheduleNotificationListingsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string appKey, string reportName, string message, int offset, long recipientReportId, Option<string> reportParams, Option<string> type)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorScheduleNotificationListings(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, appKey, reportName, message, offset, recipientReportId, reportParams, type);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="appKey"></param>
        /// <param name="reportName"></param>
        /// <param name="message"></param>
        /// <param name="offset"></param>
        /// <param name="recipientReportId"></param>
        /// <param name="reportParams"></param>
        /// <param name="type"></param>
        partial void OnErrorScheduleNotificationListings(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, string appKey, string reportName, string message, int offset, long recipientReportId, Option<string> reportParams, Option<string> type);

        /// <summary>
        /// Generate Schedule Notifications Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="appKey">The application to target</param>
        /// <param name="reportName">The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail</param>
        /// <param name="message">The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in</param>
        /// <param name="offset">Time in munites before the event starts to notify recipients</param>
        /// <param name="recipientReportId">The report id used to generate the recipient list</param>
        /// <param name="reportParams">The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)</param>
        /// <param name="type">The type of scheduled notification; supported values are: MOBILE_NOTIFICATION (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IScheduleNotificationListingsApiResponse"/>&gt;</returns>
        public async Task<IScheduleNotificationListingsApiResponse?> ScheduleNotificationListingsOrDefaultAsync(decimal version, long accountId, string appKey, string reportName, string message, int offset, long recipientReportId, Option<string> reportParams = default, Option<string> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ScheduleNotificationListingsAsync(version, accountId, appKey, reportName, message, offset, recipientReportId, reportParams, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Generate Schedule Notifications Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="appKey">The application to target</param>
        /// <param name="reportName">The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail</param>
        /// <param name="message">The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in</param>
        /// <param name="offset">Time in munites before the event starts to notify recipients</param>
        /// <param name="recipientReportId">The report id used to generate the recipient list</param>
        /// <param name="reportParams">The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)</param>
        /// <param name="type">The type of scheduled notification; supported values are: MOBILE_NOTIFICATION (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IScheduleNotificationListingsApiResponse"/>&gt;</returns>
        public async Task<IScheduleNotificationListingsApiResponse> ScheduleNotificationListingsAsync(decimal version, long accountId, string appKey, string reportName, string message, int offset, long recipientReportId, Option<string> reportParams = default, Option<string> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateScheduleNotificationListings(appKey, reportName, message, reportParams, type);

                FormatScheduleNotificationListings(ref version, ref accountId, ref appKey, ref reportName, ref message, ref offset, ref recipientReportId, ref reportParams, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/notification/schedule/generate"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/notification/schedule/generate");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);
                    parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey);
                    parseQueryStringLocalVar["reportName"] = ClientUtils.ParameterToString(reportName);
                    parseQueryStringLocalVar["message"] = ClientUtils.ParameterToString(message);
                    parseQueryStringLocalVar["offset"] = ClientUtils.ParameterToString(offset);
                    parseQueryStringLocalVar["recipientReportId"] = ClientUtils.ParameterToString(recipientReportId);

                    if (reportParams.IsSet)
                        parseQueryStringLocalVar["reportParams"] = ClientUtils.ParameterToString(reportParams.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ScheduleNotificationListingsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ScheduleNotificationListingsApiResponse>();
                        ScheduleNotificationListingsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/notification/schedule/generate", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterScheduleNotificationListingsDefaultImplementation(apiResponseLocalVar, version, accountId, appKey, reportName, message, offset, recipientReportId, reportParams, type);

                        Events.ExecuteOnScheduleNotificationListings(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorScheduleNotificationListingsDefaultImplementation(e, "/api/{version}/notification/schedule/generate", uriBuilderLocalVar.Path, version, accountId, appKey, reportName, message, offset, recipientReportId, reportParams, type);
                Events.ExecuteOnErrorScheduleNotificationListings(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ScheduleNotificationListingsApiResponse"/>
        /// </summary>
        public partial class ScheduleNotificationListingsApiResponse : Org.OpenAPITools.Client.ApiResponse, IScheduleNotificationListingsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ScheduleNotificationListingsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ScheduleNotificationListingsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ScheduleNotificationListingsApiResponse(ILogger<ScheduleNotificationListingsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ScheduleNotificationListingsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ScheduleNotificationListingsApiResponse(ILogger<ScheduleNotificationListingsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.SirqulResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.SirqulResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.SirqulResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchScheduledNotifications(ref decimal version, ref long accountId, ref Option<string> groupingId, ref Option<long> audienceId, ref Option<string> filter, ref Option<string> types, ref Option<string> contentIds, ref Option<string> contentTypes, ref Option<string> parentIds, ref Option<string> parentTypes, ref Option<string> statuses, ref Option<string> templateTypes, ref Option<string> appKey, ref Option<string> keyword, ref Option<string> sortField, ref Option<bool> descending, ref Option<int> start, ref Option<int> limit, ref Option<bool> activeOnly, ref Option<bool> groupByGroupingId, ref Option<bool> returnAudienceAccountCount);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="groupingId"></param>
        /// <param name="filter"></param>
        /// <param name="types"></param>
        /// <param name="contentIds"></param>
        /// <param name="contentTypes"></param>
        /// <param name="parentIds"></param>
        /// <param name="parentTypes"></param>
        /// <param name="statuses"></param>
        /// <param name="templateTypes"></param>
        /// <param name="appKey"></param>
        /// <param name="keyword"></param>
        /// <param name="sortField"></param>
        /// <returns></returns>
        private void ValidateSearchScheduledNotifications(Option<string> groupingId, Option<string> filter, Option<string> types, Option<string> contentIds, Option<string> contentTypes, Option<string> parentIds, Option<string> parentTypes, Option<string> statuses, Option<string> templateTypes, Option<string> appKey, Option<string> keyword, Option<string> sortField)
        {
            if (groupingId.IsSet && groupingId.Value == null)
                throw new ArgumentNullException(nameof(groupingId));

            if (filter.IsSet && filter.Value == null)
                throw new ArgumentNullException(nameof(filter));

            if (types.IsSet && types.Value == null)
                throw new ArgumentNullException(nameof(types));

            if (contentIds.IsSet && contentIds.Value == null)
                throw new ArgumentNullException(nameof(contentIds));

            if (contentTypes.IsSet && contentTypes.Value == null)
                throw new ArgumentNullException(nameof(contentTypes));

            if (parentIds.IsSet && parentIds.Value == null)
                throw new ArgumentNullException(nameof(parentIds));

            if (parentTypes.IsSet && parentTypes.Value == null)
                throw new ArgumentNullException(nameof(parentTypes));

            if (statuses.IsSet && statuses.Value == null)
                throw new ArgumentNullException(nameof(statuses));

            if (templateTypes.IsSet && templateTypes.Value == null)
                throw new ArgumentNullException(nameof(templateTypes));

            if (appKey.IsSet && appKey.Value == null)
                throw new ArgumentNullException(nameof(appKey));

            if (keyword.IsSet && keyword.Value == null)
                throw new ArgumentNullException(nameof(keyword));

            if (sortField.IsSet && sortField.Value == null)
                throw new ArgumentNullException(nameof(sortField));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="groupingId"></param>
        /// <param name="audienceId"></param>
        /// <param name="filter"></param>
        /// <param name="types"></param>
        /// <param name="contentIds"></param>
        /// <param name="contentTypes"></param>
        /// <param name="parentIds"></param>
        /// <param name="parentTypes"></param>
        /// <param name="statuses"></param>
        /// <param name="templateTypes"></param>
        /// <param name="appKey"></param>
        /// <param name="keyword"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        /// <param name="groupByGroupingId"></param>
        /// <param name="returnAudienceAccountCount"></param>
        private void AfterSearchScheduledNotificationsDefaultImplementation(ISearchScheduledNotificationsApiResponse apiResponseLocalVar, decimal version, long accountId, Option<string> groupingId, Option<long> audienceId, Option<string> filter, Option<string> types, Option<string> contentIds, Option<string> contentTypes, Option<string> parentIds, Option<string> parentTypes, Option<string> statuses, Option<string> templateTypes, Option<string> appKey, Option<string> keyword, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit, Option<bool> activeOnly, Option<bool> groupByGroupingId, Option<bool> returnAudienceAccountCount)
        {
            bool suppressDefaultLog = false;
            AfterSearchScheduledNotifications(ref suppressDefaultLog, apiResponseLocalVar, version, accountId, groupingId, audienceId, filter, types, contentIds, contentTypes, parentIds, parentTypes, statuses, templateTypes, appKey, keyword, sortField, descending, start, limit, activeOnly, groupByGroupingId, returnAudienceAccountCount);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="groupingId"></param>
        /// <param name="audienceId"></param>
        /// <param name="filter"></param>
        /// <param name="types"></param>
        /// <param name="contentIds"></param>
        /// <param name="contentTypes"></param>
        /// <param name="parentIds"></param>
        /// <param name="parentTypes"></param>
        /// <param name="statuses"></param>
        /// <param name="templateTypes"></param>
        /// <param name="appKey"></param>
        /// <param name="keyword"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        /// <param name="groupByGroupingId"></param>
        /// <param name="returnAudienceAccountCount"></param>
        partial void AfterSearchScheduledNotifications(ref bool suppressDefaultLog, ISearchScheduledNotificationsApiResponse apiResponseLocalVar, decimal version, long accountId, Option<string> groupingId, Option<long> audienceId, Option<string> filter, Option<string> types, Option<string> contentIds, Option<string> contentTypes, Option<string> parentIds, Option<string> parentTypes, Option<string> statuses, Option<string> templateTypes, Option<string> appKey, Option<string> keyword, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit, Option<bool> activeOnly, Option<bool> groupByGroupingId, Option<bool> returnAudienceAccountCount);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="groupingId"></param>
        /// <param name="audienceId"></param>
        /// <param name="filter"></param>
        /// <param name="types"></param>
        /// <param name="contentIds"></param>
        /// <param name="contentTypes"></param>
        /// <param name="parentIds"></param>
        /// <param name="parentTypes"></param>
        /// <param name="statuses"></param>
        /// <param name="templateTypes"></param>
        /// <param name="appKey"></param>
        /// <param name="keyword"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        /// <param name="groupByGroupingId"></param>
        /// <param name="returnAudienceAccountCount"></param>
        private void OnErrorSearchScheduledNotificationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, Option<string> groupingId, Option<long> audienceId, Option<string> filter, Option<string> types, Option<string> contentIds, Option<string> contentTypes, Option<string> parentIds, Option<string> parentTypes, Option<string> statuses, Option<string> templateTypes, Option<string> appKey, Option<string> keyword, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit, Option<bool> activeOnly, Option<bool> groupByGroupingId, Option<bool> returnAudienceAccountCount)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchScheduledNotifications(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, accountId, groupingId, audienceId, filter, types, contentIds, contentTypes, parentIds, parentTypes, statuses, templateTypes, appKey, keyword, sortField, descending, start, limit, activeOnly, groupByGroupingId, returnAudienceAccountCount);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="accountId"></param>
        /// <param name="groupingId"></param>
        /// <param name="audienceId"></param>
        /// <param name="filter"></param>
        /// <param name="types"></param>
        /// <param name="contentIds"></param>
        /// <param name="contentTypes"></param>
        /// <param name="parentIds"></param>
        /// <param name="parentTypes"></param>
        /// <param name="statuses"></param>
        /// <param name="templateTypes"></param>
        /// <param name="appKey"></param>
        /// <param name="keyword"></param>
        /// <param name="sortField"></param>
        /// <param name="descending"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="activeOnly"></param>
        /// <param name="groupByGroupingId"></param>
        /// <param name="returnAudienceAccountCount"></param>
        partial void OnErrorSearchScheduledNotifications(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long accountId, Option<string> groupingId, Option<long> audienceId, Option<string> filter, Option<string> types, Option<string> contentIds, Option<string> contentTypes, Option<string> parentIds, Option<string> parentTypes, Option<string> statuses, Option<string> templateTypes, Option<string> appKey, Option<string> keyword, Option<string> sortField, Option<bool> descending, Option<int> start, Option<int> limit, Option<bool> activeOnly, Option<bool> groupByGroupingId, Option<bool> returnAudienceAccountCount);

        /// <summary>
        /// Search Scheduled Notifications This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="groupingId">Filter results by a grouping identifier defined by the client (optional)</param>
        /// <param name="audienceId">Filter results by audience (optional)</param>
        /// <param name="filter">a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications. (optional)</param>
        /// <param name="types">Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION (optional)</param>
        /// <param name="contentIds">search using content IDs (optional)</param>
        /// <param name="contentTypes">search using content types (optional)</param>
        /// <param name="parentIds">search using parent IDs (optional)</param>
        /// <param name="parentTypes">search using parent types (optional)</param>
        /// <param name="statuses">Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending (optional)</param>
        /// <param name="templateTypes"> (optional)</param>
        /// <param name="appKey">Filter the list by a specific application (optional)</param>
        /// <param name="keyword">Keyword search on the scheduled notification names. (optional)</param>
        /// <param name="sortField">The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date (optional)</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order (optional)</param>
        /// <param name="start">Start the result set at some index. (optional)</param>
        /// <param name="limit">Limit the result to some number. (optional)</param>
        /// <param name="activeOnly">Determines whether to return only active results (optional)</param>
        /// <param name="groupByGroupingId">Determines whether to group results with the same groupingId together. (optional)</param>
        /// <param name="returnAudienceAccountCount">If true, include audience account counts in the response (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchScheduledNotificationsApiResponse"/>&gt;</returns>
        public async Task<ISearchScheduledNotificationsApiResponse?> SearchScheduledNotificationsOrDefaultAsync(decimal version, long accountId, Option<string> groupingId = default, Option<long> audienceId = default, Option<string> filter = default, Option<string> types = default, Option<string> contentIds = default, Option<string> contentTypes = default, Option<string> parentIds = default, Option<string> parentTypes = default, Option<string> statuses = default, Option<string> templateTypes = default, Option<string> appKey = default, Option<string> keyword = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, Option<bool> activeOnly = default, Option<bool> groupByGroupingId = default, Option<bool> returnAudienceAccountCount = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchScheduledNotificationsAsync(version, accountId, groupingId, audienceId, filter, types, contentIds, contentTypes, parentIds, parentTypes, statuses, templateTypes, appKey, keyword, sortField, descending, start, limit, activeOnly, groupByGroupingId, returnAudienceAccountCount, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Scheduled Notifications This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="groupingId">Filter results by a grouping identifier defined by the client (optional)</param>
        /// <param name="audienceId">Filter results by audience (optional)</param>
        /// <param name="filter">a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications. (optional)</param>
        /// <param name="types">Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION (optional)</param>
        /// <param name="contentIds">search using content IDs (optional)</param>
        /// <param name="contentTypes">search using content types (optional)</param>
        /// <param name="parentIds">search using parent IDs (optional)</param>
        /// <param name="parentTypes">search using parent types (optional)</param>
        /// <param name="statuses">Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending (optional)</param>
        /// <param name="templateTypes"> (optional)</param>
        /// <param name="appKey">Filter the list by a specific application (optional)</param>
        /// <param name="keyword">Keyword search on the scheduled notification names. (optional)</param>
        /// <param name="sortField">The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date (optional)</param>
        /// <param name="descending">Determines whether the sorted list is in descending or ascending order (optional)</param>
        /// <param name="start">Start the result set at some index. (optional)</param>
        /// <param name="limit">Limit the result to some number. (optional)</param>
        /// <param name="activeOnly">Determines whether to return only active results (optional)</param>
        /// <param name="groupByGroupingId">Determines whether to group results with the same groupingId together. (optional)</param>
        /// <param name="returnAudienceAccountCount">If true, include audience account counts in the response (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchScheduledNotificationsApiResponse"/>&gt;</returns>
        public async Task<ISearchScheduledNotificationsApiResponse> SearchScheduledNotificationsAsync(decimal version, long accountId, Option<string> groupingId = default, Option<long> audienceId = default, Option<string> filter = default, Option<string> types = default, Option<string> contentIds = default, Option<string> contentTypes = default, Option<string> parentIds = default, Option<string> parentTypes = default, Option<string> statuses = default, Option<string> templateTypes = default, Option<string> appKey = default, Option<string> keyword = default, Option<string> sortField = default, Option<bool> descending = default, Option<int> start = default, Option<int> limit = default, Option<bool> activeOnly = default, Option<bool> groupByGroupingId = default, Option<bool> returnAudienceAccountCount = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchScheduledNotifications(groupingId, filter, types, contentIds, contentTypes, parentIds, parentTypes, statuses, templateTypes, appKey, keyword, sortField);

                FormatSearchScheduledNotifications(ref version, ref accountId, ref groupingId, ref audienceId, ref filter, ref types, ref contentIds, ref contentTypes, ref parentIds, ref parentTypes, ref statuses, ref templateTypes, ref appKey, ref keyword, ref sortField, ref descending, ref start, ref limit, ref activeOnly, ref groupByGroupingId, ref returnAudienceAccountCount);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/notification/schedule/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/notification/schedule/search");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    if (groupingId.IsSet)
                        parseQueryStringLocalVar["groupingId"] = ClientUtils.ParameterToString(groupingId.Value);

                    if (audienceId.IsSet)
                        parseQueryStringLocalVar["audienceId"] = ClientUtils.ParameterToString(audienceId.Value);

                    if (filter.IsSet)
                        parseQueryStringLocalVar["filter"] = ClientUtils.ParameterToString(filter.Value);

                    if (types.IsSet)
                        parseQueryStringLocalVar["types"] = ClientUtils.ParameterToString(types.Value);

                    if (contentIds.IsSet)
                        parseQueryStringLocalVar["contentIds"] = ClientUtils.ParameterToString(contentIds.Value);

                    if (contentTypes.IsSet)
                        parseQueryStringLocalVar["contentTypes"] = ClientUtils.ParameterToString(contentTypes.Value);

                    if (parentIds.IsSet)
                        parseQueryStringLocalVar["parentIds"] = ClientUtils.ParameterToString(parentIds.Value);

                    if (parentTypes.IsSet)
                        parseQueryStringLocalVar["parentTypes"] = ClientUtils.ParameterToString(parentTypes.Value);

                    if (statuses.IsSet)
                        parseQueryStringLocalVar["statuses"] = ClientUtils.ParameterToString(statuses.Value);

                    if (templateTypes.IsSet)
                        parseQueryStringLocalVar["templateTypes"] = ClientUtils.ParameterToString(templateTypes.Value);

                    if (appKey.IsSet)
                        parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey.Value);

                    if (keyword.IsSet)
                        parseQueryStringLocalVar["keyword"] = ClientUtils.ParameterToString(keyword.Value);

                    if (sortField.IsSet)
                        parseQueryStringLocalVar["sortField"] = ClientUtils.ParameterToString(sortField.Value);

                    if (descending.IsSet)
                        parseQueryStringLocalVar["descending"] = ClientUtils.ParameterToString(descending.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (activeOnly.IsSet)
                        parseQueryStringLocalVar["activeOnly"] = ClientUtils.ParameterToString(activeOnly.Value);

                    if (groupByGroupingId.IsSet)
                        parseQueryStringLocalVar["groupByGroupingId"] = ClientUtils.ParameterToString(groupByGroupingId.Value);

                    if (returnAudienceAccountCount.IsSet)
                        parseQueryStringLocalVar["returnAudienceAccountCount"] = ClientUtils.ParameterToString(returnAudienceAccountCount.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchScheduledNotificationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchScheduledNotificationsApiResponse>();
                        SearchScheduledNotificationsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/notification/schedule/search", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchScheduledNotificationsDefaultImplementation(apiResponseLocalVar, version, accountId, groupingId, audienceId, filter, types, contentIds, contentTypes, parentIds, parentTypes, statuses, templateTypes, appKey, keyword, sortField, descending, start, limit, activeOnly, groupByGroupingId, returnAudienceAccountCount);

                        Events.ExecuteOnSearchScheduledNotifications(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchScheduledNotificationsDefaultImplementation(e, "/api/{version}/notification/schedule/search", uriBuilderLocalVar.Path, version, accountId, groupingId, audienceId, filter, types, contentIds, contentTypes, parentIds, parentTypes, statuses, templateTypes, appKey, keyword, sortField, descending, start, limit, activeOnly, groupByGroupingId, returnAudienceAccountCount);
                Events.ExecuteOnErrorSearchScheduledNotifications(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchScheduledNotificationsApiResponse"/>
        /// </summary>
        public partial class SearchScheduledNotificationsApiResponse : Org.OpenAPITools.Client.ApiResponse, ISearchScheduledNotificationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchScheduledNotificationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchScheduledNotificationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchScheduledNotificationsApiResponse(ILogger<SearchScheduledNotificationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchScheduledNotificationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchScheduledNotificationsApiResponse(ILogger<SearchScheduledNotificationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ScheduledNotificationFullResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ScheduledNotificationFullResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ScheduledNotificationFullResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateScheduledNotification(ref decimal version, ref long scheduledNotificationId, ref long accountId, ref Option<string> name, ref Option<string> type, ref Option<string> message, ref Option<string> payload, ref Option<long> contentId, ref Option<string> contentName, ref Option<string> contentType, ref Option<long> parentId, ref Option<string> parentType, ref Option<string> appKey, ref Option<string> groupingId, ref Option<string> connectionGroupIds, ref Option<string> connectionAccountIds, ref Option<long> audienceId, ref Option<string> audienceIds, ref Option<string> albumIds, ref Option<long> reportId, ref Option<string> reportParams, ref Option<string> endpointURL, ref Option<long> scheduledDate, ref Option<long> startDate, ref Option<long> endDate, ref Option<string> cronExpression, ref Option<string> cronType, ref Option<string> metaData, ref Option<string> conditionalInput, ref Option<string> templateType, ref Option<string> visibility, ref Option<bool> active, ref Option<string> errorMessage, ref Option<string> status, ref Option<bool> updateByGroupingId, ref Option<bool> sendNow, ref Option<string> eventType, ref Option<string> deepLinkURI, ref Option<bool> sendToAll);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="name"></param>
        /// <param name="type"></param>
        /// <param name="message"></param>
        /// <param name="payload"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentType"></param>
        /// <param name="appKey"></param>
        /// <param name="groupingId"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="audienceIds"></param>
        /// <param name="albumIds"></param>
        /// <param name="reportParams"></param>
        /// <param name="endpointURL"></param>
        /// <param name="cronExpression"></param>
        /// <param name="cronType"></param>
        /// <param name="metaData"></param>
        /// <param name="conditionalInput"></param>
        /// <param name="templateType"></param>
        /// <param name="visibility"></param>
        /// <param name="errorMessage"></param>
        /// <param name="status"></param>
        /// <param name="eventType"></param>
        /// <param name="deepLinkURI"></param>
        /// <returns></returns>
        private void ValidateUpdateScheduledNotification(Option<string> name, Option<string> type, Option<string> message, Option<string> payload, Option<string> contentName, Option<string> contentType, Option<string> parentType, Option<string> appKey, Option<string> groupingId, Option<string> connectionGroupIds, Option<string> connectionAccountIds, Option<string> audienceIds, Option<string> albumIds, Option<string> reportParams, Option<string> endpointURL, Option<string> cronExpression, Option<string> cronType, Option<string> metaData, Option<string> conditionalInput, Option<string> templateType, Option<string> visibility, Option<string> errorMessage, Option<string> status, Option<string> eventType, Option<string> deepLinkURI)
        {
            if (name.IsSet && name.Value == null)
                throw new ArgumentNullException(nameof(name));

            if (type.IsSet && type.Value == null)
                throw new ArgumentNullException(nameof(type));

            if (message.IsSet && message.Value == null)
                throw new ArgumentNullException(nameof(message));

            if (payload.IsSet && payload.Value == null)
                throw new ArgumentNullException(nameof(payload));

            if (contentName.IsSet && contentName.Value == null)
                throw new ArgumentNullException(nameof(contentName));

            if (contentType.IsSet && contentType.Value == null)
                throw new ArgumentNullException(nameof(contentType));

            if (parentType.IsSet && parentType.Value == null)
                throw new ArgumentNullException(nameof(parentType));

            if (appKey.IsSet && appKey.Value == null)
                throw new ArgumentNullException(nameof(appKey));

            if (groupingId.IsSet && groupingId.Value == null)
                throw new ArgumentNullException(nameof(groupingId));

            if (connectionGroupIds.IsSet && connectionGroupIds.Value == null)
                throw new ArgumentNullException(nameof(connectionGroupIds));

            if (connectionAccountIds.IsSet && connectionAccountIds.Value == null)
                throw new ArgumentNullException(nameof(connectionAccountIds));

            if (audienceIds.IsSet && audienceIds.Value == null)
                throw new ArgumentNullException(nameof(audienceIds));

            if (albumIds.IsSet && albumIds.Value == null)
                throw new ArgumentNullException(nameof(albumIds));

            if (reportParams.IsSet && reportParams.Value == null)
                throw new ArgumentNullException(nameof(reportParams));

            if (endpointURL.IsSet && endpointURL.Value == null)
                throw new ArgumentNullException(nameof(endpointURL));

            if (cronExpression.IsSet && cronExpression.Value == null)
                throw new ArgumentNullException(nameof(cronExpression));

            if (cronType.IsSet && cronType.Value == null)
                throw new ArgumentNullException(nameof(cronType));

            if (metaData.IsSet && metaData.Value == null)
                throw new ArgumentNullException(nameof(metaData));

            if (conditionalInput.IsSet && conditionalInput.Value == null)
                throw new ArgumentNullException(nameof(conditionalInput));

            if (templateType.IsSet && templateType.Value == null)
                throw new ArgumentNullException(nameof(templateType));

            if (visibility.IsSet && visibility.Value == null)
                throw new ArgumentNullException(nameof(visibility));

            if (errorMessage.IsSet && errorMessage.Value == null)
                throw new ArgumentNullException(nameof(errorMessage));

            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status));

            if (eventType.IsSet && eventType.Value == null)
                throw new ArgumentNullException(nameof(eventType));

            if (deepLinkURI.IsSet && deepLinkURI.Value == null)
                throw new ArgumentNullException(nameof(deepLinkURI));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="scheduledNotificationId"></param>
        /// <param name="accountId"></param>
        /// <param name="name"></param>
        /// <param name="type"></param>
        /// <param name="message"></param>
        /// <param name="payload"></param>
        /// <param name="contentId"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentId"></param>
        /// <param name="parentType"></param>
        /// <param name="appKey"></param>
        /// <param name="groupingId"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="audienceId"></param>
        /// <param name="audienceIds"></param>
        /// <param name="albumIds"></param>
        /// <param name="reportId"></param>
        /// <param name="reportParams"></param>
        /// <param name="endpointURL"></param>
        /// <param name="scheduledDate"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="cronExpression"></param>
        /// <param name="cronType"></param>
        /// <param name="metaData"></param>
        /// <param name="conditionalInput"></param>
        /// <param name="templateType"></param>
        /// <param name="visibility"></param>
        /// <param name="active"></param>
        /// <param name="errorMessage"></param>
        /// <param name="status"></param>
        /// <param name="updateByGroupingId"></param>
        /// <param name="sendNow"></param>
        /// <param name="eventType"></param>
        /// <param name="deepLinkURI"></param>
        /// <param name="sendToAll"></param>
        private void AfterUpdateScheduledNotificationDefaultImplementation(IUpdateScheduledNotificationApiResponse apiResponseLocalVar, decimal version, long scheduledNotificationId, long accountId, Option<string> name, Option<string> type, Option<string> message, Option<string> payload, Option<long> contentId, Option<string> contentName, Option<string> contentType, Option<long> parentId, Option<string> parentType, Option<string> appKey, Option<string> groupingId, Option<string> connectionGroupIds, Option<string> connectionAccountIds, Option<long> audienceId, Option<string> audienceIds, Option<string> albumIds, Option<long> reportId, Option<string> reportParams, Option<string> endpointURL, Option<long> scheduledDate, Option<long> startDate, Option<long> endDate, Option<string> cronExpression, Option<string> cronType, Option<string> metaData, Option<string> conditionalInput, Option<string> templateType, Option<string> visibility, Option<bool> active, Option<string> errorMessage, Option<string> status, Option<bool> updateByGroupingId, Option<bool> sendNow, Option<string> eventType, Option<string> deepLinkURI, Option<bool> sendToAll)
        {
            bool suppressDefaultLog = false;
            AfterUpdateScheduledNotification(ref suppressDefaultLog, apiResponseLocalVar, version, scheduledNotificationId, accountId, name, type, message, payload, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, errorMessage, status, updateByGroupingId, sendNow, eventType, deepLinkURI, sendToAll);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="scheduledNotificationId"></param>
        /// <param name="accountId"></param>
        /// <param name="name"></param>
        /// <param name="type"></param>
        /// <param name="message"></param>
        /// <param name="payload"></param>
        /// <param name="contentId"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentId"></param>
        /// <param name="parentType"></param>
        /// <param name="appKey"></param>
        /// <param name="groupingId"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="audienceId"></param>
        /// <param name="audienceIds"></param>
        /// <param name="albumIds"></param>
        /// <param name="reportId"></param>
        /// <param name="reportParams"></param>
        /// <param name="endpointURL"></param>
        /// <param name="scheduledDate"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="cronExpression"></param>
        /// <param name="cronType"></param>
        /// <param name="metaData"></param>
        /// <param name="conditionalInput"></param>
        /// <param name="templateType"></param>
        /// <param name="visibility"></param>
        /// <param name="active"></param>
        /// <param name="errorMessage"></param>
        /// <param name="status"></param>
        /// <param name="updateByGroupingId"></param>
        /// <param name="sendNow"></param>
        /// <param name="eventType"></param>
        /// <param name="deepLinkURI"></param>
        /// <param name="sendToAll"></param>
        partial void AfterUpdateScheduledNotification(ref bool suppressDefaultLog, IUpdateScheduledNotificationApiResponse apiResponseLocalVar, decimal version, long scheduledNotificationId, long accountId, Option<string> name, Option<string> type, Option<string> message, Option<string> payload, Option<long> contentId, Option<string> contentName, Option<string> contentType, Option<long> parentId, Option<string> parentType, Option<string> appKey, Option<string> groupingId, Option<string> connectionGroupIds, Option<string> connectionAccountIds, Option<long> audienceId, Option<string> audienceIds, Option<string> albumIds, Option<long> reportId, Option<string> reportParams, Option<string> endpointURL, Option<long> scheduledDate, Option<long> startDate, Option<long> endDate, Option<string> cronExpression, Option<string> cronType, Option<string> metaData, Option<string> conditionalInput, Option<string> templateType, Option<string> visibility, Option<bool> active, Option<string> errorMessage, Option<string> status, Option<bool> updateByGroupingId, Option<bool> sendNow, Option<string> eventType, Option<string> deepLinkURI, Option<bool> sendToAll);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="scheduledNotificationId"></param>
        /// <param name="accountId"></param>
        /// <param name="name"></param>
        /// <param name="type"></param>
        /// <param name="message"></param>
        /// <param name="payload"></param>
        /// <param name="contentId"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentId"></param>
        /// <param name="parentType"></param>
        /// <param name="appKey"></param>
        /// <param name="groupingId"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="audienceId"></param>
        /// <param name="audienceIds"></param>
        /// <param name="albumIds"></param>
        /// <param name="reportId"></param>
        /// <param name="reportParams"></param>
        /// <param name="endpointURL"></param>
        /// <param name="scheduledDate"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="cronExpression"></param>
        /// <param name="cronType"></param>
        /// <param name="metaData"></param>
        /// <param name="conditionalInput"></param>
        /// <param name="templateType"></param>
        /// <param name="visibility"></param>
        /// <param name="active"></param>
        /// <param name="errorMessage"></param>
        /// <param name="status"></param>
        /// <param name="updateByGroupingId"></param>
        /// <param name="sendNow"></param>
        /// <param name="eventType"></param>
        /// <param name="deepLinkURI"></param>
        /// <param name="sendToAll"></param>
        private void OnErrorUpdateScheduledNotificationDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long scheduledNotificationId, long accountId, Option<string> name, Option<string> type, Option<string> message, Option<string> payload, Option<long> contentId, Option<string> contentName, Option<string> contentType, Option<long> parentId, Option<string> parentType, Option<string> appKey, Option<string> groupingId, Option<string> connectionGroupIds, Option<string> connectionAccountIds, Option<long> audienceId, Option<string> audienceIds, Option<string> albumIds, Option<long> reportId, Option<string> reportParams, Option<string> endpointURL, Option<long> scheduledDate, Option<long> startDate, Option<long> endDate, Option<string> cronExpression, Option<string> cronType, Option<string> metaData, Option<string> conditionalInput, Option<string> templateType, Option<string> visibility, Option<bool> active, Option<string> errorMessage, Option<string> status, Option<bool> updateByGroupingId, Option<bool> sendNow, Option<string> eventType, Option<string> deepLinkURI, Option<bool> sendToAll)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateScheduledNotification(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, version, scheduledNotificationId, accountId, name, type, message, payload, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, errorMessage, status, updateByGroupingId, sendNow, eventType, deepLinkURI, sendToAll);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="version"></param>
        /// <param name="scheduledNotificationId"></param>
        /// <param name="accountId"></param>
        /// <param name="name"></param>
        /// <param name="type"></param>
        /// <param name="message"></param>
        /// <param name="payload"></param>
        /// <param name="contentId"></param>
        /// <param name="contentName"></param>
        /// <param name="contentType"></param>
        /// <param name="parentId"></param>
        /// <param name="parentType"></param>
        /// <param name="appKey"></param>
        /// <param name="groupingId"></param>
        /// <param name="connectionGroupIds"></param>
        /// <param name="connectionAccountIds"></param>
        /// <param name="audienceId"></param>
        /// <param name="audienceIds"></param>
        /// <param name="albumIds"></param>
        /// <param name="reportId"></param>
        /// <param name="reportParams"></param>
        /// <param name="endpointURL"></param>
        /// <param name="scheduledDate"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="cronExpression"></param>
        /// <param name="cronType"></param>
        /// <param name="metaData"></param>
        /// <param name="conditionalInput"></param>
        /// <param name="templateType"></param>
        /// <param name="visibility"></param>
        /// <param name="active"></param>
        /// <param name="errorMessage"></param>
        /// <param name="status"></param>
        /// <param name="updateByGroupingId"></param>
        /// <param name="sendNow"></param>
        /// <param name="eventType"></param>
        /// <param name="deepLinkURI"></param>
        /// <param name="sendToAll"></param>
        partial void OnErrorUpdateScheduledNotification(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, decimal version, long scheduledNotificationId, long accountId, Option<string> name, Option<string> type, Option<string> message, Option<string> payload, Option<long> contentId, Option<string> contentName, Option<string> contentType, Option<long> parentId, Option<string> parentType, Option<string> appKey, Option<string> groupingId, Option<string> connectionGroupIds, Option<string> connectionAccountIds, Option<long> audienceId, Option<string> audienceIds, Option<string> albumIds, Option<long> reportId, Option<string> reportParams, Option<string> endpointURL, Option<long> scheduledDate, Option<long> startDate, Option<long> endDate, Option<string> cronExpression, Option<string> cronType, Option<string> metaData, Option<string> conditionalInput, Option<string> templateType, Option<string> visibility, Option<bool> active, Option<string> errorMessage, Option<string> status, Option<bool> updateByGroupingId, Option<bool> sendNow, Option<string> eventType, Option<string> deepLinkURI, Option<bool> sendToAll);

        /// <summary>
        /// Update Scheduled Notification This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.
        /// </summary>
        /// <param name="version"></param>
        /// <param name="scheduledNotificationId">The id of scheduled notification to update</param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="name">The name of the scheduled notification (optional)</param>
        /// <param name="type">The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (optional)</param>
        /// <param name="message">The message to send (optional)</param>
        /// <param name="payload">The parameters for making an HTTP call (optional)</param>
        /// <param name="contentId">The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="contentName">The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="contentType">The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="parentId">The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="parentType">The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="appKey">The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)</param>
        /// <param name="groupingId">Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)</param>
        /// <param name="connectionGroupIds">The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)</param>
        /// <param name="connectionAccountIds">The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)</param>
        /// <param name="audienceId">This parameter is deprecated. The audience used to generate the list of recipients (optional)</param>
        /// <param name="audienceIds">The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)</param>
        /// <param name="albumIds">The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)</param>
        /// <param name="reportId">The report used to generate the the list of recipients (optional)</param>
        /// <param name="reportParams">The parameters to supply to the report used to generate the the list of recipients (optional)</param>
        /// <param name="endpointURL">The URL for making an HTTP call (optional)</param>
        /// <param name="scheduledDate">The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)</param>
        /// <param name="startDate">The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)</param>
        /// <param name="endDate">The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)</param>
        /// <param name="cronExpression">The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)</param>
        /// <param name="cronType">The cron expression type: UNIX, CRON4J, QUARTZ (optional)</param>
        /// <param name="metaData">Additional metadata for the scheduled notification (optional)</param>
        /// <param name="conditionalInput">Json input representing conditional logic that has to be met before running the scheduled notification (optional)</param>
        /// <param name="templateType">This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)</param>
        /// <param name="visibility">Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)</param>
        /// <param name="active">Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. (optional)</param>
        /// <param name="errorMessage">the error message associated with the scheduled notification (optional)</param>
        /// <param name="status">the status of the scheduled notification (optional)</param>
        /// <param name="updateByGroupingId">also updates ScheduledNotifications with the same groupingId and account (optional)</param>
        /// <param name="sendNow">whether to send the scheduled notification now or not (optional)</param>
        /// <param name="eventType">Sets the event type for the notification (optional, default to &quot;CUSTOM&quot;)</param>
        /// <param name="deepLinkURI">The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)</param>
        /// <param name="sendToAll">Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateScheduledNotificationApiResponse"/>&gt;</returns>
        public async Task<IUpdateScheduledNotificationApiResponse?> UpdateScheduledNotificationOrDefaultAsync(decimal version, long scheduledNotificationId, long accountId, Option<string> name = default, Option<string> type = default, Option<string> message = default, Option<string> payload = default, Option<long> contentId = default, Option<string> contentName = default, Option<string> contentType = default, Option<long> parentId = default, Option<string> parentType = default, Option<string> appKey = default, Option<string> groupingId = default, Option<string> connectionGroupIds = default, Option<string> connectionAccountIds = default, Option<long> audienceId = default, Option<string> audienceIds = default, Option<string> albumIds = default, Option<long> reportId = default, Option<string> reportParams = default, Option<string> endpointURL = default, Option<long> scheduledDate = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> cronExpression = default, Option<string> cronType = default, Option<string> metaData = default, Option<string> conditionalInput = default, Option<string> templateType = default, Option<string> visibility = default, Option<bool> active = default, Option<string> errorMessage = default, Option<string> status = default, Option<bool> updateByGroupingId = default, Option<bool> sendNow = default, Option<string> eventType = default, Option<string> deepLinkURI = default, Option<bool> sendToAll = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateScheduledNotificationAsync(version, scheduledNotificationId, accountId, name, type, message, payload, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, errorMessage, status, updateByGroupingId, sendNow, eventType, deepLinkURI, sendToAll, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update Scheduled Notification This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="version"></param>
        /// <param name="scheduledNotificationId">The id of scheduled notification to update</param>
        /// <param name="accountId">The logged in user.</param>
        /// <param name="name">The name of the scheduled notification (optional)</param>
        /// <param name="type">The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (optional)</param>
        /// <param name="message">The message to send (optional)</param>
        /// <param name="payload">The parameters for making an HTTP call (optional)</param>
        /// <param name="contentId">The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="contentName">The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="contentType">The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="parentId">The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="parentType">The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)</param>
        /// <param name="appKey">The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)</param>
        /// <param name="groupingId">Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)</param>
        /// <param name="connectionGroupIds">The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)</param>
        /// <param name="connectionAccountIds">The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)</param>
        /// <param name="audienceId">This parameter is deprecated. The audience used to generate the list of recipients (optional)</param>
        /// <param name="audienceIds">The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)</param>
        /// <param name="albumIds">The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)</param>
        /// <param name="reportId">The report used to generate the the list of recipients (optional)</param>
        /// <param name="reportParams">The parameters to supply to the report used to generate the the list of recipients (optional)</param>
        /// <param name="endpointURL">The URL for making an HTTP call (optional)</param>
        /// <param name="scheduledDate">The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)</param>
        /// <param name="startDate">The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)</param>
        /// <param name="endDate">The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)</param>
        /// <param name="cronExpression">The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)</param>
        /// <param name="cronType">The cron expression type: UNIX, CRON4J, QUARTZ (optional)</param>
        /// <param name="metaData">Additional metadata for the scheduled notification (optional)</param>
        /// <param name="conditionalInput">Json input representing conditional logic that has to be met before running the scheduled notification (optional)</param>
        /// <param name="templateType">This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)</param>
        /// <param name="visibility">Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)</param>
        /// <param name="active">Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. (optional)</param>
        /// <param name="errorMessage">the error message associated with the scheduled notification (optional)</param>
        /// <param name="status">the status of the scheduled notification (optional)</param>
        /// <param name="updateByGroupingId">also updates ScheduledNotifications with the same groupingId and account (optional)</param>
        /// <param name="sendNow">whether to send the scheduled notification now or not (optional)</param>
        /// <param name="eventType">Sets the event type for the notification (optional, default to &quot;CUSTOM&quot;)</param>
        /// <param name="deepLinkURI">The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)</param>
        /// <param name="sendToAll">Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateScheduledNotificationApiResponse"/>&gt;</returns>
        public async Task<IUpdateScheduledNotificationApiResponse> UpdateScheduledNotificationAsync(decimal version, long scheduledNotificationId, long accountId, Option<string> name = default, Option<string> type = default, Option<string> message = default, Option<string> payload = default, Option<long> contentId = default, Option<string> contentName = default, Option<string> contentType = default, Option<long> parentId = default, Option<string> parentType = default, Option<string> appKey = default, Option<string> groupingId = default, Option<string> connectionGroupIds = default, Option<string> connectionAccountIds = default, Option<long> audienceId = default, Option<string> audienceIds = default, Option<string> albumIds = default, Option<long> reportId = default, Option<string> reportParams = default, Option<string> endpointURL = default, Option<long> scheduledDate = default, Option<long> startDate = default, Option<long> endDate = default, Option<string> cronExpression = default, Option<string> cronType = default, Option<string> metaData = default, Option<string> conditionalInput = default, Option<string> templateType = default, Option<string> visibility = default, Option<bool> active = default, Option<string> errorMessage = default, Option<string> status = default, Option<bool> updateByGroupingId = default, Option<bool> sendNow = default, Option<string> eventType = default, Option<string> deepLinkURI = default, Option<bool> sendToAll = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateScheduledNotification(name, type, message, payload, contentName, contentType, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceIds, albumIds, reportParams, endpointURL, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, errorMessage, status, eventType, deepLinkURI);

                FormatUpdateScheduledNotification(ref version, ref scheduledNotificationId, ref accountId, ref name, ref type, ref message, ref payload, ref contentId, ref contentName, ref contentType, ref parentId, ref parentType, ref appKey, ref groupingId, ref connectionGroupIds, ref connectionAccountIds, ref audienceId, ref audienceIds, ref albumIds, ref reportId, ref reportParams, ref endpointURL, ref scheduledDate, ref startDate, ref endDate, ref cronExpression, ref cronType, ref metaData, ref conditionalInput, ref templateType, ref visibility, ref active, ref errorMessage, ref status, ref updateByGroupingId, ref sendNow, ref eventType, ref deepLinkURI, ref sendToAll);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/{version}/notification/schedule/update"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/{version}/notification/schedule/update");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bversion%7D", Uri.EscapeDataString(version.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["scheduledNotificationId"] = ClientUtils.ParameterToString(scheduledNotificationId);
                    parseQueryStringLocalVar["accountId"] = ClientUtils.ParameterToString(accountId);

                    if (name.IsSet)
                        parseQueryStringLocalVar["name"] = ClientUtils.ParameterToString(name.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    if (message.IsSet)
                        parseQueryStringLocalVar["message"] = ClientUtils.ParameterToString(message.Value);

                    if (payload.IsSet)
                        parseQueryStringLocalVar["payload"] = ClientUtils.ParameterToString(payload.Value);

                    if (contentId.IsSet)
                        parseQueryStringLocalVar["contentId"] = ClientUtils.ParameterToString(contentId.Value);

                    if (contentName.IsSet)
                        parseQueryStringLocalVar["contentName"] = ClientUtils.ParameterToString(contentName.Value);

                    if (contentType.IsSet)
                        parseQueryStringLocalVar["contentType"] = ClientUtils.ParameterToString(contentType.Value);

                    if (parentId.IsSet)
                        parseQueryStringLocalVar["parentId"] = ClientUtils.ParameterToString(parentId.Value);

                    if (parentType.IsSet)
                        parseQueryStringLocalVar["parentType"] = ClientUtils.ParameterToString(parentType.Value);

                    if (appKey.IsSet)
                        parseQueryStringLocalVar["appKey"] = ClientUtils.ParameterToString(appKey.Value);

                    if (groupingId.IsSet)
                        parseQueryStringLocalVar["groupingId"] = ClientUtils.ParameterToString(groupingId.Value);

                    if (connectionGroupIds.IsSet)
                        parseQueryStringLocalVar["connectionGroupIds"] = ClientUtils.ParameterToString(connectionGroupIds.Value);

                    if (connectionAccountIds.IsSet)
                        parseQueryStringLocalVar["connectionAccountIds"] = ClientUtils.ParameterToString(connectionAccountIds.Value);

                    if (audienceId.IsSet)
                        parseQueryStringLocalVar["audienceId"] = ClientUtils.ParameterToString(audienceId.Value);

                    if (audienceIds.IsSet)
                        parseQueryStringLocalVar["audienceIds"] = ClientUtils.ParameterToString(audienceIds.Value);

                    if (albumIds.IsSet)
                        parseQueryStringLocalVar["albumIds"] = ClientUtils.ParameterToString(albumIds.Value);

                    if (reportId.IsSet)
                        parseQueryStringLocalVar["reportId"] = ClientUtils.ParameterToString(reportId.Value);

                    if (reportParams.IsSet)
                        parseQueryStringLocalVar["reportParams"] = ClientUtils.ParameterToString(reportParams.Value);

                    if (endpointURL.IsSet)
                        parseQueryStringLocalVar["endpointURL"] = ClientUtils.ParameterToString(endpointURL.Value);

                    if (scheduledDate.IsSet)
                        parseQueryStringLocalVar["scheduledDate"] = ClientUtils.ParameterToString(scheduledDate.Value);

                    if (startDate.IsSet)
                        parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate.Value);

                    if (endDate.IsSet)
                        parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate.Value);

                    if (cronExpression.IsSet)
                        parseQueryStringLocalVar["cronExpression"] = ClientUtils.ParameterToString(cronExpression.Value);

                    if (cronType.IsSet)
                        parseQueryStringLocalVar["cronType"] = ClientUtils.ParameterToString(cronType.Value);

                    if (metaData.IsSet)
                        parseQueryStringLocalVar["metaData"] = ClientUtils.ParameterToString(metaData.Value);

                    if (conditionalInput.IsSet)
                        parseQueryStringLocalVar["conditionalInput"] = ClientUtils.ParameterToString(conditionalInput.Value);

                    if (templateType.IsSet)
                        parseQueryStringLocalVar["templateType"] = ClientUtils.ParameterToString(templateType.Value);

                    if (visibility.IsSet)
                        parseQueryStringLocalVar["visibility"] = ClientUtils.ParameterToString(visibility.Value);

                    if (active.IsSet)
                        parseQueryStringLocalVar["active"] = ClientUtils.ParameterToString(active.Value);

                    if (errorMessage.IsSet)
                        parseQueryStringLocalVar["errorMessage"] = ClientUtils.ParameterToString(errorMessage.Value);

                    if (status.IsSet)
                        parseQueryStringLocalVar["status"] = ClientUtils.ParameterToString(status.Value);

                    if (updateByGroupingId.IsSet)
                        parseQueryStringLocalVar["updateByGroupingId"] = ClientUtils.ParameterToString(updateByGroupingId.Value);

                    if (sendNow.IsSet)
                        parseQueryStringLocalVar["sendNow"] = ClientUtils.ParameterToString(sendNow.Value);

                    if (eventType.IsSet)
                        parseQueryStringLocalVar["eventType"] = ClientUtils.ParameterToString(eventType.Value);

                    if (deepLinkURI.IsSet)
                        parseQueryStringLocalVar["deepLinkURI"] = ClientUtils.ParameterToString(deepLinkURI.Value);

                    if (sendToAll.IsSet)
                        parseQueryStringLocalVar["sendToAll"] = ClientUtils.ParameterToString(sendToAll.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UpdateScheduledNotificationApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateScheduledNotificationApiResponse>();
                        UpdateScheduledNotificationApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/{version}/notification/schedule/update", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUpdateScheduledNotificationDefaultImplementation(apiResponseLocalVar, version, scheduledNotificationId, accountId, name, type, message, payload, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, errorMessage, status, updateByGroupingId, sendNow, eventType, deepLinkURI, sendToAll);

                        Events.ExecuteOnUpdateScheduledNotification(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateScheduledNotificationDefaultImplementation(e, "/api/{version}/notification/schedule/update", uriBuilderLocalVar.Path, version, scheduledNotificationId, accountId, name, type, message, payload, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, errorMessage, status, updateByGroupingId, sendNow, eventType, deepLinkURI, sendToAll);
                Events.ExecuteOnErrorUpdateScheduledNotification(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateScheduledNotificationApiResponse"/>
        /// </summary>
        public partial class UpdateScheduledNotificationApiResponse : Org.OpenAPITools.Client.ApiResponse, IUpdateScheduledNotificationApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateScheduledNotificationApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateScheduledNotificationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateScheduledNotificationApiResponse(ILogger<UpdateScheduledNotificationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UpdateScheduledNotificationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateScheduledNotificationApiResponse(ILogger<UpdateScheduledNotificationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ScheduledNotificationFullResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ScheduledNotificationFullResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ScheduledNotificationFullResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
