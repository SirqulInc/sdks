// <auto-generated>
/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Org.OpenAPITools.Client;

namespace Org.OpenAPITools.Model
{
    /// <summary>
    /// Pack
    /// </summary>
    public partial class Pack : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Pack" /> class.
        /// </summary>
        /// <param name="id">id</param>
        /// <param name="active">active</param>
        /// <param name="valid">valid</param>
        /// <param name="newOwnerId">newOwnerId</param>
        /// <param name="owner">owner</param>
        /// <param name="application">application</param>
        /// <param name="sequenceType">sequenceType</param>
        /// <param name="title">title</param>
        /// <param name="description">description</param>
        /// <param name="startDate">startDate</param>
        /// <param name="endDate">endDate</param>
        /// <param name="packType">packType</param>
        /// <param name="image">image</param>
        /// <param name="background">background</param>
        /// <param name="imageURL">imageURL</param>
        /// <param name="gameLevels">gameLevels</param>
        /// <param name="hasMoreItems">hasMoreItems</param>
        /// <param name="totalCount">totalCount</param>
        /// <param name="downloaded">downloaded</param>
        /// <param name="authorOverride">authorOverride</param>
        /// <param name="packOrder">packOrder</param>
        /// <param name="inGame">inGame</param>
        /// <param name="highest">highest</param>
        /// <param name="notificationCount">notificationCount</param>
        /// <param name="points">points</param>
        /// <param name="ticketType">ticketType</param>
        /// <param name="ticketCount">ticketCount</param>
        /// <param name="priceType">priceType</param>
        /// <param name="price">price</param>
        /// <param name="allocateTickets">allocateTickets</param>
        /// <param name="applicationTitle">applicationTitle</param>
        /// <param name="levelNumberMap">levelNumberMap</param>
        [JsonConstructor]
        public Pack(Option<long?> id = default, Option<bool?> active = default, Option<bool?> valid = default, Option<long?> newOwnerId = default, Option<Account?> owner = default, Option<Application?> application = default, Option<SequenceTypeEnum?> sequenceType = default, Option<string?> title = default, Option<string?> description = default, Option<DateTime?> startDate = default, Option<DateTime?> endDate = default, Option<PackTypeEnum?> packType = default, Option<Asset?> image = default, Option<Asset?> background = default, Option<string?> imageURL = default, Option<List<GameLevel>?> gameLevels = default, Option<bool?> hasMoreItems = default, Option<long?> totalCount = default, Option<bool?> downloaded = default, Option<string?> authorOverride = default, Option<long?> packOrder = default, Option<bool?> inGame = default, Option<bool?> highest = default, Option<int?> notificationCount = default, Option<long?> points = default, Option<string?> ticketType = default, Option<long?> ticketCount = default, Option<string?> priceType = default, Option<int?> price = default, Option<bool?> allocateTickets = default, Option<string?> applicationTitle = default, Option<Dictionary<string, GameLevel>?> levelNumberMap = default)
        {
            IdOption = id;
            ActiveOption = active;
            ValidOption = valid;
            NewOwnerIdOption = newOwnerId;
            OwnerOption = owner;
            ApplicationOption = application;
            SequenceTypeOption = sequenceType;
            TitleOption = title;
            DescriptionOption = description;
            StartDateOption = startDate;
            EndDateOption = endDate;
            PackTypeOption = packType;
            ImageOption = image;
            BackgroundOption = background;
            ImageURLOption = imageURL;
            GameLevelsOption = gameLevels;
            HasMoreItemsOption = hasMoreItems;
            TotalCountOption = totalCount;
            DownloadedOption = downloaded;
            AuthorOverrideOption = authorOverride;
            PackOrderOption = packOrder;
            InGameOption = inGame;
            HighestOption = highest;
            NotificationCountOption = notificationCount;
            PointsOption = points;
            TicketTypeOption = ticketType;
            TicketCountOption = ticketCount;
            PriceTypeOption = priceType;
            PriceOption = price;
            AllocateTicketsOption = allocateTickets;
            ApplicationTitleOption = applicationTitle;
            LevelNumberMapOption = levelNumberMap;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Defines SequenceType
        /// </summary>
        public enum SequenceTypeEnum
        {
            /// <summary>
            /// Enum FIRSTAVAILABLE for value: FIRST_AVAILABLE
            /// </summary>
            FIRSTAVAILABLE = 1,

            /// <summary>
            /// Enum ALLAVAILABLE for value: ALL_AVAILABLE
            /// </summary>
            ALLAVAILABLE = 2
        }

        /// <summary>
        /// Returns a <see cref="SequenceTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static SequenceTypeEnum SequenceTypeEnumFromString(string value)
        {
            if (value.Equals("FIRST_AVAILABLE"))
                return SequenceTypeEnum.FIRSTAVAILABLE;

            if (value.Equals("ALL_AVAILABLE"))
                return SequenceTypeEnum.ALLAVAILABLE;

            throw new NotImplementedException($"Could not convert value to type SequenceTypeEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="SequenceTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static SequenceTypeEnum? SequenceTypeEnumFromStringOrDefault(string value)
        {
            if (value.Equals("FIRST_AVAILABLE"))
                return SequenceTypeEnum.FIRSTAVAILABLE;

            if (value.Equals("ALL_AVAILABLE"))
                return SequenceTypeEnum.ALLAVAILABLE;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="SequenceTypeEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string SequenceTypeEnumToJsonValue(SequenceTypeEnum? value)
        {
            if (value == SequenceTypeEnum.FIRSTAVAILABLE)
                return "FIRST_AVAILABLE";

            if (value == SequenceTypeEnum.ALLAVAILABLE)
                return "ALL_AVAILABLE";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of SequenceType
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<SequenceTypeEnum?> SequenceTypeOption { get; private set; }

        /// <summary>
        /// Gets or Sets SequenceType
        /// </summary>
        [JsonPropertyName("sequenceType")]
        public SequenceTypeEnum? SequenceType { get { return this.SequenceTypeOption; } set { this.SequenceTypeOption = new(value); } }

        /// <summary>
        /// Defines PackType
        /// </summary>
        public enum PackTypeEnum
        {
            /// <summary>
            /// Enum TUTORIAL for value: TUTORIAL
            /// </summary>
            TUTORIAL = 1,

            /// <summary>
            /// Enum BUILTIN for value: BUILTIN
            /// </summary>
            BUILTIN = 2,

            /// <summary>
            /// Enum DOWNLOAD for value: DOWNLOAD
            /// </summary>
            DOWNLOAD = 3,

            /// <summary>
            /// Enum THRESHOLD for value: THRESHOLD
            /// </summary>
            THRESHOLD = 4,

            /// <summary>
            /// Enum THEME for value: THEME
            /// </summary>
            THEME = 5,

            /// <summary>
            /// Enum TOURNAMENT for value: TOURNAMENT
            /// </summary>
            TOURNAMENT = 6
        }

        /// <summary>
        /// Returns a <see cref="PackTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static PackTypeEnum PackTypeEnumFromString(string value)
        {
            if (value.Equals("TUTORIAL"))
                return PackTypeEnum.TUTORIAL;

            if (value.Equals("BUILTIN"))
                return PackTypeEnum.BUILTIN;

            if (value.Equals("DOWNLOAD"))
                return PackTypeEnum.DOWNLOAD;

            if (value.Equals("THRESHOLD"))
                return PackTypeEnum.THRESHOLD;

            if (value.Equals("THEME"))
                return PackTypeEnum.THEME;

            if (value.Equals("TOURNAMENT"))
                return PackTypeEnum.TOURNAMENT;

            throw new NotImplementedException($"Could not convert value to type PackTypeEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="PackTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static PackTypeEnum? PackTypeEnumFromStringOrDefault(string value)
        {
            if (value.Equals("TUTORIAL"))
                return PackTypeEnum.TUTORIAL;

            if (value.Equals("BUILTIN"))
                return PackTypeEnum.BUILTIN;

            if (value.Equals("DOWNLOAD"))
                return PackTypeEnum.DOWNLOAD;

            if (value.Equals("THRESHOLD"))
                return PackTypeEnum.THRESHOLD;

            if (value.Equals("THEME"))
                return PackTypeEnum.THEME;

            if (value.Equals("TOURNAMENT"))
                return PackTypeEnum.TOURNAMENT;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="PackTypeEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string PackTypeEnumToJsonValue(PackTypeEnum? value)
        {
            if (value == PackTypeEnum.TUTORIAL)
                return "TUTORIAL";

            if (value == PackTypeEnum.BUILTIN)
                return "BUILTIN";

            if (value == PackTypeEnum.DOWNLOAD)
                return "DOWNLOAD";

            if (value == PackTypeEnum.THRESHOLD)
                return "THRESHOLD";

            if (value == PackTypeEnum.THEME)
                return "THEME";

            if (value == PackTypeEnum.TOURNAMENT)
                return "TOURNAMENT";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of PackType
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<PackTypeEnum?> PackTypeOption { get; private set; }

        /// <summary>
        /// Gets or Sets PackType
        /// </summary>
        [JsonPropertyName("packType")]
        public PackTypeEnum? PackType { get { return this.PackTypeOption; } set { this.PackTypeOption = new(value); } }

        /// <summary>
        /// Used to track the state of Id
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> IdOption { get; private set; }

        /// <summary>
        /// Gets or Sets Id
        /// </summary>
        [JsonPropertyName("id")]
        public long? Id { get { return this.IdOption; } set { this.IdOption = new(value); } }

        /// <summary>
        /// Used to track the state of Active
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> ActiveOption { get; private set; }

        /// <summary>
        /// Gets or Sets Active
        /// </summary>
        [JsonPropertyName("active")]
        public bool? Active { get { return this.ActiveOption; } set { this.ActiveOption = new(value); } }

        /// <summary>
        /// Used to track the state of Valid
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> ValidOption { get; private set; }

        /// <summary>
        /// Gets or Sets Valid
        /// </summary>
        [JsonPropertyName("valid")]
        public bool? Valid { get { return this.ValidOption; } set { this.ValidOption = new(value); } }

        /// <summary>
        /// Used to track the state of NewOwnerId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> NewOwnerIdOption { get; private set; }

        /// <summary>
        /// Gets or Sets NewOwnerId
        /// </summary>
        [JsonPropertyName("newOwnerId")]
        public long? NewOwnerId { get { return this.NewOwnerIdOption; } set { this.NewOwnerIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of Owner
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Account?> OwnerOption { get; private set; }

        /// <summary>
        /// Gets or Sets Owner
        /// </summary>
        [JsonPropertyName("owner")]
        public Account? Owner { get { return this.OwnerOption; } set { this.OwnerOption = new(value); } }

        /// <summary>
        /// Used to track the state of Application
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Application?> ApplicationOption { get; private set; }

        /// <summary>
        /// Gets or Sets Application
        /// </summary>
        [JsonPropertyName("application")]
        public Application? Application { get { return this.ApplicationOption; } set { this.ApplicationOption = new(value); } }

        /// <summary>
        /// Used to track the state of Title
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> TitleOption { get; private set; }

        /// <summary>
        /// Gets or Sets Title
        /// </summary>
        [JsonPropertyName("title")]
        public string? Title { get { return this.TitleOption; } set { this.TitleOption = new(value); } }

        /// <summary>
        /// Used to track the state of Description
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> DescriptionOption { get; private set; }

        /// <summary>
        /// Gets or Sets Description
        /// </summary>
        [JsonPropertyName("description")]
        public string? Description { get { return this.DescriptionOption; } set { this.DescriptionOption = new(value); } }

        /// <summary>
        /// Used to track the state of StartDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> StartDateOption { get; private set; }

        /// <summary>
        /// Gets or Sets StartDate
        /// </summary>
        [JsonPropertyName("startDate")]
        public DateTime? StartDate { get { return this.StartDateOption; } set { this.StartDateOption = new(value); } }

        /// <summary>
        /// Used to track the state of EndDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> EndDateOption { get; private set; }

        /// <summary>
        /// Gets or Sets EndDate
        /// </summary>
        [JsonPropertyName("endDate")]
        public DateTime? EndDate { get { return this.EndDateOption; } set { this.EndDateOption = new(value); } }

        /// <summary>
        /// Used to track the state of Image
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Asset?> ImageOption { get; private set; }

        /// <summary>
        /// Gets or Sets Image
        /// </summary>
        [JsonPropertyName("image")]
        public Asset? Image { get { return this.ImageOption; } set { this.ImageOption = new(value); } }

        /// <summary>
        /// Used to track the state of Background
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Asset?> BackgroundOption { get; private set; }

        /// <summary>
        /// Gets or Sets Background
        /// </summary>
        [JsonPropertyName("background")]
        public Asset? Background { get { return this.BackgroundOption; } set { this.BackgroundOption = new(value); } }

        /// <summary>
        /// Used to track the state of ImageURL
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ImageURLOption { get; private set; }

        /// <summary>
        /// Gets or Sets ImageURL
        /// </summary>
        [JsonPropertyName("imageURL")]
        public string? ImageURL { get { return this.ImageURLOption; } set { this.ImageURLOption = new(value); } }

        /// <summary>
        /// Used to track the state of GameLevels
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<GameLevel>?> GameLevelsOption { get; private set; }

        /// <summary>
        /// Gets or Sets GameLevels
        /// </summary>
        [JsonPropertyName("gameLevels")]
        public List<GameLevel>? GameLevels { get { return this.GameLevelsOption; } set { this.GameLevelsOption = new(value); } }

        /// <summary>
        /// Used to track the state of HasMoreItems
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> HasMoreItemsOption { get; private set; }

        /// <summary>
        /// Gets or Sets HasMoreItems
        /// </summary>
        [JsonPropertyName("hasMoreItems")]
        public bool? HasMoreItems { get { return this.HasMoreItemsOption; } set { this.HasMoreItemsOption = new(value); } }

        /// <summary>
        /// Used to track the state of TotalCount
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> TotalCountOption { get; private set; }

        /// <summary>
        /// Gets or Sets TotalCount
        /// </summary>
        [JsonPropertyName("totalCount")]
        public long? TotalCount { get { return this.TotalCountOption; } set { this.TotalCountOption = new(value); } }

        /// <summary>
        /// Used to track the state of Downloaded
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> DownloadedOption { get; private set; }

        /// <summary>
        /// Gets or Sets Downloaded
        /// </summary>
        [JsonPropertyName("downloaded")]
        public bool? Downloaded { get { return this.DownloadedOption; } set { this.DownloadedOption = new(value); } }

        /// <summary>
        /// Used to track the state of AuthorOverride
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> AuthorOverrideOption { get; private set; }

        /// <summary>
        /// Gets or Sets AuthorOverride
        /// </summary>
        [JsonPropertyName("authorOverride")]
        public string? AuthorOverride { get { return this.AuthorOverrideOption; } set { this.AuthorOverrideOption = new(value); } }

        /// <summary>
        /// Used to track the state of PackOrder
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> PackOrderOption { get; private set; }

        /// <summary>
        /// Gets or Sets PackOrder
        /// </summary>
        [JsonPropertyName("packOrder")]
        public long? PackOrder { get { return this.PackOrderOption; } set { this.PackOrderOption = new(value); } }

        /// <summary>
        /// Used to track the state of InGame
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> InGameOption { get; private set; }

        /// <summary>
        /// Gets or Sets InGame
        /// </summary>
        [JsonPropertyName("inGame")]
        public bool? InGame { get { return this.InGameOption; } set { this.InGameOption = new(value); } }

        /// <summary>
        /// Used to track the state of Highest
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> HighestOption { get; private set; }

        /// <summary>
        /// Gets or Sets Highest
        /// </summary>
        [JsonPropertyName("highest")]
        public bool? Highest { get { return this.HighestOption; } set { this.HighestOption = new(value); } }

        /// <summary>
        /// Used to track the state of NotificationCount
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> NotificationCountOption { get; private set; }

        /// <summary>
        /// Gets or Sets NotificationCount
        /// </summary>
        [JsonPropertyName("notificationCount")]
        public int? NotificationCount { get { return this.NotificationCountOption; } set { this.NotificationCountOption = new(value); } }

        /// <summary>
        /// Used to track the state of Points
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> PointsOption { get; private set; }

        /// <summary>
        /// Gets or Sets Points
        /// </summary>
        [JsonPropertyName("points")]
        public long? Points { get { return this.PointsOption; } set { this.PointsOption = new(value); } }

        /// <summary>
        /// Used to track the state of TicketType
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> TicketTypeOption { get; private set; }

        /// <summary>
        /// Gets or Sets TicketType
        /// </summary>
        [JsonPropertyName("ticketType")]
        public string? TicketType { get { return this.TicketTypeOption; } set { this.TicketTypeOption = new(value); } }

        /// <summary>
        /// Used to track the state of TicketCount
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> TicketCountOption { get; private set; }

        /// <summary>
        /// Gets or Sets TicketCount
        /// </summary>
        [JsonPropertyName("ticketCount")]
        public long? TicketCount { get { return this.TicketCountOption; } set { this.TicketCountOption = new(value); } }

        /// <summary>
        /// Used to track the state of PriceType
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> PriceTypeOption { get; private set; }

        /// <summary>
        /// Gets or Sets PriceType
        /// </summary>
        [JsonPropertyName("priceType")]
        public string? PriceType { get { return this.PriceTypeOption; } set { this.PriceTypeOption = new(value); } }

        /// <summary>
        /// Used to track the state of Price
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> PriceOption { get; private set; }

        /// <summary>
        /// Gets or Sets Price
        /// </summary>
        [JsonPropertyName("price")]
        public int? Price { get { return this.PriceOption; } set { this.PriceOption = new(value); } }

        /// <summary>
        /// Used to track the state of AllocateTickets
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> AllocateTicketsOption { get; private set; }

        /// <summary>
        /// Gets or Sets AllocateTickets
        /// </summary>
        [JsonPropertyName("allocateTickets")]
        public bool? AllocateTickets { get { return this.AllocateTicketsOption; } set { this.AllocateTicketsOption = new(value); } }

        /// <summary>
        /// Used to track the state of ApplicationTitle
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ApplicationTitleOption { get; private set; }

        /// <summary>
        /// Gets or Sets ApplicationTitle
        /// </summary>
        [JsonPropertyName("applicationTitle")]
        public string? ApplicationTitle { get { return this.ApplicationTitleOption; } set { this.ApplicationTitleOption = new(value); } }

        /// <summary>
        /// Used to track the state of LevelNumberMap
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Dictionary<string, GameLevel>?> LevelNumberMapOption { get; private set; }

        /// <summary>
        /// Gets or Sets LevelNumberMap
        /// </summary>
        [JsonPropertyName("levelNumberMap")]
        public Dictionary<string, GameLevel>? LevelNumberMap { get { return this.LevelNumberMapOption; } set { this.LevelNumberMapOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Pack {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Active: ").Append(Active).Append("\n");
            sb.Append("  Valid: ").Append(Valid).Append("\n");
            sb.Append("  NewOwnerId: ").Append(NewOwnerId).Append("\n");
            sb.Append("  Owner: ").Append(Owner).Append("\n");
            sb.Append("  Application: ").Append(Application).Append("\n");
            sb.Append("  SequenceType: ").Append(SequenceType).Append("\n");
            sb.Append("  Title: ").Append(Title).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  StartDate: ").Append(StartDate).Append("\n");
            sb.Append("  EndDate: ").Append(EndDate).Append("\n");
            sb.Append("  PackType: ").Append(PackType).Append("\n");
            sb.Append("  Image: ").Append(Image).Append("\n");
            sb.Append("  Background: ").Append(Background).Append("\n");
            sb.Append("  ImageURL: ").Append(ImageURL).Append("\n");
            sb.Append("  GameLevels: ").Append(GameLevels).Append("\n");
            sb.Append("  HasMoreItems: ").Append(HasMoreItems).Append("\n");
            sb.Append("  TotalCount: ").Append(TotalCount).Append("\n");
            sb.Append("  Downloaded: ").Append(Downloaded).Append("\n");
            sb.Append("  AuthorOverride: ").Append(AuthorOverride).Append("\n");
            sb.Append("  PackOrder: ").Append(PackOrder).Append("\n");
            sb.Append("  InGame: ").Append(InGame).Append("\n");
            sb.Append("  Highest: ").Append(Highest).Append("\n");
            sb.Append("  NotificationCount: ").Append(NotificationCount).Append("\n");
            sb.Append("  Points: ").Append(Points).Append("\n");
            sb.Append("  TicketType: ").Append(TicketType).Append("\n");
            sb.Append("  TicketCount: ").Append(TicketCount).Append("\n");
            sb.Append("  PriceType: ").Append(PriceType).Append("\n");
            sb.Append("  Price: ").Append(Price).Append("\n");
            sb.Append("  AllocateTickets: ").Append(AllocateTickets).Append("\n");
            sb.Append("  ApplicationTitle: ").Append(ApplicationTitle).Append("\n");
            sb.Append("  LevelNumberMap: ").Append(LevelNumberMap).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="Pack" />
    /// </summary>
    public class PackJsonConverter : JsonConverter<Pack>
    {
        /// <summary>
        /// The format to use to serialize StartDate
        /// </summary>
        public static string StartDateFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize EndDate
        /// </summary>
        public static string EndDateFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="Pack" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override Pack Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<long?> id = default;
            Option<bool?> active = default;
            Option<bool?> valid = default;
            Option<long?> newOwnerId = default;
            Option<Account?> owner = default;
            Option<Application?> application = default;
            Option<Pack.SequenceTypeEnum?> sequenceType = default;
            Option<string?> title = default;
            Option<string?> description = default;
            Option<DateTime?> startDate = default;
            Option<DateTime?> endDate = default;
            Option<Pack.PackTypeEnum?> packType = default;
            Option<Asset?> image = default;
            Option<Asset?> background = default;
            Option<string?> imageURL = default;
            Option<List<GameLevel>?> gameLevels = default;
            Option<bool?> hasMoreItems = default;
            Option<long?> totalCount = default;
            Option<bool?> downloaded = default;
            Option<string?> authorOverride = default;
            Option<long?> packOrder = default;
            Option<bool?> inGame = default;
            Option<bool?> highest = default;
            Option<int?> notificationCount = default;
            Option<long?> points = default;
            Option<string?> ticketType = default;
            Option<long?> ticketCount = default;
            Option<string?> priceType = default;
            Option<int?> price = default;
            Option<bool?> allocateTickets = default;
            Option<string?> applicationTitle = default;
            Option<Dictionary<string, GameLevel>?> levelNumberMap = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "id":
                            id = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "active":
                            active = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "valid":
                            valid = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "newOwnerId":
                            newOwnerId = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "owner":
                            owner = new Option<Account?>(JsonSerializer.Deserialize<Account>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "application":
                            application = new Option<Application?>(JsonSerializer.Deserialize<Application>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "sequenceType":
                            string? sequenceTypeRawValue = utf8JsonReader.GetString();
                            if (sequenceTypeRawValue != null)
                                sequenceType = new Option<Pack.SequenceTypeEnum?>(Pack.SequenceTypeEnumFromStringOrDefault(sequenceTypeRawValue));
                            break;
                        case "title":
                            title = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "description":
                            description = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "startDate":
                            startDate = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "endDate":
                            endDate = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "packType":
                            string? packTypeRawValue = utf8JsonReader.GetString();
                            if (packTypeRawValue != null)
                                packType = new Option<Pack.PackTypeEnum?>(Pack.PackTypeEnumFromStringOrDefault(packTypeRawValue));
                            break;
                        case "image":
                            image = new Option<Asset?>(JsonSerializer.Deserialize<Asset>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "background":
                            background = new Option<Asset?>(JsonSerializer.Deserialize<Asset>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "imageURL":
                            imageURL = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "gameLevels":
                            gameLevels = new Option<List<GameLevel>?>(JsonSerializer.Deserialize<List<GameLevel>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "hasMoreItems":
                            hasMoreItems = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "totalCount":
                            totalCount = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "downloaded":
                            downloaded = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "authorOverride":
                            authorOverride = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "packOrder":
                            packOrder = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "inGame":
                            inGame = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "highest":
                            highest = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "notificationCount":
                            notificationCount = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "points":
                            points = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "ticketType":
                            ticketType = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "ticketCount":
                            ticketCount = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "priceType":
                            priceType = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "price":
                            price = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "allocateTickets":
                            allocateTickets = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "applicationTitle":
                            applicationTitle = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "levelNumberMap":
                            levelNumberMap = new Option<Dictionary<string, GameLevel>?>(JsonSerializer.Deserialize<Dictionary<string, GameLevel>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id), "Property is not nullable for class Pack.");

            if (active.IsSet && active.Value == null)
                throw new ArgumentNullException(nameof(active), "Property is not nullable for class Pack.");

            if (valid.IsSet && valid.Value == null)
                throw new ArgumentNullException(nameof(valid), "Property is not nullable for class Pack.");

            if (newOwnerId.IsSet && newOwnerId.Value == null)
                throw new ArgumentNullException(nameof(newOwnerId), "Property is not nullable for class Pack.");

            if (owner.IsSet && owner.Value == null)
                throw new ArgumentNullException(nameof(owner), "Property is not nullable for class Pack.");

            if (application.IsSet && application.Value == null)
                throw new ArgumentNullException(nameof(application), "Property is not nullable for class Pack.");

            if (sequenceType.IsSet && sequenceType.Value == null)
                throw new ArgumentNullException(nameof(sequenceType), "Property is not nullable for class Pack.");

            if (title.IsSet && title.Value == null)
                throw new ArgumentNullException(nameof(title), "Property is not nullable for class Pack.");

            if (description.IsSet && description.Value == null)
                throw new ArgumentNullException(nameof(description), "Property is not nullable for class Pack.");

            if (startDate.IsSet && startDate.Value == null)
                throw new ArgumentNullException(nameof(startDate), "Property is not nullable for class Pack.");

            if (endDate.IsSet && endDate.Value == null)
                throw new ArgumentNullException(nameof(endDate), "Property is not nullable for class Pack.");

            if (packType.IsSet && packType.Value == null)
                throw new ArgumentNullException(nameof(packType), "Property is not nullable for class Pack.");

            if (image.IsSet && image.Value == null)
                throw new ArgumentNullException(nameof(image), "Property is not nullable for class Pack.");

            if (background.IsSet && background.Value == null)
                throw new ArgumentNullException(nameof(background), "Property is not nullable for class Pack.");

            if (imageURL.IsSet && imageURL.Value == null)
                throw new ArgumentNullException(nameof(imageURL), "Property is not nullable for class Pack.");

            if (gameLevels.IsSet && gameLevels.Value == null)
                throw new ArgumentNullException(nameof(gameLevels), "Property is not nullable for class Pack.");

            if (hasMoreItems.IsSet && hasMoreItems.Value == null)
                throw new ArgumentNullException(nameof(hasMoreItems), "Property is not nullable for class Pack.");

            if (totalCount.IsSet && totalCount.Value == null)
                throw new ArgumentNullException(nameof(totalCount), "Property is not nullable for class Pack.");

            if (downloaded.IsSet && downloaded.Value == null)
                throw new ArgumentNullException(nameof(downloaded), "Property is not nullable for class Pack.");

            if (authorOverride.IsSet && authorOverride.Value == null)
                throw new ArgumentNullException(nameof(authorOverride), "Property is not nullable for class Pack.");

            if (packOrder.IsSet && packOrder.Value == null)
                throw new ArgumentNullException(nameof(packOrder), "Property is not nullable for class Pack.");

            if (inGame.IsSet && inGame.Value == null)
                throw new ArgumentNullException(nameof(inGame), "Property is not nullable for class Pack.");

            if (highest.IsSet && highest.Value == null)
                throw new ArgumentNullException(nameof(highest), "Property is not nullable for class Pack.");

            if (notificationCount.IsSet && notificationCount.Value == null)
                throw new ArgumentNullException(nameof(notificationCount), "Property is not nullable for class Pack.");

            if (points.IsSet && points.Value == null)
                throw new ArgumentNullException(nameof(points), "Property is not nullable for class Pack.");

            if (ticketType.IsSet && ticketType.Value == null)
                throw new ArgumentNullException(nameof(ticketType), "Property is not nullable for class Pack.");

            if (ticketCount.IsSet && ticketCount.Value == null)
                throw new ArgumentNullException(nameof(ticketCount), "Property is not nullable for class Pack.");

            if (priceType.IsSet && priceType.Value == null)
                throw new ArgumentNullException(nameof(priceType), "Property is not nullable for class Pack.");

            if (price.IsSet && price.Value == null)
                throw new ArgumentNullException(nameof(price), "Property is not nullable for class Pack.");

            if (allocateTickets.IsSet && allocateTickets.Value == null)
                throw new ArgumentNullException(nameof(allocateTickets), "Property is not nullable for class Pack.");

            if (applicationTitle.IsSet && applicationTitle.Value == null)
                throw new ArgumentNullException(nameof(applicationTitle), "Property is not nullable for class Pack.");

            if (levelNumberMap.IsSet && levelNumberMap.Value == null)
                throw new ArgumentNullException(nameof(levelNumberMap), "Property is not nullable for class Pack.");

            return new Pack(id, active, valid, newOwnerId, owner, application, sequenceType, title, description, startDate, endDate, packType, image, background, imageURL, gameLevels, hasMoreItems, totalCount, downloaded, authorOverride, packOrder, inGame, highest, notificationCount, points, ticketType, ticketCount, priceType, price, allocateTickets, applicationTitle, levelNumberMap);
        }

        /// <summary>
        /// Serializes a <see cref="Pack" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="pack"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, Pack pack, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, pack, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="Pack" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="pack"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, Pack pack, JsonSerializerOptions jsonSerializerOptions)
        {
            if (pack.OwnerOption.IsSet && pack.Owner == null)
                throw new ArgumentNullException(nameof(pack.Owner), "Property is required for class Pack.");

            if (pack.ApplicationOption.IsSet && pack.Application == null)
                throw new ArgumentNullException(nameof(pack.Application), "Property is required for class Pack.");

            if (pack.TitleOption.IsSet && pack.Title == null)
                throw new ArgumentNullException(nameof(pack.Title), "Property is required for class Pack.");

            if (pack.DescriptionOption.IsSet && pack.Description == null)
                throw new ArgumentNullException(nameof(pack.Description), "Property is required for class Pack.");

            if (pack.ImageOption.IsSet && pack.Image == null)
                throw new ArgumentNullException(nameof(pack.Image), "Property is required for class Pack.");

            if (pack.BackgroundOption.IsSet && pack.Background == null)
                throw new ArgumentNullException(nameof(pack.Background), "Property is required for class Pack.");

            if (pack.ImageURLOption.IsSet && pack.ImageURL == null)
                throw new ArgumentNullException(nameof(pack.ImageURL), "Property is required for class Pack.");

            if (pack.GameLevelsOption.IsSet && pack.GameLevels == null)
                throw new ArgumentNullException(nameof(pack.GameLevels), "Property is required for class Pack.");

            if (pack.AuthorOverrideOption.IsSet && pack.AuthorOverride == null)
                throw new ArgumentNullException(nameof(pack.AuthorOverride), "Property is required for class Pack.");

            if (pack.TicketTypeOption.IsSet && pack.TicketType == null)
                throw new ArgumentNullException(nameof(pack.TicketType), "Property is required for class Pack.");

            if (pack.PriceTypeOption.IsSet && pack.PriceType == null)
                throw new ArgumentNullException(nameof(pack.PriceType), "Property is required for class Pack.");

            if (pack.ApplicationTitleOption.IsSet && pack.ApplicationTitle == null)
                throw new ArgumentNullException(nameof(pack.ApplicationTitle), "Property is required for class Pack.");

            if (pack.LevelNumberMapOption.IsSet && pack.LevelNumberMap == null)
                throw new ArgumentNullException(nameof(pack.LevelNumberMap), "Property is required for class Pack.");

            if (pack.IdOption.IsSet)
                writer.WriteNumber("id", pack.IdOption.Value!.Value);

            if (pack.ActiveOption.IsSet)
                writer.WriteBoolean("active", pack.ActiveOption.Value!.Value);

            if (pack.ValidOption.IsSet)
                writer.WriteBoolean("valid", pack.ValidOption.Value!.Value);

            if (pack.NewOwnerIdOption.IsSet)
                writer.WriteNumber("newOwnerId", pack.NewOwnerIdOption.Value!.Value);

            if (pack.OwnerOption.IsSet)
            {
                writer.WritePropertyName("owner");
                JsonSerializer.Serialize(writer, pack.Owner, jsonSerializerOptions);
            }
            if (pack.ApplicationOption.IsSet)
            {
                writer.WritePropertyName("application");
                JsonSerializer.Serialize(writer, pack.Application, jsonSerializerOptions);
            }
            var sequenceTypeRawValue = Pack.SequenceTypeEnumToJsonValue(pack.SequenceTypeOption.Value!.Value);
            writer.WriteString("sequenceType", sequenceTypeRawValue);
            if (pack.TitleOption.IsSet)
                writer.WriteString("title", pack.Title);

            if (pack.DescriptionOption.IsSet)
                writer.WriteString("description", pack.Description);

            if (pack.StartDateOption.IsSet)
                writer.WriteString("startDate", pack.StartDateOption.Value!.Value.ToString(StartDateFormat));

            if (pack.EndDateOption.IsSet)
                writer.WriteString("endDate", pack.EndDateOption.Value!.Value.ToString(EndDateFormat));

            var packTypeRawValue = Pack.PackTypeEnumToJsonValue(pack.PackTypeOption.Value!.Value);
            writer.WriteString("packType", packTypeRawValue);
            if (pack.ImageOption.IsSet)
            {
                writer.WritePropertyName("image");
                JsonSerializer.Serialize(writer, pack.Image, jsonSerializerOptions);
            }
            if (pack.BackgroundOption.IsSet)
            {
                writer.WritePropertyName("background");
                JsonSerializer.Serialize(writer, pack.Background, jsonSerializerOptions);
            }
            if (pack.ImageURLOption.IsSet)
                writer.WriteString("imageURL", pack.ImageURL);

            if (pack.GameLevelsOption.IsSet)
            {
                writer.WritePropertyName("gameLevels");
                JsonSerializer.Serialize(writer, pack.GameLevels, jsonSerializerOptions);
            }
            if (pack.HasMoreItemsOption.IsSet)
                writer.WriteBoolean("hasMoreItems", pack.HasMoreItemsOption.Value!.Value);

            if (pack.TotalCountOption.IsSet)
                writer.WriteNumber("totalCount", pack.TotalCountOption.Value!.Value);

            if (pack.DownloadedOption.IsSet)
                writer.WriteBoolean("downloaded", pack.DownloadedOption.Value!.Value);

            if (pack.AuthorOverrideOption.IsSet)
                writer.WriteString("authorOverride", pack.AuthorOverride);

            if (pack.PackOrderOption.IsSet)
                writer.WriteNumber("packOrder", pack.PackOrderOption.Value!.Value);

            if (pack.InGameOption.IsSet)
                writer.WriteBoolean("inGame", pack.InGameOption.Value!.Value);

            if (pack.HighestOption.IsSet)
                writer.WriteBoolean("highest", pack.HighestOption.Value!.Value);

            if (pack.NotificationCountOption.IsSet)
                writer.WriteNumber("notificationCount", pack.NotificationCountOption.Value!.Value);

            if (pack.PointsOption.IsSet)
                writer.WriteNumber("points", pack.PointsOption.Value!.Value);

            if (pack.TicketTypeOption.IsSet)
                writer.WriteString("ticketType", pack.TicketType);

            if (pack.TicketCountOption.IsSet)
                writer.WriteNumber("ticketCount", pack.TicketCountOption.Value!.Value);

            if (pack.PriceTypeOption.IsSet)
                writer.WriteString("priceType", pack.PriceType);

            if (pack.PriceOption.IsSet)
                writer.WriteNumber("price", pack.PriceOption.Value!.Value);

            if (pack.AllocateTicketsOption.IsSet)
                writer.WriteBoolean("allocateTickets", pack.AllocateTicketsOption.Value!.Value);

            if (pack.ApplicationTitleOption.IsSet)
                writer.WriteString("applicationTitle", pack.ApplicationTitle);

            if (pack.LevelNumberMapOption.IsSet)
            {
                writer.WritePropertyName("levelNumberMap");
                JsonSerializer.Serialize(writer, pack.LevelNumberMap, jsonSerializerOptions);
            }
        }
    }
}
