// <auto-generated>
/*
 * Sirqul IoT Platform
 *
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Org.OpenAPITools.Client;

namespace Org.OpenAPITools.Model
{
    /// <summary>
    /// Connection
    /// </summary>
    public partial class Connection : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Connection" /> class.
        /// </summary>
        /// <param name="id">id</param>
        /// <param name="created">created</param>
        /// <param name="updated">updated</param>
        /// <param name="deleted">deleted</param>
        /// <param name="objectType">objectType</param>
        /// <param name="legacyId">legacyId</param>
        /// <param name="searchTags">searchTags</param>
        /// <param name="active">active</param>
        /// <param name="valid">valid</param>
        /// <param name="account">account</param>
        /// <param name="varConnection">varConnection</param>
        /// <param name="pendingConnection">pendingConnection</param>
        /// <param name="friend">friend</param>
        /// <param name="friendRequested">friendRequested</param>
        /// <param name="friendRequestPending">friendRequestPending</param>
        /// <param name="following">following</param>
        /// <param name="follower">follower</param>
        /// <param name="trusted">trusted</param>
        /// <param name="blocked">blocked</param>
        /// <param name="friendRequestDate">friendRequestDate</param>
        /// <param name="friendResponseDate">friendResponseDate</param>
        /// <param name="display">display</param>
        /// <param name="connectionViewedDate">connectionViewedDate</param>
        /// <param name="connectionType">connectionType</param>
        /// <param name="title">title</param>
        /// <param name="pendingConnectionId">pendingConnectionId</param>
        /// <param name="latitude">latitude</param>
        /// <param name="longitude">longitude</param>
        [JsonConstructor]
        public Connection(Option<long?> id = default, Option<DateTime?> created = default, Option<DateTime?> updated = default, Option<DateTime?> deleted = default, Option<string?> objectType = default, Option<string?> legacyId = default, Option<string?> searchTags = default, Option<bool?> active = default, Option<bool?> valid = default, Option<Account?> account = default, Option<Account?> varConnection = default, Option<ConnectedFriend?> pendingConnection = default, Option<bool?> friend = default, Option<bool?> friendRequested = default, Option<bool?> friendRequestPending = default, Option<bool?> following = default, Option<bool?> follower = default, Option<bool?> trusted = default, Option<bool?> blocked = default, Option<DateTime?> friendRequestDate = default, Option<DateTime?> friendResponseDate = default, Option<string?> display = default, Option<DateTime?> connectionViewedDate = default, Option<ConnectionTypeEnum?> connectionType = default, Option<string?> title = default, Option<long?> pendingConnectionId = default, Option<double?> latitude = default, Option<double?> longitude = default)
        {
            IdOption = id;
            CreatedOption = created;
            UpdatedOption = updated;
            DeletedOption = deleted;
            ObjectTypeOption = objectType;
            LegacyIdOption = legacyId;
            SearchTagsOption = searchTags;
            ActiveOption = active;
            ValidOption = valid;
            AccountOption = account;
            VarConnectionOption = varConnection;
            PendingConnectionOption = pendingConnection;
            FriendOption = friend;
            FriendRequestedOption = friendRequested;
            FriendRequestPendingOption = friendRequestPending;
            FollowingOption = following;
            FollowerOption = follower;
            TrustedOption = trusted;
            BlockedOption = blocked;
            FriendRequestDateOption = friendRequestDate;
            FriendResponseDateOption = friendResponseDate;
            DisplayOption = display;
            ConnectionViewedDateOption = connectionViewedDate;
            ConnectionTypeOption = connectionType;
            TitleOption = title;
            PendingConnectionIdOption = pendingConnectionId;
            LatitudeOption = latitude;
            LongitudeOption = longitude;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Defines ConnectionType
        /// </summary>
        public enum ConnectionTypeEnum
        {
            /// <summary>
            /// Enum PRIMARY for value: PRIMARY
            /// </summary>
            PRIMARY = 1,

            /// <summary>
            /// Enum SECONDARY for value: SECONDARY
            /// </summary>
            SECONDARY = 2,

            /// <summary>
            /// Enum DEPENDENT for value: DEPENDENT
            /// </summary>
            DEPENDENT = 3,

            /// <summary>
            /// Enum ACQUAINTANCE for value: ACQUAINTANCE
            /// </summary>
            ACQUAINTANCE = 4
        }

        /// <summary>
        /// Returns a <see cref="ConnectionTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static ConnectionTypeEnum ConnectionTypeEnumFromString(string value)
        {
            if (value.Equals("PRIMARY"))
                return ConnectionTypeEnum.PRIMARY;

            if (value.Equals("SECONDARY"))
                return ConnectionTypeEnum.SECONDARY;

            if (value.Equals("DEPENDENT"))
                return ConnectionTypeEnum.DEPENDENT;

            if (value.Equals("ACQUAINTANCE"))
                return ConnectionTypeEnum.ACQUAINTANCE;

            throw new NotImplementedException($"Could not convert value to type ConnectionTypeEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="ConnectionTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static ConnectionTypeEnum? ConnectionTypeEnumFromStringOrDefault(string value)
        {
            if (value.Equals("PRIMARY"))
                return ConnectionTypeEnum.PRIMARY;

            if (value.Equals("SECONDARY"))
                return ConnectionTypeEnum.SECONDARY;

            if (value.Equals("DEPENDENT"))
                return ConnectionTypeEnum.DEPENDENT;

            if (value.Equals("ACQUAINTANCE"))
                return ConnectionTypeEnum.ACQUAINTANCE;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="ConnectionTypeEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string ConnectionTypeEnumToJsonValue(ConnectionTypeEnum? value)
        {
            if (value == ConnectionTypeEnum.PRIMARY)
                return "PRIMARY";

            if (value == ConnectionTypeEnum.SECONDARY)
                return "SECONDARY";

            if (value == ConnectionTypeEnum.DEPENDENT)
                return "DEPENDENT";

            if (value == ConnectionTypeEnum.ACQUAINTANCE)
                return "ACQUAINTANCE";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of ConnectionType
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<ConnectionTypeEnum?> ConnectionTypeOption { get; private set; }

        /// <summary>
        /// Gets or Sets ConnectionType
        /// </summary>
        [JsonPropertyName("connectionType")]
        public ConnectionTypeEnum? ConnectionType { get { return this.ConnectionTypeOption; } set { this.ConnectionTypeOption = new(value); } }

        /// <summary>
        /// Used to track the state of Id
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> IdOption { get; private set; }

        /// <summary>
        /// Gets or Sets Id
        /// </summary>
        [JsonPropertyName("id")]
        public long? Id { get { return this.IdOption; } set { this.IdOption = new(value); } }

        /// <summary>
        /// Used to track the state of Created
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> CreatedOption { get; private set; }

        /// <summary>
        /// Gets or Sets Created
        /// </summary>
        [JsonPropertyName("created")]
        public DateTime? Created { get { return this.CreatedOption; } set { this.CreatedOption = new(value); } }

        /// <summary>
        /// Used to track the state of Updated
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> UpdatedOption { get; private set; }

        /// <summary>
        /// Gets or Sets Updated
        /// </summary>
        [JsonPropertyName("updated")]
        public DateTime? Updated { get { return this.UpdatedOption; } set { this.UpdatedOption = new(value); } }

        /// <summary>
        /// Used to track the state of Deleted
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> DeletedOption { get; private set; }

        /// <summary>
        /// Gets or Sets Deleted
        /// </summary>
        [JsonPropertyName("deleted")]
        public DateTime? Deleted { get { return this.DeletedOption; } set { this.DeletedOption = new(value); } }

        /// <summary>
        /// Used to track the state of ObjectType
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ObjectTypeOption { get; private set; }

        /// <summary>
        /// Gets or Sets ObjectType
        /// </summary>
        [JsonPropertyName("objectType")]
        public string? ObjectType { get { return this.ObjectTypeOption; } set { this.ObjectTypeOption = new(value); } }

        /// <summary>
        /// Used to track the state of LegacyId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> LegacyIdOption { get; private set; }

        /// <summary>
        /// Gets or Sets LegacyId
        /// </summary>
        [JsonPropertyName("legacyId")]
        public string? LegacyId { get { return this.LegacyIdOption; } set { this.LegacyIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of SearchTags
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> SearchTagsOption { get; private set; }

        /// <summary>
        /// Gets or Sets SearchTags
        /// </summary>
        [JsonPropertyName("searchTags")]
        public string? SearchTags { get { return this.SearchTagsOption; } set { this.SearchTagsOption = new(value); } }

        /// <summary>
        /// Used to track the state of Active
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> ActiveOption { get; private set; }

        /// <summary>
        /// Gets or Sets Active
        /// </summary>
        [JsonPropertyName("active")]
        public bool? Active { get { return this.ActiveOption; } set { this.ActiveOption = new(value); } }

        /// <summary>
        /// Used to track the state of Valid
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> ValidOption { get; private set; }

        /// <summary>
        /// Gets or Sets Valid
        /// </summary>
        [JsonPropertyName("valid")]
        public bool? Valid { get { return this.ValidOption; } set { this.ValidOption = new(value); } }

        /// <summary>
        /// Used to track the state of Account
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Account?> AccountOption { get; private set; }

        /// <summary>
        /// Gets or Sets Account
        /// </summary>
        [JsonPropertyName("account")]
        public Account? Account { get { return this.AccountOption; } set { this.AccountOption = new(value); } }

        /// <summary>
        /// Used to track the state of VarConnection
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Account?> VarConnectionOption { get; private set; }

        /// <summary>
        /// Gets or Sets VarConnection
        /// </summary>
        [JsonPropertyName("connection")]
        public Account? VarConnection { get { return this.VarConnectionOption; } set { this.VarConnectionOption = new(value); } }

        /// <summary>
        /// Used to track the state of PendingConnection
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<ConnectedFriend?> PendingConnectionOption { get; private set; }

        /// <summary>
        /// Gets or Sets PendingConnection
        /// </summary>
        [JsonPropertyName("pendingConnection")]
        public ConnectedFriend? PendingConnection { get { return this.PendingConnectionOption; } set { this.PendingConnectionOption = new(value); } }

        /// <summary>
        /// Used to track the state of Friend
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> FriendOption { get; private set; }

        /// <summary>
        /// Gets or Sets Friend
        /// </summary>
        [JsonPropertyName("friend")]
        public bool? Friend { get { return this.FriendOption; } set { this.FriendOption = new(value); } }

        /// <summary>
        /// Used to track the state of FriendRequested
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> FriendRequestedOption { get; private set; }

        /// <summary>
        /// Gets or Sets FriendRequested
        /// </summary>
        [JsonPropertyName("friendRequested")]
        public bool? FriendRequested { get { return this.FriendRequestedOption; } set { this.FriendRequestedOption = new(value); } }

        /// <summary>
        /// Used to track the state of FriendRequestPending
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> FriendRequestPendingOption { get; private set; }

        /// <summary>
        /// Gets or Sets FriendRequestPending
        /// </summary>
        [JsonPropertyName("friendRequestPending")]
        public bool? FriendRequestPending { get { return this.FriendRequestPendingOption; } set { this.FriendRequestPendingOption = new(value); } }

        /// <summary>
        /// Used to track the state of Following
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> FollowingOption { get; private set; }

        /// <summary>
        /// Gets or Sets Following
        /// </summary>
        [JsonPropertyName("following")]
        public bool? Following { get { return this.FollowingOption; } set { this.FollowingOption = new(value); } }

        /// <summary>
        /// Used to track the state of Follower
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> FollowerOption { get; private set; }

        /// <summary>
        /// Gets or Sets Follower
        /// </summary>
        [JsonPropertyName("follower")]
        public bool? Follower { get { return this.FollowerOption; } set { this.FollowerOption = new(value); } }

        /// <summary>
        /// Used to track the state of Trusted
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> TrustedOption { get; private set; }

        /// <summary>
        /// Gets or Sets Trusted
        /// </summary>
        [JsonPropertyName("trusted")]
        public bool? Trusted { get { return this.TrustedOption; } set { this.TrustedOption = new(value); } }

        /// <summary>
        /// Used to track the state of Blocked
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> BlockedOption { get; private set; }

        /// <summary>
        /// Gets or Sets Blocked
        /// </summary>
        [JsonPropertyName("blocked")]
        public bool? Blocked { get { return this.BlockedOption; } set { this.BlockedOption = new(value); } }

        /// <summary>
        /// Used to track the state of FriendRequestDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> FriendRequestDateOption { get; private set; }

        /// <summary>
        /// Gets or Sets FriendRequestDate
        /// </summary>
        [JsonPropertyName("friendRequestDate")]
        public DateTime? FriendRequestDate { get { return this.FriendRequestDateOption; } set { this.FriendRequestDateOption = new(value); } }

        /// <summary>
        /// Used to track the state of FriendResponseDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> FriendResponseDateOption { get; private set; }

        /// <summary>
        /// Gets or Sets FriendResponseDate
        /// </summary>
        [JsonPropertyName("friendResponseDate")]
        public DateTime? FriendResponseDate { get { return this.FriendResponseDateOption; } set { this.FriendResponseDateOption = new(value); } }

        /// <summary>
        /// Used to track the state of Display
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> DisplayOption { get; private set; }

        /// <summary>
        /// Gets or Sets Display
        /// </summary>
        [JsonPropertyName("display")]
        public string? Display { get { return this.DisplayOption; } set { this.DisplayOption = new(value); } }

        /// <summary>
        /// Used to track the state of ConnectionViewedDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> ConnectionViewedDateOption { get; private set; }

        /// <summary>
        /// Gets or Sets ConnectionViewedDate
        /// </summary>
        [JsonPropertyName("connectionViewedDate")]
        public DateTime? ConnectionViewedDate { get { return this.ConnectionViewedDateOption; } set { this.ConnectionViewedDateOption = new(value); } }

        /// <summary>
        /// Used to track the state of Title
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> TitleOption { get; private set; }

        /// <summary>
        /// Gets or Sets Title
        /// </summary>
        [JsonPropertyName("title")]
        public string? Title { get { return this.TitleOption; } set { this.TitleOption = new(value); } }

        /// <summary>
        /// Used to track the state of PendingConnectionId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> PendingConnectionIdOption { get; private set; }

        /// <summary>
        /// Gets or Sets PendingConnectionId
        /// </summary>
        [JsonPropertyName("pendingConnection_id")]
        public long? PendingConnectionId { get { return this.PendingConnectionIdOption; } set { this.PendingConnectionIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of Latitude
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<double?> LatitudeOption { get; private set; }

        /// <summary>
        /// Gets or Sets Latitude
        /// </summary>
        [JsonPropertyName("latitude")]
        public double? Latitude { get { return this.LatitudeOption; } set { this.LatitudeOption = new(value); } }

        /// <summary>
        /// Used to track the state of Longitude
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<double?> LongitudeOption { get; private set; }

        /// <summary>
        /// Gets or Sets Longitude
        /// </summary>
        [JsonPropertyName("longitude")]
        public double? Longitude { get { return this.LongitudeOption; } set { this.LongitudeOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Connection {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Created: ").Append(Created).Append("\n");
            sb.Append("  Updated: ").Append(Updated).Append("\n");
            sb.Append("  Deleted: ").Append(Deleted).Append("\n");
            sb.Append("  ObjectType: ").Append(ObjectType).Append("\n");
            sb.Append("  LegacyId: ").Append(LegacyId).Append("\n");
            sb.Append("  SearchTags: ").Append(SearchTags).Append("\n");
            sb.Append("  Active: ").Append(Active).Append("\n");
            sb.Append("  Valid: ").Append(Valid).Append("\n");
            sb.Append("  Account: ").Append(Account).Append("\n");
            sb.Append("  VarConnection: ").Append(VarConnection).Append("\n");
            sb.Append("  PendingConnection: ").Append(PendingConnection).Append("\n");
            sb.Append("  Friend: ").Append(Friend).Append("\n");
            sb.Append("  FriendRequested: ").Append(FriendRequested).Append("\n");
            sb.Append("  FriendRequestPending: ").Append(FriendRequestPending).Append("\n");
            sb.Append("  Following: ").Append(Following).Append("\n");
            sb.Append("  Follower: ").Append(Follower).Append("\n");
            sb.Append("  Trusted: ").Append(Trusted).Append("\n");
            sb.Append("  Blocked: ").Append(Blocked).Append("\n");
            sb.Append("  FriendRequestDate: ").Append(FriendRequestDate).Append("\n");
            sb.Append("  FriendResponseDate: ").Append(FriendResponseDate).Append("\n");
            sb.Append("  Display: ").Append(Display).Append("\n");
            sb.Append("  ConnectionViewedDate: ").Append(ConnectionViewedDate).Append("\n");
            sb.Append("  ConnectionType: ").Append(ConnectionType).Append("\n");
            sb.Append("  Title: ").Append(Title).Append("\n");
            sb.Append("  PendingConnectionId: ").Append(PendingConnectionId).Append("\n");
            sb.Append("  Latitude: ").Append(Latitude).Append("\n");
            sb.Append("  Longitude: ").Append(Longitude).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="Connection" />
    /// </summary>
    public class ConnectionJsonConverter : JsonConverter<Connection>
    {
        /// <summary>
        /// The format to use to serialize Created
        /// </summary>
        public static string CreatedFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize Updated
        /// </summary>
        public static string UpdatedFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize Deleted
        /// </summary>
        public static string DeletedFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize FriendRequestDate
        /// </summary>
        public static string FriendRequestDateFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize FriendResponseDate
        /// </summary>
        public static string FriendResponseDateFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize ConnectionViewedDate
        /// </summary>
        public static string ConnectionViewedDateFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="Connection" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override Connection Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<long?> id = default;
            Option<DateTime?> created = default;
            Option<DateTime?> updated = default;
            Option<DateTime?> deleted = default;
            Option<string?> objectType = default;
            Option<string?> legacyId = default;
            Option<string?> searchTags = default;
            Option<bool?> active = default;
            Option<bool?> valid = default;
            Option<Account?> account = default;
            Option<Account?> varConnection = default;
            Option<ConnectedFriend?> pendingConnection = default;
            Option<bool?> friend = default;
            Option<bool?> friendRequested = default;
            Option<bool?> friendRequestPending = default;
            Option<bool?> following = default;
            Option<bool?> follower = default;
            Option<bool?> trusted = default;
            Option<bool?> blocked = default;
            Option<DateTime?> friendRequestDate = default;
            Option<DateTime?> friendResponseDate = default;
            Option<string?> display = default;
            Option<DateTime?> connectionViewedDate = default;
            Option<Connection.ConnectionTypeEnum?> connectionType = default;
            Option<string?> title = default;
            Option<long?> pendingConnectionId = default;
            Option<double?> latitude = default;
            Option<double?> longitude = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "id":
                            id = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "created":
                            created = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "updated":
                            updated = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "deleted":
                            deleted = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "objectType":
                            objectType = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "legacyId":
                            legacyId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "searchTags":
                            searchTags = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "active":
                            active = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "valid":
                            valid = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "account":
                            account = new Option<Account?>(JsonSerializer.Deserialize<Account>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "connection":
                            varConnection = new Option<Account?>(JsonSerializer.Deserialize<Account>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "pendingConnection":
                            pendingConnection = new Option<ConnectedFriend?>(JsonSerializer.Deserialize<ConnectedFriend>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "friend":
                            friend = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "friendRequested":
                            friendRequested = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "friendRequestPending":
                            friendRequestPending = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "following":
                            following = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "follower":
                            follower = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "trusted":
                            trusted = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "blocked":
                            blocked = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "friendRequestDate":
                            friendRequestDate = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "friendResponseDate":
                            friendResponseDate = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "display":
                            display = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "connectionViewedDate":
                            connectionViewedDate = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "connectionType":
                            string? connectionTypeRawValue = utf8JsonReader.GetString();
                            if (connectionTypeRawValue != null)
                                connectionType = new Option<Connection.ConnectionTypeEnum?>(Connection.ConnectionTypeEnumFromStringOrDefault(connectionTypeRawValue));
                            break;
                        case "title":
                            title = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "pendingConnection_id":
                            pendingConnectionId = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "latitude":
                            latitude = new Option<double?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (double?)null : utf8JsonReader.GetDouble());
                            break;
                        case "longitude":
                            longitude = new Option<double?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (double?)null : utf8JsonReader.GetDouble());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id), "Property is not nullable for class Connection.");

            if (created.IsSet && created.Value == null)
                throw new ArgumentNullException(nameof(created), "Property is not nullable for class Connection.");

            if (updated.IsSet && updated.Value == null)
                throw new ArgumentNullException(nameof(updated), "Property is not nullable for class Connection.");

            if (deleted.IsSet && deleted.Value == null)
                throw new ArgumentNullException(nameof(deleted), "Property is not nullable for class Connection.");

            if (objectType.IsSet && objectType.Value == null)
                throw new ArgumentNullException(nameof(objectType), "Property is not nullable for class Connection.");

            if (legacyId.IsSet && legacyId.Value == null)
                throw new ArgumentNullException(nameof(legacyId), "Property is not nullable for class Connection.");

            if (searchTags.IsSet && searchTags.Value == null)
                throw new ArgumentNullException(nameof(searchTags), "Property is not nullable for class Connection.");

            if (active.IsSet && active.Value == null)
                throw new ArgumentNullException(nameof(active), "Property is not nullable for class Connection.");

            if (valid.IsSet && valid.Value == null)
                throw new ArgumentNullException(nameof(valid), "Property is not nullable for class Connection.");

            if (account.IsSet && account.Value == null)
                throw new ArgumentNullException(nameof(account), "Property is not nullable for class Connection.");

            if (varConnection.IsSet && varConnection.Value == null)
                throw new ArgumentNullException(nameof(varConnection), "Property is not nullable for class Connection.");

            if (pendingConnection.IsSet && pendingConnection.Value == null)
                throw new ArgumentNullException(nameof(pendingConnection), "Property is not nullable for class Connection.");

            if (friend.IsSet && friend.Value == null)
                throw new ArgumentNullException(nameof(friend), "Property is not nullable for class Connection.");

            if (friendRequested.IsSet && friendRequested.Value == null)
                throw new ArgumentNullException(nameof(friendRequested), "Property is not nullable for class Connection.");

            if (friendRequestPending.IsSet && friendRequestPending.Value == null)
                throw new ArgumentNullException(nameof(friendRequestPending), "Property is not nullable for class Connection.");

            if (following.IsSet && following.Value == null)
                throw new ArgumentNullException(nameof(following), "Property is not nullable for class Connection.");

            if (follower.IsSet && follower.Value == null)
                throw new ArgumentNullException(nameof(follower), "Property is not nullable for class Connection.");

            if (trusted.IsSet && trusted.Value == null)
                throw new ArgumentNullException(nameof(trusted), "Property is not nullable for class Connection.");

            if (blocked.IsSet && blocked.Value == null)
                throw new ArgumentNullException(nameof(blocked), "Property is not nullable for class Connection.");

            if (friendRequestDate.IsSet && friendRequestDate.Value == null)
                throw new ArgumentNullException(nameof(friendRequestDate), "Property is not nullable for class Connection.");

            if (friendResponseDate.IsSet && friendResponseDate.Value == null)
                throw new ArgumentNullException(nameof(friendResponseDate), "Property is not nullable for class Connection.");

            if (display.IsSet && display.Value == null)
                throw new ArgumentNullException(nameof(display), "Property is not nullable for class Connection.");

            if (connectionViewedDate.IsSet && connectionViewedDate.Value == null)
                throw new ArgumentNullException(nameof(connectionViewedDate), "Property is not nullable for class Connection.");

            if (connectionType.IsSet && connectionType.Value == null)
                throw new ArgumentNullException(nameof(connectionType), "Property is not nullable for class Connection.");

            if (title.IsSet && title.Value == null)
                throw new ArgumentNullException(nameof(title), "Property is not nullable for class Connection.");

            if (pendingConnectionId.IsSet && pendingConnectionId.Value == null)
                throw new ArgumentNullException(nameof(pendingConnectionId), "Property is not nullable for class Connection.");

            if (latitude.IsSet && latitude.Value == null)
                throw new ArgumentNullException(nameof(latitude), "Property is not nullable for class Connection.");

            if (longitude.IsSet && longitude.Value == null)
                throw new ArgumentNullException(nameof(longitude), "Property is not nullable for class Connection.");

            return new Connection(id, created, updated, deleted, objectType, legacyId, searchTags, active, valid, account, varConnection, pendingConnection, friend, friendRequested, friendRequestPending, following, follower, trusted, blocked, friendRequestDate, friendResponseDate, display, connectionViewedDate, connectionType, title, pendingConnectionId, latitude, longitude);
        }

        /// <summary>
        /// Serializes a <see cref="Connection" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="connection"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, Connection connection, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, connection, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="Connection" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="connection"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, Connection connection, JsonSerializerOptions jsonSerializerOptions)
        {
            if (connection.ObjectTypeOption.IsSet && connection.ObjectType == null)
                throw new ArgumentNullException(nameof(connection.ObjectType), "Property is required for class Connection.");

            if (connection.LegacyIdOption.IsSet && connection.LegacyId == null)
                throw new ArgumentNullException(nameof(connection.LegacyId), "Property is required for class Connection.");

            if (connection.SearchTagsOption.IsSet && connection.SearchTags == null)
                throw new ArgumentNullException(nameof(connection.SearchTags), "Property is required for class Connection.");

            if (connection.AccountOption.IsSet && connection.Account == null)
                throw new ArgumentNullException(nameof(connection.Account), "Property is required for class Connection.");

            if (connection.VarConnectionOption.IsSet && connection.VarConnection == null)
                throw new ArgumentNullException(nameof(connection.VarConnection), "Property is required for class Connection.");

            if (connection.PendingConnectionOption.IsSet && connection.PendingConnection == null)
                throw new ArgumentNullException(nameof(connection.PendingConnection), "Property is required for class Connection.");

            if (connection.DisplayOption.IsSet && connection.Display == null)
                throw new ArgumentNullException(nameof(connection.Display), "Property is required for class Connection.");

            if (connection.TitleOption.IsSet && connection.Title == null)
                throw new ArgumentNullException(nameof(connection.Title), "Property is required for class Connection.");

            if (connection.IdOption.IsSet)
                writer.WriteNumber("id", connection.IdOption.Value!.Value);

            if (connection.CreatedOption.IsSet)
                writer.WriteString("created", connection.CreatedOption.Value!.Value.ToString(CreatedFormat));

            if (connection.UpdatedOption.IsSet)
                writer.WriteString("updated", connection.UpdatedOption.Value!.Value.ToString(UpdatedFormat));

            if (connection.DeletedOption.IsSet)
                writer.WriteString("deleted", connection.DeletedOption.Value!.Value.ToString(DeletedFormat));

            if (connection.ObjectTypeOption.IsSet)
                writer.WriteString("objectType", connection.ObjectType);

            if (connection.LegacyIdOption.IsSet)
                writer.WriteString("legacyId", connection.LegacyId);

            if (connection.SearchTagsOption.IsSet)
                writer.WriteString("searchTags", connection.SearchTags);

            if (connection.ActiveOption.IsSet)
                writer.WriteBoolean("active", connection.ActiveOption.Value!.Value);

            if (connection.ValidOption.IsSet)
                writer.WriteBoolean("valid", connection.ValidOption.Value!.Value);

            if (connection.AccountOption.IsSet)
            {
                writer.WritePropertyName("account");
                JsonSerializer.Serialize(writer, connection.Account, jsonSerializerOptions);
            }
            if (connection.VarConnectionOption.IsSet)
            {
                writer.WritePropertyName("connection");
                JsonSerializer.Serialize(writer, connection.VarConnection, jsonSerializerOptions);
            }
            if (connection.PendingConnectionOption.IsSet)
            {
                writer.WritePropertyName("pendingConnection");
                JsonSerializer.Serialize(writer, connection.PendingConnection, jsonSerializerOptions);
            }
            if (connection.FriendOption.IsSet)
                writer.WriteBoolean("friend", connection.FriendOption.Value!.Value);

            if (connection.FriendRequestedOption.IsSet)
                writer.WriteBoolean("friendRequested", connection.FriendRequestedOption.Value!.Value);

            if (connection.FriendRequestPendingOption.IsSet)
                writer.WriteBoolean("friendRequestPending", connection.FriendRequestPendingOption.Value!.Value);

            if (connection.FollowingOption.IsSet)
                writer.WriteBoolean("following", connection.FollowingOption.Value!.Value);

            if (connection.FollowerOption.IsSet)
                writer.WriteBoolean("follower", connection.FollowerOption.Value!.Value);

            if (connection.TrustedOption.IsSet)
                writer.WriteBoolean("trusted", connection.TrustedOption.Value!.Value);

            if (connection.BlockedOption.IsSet)
                writer.WriteBoolean("blocked", connection.BlockedOption.Value!.Value);

            if (connection.FriendRequestDateOption.IsSet)
                writer.WriteString("friendRequestDate", connection.FriendRequestDateOption.Value!.Value.ToString(FriendRequestDateFormat));

            if (connection.FriendResponseDateOption.IsSet)
                writer.WriteString("friendResponseDate", connection.FriendResponseDateOption.Value!.Value.ToString(FriendResponseDateFormat));

            if (connection.DisplayOption.IsSet)
                writer.WriteString("display", connection.Display);

            if (connection.ConnectionViewedDateOption.IsSet)
                writer.WriteString("connectionViewedDate", connection.ConnectionViewedDateOption.Value!.Value.ToString(ConnectionViewedDateFormat));

            var connectionTypeRawValue = Connection.ConnectionTypeEnumToJsonValue(connection.ConnectionTypeOption.Value!.Value);
            writer.WriteString("connectionType", connectionTypeRawValue);
            if (connection.TitleOption.IsSet)
                writer.WriteString("title", connection.Title);

            if (connection.PendingConnectionIdOption.IsSet)
                writer.WriteNumber("pendingConnection_id", connection.PendingConnectionIdOption.Value!.Value);

            if (connection.LatitudeOption.IsSet)
                writer.WriteNumber("latitude", connection.LatitudeOption.Value!.Value);

            if (connection.LongitudeOption.IsSet)
                writer.WriteNumber("longitude", connection.LongitudeOption.Value!.Value);
        }
    }
}
