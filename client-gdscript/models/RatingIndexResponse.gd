extends Resource
class_name RatingIndexResponse

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, Â© Public Domain, 2022

# RatingIndexResponse Model


# Required: False
# isArray: false
@export var ratingIndexId: float:
	set(value):
		__ratingIndexId__was__set = true
		ratingIndexId = value
var __ratingIndexId__was__set := false

# Required: False
# isArray: false
@export var ratingCount: float:
	set(value):
		__ratingCount__was__set = true
		ratingCount = value
var __ratingCount__was__set := false

# Required: False
# isArray: false
@export var ratingAverage: float:
	set(value):
		__ratingAverage__was__set = true
		ratingAverage = value
var __ratingAverage__was__set := false

# Required: False
# isArray: false
@export var value: float:
	set(value):
		__value__was__set = true
		value = value
var __value__was__set := false

# Required: False
# isArray: false
@export var display: String = "":
	set(value):
		__display__was__set = true
		display = value
var __display__was__set := false

# Required: False
# isArray: false
# Allowed values: "LOCATABLE", "RESERVABLE", "PERMISSIONABLE", "NOTABLE", "ASSETABLE", "LIKABLE", "FLAGABLE", "FAVORITABLE", "RATABLE", "ALBUM", "COLLECTION", "APPLICATION", "APPLICATION_SETTING", "APPLICATION_CERT", "APPLICATION_PLACEMENT", "ACCOUNT", "ACCOUNT_SETTING", "GAME_LEVEL", "PACK", "MISSION", "TOURNAMENT", "ASSET", "ALBUM_CONTEST", "THEME_DESCRIPTOR", "OFFER", "OFFER_LOCATION", "EVENT", "RETAILER", "RETAILER_LOCATION", "NOTE", "CREATIVE", "FAVORITE", "LIKE", "RATING", "ANALYTIC", "THIRD_PARTY_CREDENTIAL", "THIRD_PARTY_NETWORK", "REGION"
@export var ratableType: String = "":
	set(value):
		if str(value) != "" and not (str(value) in __ratableType__allowable__values):
			push_error("RatingIndexResponse: tried to set property `ratableType` to a value that is not allowed." +
				"  Allowed values: `LOCATABLE`, `RESERVABLE`, `PERMISSIONABLE`, `NOTABLE`, `ASSETABLE`, `LIKABLE`, `FLAGABLE`, `FAVORITABLE`, `RATABLE`, `ALBUM`, `COLLECTION`, `APPLICATION`, `APPLICATION_SETTING`, `APPLICATION_CERT`, `APPLICATION_PLACEMENT`, `ACCOUNT`, `ACCOUNT_SETTING`, `GAME_LEVEL`, `PACK`, `MISSION`, `TOURNAMENT`, `ASSET`, `ALBUM_CONTEST`, `THEME_DESCRIPTOR`, `OFFER`, `OFFER_LOCATION`, `EVENT`, `RETAILER`, `RETAILER_LOCATION`, `NOTE`, `CREATIVE`, `FAVORITE`, `LIKE`, `RATING`, `ANALYTIC`, `THIRD_PARTY_CREDENTIAL`, `THIRD_PARTY_NETWORK`, `REGION`")
			return
		__ratableType__was__set = true
		ratableType = value
var __ratableType__was__set := false
var __ratableType__allowable__values := ["LOCATABLE", "RESERVABLE", "PERMISSIONABLE", "NOTABLE", "ASSETABLE", "LIKABLE", "FLAGABLE", "FAVORITABLE", "RATABLE", "ALBUM", "COLLECTION", "APPLICATION", "APPLICATION_SETTING", "APPLICATION_CERT", "APPLICATION_PLACEMENT", "ACCOUNT", "ACCOUNT_SETTING", "GAME_LEVEL", "PACK", "MISSION", "TOURNAMENT", "ASSET", "ALBUM_CONTEST", "THEME_DESCRIPTOR", "OFFER", "OFFER_LOCATION", "EVENT", "RETAILER", "RETAILER_LOCATION", "NOTE", "CREATIVE", "FAVORITE", "LIKE", "RATING", "ANALYTIC", "THIRD_PARTY_CREDENTIAL", "THIRD_PARTY_NETWORK", "REGION"]

# Required: False
# isArray: false
@export var ratableId: float:
	set(value):
		__ratableId__was__set = true
		ratableId = value
var __ratableId__was__set := false

# Required: False
# isArray: false
@export var category: CategoryResponse:
	set(value):
		__category__was__set = true
		category = value
var __category__was__set := false

# Required: False
# isArray: false
@export var ratable: Object:
	set(value):
		__ratable__was__set = true
		ratable = value
var __ratable__was__set := false

# Required: False
# isArray: false
@export var secondaryType: String = "":
	set(value):
		__secondaryType__was__set = true
		secondaryType = value
var __secondaryType__was__set := false


func bzz_collect_missing_properties() -> Array:
	var bzz_missing_properties := Array()
	return bzz_missing_properties


func bzz_normalize() -> Dictionary:
	var bzz_dictionary := Dictionary()
	if self.__ratingIndexId__was__set:
		bzz_dictionary["ratingIndexId"] = self.ratingIndexId
	if self.__ratingCount__was__set:
		bzz_dictionary["ratingCount"] = self.ratingCount
	if self.__ratingAverage__was__set:
		bzz_dictionary["ratingAverage"] = self.ratingAverage
	if self.__value__was__set:
		bzz_dictionary["value"] = self.value
	if self.__display__was__set:
		bzz_dictionary["display"] = self.display
	if self.__ratableType__was__set:
		bzz_dictionary["ratableType"] = self.ratableType
	if self.__ratableId__was__set:
		bzz_dictionary["ratableId"] = self.ratableId
	if self.__category__was__set:
		bzz_dictionary["category"] = self.category
	if self.__ratable__was__set:
		bzz_dictionary["ratable"] = self.ratable
	if self.__secondaryType__was__set:
		bzz_dictionary["secondaryType"] = self.secondaryType
	return bzz_dictionary


# Won't work for JSON+LD
static func bzz_denormalize_single(from_dict: Dictionary):
	var me := new()
	if from_dict.has("ratingIndexId"):
		me.ratingIndexId = from_dict["ratingIndexId"]
	if from_dict.has("ratingCount"):
		me.ratingCount = from_dict["ratingCount"]
	if from_dict.has("ratingAverage"):
		me.ratingAverage = from_dict["ratingAverage"]
	if from_dict.has("value"):
		me.value = from_dict["value"]
	if from_dict.has("display"):
		me.display = from_dict["display"]
	if from_dict.has("ratableType"):
		me.ratableType = from_dict["ratableType"]
	if from_dict.has("ratableId"):
		me.ratableId = from_dict["ratableId"]
	if from_dict.has("category"):
		me.category = CategoryResponse.bzz_denormalize_single(from_dict["category"])
	if from_dict.has("ratable"):
		me.ratable = from_dict["ratable"]
	if from_dict.has("secondaryType"):
		me.secondaryType = from_dict["secondaryType"]
	return me


# Won't work for JSON+LD
static func bzz_denormalize_multiple(from_array: Array):
	var mes := Array()
	for element in from_array:
		if element is Array:
			mes.append(bzz_denormalize_multiple(element))
		elif element is Dictionary:
			# TODO: perhaps check first if it looks like a match or an intermediate container
			mes.append(bzz_denormalize_single(element))
		else:
			mes.append(element)
	return mes

