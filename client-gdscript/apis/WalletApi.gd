extends ApiBee
class_name WalletApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API WalletApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "WalletApi"


# Operation createOfferTransaction → POST /api/{version}/wallet/create
# Create Wallet Offers
#
# Adds offers to the wallet
func create_offer_transaction(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# offerId: float   Eg: 789
	# The id of the offer being added (offerId or offeLocationId required)
	offerId = null,
	# offerLocationId: float   Eg: 789
	# The id of the offer location being added (offerId or offeLocationId required)
	offerLocationId = null,
	# offerCart: String = ""   Eg: offerCart_example
	# A JSON list of offers to purchase. ```json [   {     \"offerId\": 123,     \"offerLocationId\": 234,     \"quantity\": 2   },   {     \"offerId\": 456,     \"offerLocationId\": 567,     \"quantity\": 1   } ] ``` 
	offerCart = "",
	# promoCode: String = ""   Eg: promoCode_example
	# The promoCode
	promoCode = "",
	# currencyType: String = "CASH"   Eg: currencyType_example
	# Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets
	currencyType = "CASH",
	# usePoints: bool   Eg: true
	# Sets the currencyType to POINTS
	usePoints = null,
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# appKey: String = ""   Eg: appKey_example
	# The application requesting the purchase, required when currencyType is TICKETS
	appKey = "",
	# status: int   Eg: 56
	# Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)
	status = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/wallet/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["offerId"] = offerId
	bzz_query["offerLocationId"] = offerLocationId
	bzz_query["offerCart"] = offerCart
	bzz_query["promoCode"] = promoCode
	bzz_query["currencyType"] = currencyType
	bzz_query["usePoints"] = usePoints
	bzz_query["metaData"] = metaData
	bzz_query["appKey"] = appKey
	bzz_query["status"] = status

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OfferTransactionResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_offer_transaction_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# offerId: float   Eg: 789
	# The id of the offer being added (offerId or offeLocationId required)
	offerId = null,
	# offerLocationId: float   Eg: 789
	# The id of the offer location being added (offerId or offeLocationId required)
	offerLocationId = null,
	# offerCart: String = ""   Eg: offerCart_example
	# A JSON list of offers to purchase. ```json [   {     \"offerId\": 123,     \"offerLocationId\": 234,     \"quantity\": 2   },   {     \"offerId\": 456,     \"offerLocationId\": 567,     \"quantity\": 1   } ] ``` 
	offerCart = "",
	# promoCode: String = ""   Eg: promoCode_example
	# The promoCode
	promoCode = "",
	# currencyType: String = "CASH"   Eg: currencyType_example
	# Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets
	currencyType = "CASH",
	# usePoints: bool   Eg: true
	# Sets the currencyType to POINTS
	usePoints = null,
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# appKey: String = ""   Eg: appKey_example
	# The application requesting the purchase, required when currencyType is TICKETS
	appKey = "",
	# status: int   Eg: 56
	# Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)
	status = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_offer_transaction")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		offerId,
		offerLocationId,
		offerCart,
		promoCode,
		currencyType,
		usePoints,
		metaData,
		appKey,
		status,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteOfferTransaction → POST /api/{version}/wallet/delete
# Delete Wallet Offer
#
# Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.
func delete_offer_transaction(
	# version: float   Eg: 3.16
	version: float,
	# transactionId: float   Eg: 789
	# The offer transaction id to remove
	transactionId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/wallet/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["transactionId"] = transactionId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_offer_transaction_threaded(
	# version: float   Eg: 3.16
	version: float,
	# transactionId: float   Eg: 789
	# The offer transaction id to remove
	transactionId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_offer_transaction")
	bzz_callable.bind(
		version,
		transactionId,
		deviceId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getOfferTransaction → GET /api/{version}/wallet/get
# Get Wallet Offer
func get_offer_transaction(
	# version: float   Eg: 3.16
	version: float,
	# transactionId: float   Eg: 789
	# The offer transaction id to get details of
	transactionId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# includeMission: bool = false   Eg: true
	# If true then include mission data, false to not include
	includeMission = false,
	# latitude: int   Eg: 1.2
	# The latitude location of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# The latitude location of the user
	longitude = null,
	# returnFullResponse: bool = true   Eg: true
	# Determines whether to return a detailed version of the response
	returnFullResponse = true,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/wallet/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["transactionId"] = transactionId
	bzz_query["includeMission"] = includeMission
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["returnFullResponse"] = returnFullResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OfferTransactionResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_offer_transaction_threaded(
	# version: float   Eg: 3.16
	version: float,
	# transactionId: float   Eg: 789
	# The offer transaction id to get details of
	transactionId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# includeMission: bool = false   Eg: true
	# If true then include mission data, false to not include
	includeMission = false,
	# latitude: int   Eg: 1.2
	# The latitude location of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# The latitude location of the user
	longitude = null,
	# returnFullResponse: bool = true   Eg: true
	# Determines whether to return a detailed version of the response
	returnFullResponse = true,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_offer_transaction")
	bzz_callable.bind(
		version,
		transactionId,
		deviceId,
		accountId,
		includeMission,
		latitude,
		longitude,
		returnFullResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation previewOfferTransaction → POST /api/{version}/wallet/preview
# Preview Wallet Offers
#
# Preview the final cost of a transaction without charging the user
func preview_offer_transaction(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# offerId: float   Eg: 789
	# The id of the offer being added (offerId or offeLocationId required)
	offerId = null,
	# offerLocationId: float   Eg: 789
	# The id of the offer location being added (offerId or offeLocationId required)
	offerLocationId = null,
	# offerCart: String = ""   Eg: offerCart_example
	# A JSON list of offers to purchase.
	offerCart = "",
	# promoCode: String = ""   Eg: promoCode_example
	# The promoCode
	promoCode = "",
	# currencyType: String = "CASH"   Eg: currencyType_example
	# Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets
	currencyType = "CASH",
	# usePoints: bool   Eg: true
	# Sets the currencyType to POINTS
	usePoints = null,
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# appKey: String = ""   Eg: appKey_example
	# The application requesting the purchase, required when currencyType is TICKETS
	appKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/wallet/preview".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["offerId"] = offerId
	bzz_query["offerLocationId"] = offerLocationId
	bzz_query["offerCart"] = offerCart
	bzz_query["promoCode"] = promoCode
	bzz_query["currencyType"] = currencyType
	bzz_query["usePoints"] = usePoints
	bzz_query["metaData"] = metaData
	bzz_query["appKey"] = appKey

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OfferTransactionResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func preview_offer_transaction_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# offerId: float   Eg: 789
	# The id of the offer being added (offerId or offeLocationId required)
	offerId = null,
	# offerLocationId: float   Eg: 789
	# The id of the offer location being added (offerId or offeLocationId required)
	offerLocationId = null,
	# offerCart: String = ""   Eg: offerCart_example
	# A JSON list of offers to purchase.
	offerCart = "",
	# promoCode: String = ""   Eg: promoCode_example
	# The promoCode
	promoCode = "",
	# currencyType: String = "CASH"   Eg: currencyType_example
	# Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets
	currencyType = "CASH",
	# usePoints: bool   Eg: true
	# Sets the currencyType to POINTS
	usePoints = null,
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# appKey: String = ""   Eg: appKey_example
	# The application requesting the purchase, required when currencyType is TICKETS
	appKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "preview_offer_transaction")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		offerId,
		offerLocationId,
		offerCart,
		promoCode,
		currencyType,
		usePoints,
		metaData,
		appKey,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchOfferTransactions → GET /api/{version}/wallet/search
# Search Wallet Offers
#
# Search on active offers currently in the user's wallet, or past offers the user has already redeemed.
func search_offer_transactions(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# keyword: String = ""   Eg: keyword_example
	# The keyword to search for
	keyword = "",
	# retailerId: float   Eg: 789
	# Filter results for this retailer
	retailerId = null,
	# retailerIds: String = ""   Eg: retailerIds_example
	# Filter results for a list of retailers
	retailerIds = "",
	# retailerLocationId: float   Eg: 789
	# Filter results for this retailer location
	retailerLocationId = null,
	# retailerLocationIds: String = ""   Eg: retailerLocationIds_example
	# Filter results for a list of retailer locations
	retailerLocationIds = "",
	# excludeRetailerLocationIds: String = ""   Eg: excludeRetailerLocationIds_example
	# Filter results to exclude retailer locations
	excludeRetailerLocationIds = "",
	# offerId: float   Eg: 789
	# Filter results for this offer
	offerId = null,
	# offerIds: String = ""   Eg: offerIds_example
	# Filter results for a list of offer
	offerIds = "",
	# offerLocationId: float   Eg: 789
	# Filter results for this offer location
	offerLocationId = null,
	# offerLocationIds: String = ""   Eg: offerLocationIds_example
	# Filter results for a list of offer locations
	offerLocationIds = "",
	# offerType: String = ""   Eg: offerType_example
	# Filter results to return a specific offer type
	offerType = "",
	# offerTypes: String = ""   Eg: offerTypes_example
	# Filter results to return specific offer types
	offerTypes = "",
	# specialOfferType: String = ""   Eg: specialOfferType_example
	# Filter results to return a specific special offer type
	specialOfferType = "",
	# specialOfferTypes: String = ""   Eg: specialOfferTypes_example
	# Filter results to return specific special offer types
	specialOfferTypes = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# Category Ids
	categoryIds = "",
	# filterIds: String = ""   Eg: filterIds_example
	# Filter Ids
	filterIds = "",
	# offerAudienceIds: String = ""   Eg: offerAudienceIds_example
	# Offer Audience Ids
	offerAudienceIds = "",
	# sortField: String = "CREATED"   Eg: sortField_example
	# Determines what to sort the results by
	sortField = "CREATED",
	# descending: bool = true   Eg: true
	# Determines whether the results are in descending order
	descending = true,
	# start: int = 0   Eg: 56
	# The start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# The limit for pagination
	limit = 20,
	# latitude: int   Eg: 1.2
	# The latitude location of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# The latitude location of the user
	longitude = null,
	# redeemableStartDate: float   Eg: 789
	# Filter results by the offer redeemable date
	redeemableStartDate = null,
	# redeemableEndDate: float   Eg: 789
	# Filter results by the offer redeemable date
	redeemableEndDate = null,
	# filterByParentOffer: bool = false   Eg: true
	# Apply params to offer's parent
	filterByParentOffer = false,
	# startedSince: float   Eg: 789
	# Filter results by the offer start date
	startedSince = null,
	# startedBefore: float   Eg: 789
	# Filter results by the offer start date
	startedBefore = null,
	# endedSince: float   Eg: 789
	# Filter results by the offer end date
	endedSince = null,
	# endedBefore: float   Eg: 789
	# Filter results by the offer end date
	endedBefore = null,
	# redeemed: bool = false   Eg: true
	# If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1)
	redeemed = false,
	# statuses: String = ""   Eg: statuses_example
	# Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)
	statuses = "",
	# reservationsOnly: bool = false   Eg: true
	# Returns only reservation transactions if true
	reservationsOnly = false,
	# activeOnly: bool = false   Eg: true
	# Active Only
	activeOnly = false,
	# returnFullResponse: bool = false   Eg: true
	# Determines whether to return a detailed version of the response
	returnFullResponse = false,
	# recurringStartedSince: float   Eg: 789
	# Filter results by the recurring billing start date
	recurringStartedSince = null,
	# recurringStartedBefore: float   Eg: 789
	# Filter results by the recurring billing start date
	recurringStartedBefore = null,
	# recurringExpirationSince: float   Eg: 789
	# Filter results by the recurring billing expiration date
	recurringExpirationSince = null,
	# recurringExpirationBefore: float   Eg: 789
	# Filter results by the recurring billing expiration date
	recurringExpirationBefore = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/wallet/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["keyword"] = keyword
	bzz_query["retailerId"] = retailerId
	bzz_query["retailerIds"] = retailerIds
	bzz_query["retailerLocationId"] = retailerLocationId
	bzz_query["retailerLocationIds"] = retailerLocationIds
	bzz_query["excludeRetailerLocationIds"] = excludeRetailerLocationIds
	bzz_query["offerId"] = offerId
	bzz_query["offerIds"] = offerIds
	bzz_query["offerLocationId"] = offerLocationId
	bzz_query["offerLocationIds"] = offerLocationIds
	bzz_query["offerType"] = offerType
	bzz_query["offerTypes"] = offerTypes
	bzz_query["specialOfferType"] = specialOfferType
	bzz_query["specialOfferTypes"] = specialOfferTypes
	bzz_query["categoryIds"] = categoryIds
	bzz_query["filterIds"] = filterIds
	bzz_query["offerAudienceIds"] = offerAudienceIds
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["redeemableStartDate"] = redeemableStartDate
	bzz_query["redeemableEndDate"] = redeemableEndDate
	bzz_query["filterByParentOffer"] = filterByParentOffer
	bzz_query["startedSince"] = startedSince
	bzz_query["startedBefore"] = startedBefore
	bzz_query["endedSince"] = endedSince
	bzz_query["endedBefore"] = endedBefore
	bzz_query["redeemed"] = redeemed
	bzz_query["statuses"] = statuses
	bzz_query["reservationsOnly"] = reservationsOnly
	bzz_query["activeOnly"] = activeOnly
	bzz_query["returnFullResponse"] = returnFullResponse
	bzz_query["recurringStartedSince"] = recurringStartedSince
	bzz_query["recurringStartedBefore"] = recurringStartedBefore
	bzz_query["recurringExpirationSince"] = recurringExpirationSince
	bzz_query["recurringExpirationBefore"] = recurringExpirationBefore

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OfferTransactionResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_offer_transactions_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# keyword: String = ""   Eg: keyword_example
	# The keyword to search for
	keyword = "",
	# retailerId: float   Eg: 789
	# Filter results for this retailer
	retailerId = null,
	# retailerIds: String = ""   Eg: retailerIds_example
	# Filter results for a list of retailers
	retailerIds = "",
	# retailerLocationId: float   Eg: 789
	# Filter results for this retailer location
	retailerLocationId = null,
	# retailerLocationIds: String = ""   Eg: retailerLocationIds_example
	# Filter results for a list of retailer locations
	retailerLocationIds = "",
	# excludeRetailerLocationIds: String = ""   Eg: excludeRetailerLocationIds_example
	# Filter results to exclude retailer locations
	excludeRetailerLocationIds = "",
	# offerId: float   Eg: 789
	# Filter results for this offer
	offerId = null,
	# offerIds: String = ""   Eg: offerIds_example
	# Filter results for a list of offer
	offerIds = "",
	# offerLocationId: float   Eg: 789
	# Filter results for this offer location
	offerLocationId = null,
	# offerLocationIds: String = ""   Eg: offerLocationIds_example
	# Filter results for a list of offer locations
	offerLocationIds = "",
	# offerType: String = ""   Eg: offerType_example
	# Filter results to return a specific offer type
	offerType = "",
	# offerTypes: String = ""   Eg: offerTypes_example
	# Filter results to return specific offer types
	offerTypes = "",
	# specialOfferType: String = ""   Eg: specialOfferType_example
	# Filter results to return a specific special offer type
	specialOfferType = "",
	# specialOfferTypes: String = ""   Eg: specialOfferTypes_example
	# Filter results to return specific special offer types
	specialOfferTypes = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# Category Ids
	categoryIds = "",
	# filterIds: String = ""   Eg: filterIds_example
	# Filter Ids
	filterIds = "",
	# offerAudienceIds: String = ""   Eg: offerAudienceIds_example
	# Offer Audience Ids
	offerAudienceIds = "",
	# sortField: String = "CREATED"   Eg: sortField_example
	# Determines what to sort the results by
	sortField = "CREATED",
	# descending: bool = true   Eg: true
	# Determines whether the results are in descending order
	descending = true,
	# start: int = 0   Eg: 56
	# The start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# The limit for pagination
	limit = 20,
	# latitude: int   Eg: 1.2
	# The latitude location of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# The latitude location of the user
	longitude = null,
	# redeemableStartDate: float   Eg: 789
	# Filter results by the offer redeemable date
	redeemableStartDate = null,
	# redeemableEndDate: float   Eg: 789
	# Filter results by the offer redeemable date
	redeemableEndDate = null,
	# filterByParentOffer: bool = false   Eg: true
	# Apply params to offer's parent
	filterByParentOffer = false,
	# startedSince: float   Eg: 789
	# Filter results by the offer start date
	startedSince = null,
	# startedBefore: float   Eg: 789
	# Filter results by the offer start date
	startedBefore = null,
	# endedSince: float   Eg: 789
	# Filter results by the offer end date
	endedSince = null,
	# endedBefore: float   Eg: 789
	# Filter results by the offer end date
	endedBefore = null,
	# redeemed: bool = false   Eg: true
	# If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1)
	redeemed = false,
	# statuses: String = ""   Eg: statuses_example
	# Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)
	statuses = "",
	# reservationsOnly: bool = false   Eg: true
	# Returns only reservation transactions if true
	reservationsOnly = false,
	# activeOnly: bool = false   Eg: true
	# Active Only
	activeOnly = false,
	# returnFullResponse: bool = false   Eg: true
	# Determines whether to return a detailed version of the response
	returnFullResponse = false,
	# recurringStartedSince: float   Eg: 789
	# Filter results by the recurring billing start date
	recurringStartedSince = null,
	# recurringStartedBefore: float   Eg: 789
	# Filter results by the recurring billing start date
	recurringStartedBefore = null,
	# recurringExpirationSince: float   Eg: 789
	# Filter results by the recurring billing expiration date
	recurringExpirationSince = null,
	# recurringExpirationBefore: float   Eg: 789
	# Filter results by the recurring billing expiration date
	recurringExpirationBefore = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_offer_transactions")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		keyword,
		retailerId,
		retailerIds,
		retailerLocationId,
		retailerLocationIds,
		excludeRetailerLocationIds,
		offerId,
		offerIds,
		offerLocationId,
		offerLocationIds,
		offerType,
		offerTypes,
		specialOfferType,
		specialOfferTypes,
		categoryIds,
		filterIds,
		offerAudienceIds,
		sortField,
		descending,
		start,
		limit,
		latitude,
		longitude,
		redeemableStartDate,
		redeemableEndDate,
		filterByParentOffer,
		startedSince,
		startedBefore,
		endedSince,
		endedBefore,
		redeemed,
		statuses,
		reservationsOnly,
		activeOnly,
		returnFullResponse,
		recurringStartedSince,
		recurringStartedBefore,
		recurringExpirationSince,
		recurringExpirationBefore,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateOfferTransaction → POST /api/{version}/wallet/update
# Update Wallet Offer
#
# Update offer status. The status values are: 0 - not redeemable, 1 - redeemable.  Not redeemable means the customer has received the offer but has not decided to use (or print) it yet.  Until they choose to do this the merchant cannot redeem the offer (has not been given permission yet).   Redeemable means the customer has chosen to use the offer and wishes to redeem it.  Redeemed means the merchant has accepted the offer and the given the customer its value, then marked it a used in the system.  This status change is handled by a merchant end point.
func update_offer_transaction(
	# version: float   Eg: 3.16
	version: float,
	# transactionId: float   Eg: 789
	# The offer transaction id to remove
	transactionId: float,
	# status: int   Eg: 56
	# The status value to change to (0 or 1)
	status: int,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# offerLocationId: float   Eg: 789
	# Offer Location Id
	offerLocationId = null,
	# currencyType: String = "CASH"   Eg: currencyType_example
	# Currency Type
	currencyType = "CASH",
	# usePoints: bool   Eg: true
	# Use Points
	usePoints = null,
	# appKey: String = ""   Eg: appKey_example
	# App Key
	appKey = "",
	# latitude: int   Eg: 1.2
	# The latitude location of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# The latitude location of the user
	longitude = null,
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# returnFullResponse: bool = false   Eg: true
	# Determines whether to return a detailed version of the response
	returnFullResponse = false,
	# exceptionMembershipOfferIds: String = ""   Eg: exceptionMembershipOfferIds_example
	# Exception Offers, transaction audiences of these offers won't be removed out of the account when up
	exceptionMembershipOfferIds = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/wallet/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["transactionId"] = transactionId
	bzz_query["offerLocationId"] = offerLocationId
	bzz_query["currencyType"] = currencyType
	bzz_query["usePoints"] = usePoints
	bzz_query["appKey"] = appKey
	bzz_query["status"] = status
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["metaData"] = metaData
	bzz_query["returnFullResponse"] = returnFullResponse
	bzz_query["exceptionMembershipOfferIds"] = exceptionMembershipOfferIds

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OfferTransactionResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_offer_transaction_threaded(
	# version: float   Eg: 3.16
	version: float,
	# transactionId: float   Eg: 789
	# The offer transaction id to remove
	transactionId: float,
	# status: int   Eg: 56
	# The status value to change to (0 or 1)
	status: int,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# offerLocationId: float   Eg: 789
	# Offer Location Id
	offerLocationId = null,
	# currencyType: String = "CASH"   Eg: currencyType_example
	# Currency Type
	currencyType = "CASH",
	# usePoints: bool   Eg: true
	# Use Points
	usePoints = null,
	# appKey: String = ""   Eg: appKey_example
	# App Key
	appKey = "",
	# latitude: int   Eg: 1.2
	# The latitude location of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# The latitude location of the user
	longitude = null,
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# returnFullResponse: bool = false   Eg: true
	# Determines whether to return a detailed version of the response
	returnFullResponse = false,
	# exceptionMembershipOfferIds: String = ""   Eg: exceptionMembershipOfferIds_example
	# Exception Offers, transaction audiences of these offers won't be removed out of the account when up
	exceptionMembershipOfferIds = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_offer_transaction")
	bzz_callable.bind(
		version,
		transactionId,
		status,
		deviceId,
		accountId,
		offerLocationId,
		currencyType,
		usePoints,
		appKey,
		latitude,
		longitude,
		metaData,
		returnFullResponse,
		exceptionMembershipOfferIds,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


