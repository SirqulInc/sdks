extends ApiBee
class_name VatomApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API VatomApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "VatomApi"


# Operation createFollowing → POST /api/{version}/vatom/me/rels/following/create
# Create following
#
# Create following.
func create_following(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/me/rels/following/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_following_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_following")
	bzz_callable.bind(
		version,
		accountId,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createSpace → POST /api/{version}/vatom/b/spaces/create
# Create Vatom Space
#
# Create a Vatom space.
func create_space(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/spaces/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_space_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_space")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createVatomEvent → POST /api/{version}/vatom/b/events/create
# Create Vatom Event
#
# Create a Vatom event.
func create_vatom_event(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/events/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_vatom_event_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_vatom_event")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteFollowing → POST /api/{version}/vatom/me/rels/following/delete
# Delete following
#
# Delete following.
func delete_following(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomRelsKey: String = ""   Eg: vatomRelsKey_example
	# Vatom Rels Key
	vatomRelsKey: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/me/rels/following/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomRelsKey"] = vatomRelsKey
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_following_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomRelsKey: String = ""   Eg: vatomRelsKey_example
	# Vatom Rels Key
	vatomRelsKey: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_following")
	bzz_callable.bind(
		version,
		accountId,
		vatomRelsKey,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deletePointsBalance → POST /api/{version}/vatom/b/campaign/points/delete
# Reset All Points Balance
#
# Reset All Points Balance.
func delete_points_balance(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomCampaignId: String = ""   Eg: vatomCampaignId_example
	# Vatom Campaign Id
	vatomCampaignId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/campaign/points/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomCampaignId"] = vatomCampaignId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_points_balance_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomCampaignId: String = ""   Eg: vatomCampaignId_example
	# Vatom Campaign Id
	vatomCampaignId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_points_balance")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomCampaignId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteSpace → POST /api/{version}/vatom/b/spaces/delete
# Delete Vatom Space
#
# Delete a Vatom space.
func delete_space(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomSpaceId: String = ""   Eg: vatomSpaceId_example
	# Vatom Space Id
	vatomSpaceId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/spaces/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomSpaceId"] = vatomSpaceId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_space_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomSpaceId: String = ""   Eg: vatomSpaceId_example
	# Vatom Space Id
	vatomSpaceId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_space")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomSpaceId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteVatomEvent → POST /api/{version}/vatom/b/events/delete
# Delete Vatom Event
#
# Delete a Vatom event.
func delete_vatom_event(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomEventId: String = ""   Eg: vatomEventId_example
	# Vatom Event Id
	vatomEventId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/events/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomEventId"] = vatomEventId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_vatom_event_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomEventId: String = ""   Eg: vatomEventId_example
	# Vatom Event Id
	vatomEventId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_vatom_event")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomEventId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteVatomNFT → POST /api/{version}/vatom/vatoms/delete
# Delete Vatom NFT
#
# Delete Vatom NFT
func delete_vatom_nft(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomId: String = ""   Eg: vatomId_example
	# Vatom NFT Id
	vatomId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/vatoms/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomId"] = vatomId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_vatom_nft_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomId: String = ""   Eg: vatomId_example
	# Vatom NFT Id
	vatomId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_vatom_nft")
	bzz_callable.bind(
		version,
		accountId,
		vatomId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation executeActionOnNFT → POST /api/{version}/vatom/vatoms/execute-action
# Execute Action on NFT
#
# Execute Action on NFT.
func execute_action_on_nft(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomId: String = ""   Eg: vatomId_example
	# Vatom NFT Id
	vatomId: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/vatoms/execute-action".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomId"] = vatomId
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func execute_action_on_nft_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomId: String = ""   Eg: vatomId_example
	# Vatom NFT Id
	vatomId: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "execute_action_on_nft")
	bzz_callable.bind(
		version,
		accountId,
		vatomId,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation geomapSearch → GET /api/{version}/vatom/vatoms/geo-map/search
# Search Vatom Geo Map
#
# Search Vatom Geo Map
func geomap_search(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/vatoms/geo-map/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func geomap_search_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "geomap_search")
	bzz_callable.bind(
		version,
		accountId,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getBusinessBehaviors → GET /api/{version}/vatom/b/behaviors
# Get Vatom Business Behaviors
#
# Gets the behaviors of a business.
func get_business_behaviors(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/behaviors".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_business_behaviors_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_business_behaviors")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getBusinessCoinsBalance → GET /api/{version}/vatom/b/coins/get
# Get the coins for a Business
#
# Get the coins for a Businesss.
func get_business_coins_balance(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/coins/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_business_coins_balance_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_business_coins_balance")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getBusinessIds → GET /api/{version}/vatom/me/businesses
# Get the user business ids
#
# Get the business ids the logged in user has access to.
func get_business_ids(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/me/businesses".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_business_ids_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_business_ids")
	bzz_callable.bind(
		version,
		accountId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getBusinessInfo → GET /api/{version}/vatom/b/get
# Get Vatom Business Info
#
# Gets the business info tied to this account.
func get_business_info(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters = "",
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_business_info_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters = "",
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_business_info")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getBusinessUsers → GET /api/{version}/vatom/b/users
# Get Vatom Business Users
#
# Gets the users of a business.
func get_business_users(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/users".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_business_users_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_business_users")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getCampaignGroupEntities → GET /api/{version}/vatom/b/campaign-groups/entities
# Get Campaign Group Entities
#
# Get campaign group entities.
func get_campaign_group_entities(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomCampaignId: String = ""   Eg: vatomCampaignId_example
	# Vatom Campaign Id
	vatomCampaignId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/campaign-groups/entities".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomCampaignId"] = vatomCampaignId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_campaign_group_entities_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomCampaignId: String = ""   Eg: vatomCampaignId_example
	# Vatom Campaign Id
	vatomCampaignId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_campaign_group_entities")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomCampaignId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getCampaignGroupRules → GET /api/{version}/vatom/b/campaign-groups/rules
# Get Campaign Group Rules
#
# Get campaign group rules.
func get_campaign_group_rules(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomCampaignId: String = ""   Eg: vatomCampaignId_example
	# Vatom Campaign Id
	vatomCampaignId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/campaign-groups/rules".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomCampaignId"] = vatomCampaignId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_campaign_group_rules_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomCampaignId: String = ""   Eg: vatomCampaignId_example
	# Vatom Campaign Id
	vatomCampaignId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_campaign_group_rules")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomCampaignId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getCampaignGroupStats → GET /api/{version}/vatom/b/campaign-groups/stats
# Get Campaign Group Stats
#
# Get campaign group stats.
func get_campaign_group_stats(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomCampaignId: String = ""   Eg: vatomCampaignId_example
	# Vatom Campaign Id
	vatomCampaignId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/campaign-groups/stats".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomCampaignId"] = vatomCampaignId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_campaign_group_stats_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomCampaignId: String = ""   Eg: vatomCampaignId_example
	# Vatom Campaign Id
	vatomCampaignId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_campaign_group_stats")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomCampaignId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getCampaignInfo → GET /api/{version}/vatom/b/campaign-groups/get
# Get Campaign Info
#
# Gets the info on a campaign.
func get_campaign_info(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomCampaignId: String = ""   Eg: vatomCampaignId_example
	# Vatom Campaign Id
	vatomCampaignId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/campaign-groups/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomCampaignId"] = vatomCampaignId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_campaign_info_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomCampaignId: String = ""   Eg: vatomCampaignId_example
	# Vatom Campaign Id
	vatomCampaignId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_campaign_info")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomCampaignId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getEventGuestList → GET /api/{version}/vatom/b/events/guests/get
# Get Vatom Event Guest List
#
# Gets the guest list of an event.
func get_event_guest_list(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomEventId: String = ""   Eg: vatomEventId_example
	# Vatom Event Id
	vatomEventId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/events/guests/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomEventId"] = vatomEventId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_event_guest_list_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomEventId: String = ""   Eg: vatomEventId_example
	# Vatom Event Id
	vatomEventId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_event_guest_list")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomEventId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getInventory → GET /api/{version}/vatom/me/inventory
# Get Vatom User's Inventory
#
# Gets the logged in user's Vatom Inventory.
func get_inventory(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/me/inventory".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_inventory_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_inventory")
	bzz_callable.bind(
		version,
		accountId,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getMyFollowing → GET /api/{version}/vatom/me/rels/following
# Get following
#
# Get following.
func get_my_following(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/me/rels/following".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_my_following_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_my_following")
	bzz_callable.bind(
		version,
		accountId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getPointsBalance → GET /api/{version}/vatom/u/campaign/points/get
# Get Points Balance
#
# Gets the points balance of a Vatom user.
func get_points_balance(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# vatomCampaignId: String = ""   Eg: vatomCampaignId_example
	# Vatom Campaign Id
	vatomCampaignId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/u/campaign/points/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomUserId"] = vatomUserId
	bzz_query["vatomCampaignId"] = vatomCampaignId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_points_balance_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# vatomCampaignId: String = ""   Eg: vatomCampaignId_example
	# Vatom Campaign Id
	vatomCampaignId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_points_balance")
	bzz_callable.bind(
		version,
		accountId,
		vatomUserId,
		vatomCampaignId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getPointsBalanceAsBusiness → GET /api/{version}/vatom/b/campaign/u/points/get
# Get Points Balance as Business
#
# Gets the points balance of a Vatom user.
func get_points_balance_as_business(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# vatomCampaignId: String = ""   Eg: vatomCampaignId_example
	# Vatom Campaign Id
	vatomCampaignId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/campaign/u/points/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomUserId"] = vatomUserId
	bzz_query["vatomCampaignId"] = vatomCampaignId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_points_balance_as_business_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# vatomCampaignId: String = ""   Eg: vatomCampaignId_example
	# Vatom Campaign Id
	vatomCampaignId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_points_balance_as_business")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomUserId,
		vatomCampaignId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getSpace → GET /api/{version}/vatom/b/spaces/get
# Get Vatom Space
#
# Gets the details of a space.
func get_space(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomSpaceId: String = ""   Eg: vatomSpaceId_example
	# Vatom Space Id
	vatomSpaceId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/spaces/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomSpaceId"] = vatomSpaceId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_space_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomSpaceId: String = ""   Eg: vatomSpaceId_example
	# Vatom Space Id
	vatomSpaceId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_space")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomSpaceId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getUserCoinsAsBusiness → GET /api/{version}/vatom/b/users/coins/get
# Get the coins for a user (as a Business)
#
# Get the coins for a user (as a Business).
func get_user_coins_as_business(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/users/coins/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomUserId"] = vatomUserId
	bzz_query["appKey"] = appKey
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_user_coins_as_business_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_user_coins_as_business")
	bzz_callable.bind(
		version,
		accountId,
		vatomUserId,
		appKey,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getUserCoinsBalance → GET /api/{version}/vatom/u/coins/get
# Gets the coins balance for a Vatom User
#
# Gets the coins balance for a Vatom User.
func get_user_coins_balance(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters = "",
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/u/coins/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomUserId"] = vatomUserId
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_user_coins_balance_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters = "",
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_user_coins_balance")
	bzz_callable.bind(
		version,
		accountId,
		vatomUserId,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getUserFollowers → GET /api/{version}/vatom/users/rels/followers
# Get user followers
#
# Get user followers.
func get_user_followers(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/users/rels/followers".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomUserId"] = vatomUserId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_user_followers_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_user_followers")
	bzz_callable.bind(
		version,
		accountId,
		vatomUserId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getUserFollowing → GET /api/{version}/vatom/users/rels/following
# Get user following
#
# Get user following.
func get_user_following(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/users/rels/following".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomUserId"] = vatomUserId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_user_following_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_user_following")
	bzz_callable.bind(
		version,
		accountId,
		vatomUserId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getUserInfo → GET /api/{version}/vatom/user/get
# Get User Info
#
# Get a User's Info.
func get_user_info(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/user/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomUserId"] = vatomUserId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_user_info_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_user_info")
	bzz_callable.bind(
		version,
		accountId,
		vatomUserId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getUserProfile → GET /api/{version}/vatom/me/get
# Get Vatom User Profile
#
# Gets the logged in user's profile in Vatom.
func get_user_profile(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/me/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_user_profile_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_user_profile")
	bzz_callable.bind(
		version,
		accountId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getVatomEvent → GET /api/{version}/vatom/b/events/get
# Get Vatom Event
#
# Gets the details of a event.
func get_vatom_event(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomEventId: String = ""   Eg: vatomEventId_example
	# Vatom Event Id
	vatomEventId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/events/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomEventId"] = vatomEventId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_vatom_event_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomEventId: String = ""   Eg: vatomEventId_example
	# Vatom Event Id
	vatomEventId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_vatom_event")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomEventId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getVatomNFT → GET /api/{version}/vatom/vatoms/get
# Get Vatom NFT Details
#
# Get Vatom NFT Details
func get_vatom_nft(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomId: String = ""   Eg: vatomId_example
	# Vatom NFT Id
	vatomId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/vatoms/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomId"] = vatomId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_vatom_nft_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomId: String = ""   Eg: vatomId_example
	# Vatom NFT Id
	vatomId: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_vatom_nft")
	bzz_callable.bind(
		version,
		accountId,
		vatomId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation listCommunities → GET /api/{version}/vatom/b/communities/search
# List Vatom Communities
#
# Gets the communities tied to a business.
func list_communities(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters = "",
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/communities/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func list_communities_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters = "",
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "list_communities")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation listEvents → GET /api/{version}/vatom/b/events/search
# List Vatom Events
#
# Gets the events tied to a business.
func list_events(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters = "",
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/events/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func list_events_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters = "",
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "list_events")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation listSpaces → GET /api/{version}/vatom/b/spaces/search
# List Vatom Spaces
#
# Gets the spaces tied to a business.
func list_spaces(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters = "",
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/spaces/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func list_spaces_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters = "",
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "list_spaces")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation listUserCoinTransactions → GET /api/{version}/vatom/u/coins/txns/search
# List Coin Transactions for a Vatom User
#
# Gets the logged in user's Vatom coin transactions.
func list_user_coin_transactions(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters = "",
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/u/coins/txns/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomUserId"] = vatomUserId
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func list_user_coin_transactions_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters = "",
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "list_user_coin_transactions")
	bzz_callable.bind(
		version,
		accountId,
		vatomUserId,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation listUserCoinTransactionsAsBusiness → GET /api/{version}/vatom/b/users/coins/txns/search
# List coin transactions for a user (as a Business)
#
# List coin transactions for a user (as a Business).
func list_user_coin_transactions_as_business(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters = "",
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/users/coins/txns/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomUserId"] = vatomUserId
	bzz_query["appKey"] = appKey
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func list_user_coin_transactions_as_business_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters = "",
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "list_user_coin_transactions_as_business")
	bzz_callable.bind(
		version,
		accountId,
		vatomUserId,
		appKey,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation performActionOnNFT → POST /api/{version}/vatom/me/vatoms/actions
# Perform Action on NFT
#
# Perform Action on NFT.
func perform_action_on_nft(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomId: String = ""   Eg: vatomId_example
	# Vatom NFT Id
	vatomId: String,
	# vatomAction: String = ""   Eg: vatomAction_example
	# Vatom Action
	vatomAction: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/me/vatoms/actions".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomId"] = vatomId
	bzz_query["vatomAction"] = vatomAction
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func perform_action_on_nft_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomId: String = ""   Eg: vatomId_example
	# Vatom NFT Id
	vatomId: String,
	# vatomAction: String = ""   Eg: vatomAction_example
	# Vatom Action
	vatomAction: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "perform_action_on_nft")
	bzz_callable.bind(
		version,
		accountId,
		vatomId,
		vatomAction,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation redeemNFT → POST /api/{version}/vatom/b/redemptions
# Redeem NFT
#
# Redeem an NFT.
func redeem_nft(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/redemptions".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func redeem_nft_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "redeem_nft")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation redeemUserCoinsAsBusiness → POST /api/{version}/vatom/b/users/coins/redeem
# Redeem the coins for a user (as a Business)
#
# Redeem the coins for a user (as a Business).
func redeem_user_coins_as_business(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/users/coins/redeem".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomUserId"] = vatomUserId
	bzz_query["appKey"] = appKey
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func redeem_user_coins_as_business_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "redeem_user_coins_as_business")
	bzz_callable.bind(
		version,
		accountId,
		vatomUserId,
		appKey,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchBusinesses → GET /api/{version}/vatom/b/search
# Search for Vatom Businesses
#
# Searches for Vatom businesses.
func search_businesses(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters = "",
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_businesses_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters = "",
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_businesses")
	bzz_callable.bind(
		version,
		accountId,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchCampaignGroups → GET /api/{version}/vatom/b/campaign-groups/search
# Search Campaign Groups
#
# Search campaign groups.
func search_campaign_groups(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/campaign-groups/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_campaign_groups_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_campaign_groups")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchIdentities → GET /api/{version}/vatom/me/identities/search
# Search User Identities
#
# Search User Identities.
func search_identities(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/me/identities/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_identities_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_identities")
	bzz_callable.bind(
		version,
		accountId,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchInventory → GET /api/{version}/vatom/user-inventory/search
# Search Vatom User's Inventory
#
# Searches the logged in user's Vatom Inventory.
func search_inventory(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters = "",
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/user-inventory/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_inventory_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters = "",
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_inventory")
	bzz_callable.bind(
		version,
		accountId,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation sendNFT → POST /api/{version}/vatom/b/campaigns/send
# Send NFT
#
# Send an NFT.
func send_nft(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomCampaignId: String = ""   Eg: vatomCampaignId_example
	# Vatom Campaign Id
	vatomCampaignId: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/campaigns/send".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomCampaignId"] = vatomCampaignId
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func send_nft_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomCampaignId: String = ""   Eg: vatomCampaignId_example
	# Vatom Campaign Id
	vatomCampaignId: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "send_nft")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomCampaignId,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation setPointsBalanceAsBusiness → POST /api/{version}/vatom/b/campaign/u/points/update
# Set Points Balance as Business
#
# Sets the points balance of a Vatom user.
func set_points_balance_as_business(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# vatomCampaignId: String = ""   Eg: vatomCampaignId_example
	# Vatom Campaign Id
	vatomCampaignId: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/campaign/u/points/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomUserId"] = vatomUserId
	bzz_query["vatomCampaignId"] = vatomCampaignId
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func set_points_balance_as_business_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# vatomCampaignId: String = ""   Eg: vatomCampaignId_example
	# Vatom Campaign Id
	vatomCampaignId: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "set_points_balance_as_business")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomUserId,
		vatomCampaignId,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation transferUserCoins → POST /api/{version}/vatom/u/coins/transfer
# Transfer coins from Vatom Users
#
# Transfer coins from Vatom Users.
func transfer_user_coins(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/u/coins/transfer".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomUserId"] = vatomUserId
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func transfer_user_coins_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "transfer_user_coins")
	bzz_callable.bind(
		version,
		accountId,
		vatomUserId,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateBusinessCoins → POST /api/{version}/vatom/b/coins/update
# Fund coins for a Business
#
# Fund/update coins for a Businesss.
func update_business_coins(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/coins/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_business_coins_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_business_coins")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateEventGuestList → POST /api/{version}/vatom/b/events/guests/update
# Update Vatom Event Guest List
#
# Update the guest list of an event.
func update_event_guest_list(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomEventId: String = ""   Eg: vatomEventId_example
	# Vatom Event Id
	vatomEventId: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/events/guests/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomEventId"] = vatomEventId
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_event_guest_list_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomEventId: String = ""   Eg: vatomEventId_example
	# Vatom Event Id
	vatomEventId: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_event_guest_list")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomEventId,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateSpace → POST /api/{version}/vatom/b/spaces/update
# Update Vatom Space
#
# Update a Vatom space.
func update_space(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomSpaceId: String = ""   Eg: vatomSpaceId_example
	# Vatom Space Id
	vatomSpaceId: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/spaces/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomSpaceId"] = vatomSpaceId
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_space_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomSpaceId: String = ""   Eg: vatomSpaceId_example
	# Vatom Space Id
	vatomSpaceId: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_space")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomSpaceId,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateUserCoinsAsBusiness → POST /api/{version}/vatom/b/users/coins/update
# Update the coins for a user (as a Business)
#
# Update the coins for a user (as a Business).
func update_user_coins_as_business(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/users/coins/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomUserId"] = vatomUserId
	bzz_query["appKey"] = appKey
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_user_coins_as_business_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomUserId: String = ""   Eg: vatomUserId_example
	# Vatom User Id
	vatomUserId: String,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_user_coins_as_business")
	bzz_callable.bind(
		version,
		accountId,
		vatomUserId,
		appKey,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateUserProfile → POST /api/{version}/vatom/me/update
# Update Vatom User Profile
#
# Gets the logged in user's profile in Vatom.
func update_user_profile(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/me/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_user_profile_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_user_profile")
	bzz_callable.bind(
		version,
		accountId,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateVatomEvent → POST /api/{version}/vatom/b/events/update
# Update Vatom Event
#
# Update a Vatom event.
func update_vatom_event(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomEventId: String = ""   Eg: vatomEventId_example
	# Vatom Event Id
	vatomEventId: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/vatom/b/events/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["vatomEventId"] = vatomEventId
	bzz_query["vatomParameters"] = vatomParameters
	bzz_query["returnRawResponse"] = returnRawResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_vatom_event_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# Sirqul Application Key
	appKey: String,
	# vatomEventId: String = ""   Eg: vatomEventId_example
	# Vatom Event Id
	vatomEventId: String,
	# vatomParameters: String = ""   Eg: vatomParameters_example
	# Vatom Parameters
	vatomParameters: String,
	# returnRawResponse: bool   Eg: true
	# Return raw response
	returnRawResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_vatom_event")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		vatomEventId,
		vatomParameters,
		returnRawResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


