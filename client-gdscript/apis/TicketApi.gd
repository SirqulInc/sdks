extends ApiBee
class_name TicketApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API TicketApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "TicketApi"


# Operation getTicketCount → GET /api/{version}/ticket/count
# Get Ticket Count
#
# Gets the ticket count.
func get_ticket_count(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the id of the device that owns the tickets
	deviceId = "",
	# accountId: float   Eg: 789
	# the id of the account that owns the tickets
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# this is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the applicationkey
	appKey = "",
	# ticketType: String = ""   Eg: ticketType_example
	# the type of ticket
	ticketType = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/ticket/count".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["gameType"] = gameType
	bzz_query["appKey"] = appKey
	bzz_query["ticketType"] = ticketType

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = CountResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_ticket_count_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the id of the device that owns the tickets
	deviceId = "",
	# accountId: float   Eg: 789
	# the id of the account that owns the tickets
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# this is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the applicationkey
	appKey = "",
	# ticketType: String = ""   Eg: ticketType_example
	# the type of ticket
	ticketType = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_ticket_count")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		gameType,
		appKey,
		ticketType,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getTicketList → GET /api/{version}/ticket/getList
# Get Ticket List
#
# Gets the list of tickets.
func get_ticket_list(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the id of the device that owns the tickets
	deviceId = "",
	# accountId: float   Eg: 789
	# the id of the account that owns the tickets
	accountId = null,
	# ticketObjectType: String = ""   Eg: ticketObjectType_example
	# comma separated list of TicketObjectType
	ticketObjectType = "",
	# actionType: String = ""   Eg: actionType_example
	# comma separated list of TicketActionType
	actionType = "",
	# ticketIds: String = ""   Eg: ticketIds_example
	# the ids of the tickets to get
	ticketIds = "",
	# objectIds: String = ""   Eg: objectIds_example
	# the ids of the objects to get
	objectIds = "",
	# receiptTokens: String = ""   Eg: receiptTokens_example
	receiptTokens = "",
	# gameType: String = ""   Eg: gameType_example
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/ticket/getList".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["ticketObjectType"] = ticketObjectType
	bzz_query["actionType"] = actionType
	bzz_query["ticketIds"] = ticketIds
	bzz_query["objectIds"] = objectIds
	bzz_query["receiptTokens"] = receiptTokens
	bzz_query["gameType"] = gameType
	bzz_query["appKey"] = appKey

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = TicketListResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_ticket_list_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the id of the device that owns the tickets
	deviceId = "",
	# accountId: float   Eg: 789
	# the id of the account that owns the tickets
	accountId = null,
	# ticketObjectType: String = ""   Eg: ticketObjectType_example
	# comma separated list of TicketObjectType
	ticketObjectType = "",
	# actionType: String = ""   Eg: actionType_example
	# comma separated list of TicketActionType
	actionType = "",
	# ticketIds: String = ""   Eg: ticketIds_example
	# the ids of the tickets to get
	ticketIds = "",
	# objectIds: String = ""   Eg: objectIds_example
	# the ids of the objects to get
	objectIds = "",
	# receiptTokens: String = ""   Eg: receiptTokens_example
	receiptTokens = "",
	# gameType: String = ""   Eg: gameType_example
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_ticket_list")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		ticketObjectType,
		actionType,
		ticketIds,
		objectIds,
		receiptTokens,
		gameType,
		appKey,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation giftPurchase → POST /api/{version}/purchase/gift
# Gift Tickets
#
# Gift tickets to another user.
func gift_purchase(
	# version: float   Eg: 3.16
	version: float,
	# receiverAccountId: float   Eg: 789
	# the id of the account receiving the tickets
	receiverAccountId: float,
	# ticketId: float   Eg: 789
	# the id of the tickets
	ticketId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the id of the device
	deviceId = "",
	# accountId: float   Eg: 789
	# the id of the gift owner
	accountId = null,
	# assetId: float   Eg: 789
	# the id of the asset
	assetId = null,
	# customMessage: String = ""   Eg: customMessage_example
	# a message that can be written to go along with the gift
	customMessage = "",
	# gameType: String = ""   Eg: gameType_example
	# the type of game associated with the tickets
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/purchase/gift".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["receiverAccountId"] = receiverAccountId
	bzz_query["ticketId"] = ticketId
	bzz_query["assetId"] = assetId
	bzz_query["customMessage"] = customMessage
	bzz_query["gameType"] = gameType
	bzz_query["appKey"] = appKey

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func gift_purchase_threaded(
	# version: float   Eg: 3.16
	version: float,
	# receiverAccountId: float   Eg: 789
	# the id of the account receiving the tickets
	receiverAccountId: float,
	# ticketId: float   Eg: 789
	# the id of the tickets
	ticketId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the id of the device
	deviceId = "",
	# accountId: float   Eg: 789
	# the id of the gift owner
	accountId = null,
	# assetId: float   Eg: 789
	# the id of the asset
	assetId = null,
	# customMessage: String = ""   Eg: customMessage_example
	# a message that can be written to go along with the gift
	customMessage = "",
	# gameType: String = ""   Eg: gameType_example
	# the type of game associated with the tickets
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "gift_purchase")
	bzz_callable.bind(
		version,
		receiverAccountId,
		ticketId,
		deviceId,
		accountId,
		assetId,
		customMessage,
		gameType,
		appKey,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation saveTicket → POST /api/{version}/ticket/save
# Save Ticket
#
# Allow user to acquire a purchase item and generate a ticket record. Used to redeem tickets or add tickets to the system.
func save_ticket(
	# version: float   Eg: 3.16
	version: float,
	# actionType: String = ""   Eg: actionType_example
	# the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER
	actionType: String,
	# ticketObjectType: String = ""   Eg: ticketObjectType_example
	# the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM
	ticketObjectType: String,
	# returnNulls: bool   Eg: true
	# whether to return nulls or not
	returnNulls = null,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id that owns the tickets
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id that owns the tickets
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated. deprecated, use the appKey
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# objectId: float   Eg: 789
	# the ID of the item being purchased
	objectId = null,
	# purchaseCode: String = ""   Eg: purchaseCode_example
	# a unique string identifier defined by the application owner or Executive
	purchaseCode = "",
	# receiptToken: String = ""   Eg: receiptToken_example
	# a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)
	receiptToken = "",
	# receiptData: String = ""   Eg: receiptData_example
	# the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format.
	receiptData = "",
	# count: float   Eg: 789
	# the count of tickets
	count = null,
	# ticketType: String = ""   Eg: ticketType_example
	# the ticket type
	ticketType = "",
	# purchaseProvider: String = ""   Eg: purchaseProvider_example
	# the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}
	purchaseProvider = "",
	# purchaseType: String = ""   Eg: purchaseType_example
	# a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }
	purchaseType = "",
	# returnProfileResponse: bool   Eg: true
	# returns a ProfileResponse if true, otherwise will return an AppResponse
	returnProfileResponse = null,
	# includeProfileResponse: bool   Eg: true
	# if returnProfileResponse is false, will return an AppResponse with profile data if true
	includeProfileResponse = null,
	# appVersion: String = ""   Eg: appVersion_example
	# the application version
	appVersion = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/ticket/save".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["returnNulls"] = returnNulls
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["gameType"] = gameType
	bzz_query["appKey"] = appKey
	bzz_query["actionType"] = actionType
	bzz_query["ticketObjectType"] = ticketObjectType
	bzz_query["objectId"] = objectId
	bzz_query["purchaseCode"] = purchaseCode
	bzz_query["receiptToken"] = receiptToken
	bzz_query["receiptData"] = receiptData
	bzz_query["count"] = count
	bzz_query["ticketType"] = ticketType
	bzz_query["purchaseProvider"] = purchaseProvider
	bzz_query["purchaseType"] = purchaseType
	bzz_query["returnProfileResponse"] = returnProfileResponse
	bzz_query["includeProfileResponse"] = includeProfileResponse
	bzz_query["appVersion"] = appVersion

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ProfileResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func save_ticket_threaded(
	# version: float   Eg: 3.16
	version: float,
	# actionType: String = ""   Eg: actionType_example
	# the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER
	actionType: String,
	# ticketObjectType: String = ""   Eg: ticketObjectType_example
	# the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM
	ticketObjectType: String,
	# returnNulls: bool   Eg: true
	# whether to return nulls or not
	returnNulls = null,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id that owns the tickets
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id that owns the tickets
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated. deprecated, use the appKey
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# objectId: float   Eg: 789
	# the ID of the item being purchased
	objectId = null,
	# purchaseCode: String = ""   Eg: purchaseCode_example
	# a unique string identifier defined by the application owner or Executive
	purchaseCode = "",
	# receiptToken: String = ""   Eg: receiptToken_example
	# a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)
	receiptToken = "",
	# receiptData: String = ""   Eg: receiptData_example
	# the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format.
	receiptData = "",
	# count: float   Eg: 789
	# the count of tickets
	count = null,
	# ticketType: String = ""   Eg: ticketType_example
	# the ticket type
	ticketType = "",
	# purchaseProvider: String = ""   Eg: purchaseProvider_example
	# the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}
	purchaseProvider = "",
	# purchaseType: String = ""   Eg: purchaseType_example
	# a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }
	purchaseType = "",
	# returnProfileResponse: bool   Eg: true
	# returns a ProfileResponse if true, otherwise will return an AppResponse
	returnProfileResponse = null,
	# includeProfileResponse: bool   Eg: true
	# if returnProfileResponse is false, will return an AppResponse with profile data if true
	includeProfileResponse = null,
	# appVersion: String = ""   Eg: appVersion_example
	# the application version
	appVersion = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "save_ticket")
	bzz_callable.bind(
		version,
		actionType,
		ticketObjectType,
		returnNulls,
		deviceId,
		accountId,
		gameType,
		appKey,
		objectId,
		purchaseCode,
		receiptToken,
		receiptData,
		count,
		ticketType,
		purchaseProvider,
		purchaseType,
		returnProfileResponse,
		includeProfileResponse,
		appVersion,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation saveTicketViaFileUpload → POST /api/{version}/ticket/save/fileUpload
# Save Ticket with Reciept
#
# Similar to the Save Ticket endpoint but allows the receiptData to be in binary format. This must be a multi-part post
func save_ticket_via_file_upload(
	# version: float   Eg: 3.16
	version: float,
	# actionType: String = ""   Eg: actionType_example
	# the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER }
	actionType: String,
	# ticketObjectType: String = ""   Eg: ticketObjectType_example
	# the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM}
	ticketObjectType: String,
	# receiptData: String   Eg: BINARY_DATA_HERE
	# the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format.
	receiptData: String,
	# returnNulls: bool   Eg: true
	# whether to return nulls or not
	returnNulls = null,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated. deprecated, use the appKey
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# objectId: float   Eg: 789
	# the ID of the item being purchased
	objectId = null,
	# purchaseCode: String = ""   Eg: purchaseCode_example
	# a unique string identifier defined by the application owner or Executive
	purchaseCode = "",
	# receiptToken: String = ""   Eg: receiptToken_example
	# a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)
	receiptToken = "",
	# count: float   Eg: 789
	# the count of tickets
	count = null,
	# ticketType: String = ""   Eg: ticketType_example
	# the ticket type
	ticketType = "",
	# purchaseProvider: String = ""   Eg: purchaseProvider_example
	# the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}
	purchaseProvider = "",
	# purchaseType: String = ""   Eg: purchaseType_example
	# a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }
	purchaseType = "",
	# returnProfileResponse: bool   Eg: true
	# returns a ProfileResponse if true, otherwise will return an AppResponse
	returnProfileResponse = null,
	# includeProfileResponse: bool   Eg: true
	# if returnProfileResponse is false, will return an AppResponse with profile data if true
	includeProfileResponse = null,
	# appVersion: String = ""   Eg: appVersion_example
	# the application version
	appVersion = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/ticket/save/fileUpload".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["returnNulls"] = returnNulls
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["gameType"] = gameType
	bzz_query["appKey"] = appKey
	bzz_query["actionType"] = actionType
	bzz_query["ticketObjectType"] = ticketObjectType
	bzz_query["objectId"] = objectId
	bzz_query["purchaseCode"] = purchaseCode
	bzz_query["receiptToken"] = receiptToken
	bzz_query["receiptData"] = receiptData
	bzz_query["count"] = count
	bzz_query["ticketType"] = ticketType
	bzz_query["purchaseProvider"] = purchaseProvider
	bzz_query["purchaseType"] = purchaseType
	bzz_query["returnProfileResponse"] = returnProfileResponse
	bzz_query["includeProfileResponse"] = includeProfileResponse
	bzz_query["appVersion"] = appVersion

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ProfileResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func save_ticket_via_file_upload_threaded(
	# version: float   Eg: 3.16
	version: float,
	# actionType: String = ""   Eg: actionType_example
	# the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER }
	actionType: String,
	# ticketObjectType: String = ""   Eg: ticketObjectType_example
	# the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM}
	ticketObjectType: String,
	# receiptData: String   Eg: BINARY_DATA_HERE
	# the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format.
	receiptData: String,
	# returnNulls: bool   Eg: true
	# whether to return nulls or not
	returnNulls = null,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated. deprecated, use the appKey
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# objectId: float   Eg: 789
	# the ID of the item being purchased
	objectId = null,
	# purchaseCode: String = ""   Eg: purchaseCode_example
	# a unique string identifier defined by the application owner or Executive
	purchaseCode = "",
	# receiptToken: String = ""   Eg: receiptToken_example
	# a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)
	receiptToken = "",
	# count: float   Eg: 789
	# the count of tickets
	count = null,
	# ticketType: String = ""   Eg: ticketType_example
	# the ticket type
	ticketType = "",
	# purchaseProvider: String = ""   Eg: purchaseProvider_example
	# the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}
	purchaseProvider = "",
	# purchaseType: String = ""   Eg: purchaseType_example
	# a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }
	purchaseType = "",
	# returnProfileResponse: bool   Eg: true
	# returns a ProfileResponse if true, otherwise will return an AppResponse
	returnProfileResponse = null,
	# includeProfileResponse: bool   Eg: true
	# if returnProfileResponse is false, will return an AppResponse with profile data if true
	includeProfileResponse = null,
	# appVersion: String = ""   Eg: appVersion_example
	# the application version
	appVersion = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "save_ticket_via_file_upload")
	bzz_callable.bind(
		version,
		actionType,
		ticketObjectType,
		receiptData,
		returnNulls,
		deviceId,
		accountId,
		gameType,
		appKey,
		objectId,
		purchaseCode,
		receiptToken,
		count,
		ticketType,
		purchaseProvider,
		purchaseType,
		returnProfileResponse,
		includeProfileResponse,
		appVersion,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation ticketOffers → GET /api/{version}/ticket/ticketoffers
# Get Ticket Offers
#
# Get a list offers for tickets owned by sirqul.  Purchasing these will add the number of tickets to the account specified by the offer.
func ticket_offers(
	# version: float   Eg: 3.16
	version: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/ticket/ticketoffers".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = TicketOfferResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func ticket_offers_threaded(
	# version: float   Eg: 3.16
	version: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "ticket_offers")
	bzz_callable.bind(
		version,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


