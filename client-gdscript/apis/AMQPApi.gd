extends ApiBee
class_name AMQPApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API AMQPApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "AMQPApi"


# Operation consumerCreate → POST /api/{version}/queue/consumer/create
# Create Consumer
#
# Create a connection to an existing amqp queue and register as a consumer.
func consumer_create(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
	appKey: String,
	# name: String = ""   Eg: name_example
	# The name of the queue to connect to
	name: String,
	# hostname: String = ""   Eg: hostname_example
	# The hostname of the server the queue is hosted on
	hostname: String,
	# username: String = ""   Eg: username_example
	# The username to access the server the queue is hosted on
	username: String,
	# password: String = ""   Eg: password_example
	# The password to access the queue to connect to
	password: String,
	# dataMapping: String = ""   Eg: dataMapping_example
	# The data mapping information in the format of AMQPRequest
	dataMapping: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The client deviceID
	deviceId = "",
	# accountId: float   Eg: 789
	# The logged in user ID
	accountId = null,
	# port: int = 5672   Eg: 56
	# The port of the server the queue is hosted on
	port = 5672,
	# virtualHost: String = ""   Eg: virtualHost_example
	# The virtual host defined on the server the queue is associated on
	virtualHost = "",
	# exchanger: String = ""   Eg: exchanger_example
	# The exchanger of the queue to connect to
	exchanger = "",
	# exchangerType: String = ""   Eg: exchangerType_example
	# The exchanger type of the queue to connect to
	exchangerType = "",
	# workers: int = 1   Eg: 56
	# The number of workers to generate 
	workers = 1,
	# useSSL: bool   Eg: true
	# Use SSL
	useSSL = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/queue/consumer/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["name"] = name
	bzz_query["hostname"] = hostname
	bzz_query["port"] = port
	bzz_query["username"] = username
	bzz_query["password"] = password
	bzz_query["virtualHost"] = virtualHost
	bzz_query["exchanger"] = exchanger
	bzz_query["exchangerType"] = exchangerType
	bzz_query["workers"] = workers
	bzz_query["dataMapping"] = dataMapping
	bzz_query["useSSL"] = useSSL

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = QueueResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func consumer_create_threaded(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
	appKey: String,
	# name: String = ""   Eg: name_example
	# The name of the queue to connect to
	name: String,
	# hostname: String = ""   Eg: hostname_example
	# The hostname of the server the queue is hosted on
	hostname: String,
	# username: String = ""   Eg: username_example
	# The username to access the server the queue is hosted on
	username: String,
	# password: String = ""   Eg: password_example
	# The password to access the queue to connect to
	password: String,
	# dataMapping: String = ""   Eg: dataMapping_example
	# The data mapping information in the format of AMQPRequest
	dataMapping: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The client deviceID
	deviceId = "",
	# accountId: float   Eg: 789
	# The logged in user ID
	accountId = null,
	# port: int = 5672   Eg: 56
	# The port of the server the queue is hosted on
	port = 5672,
	# virtualHost: String = ""   Eg: virtualHost_example
	# The virtual host defined on the server the queue is associated on
	virtualHost = "",
	# exchanger: String = ""   Eg: exchanger_example
	# The exchanger of the queue to connect to
	exchanger = "",
	# exchangerType: String = ""   Eg: exchangerType_example
	# The exchanger type of the queue to connect to
	exchangerType = "",
	# workers: int = 1   Eg: 56
	# The number of workers to generate 
	workers = 1,
	# useSSL: bool   Eg: true
	# Use SSL
	useSSL = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "consumer_create")
	bzz_callable.bind(
		version,
		appKey,
		name,
		hostname,
		username,
		password,
		dataMapping,
		deviceId,
		accountId,
		port,
		virtualHost,
		exchanger,
		exchangerType,
		workers,
		useSSL,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation consumerUpdate → POST /api/{version}/queue/consumer/update
# Update Consumer
#
# Update an existing amqp queue's data mapping.
func consumer_update(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
	appKey: String,
	# queueId: float   Eg: 789
	# The queue to update
	queueId: float,
	# dataMapping: String = ""   Eg: dataMapping_example
	# The data mapping information in the format of AMQPRequest
	dataMapping: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The client deviceID
	deviceId = "",
	# accountId: float   Eg: 789
	# The logged in user ID
	accountId = null,
	# useSSL: bool   Eg: true
	# Use SSL
	useSSL = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/queue/consumer/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["queueId"] = queueId
	bzz_query["dataMapping"] = dataMapping
	bzz_query["useSSL"] = useSSL

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = QueueResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func consumer_update_threaded(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
	appKey: String,
	# queueId: float   Eg: 789
	# The queue to update
	queueId: float,
	# dataMapping: String = ""   Eg: dataMapping_example
	# The data mapping information in the format of AMQPRequest
	dataMapping: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The client deviceID
	deviceId = "",
	# accountId: float   Eg: 789
	# The logged in user ID
	accountId = null,
	# useSSL: bool   Eg: true
	# Use SSL
	useSSL = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "consumer_update")
	bzz_callable.bind(
		version,
		appKey,
		queueId,
		dataMapping,
		deviceId,
		accountId,
		useSSL,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation queueCreate → POST /api/{version}/queue/create
# Create Queue
#
# Create a basic AMQP queue. If the username and password and virtual host is not sepcified, the queue will be created on the virtual host assigned to the application.
func queue_create(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key unique to each application.
	appKey: String,
	# name: String = ""   Eg: name_example
	# The name of the queue to create
	name: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The client deviceID
	deviceId = "",
	# accountId: float   Eg: 789
	# The logged in user ID
	accountId = null,
	# workers: int = 1   Eg: 56
	# The number of workers to generate 
	workers = 1,
	# analyticTags: String = ""   Eg: analyticTags_example
	# If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags
	analyticTags = "",
	# hostname: String = ""   Eg: hostname_example
	# The hostname of the server the queue is hosted on
	hostname = "",
	# port: int   Eg: 56
	# The port of the server the queue is hosted on
	port = null,
	# username: String = ""   Eg: username_example
	# The username to access the server that the queue is on
	username = "",
	# password: String = ""   Eg: password_example
	# The password to access the queue to connect to
	password = "",
	# virtualHost: String = ""   Eg: virtualHost_example
	# The virtual host defined on the server to queue
	virtualHost = "",
	# useSSL: bool   Eg: true
	# Use SSL
	useSSL = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/queue/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["name"] = name
	bzz_query["workers"] = workers
	bzz_query["analyticTags"] = analyticTags
	bzz_query["hostname"] = hostname
	bzz_query["port"] = port
	bzz_query["username"] = username
	bzz_query["password"] = password
	bzz_query["virtualHost"] = virtualHost
	bzz_query["useSSL"] = useSSL

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = QueueResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func queue_create_threaded(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key unique to each application.
	appKey: String,
	# name: String = ""   Eg: name_example
	# The name of the queue to create
	name: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The client deviceID
	deviceId = "",
	# accountId: float   Eg: 789
	# The logged in user ID
	accountId = null,
	# workers: int = 1   Eg: 56
	# The number of workers to generate 
	workers = 1,
	# analyticTags: String = ""   Eg: analyticTags_example
	# If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags
	analyticTags = "",
	# hostname: String = ""   Eg: hostname_example
	# The hostname of the server the queue is hosted on
	hostname = "",
	# port: int   Eg: 56
	# The port of the server the queue is hosted on
	port = null,
	# username: String = ""   Eg: username_example
	# The username to access the server that the queue is on
	username = "",
	# password: String = ""   Eg: password_example
	# The password to access the queue to connect to
	password = "",
	# virtualHost: String = ""   Eg: virtualHost_example
	# The virtual host defined on the server to queue
	virtualHost = "",
	# useSSL: bool   Eg: true
	# Use SSL
	useSSL = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "queue_create")
	bzz_callable.bind(
		version,
		appKey,
		name,
		deviceId,
		accountId,
		workers,
		analyticTags,
		hostname,
		port,
		username,
		password,
		virtualHost,
		useSSL,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation queueDelete → POST /api/{version}/queue/delete
# Delete Queue
#
# Delete the stored queue record and close any active connections to the AMQP servers.
func queue_delete(
	# version: float   Eg: 3.16
	version: float,
	# queueId: float   Eg: 789
	# The id of the queue to find
	queueId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The client device ID
	deviceId = "",
	# accountId: float   Eg: 789
	# The logged in user ID
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/queue/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["queueId"] = queueId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func queue_delete_threaded(
	# version: float   Eg: 3.16
	version: float,
	# queueId: float   Eg: 789
	# The id of the queue to find
	queueId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The client device ID
	deviceId = "",
	# accountId: float   Eg: 789
	# The logged in user ID
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "queue_delete")
	bzz_callable.bind(
		version,
		queueId,
		deviceId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation queueGet → GET /api/{version}/queue/get
# Get Queue
#
# Get the stored queue record. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
func queue_get(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The client device ID
	deviceId = "",
	# accountId: float   Eg: 789
	# The logged in user ID
	accountId = null,
	# queueId: float   Eg: 789
	# The id of the queue to find
	queueId = null,
	# appKey: String = ""   Eg: appKey_example
	# The application key the queue was assigned to
	appKey = "",
	# name: String = ""   Eg: name_example
	# The name of the queue to find
	name = "",
	# hostname: String = ""   Eg: hostname_example
	# The hostname of the queue to find
	hostname = "",
	# virtualHost: String = ""   Eg: virtualHost_example
	# The virtual host of the queue to find
	virtualHost = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/queue/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["queueId"] = queueId
	bzz_query["appKey"] = appKey
	bzz_query["name"] = name
	bzz_query["hostname"] = hostname
	bzz_query["virtualHost"] = virtualHost

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = QueueResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func queue_get_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The client device ID
	deviceId = "",
	# accountId: float   Eg: 789
	# The logged in user ID
	accountId = null,
	# queueId: float   Eg: 789
	# The id of the queue to find
	queueId = null,
	# appKey: String = ""   Eg: appKey_example
	# The application key the queue was assigned to
	appKey = "",
	# name: String = ""   Eg: name_example
	# The name of the queue to find
	name = "",
	# hostname: String = ""   Eg: hostname_example
	# The hostname of the queue to find
	hostname = "",
	# virtualHost: String = ""   Eg: virtualHost_example
	# The virtual host of the queue to find
	virtualHost = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "queue_get")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		queueId,
		appKey,
		name,
		hostname,
		virtualHost,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation queuePublish → POST /api/{version}/queue/publish
# Publish Queue
#
# Publish a message to a stored queue. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
func queue_publish(
	# version: float   Eg: 3.16
	version: float,
	# message: String = ""   Eg: message_example
	# The payload to send to the queue
	message: String,
	# queueId: float   Eg: 789
	# The id of the queue to publish to
	queueId = null,
	# appKey: String = ""   Eg: appKey_example
	# The application key the queue was assigned to
	appKey = "",
	# name: String = ""   Eg: name_example
	# The name of the queue to publish to or the analytic tag to handle if the analytic param is true
	name = "",
	# hostname: String = ""   Eg: hostname_example
	# The hostname of the server the queue is hosted on
	hostname = "",
	# virtualHost: String = ""   Eg: virtualHost_example
	# The virtual host defined on the server to queue
	virtualHost = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/queue/publish".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["queueId"] = queueId
	bzz_query["appKey"] = appKey
	bzz_query["name"] = name
	bzz_query["hostname"] = hostname
	bzz_query["virtualHost"] = virtualHost
	bzz_query["message"] = message

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func queue_publish_threaded(
	# version: float   Eg: 3.16
	version: float,
	# message: String = ""   Eg: message_example
	# The payload to send to the queue
	message: String,
	# queueId: float   Eg: 789
	# The id of the queue to publish to
	queueId = null,
	# appKey: String = ""   Eg: appKey_example
	# The application key the queue was assigned to
	appKey = "",
	# name: String = ""   Eg: name_example
	# The name of the queue to publish to or the analytic tag to handle if the analytic param is true
	name = "",
	# hostname: String = ""   Eg: hostname_example
	# The hostname of the server the queue is hosted on
	hostname = "",
	# virtualHost: String = ""   Eg: virtualHost_example
	# The virtual host defined on the server to queue
	virtualHost = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "queue_publish")
	bzz_callable.bind(
		version,
		message,
		queueId,
		appKey,
		name,
		hostname,
		virtualHost,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation queueSearch → GET /api/{version}/queue/search
# Search Queue
#
# Get the queues setup for the BillableEntity's applications.
func queue_search(
	# version: float   Eg: 3.16
	version: float,
	# queueId: float   Eg: 789
	# The id of the queue to find
	queueId = null,
	# deviceId: String = ""   Eg: deviceId_example
	# The client device ID
	deviceId = "",
	# accountId: float   Eg: 789
	# The logged in user ID
	accountId = null,
	# name: String = ""   Eg: name_example
	# The name of the queue to find
	name = "",
	# start: int = 0   Eg: 56
	# Start of the index
	start = 0,
	# limit: int = 10   Eg: 56
	# Limit of the index
	limit = 10,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/queue/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["queueId"] = queueId
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["name"] = name
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = QueueResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func queue_search_threaded(
	# version: float   Eg: 3.16
	version: float,
	# queueId: float   Eg: 789
	# The id of the queue to find
	queueId = null,
	# deviceId: String = ""   Eg: deviceId_example
	# The client device ID
	deviceId = "",
	# accountId: float   Eg: 789
	# The logged in user ID
	accountId = null,
	# name: String = ""   Eg: name_example
	# The name of the queue to find
	name = "",
	# start: int = 0   Eg: 56
	# Start of the index
	start = 0,
	# limit: int = 10   Eg: 56
	# Limit of the index
	limit = 10,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "queue_search")
	bzz_callable.bind(
		version,
		queueId,
		deviceId,
		accountId,
		name,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation queueUpdate → POST /api/{version}/queue/update
# Update Queue
#
# Update the basic AMQP queue.
func queue_update(
	# version: float   Eg: 3.16
	version: float,
	# queueId: float   Eg: 789
	# The id of the queue to update
	queueId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The client deviceID
	deviceId = "",
	# accountId: float   Eg: 789
	# The logged in user ID
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# The application key unique to each application.
	appKey = "",
	# workers: int   Eg: 56
	# The number of workers to generate
	workers = null,
	# analyticTags: String = ""   Eg: analyticTags_example
	# If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags
	analyticTags = "",
	# hostname: String = ""   Eg: hostname_example
	# The hostname of the server the queue is hosted on
	hostname = "",
	# port: int   Eg: 56
	# The port of the server the queue is hosted on
	port = null,
	# username: String = ""   Eg: username_example
	# The username to access the server that the queue is on
	username = "",
	# password: String = ""   Eg: password_example
	# The password to access the queue to connect to
	password = "",
	# virtualHost: String = ""   Eg: virtualHost_example
	# The virtual host defined on the server to queue
	virtualHost = "",
	# useSSL: bool   Eg: true
	# the SSL to use
	useSSL = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/queue/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["queueId"] = queueId
	bzz_query["workers"] = workers
	bzz_query["analyticTags"] = analyticTags
	bzz_query["hostname"] = hostname
	bzz_query["port"] = port
	bzz_query["username"] = username
	bzz_query["password"] = password
	bzz_query["virtualHost"] = virtualHost
	bzz_query["useSSL"] = useSSL

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = QueueResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func queue_update_threaded(
	# version: float   Eg: 3.16
	version: float,
	# queueId: float   Eg: 789
	# The id of the queue to update
	queueId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The client deviceID
	deviceId = "",
	# accountId: float   Eg: 789
	# The logged in user ID
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# The application key unique to each application.
	appKey = "",
	# workers: int   Eg: 56
	# The number of workers to generate
	workers = null,
	# analyticTags: String = ""   Eg: analyticTags_example
	# If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags
	analyticTags = "",
	# hostname: String = ""   Eg: hostname_example
	# The hostname of the server the queue is hosted on
	hostname = "",
	# port: int   Eg: 56
	# The port of the server the queue is hosted on
	port = null,
	# username: String = ""   Eg: username_example
	# The username to access the server that the queue is on
	username = "",
	# password: String = ""   Eg: password_example
	# The password to access the queue to connect to
	password = "",
	# virtualHost: String = ""   Eg: virtualHost_example
	# The virtual host defined on the server to queue
	virtualHost = "",
	# useSSL: bool   Eg: true
	# the SSL to use
	useSSL = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "queue_update")
	bzz_callable.bind(
		version,
		queueId,
		deviceId,
		accountId,
		appKey,
		workers,
		analyticTags,
		hostname,
		port,
		username,
		password,
		virtualHost,
		useSSL,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


