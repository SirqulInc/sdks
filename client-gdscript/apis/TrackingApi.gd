extends ApiBee
class_name TrackingApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API TrackingApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "TrackingApi"


# Operation batchSaveTracking → POST /tracking/batch/create
# Create Batch Tracking
#
# Batch create tracking legs
func batch_save_tracking(
	# data: String = ""   Eg: data_example
	# JSON array of tracking legs ```json [   \"distance\": \"0.08\",   \"duration\": \"10000\",   \"startLatitude\": \"47.614603\",   \"startLongitude\": \"-122.350518\",   \"endLatitude\": \"47.614384\",   \"endLongitude\": \"-122.349161\",   \"startDate\": \"1361924010000\",   \"endDate\": \"1361924020000\",   \"steps\": [     {       \"distance\": \"0.03\",       \"duration\": \"5000\",       \"startLat\": \"47.614603\",       \"startLng\": \"-122.350518\",       \"startDate\": \"1361924010000\",       \"endLat\": \"47.614941\",       \"endLng\": \"-122.350062\",       \"endDate\": \"1361924015000\"     },{       \"distance\": \"0.05\",       \"duration\": \"5000\",       \"startLat\": \"47.614941\",       \"startLng\": \"-122.350062\",       \"startDate\": \"1361924015000\",       \"endLat\": \"47.614384\",       \"endLng\": \"-122.349161\",       \"endDate\": \"1361924020000\"     }   ] ] ``` 
	data: String,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# generateAccounts: bool   Eg: true
	# Whether to generate accounts for tracking entries when the owner does not exist
	generateAccounts = null,
	# updateAccountLocations: bool   Eg: true
	# Whether to update the account's current location from the incoming tracking data
	updateAccountLocations = null,
	# defaultTag: String = "PASSIVE"   Eg: defaultTag_example
	# The default tag to apply to incoming legs when no tag is provided
	defaultTag = "PASSIVE",
	# slaveUID: String = ""   Eg: slaveUID_example
	slaveUID = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/tracking/batch/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["data"] = data
	bzz_query["generateAccounts"] = generateAccounts
	bzz_query["updateAccountLocations"] = updateAccountLocations
	bzz_query["defaultTag"] = defaultTag
	bzz_query["slaveUID"] = slaveUID

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = Leg.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func batch_save_tracking_threaded(
	# data: String = ""   Eg: data_example
	# JSON array of tracking legs ```json [   \"distance\": \"0.08\",   \"duration\": \"10000\",   \"startLatitude\": \"47.614603\",   \"startLongitude\": \"-122.350518\",   \"endLatitude\": \"47.614384\",   \"endLongitude\": \"-122.349161\",   \"startDate\": \"1361924010000\",   \"endDate\": \"1361924020000\",   \"steps\": [     {       \"distance\": \"0.03\",       \"duration\": \"5000\",       \"startLat\": \"47.614603\",       \"startLng\": \"-122.350518\",       \"startDate\": \"1361924010000\",       \"endLat\": \"47.614941\",       \"endLng\": \"-122.350062\",       \"endDate\": \"1361924015000\"     },{       \"distance\": \"0.05\",       \"duration\": \"5000\",       \"startLat\": \"47.614941\",       \"startLng\": \"-122.350062\",       \"startDate\": \"1361924015000\",       \"endLat\": \"47.614384\",       \"endLng\": \"-122.349161\",       \"endDate\": \"1361924020000\"     }   ] ] ``` 
	data: String,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# generateAccounts: bool   Eg: true
	# Whether to generate accounts for tracking entries when the owner does not exist
	generateAccounts = null,
	# updateAccountLocations: bool   Eg: true
	# Whether to update the account's current location from the incoming tracking data
	updateAccountLocations = null,
	# defaultTag: String = "PASSIVE"   Eg: defaultTag_example
	# The default tag to apply to incoming legs when no tag is provided
	defaultTag = "PASSIVE",
	# slaveUID: String = ""   Eg: slaveUID_example
	slaveUID = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "batch_save_tracking")
	bzz_callable.bind(
		data,
		deviceId,
		accountId,
		generateAccounts,
		updateAccountLocations,
		defaultTag,
		slaveUID,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getPredictedLocations → GET /tracking/predicted/get
# Get Predicted Locations
#
# Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.
func get_predicted_locations(
	# accountId: float   Eg: 789
	# The account id of the customer
	accountId: float,
	# latitude: int   Eg: 1.2
	# latitude to return a more likely result set based on the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude to return a more likely result set based on the user's current location
	longitude = null,
	# dateCheck: float   Eg: 789
	# Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, the current date will be used.
	dateCheck = null,
	# hourCheck: String = ""   Eg: hourCheck_example
	# Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".
	hourCheck = "",
	# threshold: float = 1   Eg: 789
	# The minimum number matches in 1 hour to be considered a likely location.
	threshold = 1,
	# distanceUnit: String = "MILES"   Eg: distanceUnit_example
	# Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}
	distanceUnit = "MILES",
	# searchRange: int = 0   Eg: 1.2
	# Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.
	searchRange = 0,
	# sortOrder: String = "MATCHES"   Eg: sortOrder_example
	# The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED}
	sortOrder = "MATCHES",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/tracking/predicted/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["dateCheck"] = dateCheck
	bzz_query["hourCheck"] = hourCheck
	bzz_query["threshold"] = threshold
	bzz_query["distanceUnit"] = distanceUnit
	bzz_query["searchRange"] = searchRange
	bzz_query["sortOrder"] = sortOrder

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PredictedLocationResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_predicted_locations_threaded(
	# accountId: float   Eg: 789
	# The account id of the customer
	accountId: float,
	# latitude: int   Eg: 1.2
	# latitude to return a more likely result set based on the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude to return a more likely result set based on the user's current location
	longitude = null,
	# dateCheck: float   Eg: 789
	# Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, the current date will be used.
	dateCheck = null,
	# hourCheck: String = ""   Eg: hourCheck_example
	# Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".
	hourCheck = "",
	# threshold: float = 1   Eg: 789
	# The minimum number matches in 1 hour to be considered a likely location.
	threshold = 1,
	# distanceUnit: String = "MILES"   Eg: distanceUnit_example
	# Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}
	distanceUnit = "MILES",
	# searchRange: int = 0   Eg: 1.2
	# Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.
	searchRange = 0,
	# sortOrder: String = "MATCHES"   Eg: sortOrder_example
	# The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED}
	sortOrder = "MATCHES",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_predicted_locations")
	bzz_callable.bind(
		accountId,
		latitude,
		longitude,
		dateCheck,
		hourCheck,
		threshold,
		distanceUnit,
		searchRange,
		sortOrder,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getPredictedPath → GET /tracking/path/get
# Get Tracking Path
#
# Get the path (lat/long coordinates) between 2 steps previously logged for a customer.
func get_predicted_path(
	# accountId: float   Eg: 789
	# The account id of the customer
	accountId: float,
	# startStepId: float   Eg: 789
	# The stepId to begin from
	startStepId: float,
	# endStepId: float   Eg: 789
	# The stepId to end with
	endStepId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/tracking/path/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["startStepId"] = startStepId
	bzz_query["endStepId"] = endStepId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = StepResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_predicted_path_threaded(
	# accountId: float   Eg: 789
	# The account id of the customer
	accountId: float,
	# startStepId: float   Eg: 789
	# The stepId to begin from
	startStepId: float,
	# endStepId: float   Eg: 789
	# The stepId to end with
	endStepId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_predicted_path")
	bzz_callable.bind(
		accountId,
		startStepId,
		endStepId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getPreferredLocations → GET /tracking/preferred/search
# Search Preferred Locations
#
# Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.
func get_preferred_locations(
	# accountId: float   Eg: 789
	# The account id of the customer
	accountId: float,
	# latitude: int   Eg: 1.2
	# latitude to return a more likely result set based on the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude to return a more likely result set based on the user's current location
	longitude = null,
	# dateCheck: float   Eg: 789
	# Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.
	dateCheck = null,
	# hourCheck: String = ""   Eg: hourCheck_example
	# Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".
	hourCheck = "",
	# sortField: String = "PREFERRED_DATE"   Eg: sortField_example
	# Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location
	sortField = "PREFERRED_DATE",
	# descending: bool = true   Eg: true
	# Determines whether the sorted list is in descending or ascending order
	descending = true,
	# start: int = 0   Eg: 56
	# The start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# The limit for pagination
	limit = 20,
	# searchRange: int = 0   Eg: 1.2
	# Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.
	searchRange = 0,
	# distanceUnit: String = "MILES"   Eg: distanceUnit_example
	# Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}
	distanceUnit = "MILES",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/tracking/preferred/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["dateCheck"] = dateCheck
	bzz_query["hourCheck"] = hourCheck
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["searchRange"] = searchRange
	bzz_query["distanceUnit"] = distanceUnit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PreferredLocationResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_preferred_locations_threaded(
	# accountId: float   Eg: 789
	# The account id of the customer
	accountId: float,
	# latitude: int   Eg: 1.2
	# latitude to return a more likely result set based on the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude to return a more likely result set based on the user's current location
	longitude = null,
	# dateCheck: float   Eg: 789
	# Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.
	dateCheck = null,
	# hourCheck: String = ""   Eg: hourCheck_example
	# Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".
	hourCheck = "",
	# sortField: String = "PREFERRED_DATE"   Eg: sortField_example
	# Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location
	sortField = "PREFERRED_DATE",
	# descending: bool = true   Eg: true
	# Determines whether the sorted list is in descending or ascending order
	descending = true,
	# start: int = 0   Eg: 56
	# The start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# The limit for pagination
	limit = 20,
	# searchRange: int = 0   Eg: 1.2
	# Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.
	searchRange = 0,
	# distanceUnit: String = "MILES"   Eg: distanceUnit_example
	# Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}
	distanceUnit = "MILES",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_preferred_locations")
	bzz_callable.bind(
		accountId,
		latitude,
		longitude,
		dateCheck,
		hourCheck,
		sortField,
		descending,
		start,
		limit,
		searchRange,
		distanceUnit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getTrackingLegs → GET /tracking/search
# Search Tracking
#
# Retrieve tracking data to be able to show where a user has been.
func get_tracking_legs(
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# ownerId: float   Eg: 789
	# the account id of the person the user wants to tracking data for
	ownerId = null,
	# trackingDeviceId: String = ""   Eg: trackingDeviceId_example
	# the id of the tracking device
	trackingDeviceId = "",
	# startDate: float   Eg: 789
	# the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.
	startDate = null,
	# endDate: float   Eg: 789
	# the end date in (UTC milliseconds) to filter the tracking results
	endDate = null,
	# tags: String = ""   Eg: tags_example
	# filter results by tag
	tags = "",
	# getLastPoint: bool = false   Eg: true
	# gets the last known location of the user
	getLastPoint = false,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/tracking/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["ownerId"] = ownerId
	bzz_query["trackingDeviceId"] = trackingDeviceId
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["tags"] = tags
	bzz_query["getLastPoint"] = getLastPoint

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = LegResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_tracking_legs_threaded(
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# ownerId: float   Eg: 789
	# the account id of the person the user wants to tracking data for
	ownerId = null,
	# trackingDeviceId: String = ""   Eg: trackingDeviceId_example
	# the id of the tracking device
	trackingDeviceId = "",
	# startDate: float   Eg: 789
	# the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.
	startDate = null,
	# endDate: float   Eg: 789
	# the end date in (UTC milliseconds) to filter the tracking results
	endDate = null,
	# tags: String = ""   Eg: tags_example
	# filter results by tag
	tags = "",
	# getLastPoint: bool = false   Eg: true
	# gets the last known location of the user
	getLastPoint = false,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_tracking_legs")
	bzz_callable.bind(
		deviceId,
		accountId,
		ownerId,
		trackingDeviceId,
		startDate,
		endDate,
		tags,
		getLastPoint,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation saveTrackingLeg → POST /tracking/leg/create
# Create Tracking Leg
#
# Send tracking points to be able to generate pathing data
func save_tracking_leg(
	# startLat: int   Eg: 1.2
	# the latitude of the first point
	startLat: int,
	# startLng: int   Eg: 1.2
	# the longitude of the first point
	startLng: int,
	# startDate: float   Eg: 789
	# the start date (in UTC milliseconds) of the first point
	startDate: float,
	# endLat: int   Eg: 1.2
	# the latitude of the last point
	endLat: int,
	# endLng: int   Eg: 1.2
	# the longitude of the last point
	endLng: int,
	# endDate: float   Eg: 789
	# the end date (in UTC milliseconds) of the last point
	endDate: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# distance: int   Eg: 1.2
	# the total distance
	distance = null,
	# duration: float   Eg: 789
	# the total duration
	duration = null,
	# steps: String = ""   Eg: steps_example
	# JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. ```json [{   \"distance\": \"0.03\",   \"duration\": \"5000\",   \"startLat\": \"47.614603\",   \"startLng\": \"-122.350518\",   \"startDate\": \"1361924010000\",   \"endLat\": \"47.614941\",   \"endLng\": \"-122.350062\",   \"endDate\": \"1361924015000\" }] ``` 
	steps = "",
	# tags: String = ""   Eg: tags_example
	# name the leg for searching
	tags = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/tracking/leg/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["distance"] = distance
	bzz_query["duration"] = duration
	bzz_query["startLat"] = startLat
	bzz_query["startLng"] = startLng
	bzz_query["startDate"] = startDate
	bzz_query["endLat"] = endLat
	bzz_query["endLng"] = endLng
	bzz_query["endDate"] = endDate
	bzz_query["steps"] = steps
	bzz_query["tags"] = tags

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func save_tracking_leg_threaded(
	# startLat: int   Eg: 1.2
	# the latitude of the first point
	startLat: int,
	# startLng: int   Eg: 1.2
	# the longitude of the first point
	startLng: int,
	# startDate: float   Eg: 789
	# the start date (in UTC milliseconds) of the first point
	startDate: float,
	# endLat: int   Eg: 1.2
	# the latitude of the last point
	endLat: int,
	# endLng: int   Eg: 1.2
	# the longitude of the last point
	endLng: int,
	# endDate: float   Eg: 789
	# the end date (in UTC milliseconds) of the last point
	endDate: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# distance: int   Eg: 1.2
	# the total distance
	distance = null,
	# duration: float   Eg: 789
	# the total duration
	duration = null,
	# steps: String = ""   Eg: steps_example
	# JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. ```json [{   \"distance\": \"0.03\",   \"duration\": \"5000\",   \"startLat\": \"47.614603\",   \"startLng\": \"-122.350518\",   \"startDate\": \"1361924010000\",   \"endLat\": \"47.614941\",   \"endLng\": \"-122.350062\",   \"endDate\": \"1361924015000\" }] ``` 
	steps = "",
	# tags: String = ""   Eg: tags_example
	# name the leg for searching
	tags = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "save_tracking_leg")
	bzz_callable.bind(
		startLat,
		startLng,
		startDate,
		endLat,
		endLng,
		endDate,
		deviceId,
		accountId,
		distance,
		duration,
		steps,
		tags,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation saveTrackingStep → POST /tracking/step/create
# Create Tracking Step
#
# Send tracking points to be able to generate pathing data
func save_tracking_step(
	# legId: float   Eg: 789
	# the leg to add the step to
	legId: float,
	# startLat: int   Eg: 1.2
	# the latitude of the first point
	startLat: int,
	# startLng: int   Eg: 1.2
	# the longitude of the first point
	startLng: int,
	# startDate: float   Eg: 789
	# the start date (in UTC milliseconds) of the first point
	startDate: float,
	# endLat: int   Eg: 1.2
	# the latitude of the last point
	endLat: int,
	# endLng: int   Eg: 1.2
	# the longitude of the last point
	endLng: int,
	# endDate: float   Eg: 789
	# the end date (in UTC milliseconds) of the last point
	endDate: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# distance: int   Eg: 1.2
	# the total distance
	distance = null,
	# duration: float   Eg: 789
	# the total duration
	duration = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/tracking/step/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["legId"] = legId
	bzz_query["distance"] = distance
	bzz_query["duration"] = duration
	bzz_query["startLat"] = startLat
	bzz_query["startLng"] = startLng
	bzz_query["startDate"] = startDate
	bzz_query["endLat"] = endLat
	bzz_query["endLng"] = endLng
	bzz_query["endDate"] = endDate

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func save_tracking_step_threaded(
	# legId: float   Eg: 789
	# the leg to add the step to
	legId: float,
	# startLat: int   Eg: 1.2
	# the latitude of the first point
	startLat: int,
	# startLng: int   Eg: 1.2
	# the longitude of the first point
	startLng: int,
	# startDate: float   Eg: 789
	# the start date (in UTC milliseconds) of the first point
	startDate: float,
	# endLat: int   Eg: 1.2
	# the latitude of the last point
	endLat: int,
	# endLng: int   Eg: 1.2
	# the longitude of the last point
	endLng: int,
	# endDate: float   Eg: 789
	# the end date (in UTC milliseconds) of the last point
	endDate: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# distance: int   Eg: 1.2
	# the total distance
	distance = null,
	# duration: float   Eg: 789
	# the total duration
	duration = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "save_tracking_step")
	bzz_callable.bind(
		legId,
		startLat,
		startLng,
		startDate,
		endLat,
		endLng,
		endDate,
		deviceId,
		accountId,
		distance,
		duration,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchAccountsWithTrackingLegs → GET /tracking/list
# List Tracking
#
# Search for all accounts that have tracking legs data by the given constraints.
func search_accounts_with_tracking_legs(
	# accountId: float   Eg: 789
	# The account id of the user
	accountId: float,
	# keyword: String = ""   Eg: keyword_example
	# Used for LIKE search of first or last name on the acocunt
	keyword = "",
	# startDate: float   Eg: 789
	# Range to begin in UTC milliseconds
	startDate = null,
	# endDate: float   Eg: 789
	# Range to end in UTC milliseconds
	endDate = null,
	# tags: String = ""   Eg: tags_example
	# Exact match on tag field of Legs's searchTag
	tags = "",
	# audienceIds: String = ""   Eg: audienceIds_example
	audienceIds = "",
	# latitude: int   Eg: 1.2
	# Origin latitude to perform searching constraints with given range
	latitude = null,
	# longitude: int   Eg: 1.2
	# Origin longitude to perform searching constraints with given range
	longitude = null,
	# some_range: int = 5   Eg: 1.2
	# The radius, in miles, to perform the search for
	some_range = 5,
	# sortField: String = "LEG_START_DATE"   Eg: sortField_example
	# The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY}
	sortField = "LEG_START_DATE",
	# descending: bool = true   Eg: true
	# The order to return the results. Default is false, which will return the results in ascending order.
	descending = true,
	# start: int = 0   Eg: 56
	# The index into the record set to start with. Default is 0.
	start = 0,
	# limit: int = 20   Eg: 56
	# The total number of records to return. Default is 20.
	limit = 20,
	# activeOnly: bool = false   Eg: true
	# Determines whether to return only active results. Default is false.
	activeOnly = false,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/tracking/list"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["keyword"] = keyword
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["tags"] = tags
	bzz_query["audienceIds"] = audienceIds
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["range"] = some_range
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["activeOnly"] = activeOnly

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AccountMiniResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_accounts_with_tracking_legs_threaded(
	# accountId: float   Eg: 789
	# The account id of the user
	accountId: float,
	# keyword: String = ""   Eg: keyword_example
	# Used for LIKE search of first or last name on the acocunt
	keyword = "",
	# startDate: float   Eg: 789
	# Range to begin in UTC milliseconds
	startDate = null,
	# endDate: float   Eg: 789
	# Range to end in UTC milliseconds
	endDate = null,
	# tags: String = ""   Eg: tags_example
	# Exact match on tag field of Legs's searchTag
	tags = "",
	# audienceIds: String = ""   Eg: audienceIds_example
	audienceIds = "",
	# latitude: int   Eg: 1.2
	# Origin latitude to perform searching constraints with given range
	latitude = null,
	# longitude: int   Eg: 1.2
	# Origin longitude to perform searching constraints with given range
	longitude = null,
	# some_range: int = 5   Eg: 1.2
	# The radius, in miles, to perform the search for
	some_range = 5,
	# sortField: String = "LEG_START_DATE"   Eg: sortField_example
	# The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY}
	sortField = "LEG_START_DATE",
	# descending: bool = true   Eg: true
	# The order to return the results. Default is false, which will return the results in ascending order.
	descending = true,
	# start: int = 0   Eg: 56
	# The index into the record set to start with. Default is 0.
	start = 0,
	# limit: int = 20   Eg: 56
	# The total number of records to return. Default is 20.
	limit = 20,
	# activeOnly: bool = false   Eg: true
	# Determines whether to return only active results. Default is false.
	activeOnly = false,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_accounts_with_tracking_legs")
	bzz_callable.bind(
		accountId,
		keyword,
		startDate,
		endDate,
		tags,
		audienceIds,
		latitude,
		longitude,
		some_range,
		sortField,
		descending,
		start,
		limit,
		activeOnly,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchTrackingLegs → GET /tracking/searchByBillable
# Search Tracking (Billable)
#
# Retrieve tracking data for billable/account scoped queries.
func search_tracking_legs(
	# accountId: float   Eg: 789
	# The account id to search tracking for
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key
	appKey: String,
	# trackingDeviceId: String = ""   Eg: trackingDeviceId_example
	# The id of the tracking device
	trackingDeviceId = "",
	# startDate: float   Eg: 789
	# The start date in (UTC milliseconds) to filter the tracking results
	startDate = null,
	# endDate: float   Eg: 789
	# The end date in (UTC milliseconds) to filter the tracking results
	endDate = null,
	# tags: String = ""   Eg: tags_example
	# Filter results by tag
	tags = "",
	# start: int = 0   Eg: 56
	# The start index for pagination
	start = 0,
	# limit: int = 100   Eg: 56
	# The limit for pagination
	limit = 100,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/tracking/searchByBillable"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["trackingDeviceId"] = trackingDeviceId
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["tags"] = tags
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = LegResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_tracking_legs_threaded(
	# accountId: float   Eg: 789
	# The account id to search tracking for
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key
	appKey: String,
	# trackingDeviceId: String = ""   Eg: trackingDeviceId_example
	# The id of the tracking device
	trackingDeviceId = "",
	# startDate: float   Eg: 789
	# The start date in (UTC milliseconds) to filter the tracking results
	startDate = null,
	# endDate: float   Eg: 789
	# The end date in (UTC milliseconds) to filter the tracking results
	endDate = null,
	# tags: String = ""   Eg: tags_example
	# Filter results by tag
	tags = "",
	# start: int = 0   Eg: 56
	# The start index for pagination
	start = 0,
	# limit: int = 100   Eg: 56
	# The limit for pagination
	limit = 100,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_tracking_legs")
	bzz_callable.bind(
		accountId,
		appKey,
		trackingDeviceId,
		startDate,
		endDate,
		tags,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


