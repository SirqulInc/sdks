extends ApiBee
class_name AppDataApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API AppDataApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "AppDataApi"


# Operation getAppData → GET /app/get
# Get App Data
#
# Get the application data structure.  The basic structure is a   node tree, with the root node being a AppResponse.  The response contains   the user's profile, messages from the system, and a list of MissionResponse.    A mission can have any number of GameResponses but typically is a single   game type.  A game then has any number of PackResponses which help group   the game levels. Packs are then composed of any number of GameLevelResponses.     Using the various parameters can return the applications default mission   (built-in packs to play), the list of community levels published, the user's   saved levels, or explicity levels desired.  You can choose to include the   profile or not, or just return parts of the profile.  You can also filter   out game levels that have been published with a higher version of the application.
func get_app_data(
	# start: int   Eg: 56
	# start the search results at a record.
	start: int,
	# limit: int   Eg: 56
	# limit the search results to some number.
	limit: int,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required).
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required).
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# the game to retrieve the data for, use your application key.
	gameType = "",
	# includeGameData: bool   Eg: true
	# if true then include the game data blob, otherwise don't include.
	includeGameData = null,
	# q: String = ""   Eg: q_example
	# This parameter is deprecated.
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# query string used to filter the search results when looking for community and saved levels.
	keyword = "",
	# sortField: String = ""   Eg: sortField_example
	# how to sort the results when looking for community and saved levels. possible values are: LEVEL_NAME, LEVEL_CREATED, LEVEL_UPDATED, LEVEL_LIKES, LEVEL_DISLIKES, LEVEL_NOTES, LEVEL_PLAYS.
	sortField = "",
	# descending: bool   Eg: true
	# order the search results descending or ascending when looking for community and saved levels.
	descending = null,
	# i: int   Eg: 56
	# This parameter is deprecated.
	i = null,
	# l: int   Eg: 56
	# This parameter is deprecated.
	l = null,
	# gameObjectCount: bool   Eg: true
	# if true then include the game object count, otherwise don't include.
	gameObjectCount = null,
	# filter: String = ""   Eg: filter_example
	# restrict the search to items with certain permissions, possible values are: MINE, FRIENDS, PUBLIC, ALL_PUBLIC, ALL, LIKED
	filter = "",
	# dateCreated: float   Eg: 789
	# restrict the search to items created less then date
	dateCreated = null,
	# ownerId: float   Eg: 789
	# get levels owned by a particular account
	ownerId = null,
	# missionIds: String = ""   Eg: missionIds_example
	# get missions by specified id, comman seperated list of long ids
	missionIds = "",
	# gameIds: String = ""   Eg: gameIds_example
	# get games by specified id, comman seperated list of long ids
	gameIds = "",
	# packIds: String = ""   Eg: packIds_example
	# get packs by specified id, comman seperated list of long ids
	packIds = "",
	# gameLevelIds: String = ""   Eg: gameLevelIds_example
	# get game levels by specified id, comman seperated list of long ids
	gameLevelIds = "",
	# appVersion: String = ""   Eg: appVersion_example
	# the application version, used to versin the game level data
	appVersion = "",
	# includeHigherVersionPacks: bool   Eg: true
	# default is false and will not include any packs that have levels above the specified appVersion. If true then will return all levels regardless of version.
	includeHigherVersionPacks = null,
	# includeHigherVersionLevels: bool   Eg: true
	# default is false and will not include any levels above the specified appVersion. If true then will return all levels regardless of version.
	includeHigherVersionLevels = null,
	# responseGroups: String = ""   Eg: responseGroups_example
	# use response groups to include large parts of the structure. possible values are: * MISSION_DEFAULT (default) - include the default mission (built-in packs), excludes all other mission groups * MISSION_DEFAULT_LEVELS_SAVED - include saved levels, excludes all other mission groups * MISSION_DEFAULT_LEVELS_COMMUNITY - include community levels, excludes all other mission groups * MISSION_INVITED (default) - include challenges sent to user * PROFILE (default) - include entire profile * PROFILE_DATA - only include profile date (exclude friends) * PROFILE_FRIENDS - include friends list 
	responseGroups = "",
	# purchaseType: String = ""   Eg: purchaseType_example
	# the will return the correct in app purchases for the device, possible values are: * SIRQUL (default) - purchasing from the sirqul store using tickets * IOS - purchasing from the itunes store for iPhone, iPod, iPod Touch * GOOGLE - purchasing from the google android store * AMAZON - purchasing from the amazon android store * MAC - purchasing from the itunes store for OSX * FREE - the item is free to purchase 
	purchaseType = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/app/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["gameType"] = gameType
	bzz_query["includeGameData"] = includeGameData
	bzz_query["q"] = q
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["_i"] = i
	bzz_query["start"] = start
	bzz_query["_l"] = l
	bzz_query["limit"] = limit
	bzz_query["gameObjectCount"] = gameObjectCount
	bzz_query["filter"] = filter
	bzz_query["dateCreated"] = dateCreated
	bzz_query["ownerId"] = ownerId
	bzz_query["missionIds"] = missionIds
	bzz_query["gameIds"] = gameIds
	bzz_query["packIds"] = packIds
	bzz_query["gameLevelIds"] = gameLevelIds
	bzz_query["appVersion"] = appVersion
	bzz_query["includeHigherVersionPacks"] = includeHigherVersionPacks
	bzz_query["includeHigherVersionLevels"] = includeHigherVersionLevels
	bzz_query["responseGroups"] = responseGroups
	bzz_query["purchaseType"] = purchaseType

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AppResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_app_data_threaded(
	# start: int   Eg: 56
	# start the search results at a record.
	start: int,
	# limit: int   Eg: 56
	# limit the search results to some number.
	limit: int,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required).
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required).
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# the game to retrieve the data for, use your application key.
	gameType = "",
	# includeGameData: bool   Eg: true
	# if true then include the game data blob, otherwise don't include.
	includeGameData = null,
	# q: String = ""   Eg: q_example
	# This parameter is deprecated.
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# query string used to filter the search results when looking for community and saved levels.
	keyword = "",
	# sortField: String = ""   Eg: sortField_example
	# how to sort the results when looking for community and saved levels. possible values are: LEVEL_NAME, LEVEL_CREATED, LEVEL_UPDATED, LEVEL_LIKES, LEVEL_DISLIKES, LEVEL_NOTES, LEVEL_PLAYS.
	sortField = "",
	# descending: bool   Eg: true
	# order the search results descending or ascending when looking for community and saved levels.
	descending = null,
	# i: int   Eg: 56
	# This parameter is deprecated.
	i = null,
	# l: int   Eg: 56
	# This parameter is deprecated.
	l = null,
	# gameObjectCount: bool   Eg: true
	# if true then include the game object count, otherwise don't include.
	gameObjectCount = null,
	# filter: String = ""   Eg: filter_example
	# restrict the search to items with certain permissions, possible values are: MINE, FRIENDS, PUBLIC, ALL_PUBLIC, ALL, LIKED
	filter = "",
	# dateCreated: float   Eg: 789
	# restrict the search to items created less then date
	dateCreated = null,
	# ownerId: float   Eg: 789
	# get levels owned by a particular account
	ownerId = null,
	# missionIds: String = ""   Eg: missionIds_example
	# get missions by specified id, comman seperated list of long ids
	missionIds = "",
	# gameIds: String = ""   Eg: gameIds_example
	# get games by specified id, comman seperated list of long ids
	gameIds = "",
	# packIds: String = ""   Eg: packIds_example
	# get packs by specified id, comman seperated list of long ids
	packIds = "",
	# gameLevelIds: String = ""   Eg: gameLevelIds_example
	# get game levels by specified id, comman seperated list of long ids
	gameLevelIds = "",
	# appVersion: String = ""   Eg: appVersion_example
	# the application version, used to versin the game level data
	appVersion = "",
	# includeHigherVersionPacks: bool   Eg: true
	# default is false and will not include any packs that have levels above the specified appVersion. If true then will return all levels regardless of version.
	includeHigherVersionPacks = null,
	# includeHigherVersionLevels: bool   Eg: true
	# default is false and will not include any levels above the specified appVersion. If true then will return all levels regardless of version.
	includeHigherVersionLevels = null,
	# responseGroups: String = ""   Eg: responseGroups_example
	# use response groups to include large parts of the structure. possible values are: * MISSION_DEFAULT (default) - include the default mission (built-in packs), excludes all other mission groups * MISSION_DEFAULT_LEVELS_SAVED - include saved levels, excludes all other mission groups * MISSION_DEFAULT_LEVELS_COMMUNITY - include community levels, excludes all other mission groups * MISSION_INVITED (default) - include challenges sent to user * PROFILE (default) - include entire profile * PROFILE_DATA - only include profile date (exclude friends) * PROFILE_FRIENDS - include friends list 
	responseGroups = "",
	# purchaseType: String = ""   Eg: purchaseType_example
	# the will return the correct in app purchases for the device, possible values are: * SIRQUL (default) - purchasing from the sirqul store using tickets * IOS - purchasing from the itunes store for iPhone, iPod, iPod Touch * GOOGLE - purchasing from the google android store * AMAZON - purchasing from the amazon android store * MAC - purchasing from the itunes store for OSX * FREE - the item is free to purchase 
	purchaseType = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_app_data")
	bzz_callable.bind(
		start,
		limit,
		deviceId,
		accountId,
		gameType,
		includeGameData,
		q,
		keyword,
		sortField,
		descending,
		i,
		l,
		gameObjectCount,
		filter,
		dateCreated,
		ownerId,
		missionIds,
		gameIds,
		packIds,
		gameLevelIds,
		appVersion,
		includeHigherVersionPacks,
		includeHigherVersionLevels,
		responseGroups,
		purchaseType,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation postAppData → POST /app/post
# Create App Data
#
# Publish the application data structure.  Can be used to save levels   and scores.  It then returns the application data structure.  The basic   structure is a node tree, with the root node being a AppResponse.  The response   contains the user's profile, messages from the system, and a list of MissionResponse.    A mission can have any number of GameResponses but typically is a single   game type.  A game then has any number of PackResponses which help group   the game levels. Packs are then composed of any number of GameLevelResponses.      Using the various parameters can return the applications default mission   (built-in packs to play), the list of community levels published, the user's   saved levels, or explicity levels desired.  You can choose to include the   profile or not, or just return parts of the profile.  You can also filter   out game levels that have been published with a higher version of the application
func post_app_data(
	# gameType: String = ""   Eg: gameType_example
	# the game to retrieve the data for, use your application key.
	gameType: String,
	# start: int   Eg: 56
	# start the search results at a record.
	start: int,
	# limit: int   Eg: 56
	# limit the search results to some number.
	limit: int,
	# data: String = ""   Eg: data_example
	# The analytic data AnalyticListResponse
	data: String,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required).
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required).
	accountId = null,
	# includeGameData: bool   Eg: true
	# if true then include the game data blob, otherwise don't include.
	includeGameData = null,
	# q: String = ""   Eg: q_example
	# This parameter is deprecated.
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# query string used to filter the search results when looking for community and saved levels.
	keyword = "",
	# sortField: String = ""   Eg: sortField_example
	# how to sort the results when looking for community and saved levels. possible values are: LEVEL_NAME, LEVEL_CREATED, LEVEL_UPDATED, LEVEL_LIKES, LEVEL_DISLIKES, LEVEL_NOTES, LEVEL_PLAYS.
	sortField = "",
	# descending: bool   Eg: true
	# order the search results descending or ascending when looking for community and saved levels.
	descending = null,
	# i: int   Eg: 56
	# This parameter is deprecated.
	i = null,
	# l: int   Eg: 56
	# This parameter is deprecated.
	l = null,
	# gameObjectCount: bool   Eg: true
	# if true then include the game object count, otherwise don't include.
	gameObjectCount = null,
	# filter: String = ""   Eg: filter_example
	# restrict the search to items with certain permissions, possible values are: MINE, FRIENDS, PUBLIC, ALL_PUBLIC, ALL, LIKED
	filter = "",
	# dateCreated: float   Eg: 789
	# restrict the search to items created less then date
	dateCreated = null,
	# ownerId: float   Eg: 789
	# get levels owned by a particular account
	ownerId = null,
	# missionIds: String = ""   Eg: missionIds_example
	# get missions by specified id, comman seperated list of long ids
	missionIds = "",
	# gameIds: String = ""   Eg: gameIds_example
	# get games by specified id, comman seperated list of long ids
	gameIds = "",
	# packIds: String = ""   Eg: packIds_example
	# get packs by specified id, comman seperated list of long ids
	packIds = "",
	# gameLevelIds: String = ""   Eg: gameLevelIds_example
	# get game levels by specified id, comman seperated list of long ids
	gameLevelIds = "",
	# appVersion: String = ""   Eg: appVersion_example
	# the application version, used to versin the game level data
	appVersion = "",
	# includeHigherVersionPacks: bool   Eg: true
	# default is false and will not include any packs that have levels above the specified appVersion. If true then will return all levels regardless of version.
	includeHigherVersionPacks = null,
	# includeHigherVersionLevels: bool   Eg: true
	# default is false and will not include any levels above the specified appVersion. If true then will return all levels regardless of version.
	includeHigherVersionLevels = null,
	# responseGroups: String = ""   Eg: responseGroups_example
	# use response groups to include large parts of the structure. possible values are: * MISSION_DEFAULT (default) - include the default mission (built-in packs), excludes all other mission groups * MISSION_DEFAULT_LEVELS_SAVED - include saved levels, excludes all other mission groups * MISSION_DEFAULT_LEVELS_COMMUNITY - include community levels, excludes all other mission groups * MISSION_INVITED (default) - include challenges sent to user * PROFILE (default) - include entire profile * PROFILE_DATA - only include profile date (exclude friends) * PROFILE_FRIENDS - include friends list 
	responseGroups = "",
	# purchaseType: String = ""   Eg: purchaseType_example
	# the will return the correct in app purchases for the device, possible values are: * SIRQUL (default) - purchasing from the sirqul store using tickets * IOS - purchasing from the itunes store for iPhone, iPod, iPod Touch * GOOGLE - purchasing from the google android store * AMAZON - purchasing from the amazon android store * MAC - purchasing from the itunes store for OSX * FREE - the item is free to purchase 
	purchaseType = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/app/post"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["gameType"] = gameType
	bzz_query["includeGameData"] = includeGameData
	bzz_query["q"] = q
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["_i"] = i
	bzz_query["start"] = start
	bzz_query["_l"] = l
	bzz_query["limit"] = limit
	bzz_query["gameObjectCount"] = gameObjectCount
	bzz_query["filter"] = filter
	bzz_query["dateCreated"] = dateCreated
	bzz_query["ownerId"] = ownerId
	bzz_query["missionIds"] = missionIds
	bzz_query["gameIds"] = gameIds
	bzz_query["packIds"] = packIds
	bzz_query["gameLevelIds"] = gameLevelIds
	bzz_query["appVersion"] = appVersion
	bzz_query["includeHigherVersionPacks"] = includeHigherVersionPacks
	bzz_query["includeHigherVersionLevels"] = includeHigherVersionLevels
	bzz_query["responseGroups"] = responseGroups
	bzz_query["purchaseType"] = purchaseType
	bzz_query["data"] = data

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AppResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func post_app_data_threaded(
	# gameType: String = ""   Eg: gameType_example
	# the game to retrieve the data for, use your application key.
	gameType: String,
	# start: int   Eg: 56
	# start the search results at a record.
	start: int,
	# limit: int   Eg: 56
	# limit the search results to some number.
	limit: int,
	# data: String = ""   Eg: data_example
	# The analytic data AnalyticListResponse
	data: String,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required).
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required).
	accountId = null,
	# includeGameData: bool   Eg: true
	# if true then include the game data blob, otherwise don't include.
	includeGameData = null,
	# q: String = ""   Eg: q_example
	# This parameter is deprecated.
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# query string used to filter the search results when looking for community and saved levels.
	keyword = "",
	# sortField: String = ""   Eg: sortField_example
	# how to sort the results when looking for community and saved levels. possible values are: LEVEL_NAME, LEVEL_CREATED, LEVEL_UPDATED, LEVEL_LIKES, LEVEL_DISLIKES, LEVEL_NOTES, LEVEL_PLAYS.
	sortField = "",
	# descending: bool   Eg: true
	# order the search results descending or ascending when looking for community and saved levels.
	descending = null,
	# i: int   Eg: 56
	# This parameter is deprecated.
	i = null,
	# l: int   Eg: 56
	# This parameter is deprecated.
	l = null,
	# gameObjectCount: bool   Eg: true
	# if true then include the game object count, otherwise don't include.
	gameObjectCount = null,
	# filter: String = ""   Eg: filter_example
	# restrict the search to items with certain permissions, possible values are: MINE, FRIENDS, PUBLIC, ALL_PUBLIC, ALL, LIKED
	filter = "",
	# dateCreated: float   Eg: 789
	# restrict the search to items created less then date
	dateCreated = null,
	# ownerId: float   Eg: 789
	# get levels owned by a particular account
	ownerId = null,
	# missionIds: String = ""   Eg: missionIds_example
	# get missions by specified id, comman seperated list of long ids
	missionIds = "",
	# gameIds: String = ""   Eg: gameIds_example
	# get games by specified id, comman seperated list of long ids
	gameIds = "",
	# packIds: String = ""   Eg: packIds_example
	# get packs by specified id, comman seperated list of long ids
	packIds = "",
	# gameLevelIds: String = ""   Eg: gameLevelIds_example
	# get game levels by specified id, comman seperated list of long ids
	gameLevelIds = "",
	# appVersion: String = ""   Eg: appVersion_example
	# the application version, used to versin the game level data
	appVersion = "",
	# includeHigherVersionPacks: bool   Eg: true
	# default is false and will not include any packs that have levels above the specified appVersion. If true then will return all levels regardless of version.
	includeHigherVersionPacks = null,
	# includeHigherVersionLevels: bool   Eg: true
	# default is false and will not include any levels above the specified appVersion. If true then will return all levels regardless of version.
	includeHigherVersionLevels = null,
	# responseGroups: String = ""   Eg: responseGroups_example
	# use response groups to include large parts of the structure. possible values are: * MISSION_DEFAULT (default) - include the default mission (built-in packs), excludes all other mission groups * MISSION_DEFAULT_LEVELS_SAVED - include saved levels, excludes all other mission groups * MISSION_DEFAULT_LEVELS_COMMUNITY - include community levels, excludes all other mission groups * MISSION_INVITED (default) - include challenges sent to user * PROFILE (default) - include entire profile * PROFILE_DATA - only include profile date (exclude friends) * PROFILE_FRIENDS - include friends list 
	responseGroups = "",
	# purchaseType: String = ""   Eg: purchaseType_example
	# the will return the correct in app purchases for the device, possible values are: * SIRQUL (default) - purchasing from the sirqul store using tickets * IOS - purchasing from the itunes store for iPhone, iPod, iPod Touch * GOOGLE - purchasing from the google android store * AMAZON - purchasing from the amazon android store * MAC - purchasing from the itunes store for OSX * FREE - the item is free to purchase 
	purchaseType = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "post_app_data")
	bzz_callable.bind(
		gameType,
		start,
		limit,
		data,
		deviceId,
		accountId,
		includeGameData,
		q,
		keyword,
		sortField,
		descending,
		i,
		l,
		gameObjectCount,
		filter,
		dateCreated,
		ownerId,
		missionIds,
		gameIds,
		packIds,
		gameLevelIds,
		appVersion,
		includeHigherVersionPacks,
		includeHigherVersionLevels,
		responseGroups,
		purchaseType,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation regenAppData → POST /app/regen
# Regenerate App Data
#
# Regenerate the app data cache for apps
func regen_app_data(
	# accountId: float   Eg: 789
	# the account id of the user
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# process a specific application, if null process all apps with caches
	appKey = "",
	# buildVersion: String = ""   Eg: buildVersion_example
	# create a specific version, if null use current version. Be careful if processing all
	buildVersion = "",
	# apiVersion: String = ""   Eg: apiVersion_example
	# create a specific version, if null use current version. Be careful if processing all
	apiVersion = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/app/regen"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["buildVersion"] = buildVersion
	bzz_query["apiVersion"] = apiVersion

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func regen_app_data_threaded(
	# accountId: float   Eg: 789
	# the account id of the user
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# process a specific application, if null process all apps with caches
	appKey = "",
	# buildVersion: String = ""   Eg: buildVersion_example
	# create a specific version, if null use current version. Be careful if processing all
	buildVersion = "",
	# apiVersion: String = ""   Eg: apiVersion_example
	# create a specific version, if null use current version. Be careful if processing all
	apiVersion = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "regen_app_data")
	bzz_callable.bind(
		accountId,
		appKey,
		buildVersion,
		apiVersion,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


