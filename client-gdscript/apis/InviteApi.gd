extends ApiBee
class_name InviteApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API InviteApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "InviteApi"


# Operation acceptInvite → POST /api/{version}/invite/accept
# Accept Invite
#
# Allows a user to accept an invite. The user could also become the inviter's friend.
func accept_invite(
	# version: float   Eg: 3.16
	version: float,
	# token: String = ""   Eg: token_example
	# the invite token
	token: String,
	# accountId: float   Eg: 789
	# the accountId of the user who is accepting the invite
	accountId: float,
	# albumId: float   Eg: 789
	# the album id associated with this invite (if applicable)
	albumId = null,
	# missionId: float   Eg: 789
	# the mission id associated with this invite (if applicable)
	missionId = null,
	# albumContestId: float   Eg: 789
	# the album contest id associated with this invite (if applicable)
	albumContestId = null,
	# offerId: float   Eg: 789
	# the offer id associated with this invite (if applicable)
	offerId = null,
	# offerLocationId: float   Eg: 789
	# the offer location id associated with this invite (if applicable)
	offerLocationId = null,
	# retailerLocationId: float   Eg: 789
	# the retailer location id associated with this invite (if applicable)
	retailerLocationId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# autoFriend: bool = true   Eg: true
	# whether to auto-friend the invite sender and receiver
	autoFriend = true,
	# autoAttendEvent: bool = false   Eg: true
	# whether to mark the event as attending automatically after invite is accepted
	autoAttendEvent = false,
	# autoFavoriteOffer: bool = false   Eg: true
	# whether to mark the offer as favorited automatically after invite is accepted
	autoFavoriteOffer = false,
	# autoFavoriteOfferLocation: bool = false   Eg: true
	# whether to mark the offer location as favorited automatically after invite is accepted
	autoFavoriteOfferLocation = false,
	# autoFavoriteRetailerLocation: bool = false   Eg: true
	# whether to mark the retailer location as favorited automatically after invite is accepted
	autoFavoriteRetailerLocation = false,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/invite/accept".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["token"] = token
	bzz_query["accountId"] = accountId
	bzz_query["albumId"] = albumId
	bzz_query["missionId"] = missionId
	bzz_query["albumContestId"] = albumContestId
	bzz_query["offerId"] = offerId
	bzz_query["offerLocationId"] = offerLocationId
	bzz_query["retailerLocationId"] = retailerLocationId
	bzz_query["appKey"] = appKey
	bzz_query["autoFriend"] = autoFriend
	bzz_query["autoAttendEvent"] = autoAttendEvent
	bzz_query["autoFavoriteOffer"] = autoFavoriteOffer
	bzz_query["autoFavoriteOfferLocation"] = autoFavoriteOfferLocation
	bzz_query["autoFavoriteRetailerLocation"] = autoFavoriteRetailerLocation

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ConsumerInviteResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func accept_invite_threaded(
	# version: float   Eg: 3.16
	version: float,
	# token: String = ""   Eg: token_example
	# the invite token
	token: String,
	# accountId: float   Eg: 789
	# the accountId of the user who is accepting the invite
	accountId: float,
	# albumId: float   Eg: 789
	# the album id associated with this invite (if applicable)
	albumId = null,
	# missionId: float   Eg: 789
	# the mission id associated with this invite (if applicable)
	missionId = null,
	# albumContestId: float   Eg: 789
	# the album contest id associated with this invite (if applicable)
	albumContestId = null,
	# offerId: float   Eg: 789
	# the offer id associated with this invite (if applicable)
	offerId = null,
	# offerLocationId: float   Eg: 789
	# the offer location id associated with this invite (if applicable)
	offerLocationId = null,
	# retailerLocationId: float   Eg: 789
	# the retailer location id associated with this invite (if applicable)
	retailerLocationId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# autoFriend: bool = true   Eg: true
	# whether to auto-friend the invite sender and receiver
	autoFriend = true,
	# autoAttendEvent: bool = false   Eg: true
	# whether to mark the event as attending automatically after invite is accepted
	autoAttendEvent = false,
	# autoFavoriteOffer: bool = false   Eg: true
	# whether to mark the offer as favorited automatically after invite is accepted
	autoFavoriteOffer = false,
	# autoFavoriteOfferLocation: bool = false   Eg: true
	# whether to mark the offer location as favorited automatically after invite is accepted
	autoFavoriteOfferLocation = false,
	# autoFavoriteRetailerLocation: bool = false   Eg: true
	# whether to mark the retailer location as favorited automatically after invite is accepted
	autoFavoriteRetailerLocation = false,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "accept_invite")
	bzz_callable.bind(
		version,
		token,
		accountId,
		albumId,
		missionId,
		albumContestId,
		offerId,
		offerLocationId,
		retailerLocationId,
		appKey,
		autoFriend,
		autoAttendEvent,
		autoFavoriteOffer,
		autoFavoriteOfferLocation,
		autoFavoriteRetailerLocation,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation albumContestInvite → POST /api/{version}/invite/albumContest
# Invite to Contest
#
# Allows a user to invite people to gain access to a contest. This will generate an invite token, which when used, will give the invitee access to a contest (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.
func album_contest_invite(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# appId: float   Eg: 789
	# This parameter is deprecated.
	appId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# albumContestId: float   Eg: 789
	# the album contest to share
	albumContestId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/invite/albumContest".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appId"] = appId
	bzz_query["appKey"] = appKey
	bzz_query["albumContestId"] = albumContestId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = InviteResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func album_contest_invite_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# appId: float   Eg: 789
	# This parameter is deprecated.
	appId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# albumContestId: float   Eg: 789
	# the album contest to share
	albumContestId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "album_contest_invite")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		appId,
		appKey,
		albumContestId,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation albumInvite → POST /api/{version}/invite/album
# Invite to Collection
#
# Allows a user to invite people to gain access to a collection. This will generate an invite token, which when used, will give the invitee access to a collection (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.
func album_invite(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# appId: float   Eg: 789
	# This parameter is deprecated.
	appId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# albumId: float   Eg: 789
	# the album to share
	albumId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/invite/album".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appId"] = appId
	bzz_query["appKey"] = appKey
	bzz_query["albumId"] = albumId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = InviteResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func album_invite_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# appId: float   Eg: 789
	# This parameter is deprecated.
	appId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# albumId: float   Eg: 789
	# the album to share
	albumId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "album_invite")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		appId,
		appKey,
		albumId,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation eventInvite → POST /api/{version}/invite/event
# Invite to Event
#
# Allows a user to invite people to attend an event. This will generate an invite token, which when used, will allow the invitee to add the offer to their wallet.
func event_invite(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the account ID of the user making the share
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# listingId: float   Eg: 789
	# The ID of the event listing
	listingId: float,
	# receiverAccountIds: String = ""   Eg: receiverAccountIds_example
	# the account ID of a Sirqul user they would like to share an event with
	receiverAccountIds = "",
	# retailerLocationId: float   Eg: 789
	# The retailer location id of where the event will take place
	retailerLocationId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/invite/event".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["receiverAccountIds"] = receiverAccountIds
	bzz_query["appKey"] = appKey
	bzz_query["listingId"] = listingId
	bzz_query["retailerLocationId"] = retailerLocationId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = InviteResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func event_invite_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the account ID of the user making the share
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# listingId: float   Eg: 789
	# The ID of the event listing
	listingId: float,
	# receiverAccountIds: String = ""   Eg: receiverAccountIds_example
	# the account ID of a Sirqul user they would like to share an event with
	receiverAccountIds = "",
	# retailerLocationId: float   Eg: 789
	# The retailer location id of where the event will take place
	retailerLocationId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "event_invite")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		listingId,
		receiverAccountIds,
		retailerLocationId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation gameInvite → POST /api/{version}/invite/gameLevel
# Invite to Game Level
#
# Allows a user to invite people to gain access to an album. This will generate an invite token, which when used, will give the invitee access to an album (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.
func game_invite(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# appId: float   Eg: 789
	# This parameter is deprecated.
	appId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# gameLevelId: float   Eg: 789
	# the game level that the user owns and is giving access to
	gameLevelId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/invite/gameLevel".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appId"] = appId
	bzz_query["appKey"] = appKey
	bzz_query["gameLevelId"] = gameLevelId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = InviteResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func game_invite_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# appId: float   Eg: 789
	# This parameter is deprecated.
	appId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# gameLevelId: float   Eg: 789
	# the game level that the user owns and is giving access to
	gameLevelId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "game_invite")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		appId,
		appKey,
		gameLevelId,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getInvite → GET /api/{version}/invite/get
# Get Invite
#
# This is used to determine whether an invite token is valid. If the token is valid, this will also return information about who invited the user, and what they are invited to.
func get_invite(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Account ID of the user if they are logged in
	accountId = null,
	# token: String = ""   Eg: token_example
	# the invite token
	token = "",
	# albumId: float   Eg: 789
	# album id to match the invite against (if applicable)
	albumId = null,
	# missionId: float   Eg: 789
	# mission id to match the invite against (if applicable)
	missionId = null,
	# albumContestId: float   Eg: 789
	# album contest id to match the invite against (if applicable)
	albumContestId = null,
	# offerId: float   Eg: 789
	# offer id to match the invite against (if applicable)
	offerId = null,
	# offerLocationId: float   Eg: 789
	# offer location id to match the invite against (if applicable)
	offerLocationId = null,
	# retailerLocationId: float   Eg: 789
	# retailer location id to match the invite against (if applicable)
	retailerLocationId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/invite/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["token"] = token
	bzz_query["albumId"] = albumId
	bzz_query["missionId"] = missionId
	bzz_query["albumContestId"] = albumContestId
	bzz_query["offerId"] = offerId
	bzz_query["offerLocationId"] = offerLocationId
	bzz_query["retailerLocationId"] = retailerLocationId
	bzz_query["appKey"] = appKey

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_invite_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Account ID of the user if they are logged in
	accountId = null,
	# token: String = ""   Eg: token_example
	# the invite token
	token = "",
	# albumId: float   Eg: 789
	# album id to match the invite against (if applicable)
	albumId = null,
	# missionId: float   Eg: 789
	# mission id to match the invite against (if applicable)
	missionId = null,
	# albumContestId: float   Eg: 789
	# album contest id to match the invite against (if applicable)
	albumContestId = null,
	# offerId: float   Eg: 789
	# offer id to match the invite against (if applicable)
	offerId = null,
	# offerLocationId: float   Eg: 789
	# offer location id to match the invite against (if applicable)
	offerLocationId = null,
	# retailerLocationId: float   Eg: 789
	# retailer location id to match the invite against (if applicable)
	retailerLocationId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_invite")
	bzz_callable.bind(
		version,
		accountId,
		token,
		albumId,
		missionId,
		albumContestId,
		offerId,
		offerLocationId,
		retailerLocationId,
		appKey,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation missionInvite → POST /api/{version}/invite/mission
# Invite to Mission
#
# Allows a user to invite people to gain access to a mission. This will generate an invite token, which when used, will give the invitee access to a mission (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.
func mission_invite(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# appId: float   Eg: 789
	# This parameter is deprecated.
	appId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# missionId: float   Eg: 789
	# the mission to share
	missionId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/invite/mission".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appId"] = appId
	bzz_query["appKey"] = appKey
	bzz_query["missionId"] = missionId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = InviteResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func mission_invite_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# appId: float   Eg: 789
	# This parameter is deprecated.
	appId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# missionId: float   Eg: 789
	# the mission to share
	missionId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "mission_invite")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		appId,
		appKey,
		missionId,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation offerInvite → POST /api/{version}/invite/offer
# Invite to Offer
#
# Allows a user to invite people to favorite an offer. This will generate an invite token, which when used, will give the invitee the offer in their favorite's list.
func offer_invite(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the account ID of the user making the share
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# offerId: float   Eg: 789
	# the ID of the offer used to invite to favorite
	offerId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/invite/offer".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["offerId"] = offerId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = InviteResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func offer_invite_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the account ID of the user making the share
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# offerId: float   Eg: 789
	# the ID of the offer used to invite to favorite
	offerId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "offer_invite")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		offerId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation offerLocationInvite → POST /api/{version}/invite/offerLocation
# Invite to Offer Location
#
# Allows a user to invite people to favorite an offer location. This will generate an invite token, which when used, will give the invitee the offer location in their favorite's list.
func offer_location_invite(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the account ID of the user making the share
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# offerLocationId: float   Eg: 789
	# the id of the offer location to share
	offerLocationId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/invite/offerLocation".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["offerLocationId"] = offerLocationId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = InviteResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func offer_location_invite_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the account ID of the user making the share
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# offerLocationId: float   Eg: 789
	# the id of the offer location to share
	offerLocationId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "offer_location_invite")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		offerLocationId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation retailerLocationInvite → POST /api/{version}/invite/retailerLocation
# Invite to Retailer Location
#
# Allows a user to invite people to favorite a retailer location. This will generate an invite token, which when used, will give the invitee the retailer location in their favorite's list.
func retailer_location_invite(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the account ID of the user making the share
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# retailerLocationId: float   Eg: 789
	# The retailer location id of where the event will take place
	retailerLocationId: float,
	# albumId: float   Eg: 789
	# Optional album id to link with the invite
	albumId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/invite/retailerLocation".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["retailerLocationId"] = retailerLocationId
	bzz_query["albumId"] = albumId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = InviteResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func retailer_location_invite_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the account ID of the user making the share
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# retailerLocationId: float   Eg: 789
	# The retailer location id of where the event will take place
	retailerLocationId: float,
	# albumId: float   Eg: 789
	# Optional album id to link with the invite
	albumId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "retailer_location_invite")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		retailerLocationId,
		albumId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


