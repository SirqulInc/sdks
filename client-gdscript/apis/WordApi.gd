extends ApiBee
class_name WordApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API WordApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "WordApi"


# Operation createWord → POST /game/word/create
# Create Word
#
# Create a word by the given params.
func create_word(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# word: String = ""   Eg: word_example
	# The text of the word.
	word: String,
	# definition: String = ""   Eg: definition_example
	# The definition of the word.
	definition: String,
	# active: bool = false   Eg: true
	# If true set the word to active. Default to false.
	active: bool,
	# allocateTickets: bool = false   Eg: true
	# If true then scoring will give tickets. Default to false.
	allocateTickets: bool,
	# ticketCount: float = 0   Eg: 789
	# The number of tickets to reward
	ticketCount: float,
	# assetId: float   Eg: 789
	# The asset id of the word.
	assetId = null,
	# ticketType: String = ""   Eg: ticketType_example
	# The type of ticket to reward, null means default type
	ticketType = "",
	# points: float   Eg: 789
	# The number of points to award for completing a mission
	points = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/game/word/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["word"] = word
	bzz_query["definition"] = definition
	bzz_query["assetId"] = assetId
	bzz_query["active"] = active
	bzz_query["allocateTickets"] = allocateTickets
	bzz_query["ticketCount"] = ticketCount
	bzz_query["ticketType"] = ticketType
	bzz_query["points"] = points

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = WordzWordResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_word_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# word: String = ""   Eg: word_example
	# The text of the word.
	word: String,
	# definition: String = ""   Eg: definition_example
	# The definition of the word.
	definition: String,
	# active: bool = false   Eg: true
	# If true set the word to active. Default to false.
	active: bool,
	# allocateTickets: bool = false   Eg: true
	# If true then scoring will give tickets. Default to false.
	allocateTickets: bool,
	# ticketCount: float = 0   Eg: 789
	# The number of tickets to reward
	ticketCount: float,
	# assetId: float   Eg: 789
	# The asset id of the word.
	assetId = null,
	# ticketType: String = ""   Eg: ticketType_example
	# The type of ticket to reward, null means default type
	ticketType = "",
	# points: float   Eg: 789
	# The number of points to award for completing a mission
	points = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_word")
	bzz_callable.bind(
		accountId,
		word,
		definition,
		active,
		allocateTickets,
		ticketCount,
		assetId,
		ticketType,
		points,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteWord → DELETE /game/word/delete
# Delete Word
#
# Delete a word by the given id. The accountId given needs to be the owner or executive to delete.
func delete_word(
	# wordId: float   Eg: 789
	# The id of the word to delete.
	wordId: float,
	# accountId: float   Eg: 789
	# The account vor validating permission
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("DELETE")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/game/word/delete"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["wordId"] = wordId
	bzz_query["accountId"] = accountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_word_threaded(
	# wordId: float   Eg: 789
	# The id of the word to delete.
	wordId: float,
	# accountId: float   Eg: 789
	# The account vor validating permission
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_word")
	bzz_callable.bind(
		wordId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getWord → GET /game/word/get
# Get Word
#
# Get a word by the given id.
func get_word(
	# wordId: float   Eg: 789
	# The id of the word to get.
	wordId: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/game/word/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["wordId"] = wordId
	bzz_query["accountId"] = accountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = WordzWordResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_word_threaded(
	# wordId: float   Eg: 789
	# The id of the word to get.
	wordId: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_word")
	bzz_callable.bind(
		wordId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getWords → GET /game/word/search
# Search Words
#
# Search for words by the given params.
func get_words(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# sortField: String = "id"   Eg: sortField_example
	# The column to sort the search on
	sortField: String,
	# descending: bool = false   Eg: true
	# The order to return the search results
	descending: bool,
	# activeOnly: bool = false   Eg: true
	# Return only active results if set to true.
	activeOnly: bool,
	# start: int = 0   Eg: 56
	# The record to begin the return set on.
	start: int,
	# limit: int = 20   Eg: 56
	# The number of records to return.
	limit: int,
	# keyword: String = ""   Eg: keyword_example
	# The keyword for searching words with matching definition or word text.
	keyword = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/game/word/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["activeOnly"] = activeOnly
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = WordzWordResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_words_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# sortField: String = "id"   Eg: sortField_example
	# The column to sort the search on
	sortField: String,
	# descending: bool = false   Eg: true
	# The order to return the search results
	descending: bool,
	# activeOnly: bool = false   Eg: true
	# Return only active results if set to true.
	activeOnly: bool,
	# start: int = 0   Eg: 56
	# The record to begin the return set on.
	start: int,
	# limit: int = 20   Eg: 56
	# The number of records to return.
	limit: int,
	# keyword: String = ""   Eg: keyword_example
	# The keyword for searching words with matching definition or word text.
	keyword = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_words")
	bzz_callable.bind(
		accountId,
		sortField,
		descending,
		activeOnly,
		start,
		limit,
		keyword,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateWord → POST /game/word/update
# Update Word
#
# Update a word by the given params.
func update_word(
	# wordId: float   Eg: 789
	# The id of the word to update.
	wordId: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# ticketCount: float = 0   Eg: 789
	# The number of tickets to reward
	ticketCount: float,
	# wordText: String = ""   Eg: wordText_example
	# The text for the word
	wordText = "",
	# definition: String = ""   Eg: definition_example
	# The definition of the word.
	definition = "",
	# assetId: float   Eg: 789
	# The asset id of the word.
	assetId = null,
	# active: bool   Eg: true
	# If true set the word to active.
	active = null,
	# allocateTickets: bool   Eg: true
	# If true then scoring will give tickets.
	allocateTickets = null,
	# ticketType: String = ""   Eg: ticketType_example
	# The type of ticket to reward, null means default type
	ticketType = "",
	# points: float   Eg: 789
	# The number of points to award for completing a mission
	points = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/game/word/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["wordId"] = wordId
	bzz_query["accountId"] = accountId
	bzz_query["wordText"] = wordText
	bzz_query["definition"] = definition
	bzz_query["assetId"] = assetId
	bzz_query["active"] = active
	bzz_query["allocateTickets"] = allocateTickets
	bzz_query["ticketCount"] = ticketCount
	bzz_query["ticketType"] = ticketType
	bzz_query["points"] = points

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = WordzWordResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_word_threaded(
	# wordId: float   Eg: 789
	# The id of the word to update.
	wordId: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# ticketCount: float = 0   Eg: 789
	# The number of tickets to reward
	ticketCount: float,
	# wordText: String = ""   Eg: wordText_example
	# The text for the word
	wordText = "",
	# definition: String = ""   Eg: definition_example
	# The definition of the word.
	definition = "",
	# assetId: float   Eg: 789
	# The asset id of the word.
	assetId = null,
	# active: bool   Eg: true
	# If true set the word to active.
	active = null,
	# allocateTickets: bool   Eg: true
	# If true then scoring will give tickets.
	allocateTickets = null,
	# ticketType: String = ""   Eg: ticketType_example
	# The type of ticket to reward, null means default type
	ticketType = "",
	# points: float   Eg: 789
	# The number of points to award for completing a mission
	points = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_word")
	bzz_callable.bind(
		wordId,
		accountId,
		ticketCount,
		wordText,
		definition,
		assetId,
		active,
		allocateTickets,
		ticketType,
		points,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


