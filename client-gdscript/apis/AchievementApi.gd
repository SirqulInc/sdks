extends ApiBee
class_name AchievementApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API AchievementApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "AchievementApi"


# Operation achievementTierSearchPost → POST /achievement/tier/search
# Searches an Achievement Tier
#
# Searches a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
func achievement_tier_search_post(
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# keyword: String = ""   Eg: keyword_example
	# the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier)
	keyword = "",
	# achievementType: float   Eg: 789
	# filter results by achievementType (these are exact case sensitive matches)
	achievementType = null,
	# rankType: String = ""   Eg: rankType_example
	# filter results by the rankType (these are the exact case sensitive matches)
	rankType = "",
	# sortField: String = ""   Eg: sortField_example
	# the field to sort by. See {@link AchievementApiMap}
	sortField = "",
	# descending: bool   Eg: true
	# determines whether the sort list is in descending or ascending order (of the achievement)
	descending = null,
	# descendingGoal: bool   Eg: true
	# determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement)
	descendingGoal = null,
	# start: float   Eg: 789
	# The start of the index for pagination
	start = null,
	# limit: float   Eg: 789
	# the limit for pagination (has a hard limit of 1000)
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/achievement/tier/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["keyword"] = keyword
	bzz_query["achievementType"] = achievementType
	bzz_query["rankType"] = rankType
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["descendingGoal"] = descendingGoal
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AchievementTierResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func achievement_tier_search_post_threaded(
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# keyword: String = ""   Eg: keyword_example
	# the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier)
	keyword = "",
	# achievementType: float   Eg: 789
	# filter results by achievementType (these are exact case sensitive matches)
	achievementType = null,
	# rankType: String = ""   Eg: rankType_example
	# filter results by the rankType (these are the exact case sensitive matches)
	rankType = "",
	# sortField: String = ""   Eg: sortField_example
	# the field to sort by. See {@link AchievementApiMap}
	sortField = "",
	# descending: bool   Eg: true
	# determines whether the sort list is in descending or ascending order (of the achievement)
	descending = null,
	# descendingGoal: bool   Eg: true
	# determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement)
	descendingGoal = null,
	# start: float   Eg: 789
	# The start of the index for pagination
	start = null,
	# limit: float   Eg: 789
	# the limit for pagination (has a hard limit of 1000)
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "achievement_tier_search_post")
	bzz_callable.bind(
		deviceId,
		accountId,
		appKey,
		keyword,
		achievementType,
		rankType,
		sortField,
		descending,
		descendingGoal,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createAchievement → POST /achievement/create
# Create Achievement
#
# Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
func create_achievement(
	# appKey: String = ""   Eg: appKey_example
	# the application key the achievement is for
	appKey: String,
	# title: String = ""   Eg: title_example
	# the title of the achievement (255 character limit)
	title: String,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# analyticsTag: String = ""   Eg: analyticsTag_example
	# the analytics tag that will trigger when a user's achievement count gets updated
	analyticsTag = "",
	# description: String = ""   Eg: description_example
	# the description of the achievement
	description = "",
	# rankType: String = ""   Eg: rankType_example
	# the rank type for updating leader boards
	rankType = "",
	# rankIncrement: int   Eg: 56
	# determines how much the rank count is incremented
	rankIncrement = null,
	# minIncrement: int   Eg: 56
	# restrict scores to be above or equal to this minimum value
	minIncrement = null,
	# maxIncrement: int   Eg: 56
	# restrict scores to be below or equal to this maximum value
	maxIncrement = null,
	# validate: bool   Eg: true
	# determines whether the customId on analytics are used to validate a user's achievement progress.
	validate = null,
	# active: bool   Eg: true
	# achievement is active or inactive
	active = null,
	# triggerDefinition: String = ""   Eg: triggerDefinition_example
	# if provided will define what triggers to run after a tier is completed
	triggerDefinition = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/achievement/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["analyticsTag"] = analyticsTag
	bzz_query["title"] = title
	bzz_query["description"] = description
	bzz_query["rankType"] = rankType
	bzz_query["rankIncrement"] = rankIncrement
	bzz_query["minIncrement"] = minIncrement
	bzz_query["maxIncrement"] = maxIncrement
	bzz_query["validate"] = validate
	bzz_query["active"] = active
	bzz_query["triggerDefinition"] = triggerDefinition

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AchievementResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_achievement_threaded(
	# appKey: String = ""   Eg: appKey_example
	# the application key the achievement is for
	appKey: String,
	# title: String = ""   Eg: title_example
	# the title of the achievement (255 character limit)
	title: String,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# analyticsTag: String = ""   Eg: analyticsTag_example
	# the analytics tag that will trigger when a user's achievement count gets updated
	analyticsTag = "",
	# description: String = ""   Eg: description_example
	# the description of the achievement
	description = "",
	# rankType: String = ""   Eg: rankType_example
	# the rank type for updating leader boards
	rankType = "",
	# rankIncrement: int   Eg: 56
	# determines how much the rank count is incremented
	rankIncrement = null,
	# minIncrement: int   Eg: 56
	# restrict scores to be above or equal to this minimum value
	minIncrement = null,
	# maxIncrement: int   Eg: 56
	# restrict scores to be below or equal to this maximum value
	maxIncrement = null,
	# validate: bool   Eg: true
	# determines whether the customId on analytics are used to validate a user's achievement progress.
	validate = null,
	# active: bool   Eg: true
	# achievement is active or inactive
	active = null,
	# triggerDefinition: String = ""   Eg: triggerDefinition_example
	# if provided will define what triggers to run after a tier is completed
	triggerDefinition = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_achievement")
	bzz_callable.bind(
		appKey,
		title,
		deviceId,
		accountId,
		analyticsTag,
		description,
		rankType,
		rankIncrement,
		minIncrement,
		maxIncrement,
		validate,
		active,
		triggerDefinition,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createAchievementTier → POST /achievement/tier/create
# Create Achievement Tier
#
# Create a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
func create_achievement_tier(
	# achievementId: float   Eg: 789
	# the achievement id for adding a new tier
	achievementId: float,
	# scoreAllInstances: bool   Eg: true
	# score all instances
	scoreAllInstances: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# icon: String   Eg: BINARY_DATA_HERE
	# achievement tier icon image file
	icon = null,
	# iconAssetId: float   Eg: 789
	# the icon assetId, if icon is provided, icon will overrule
	iconAssetId = null,
	# title: String = ""   Eg: title_example
	# the title of the achievement tier
	title = "",
	# description: String = ""   Eg: description_example
	# the description of the achievement tier
	description = "",
	# goalCount: float   Eg: 789
	# the count requirement for completing the achievement tier
	goalCount = null,
	# missionId: float   Eg: 789
	# The ID of the mission to associate with the achievement
	missionId = null,
	# gameId: float   Eg: 789
	# The ID of the game to associate with the achievement
	gameId = null,
	# packId: float   Eg: 789
	# The ID of the pack to associate with the achievement
	packId = null,
	# gameLevelId: float   Eg: 789
	# The ID of the game level to associate with the achievement
	gameLevelId = null,
	# gameObjectId: int   Eg: 56
	# The ID of the game object to associate with the achievement
	gameObjectId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/achievement/tier/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["achievementId"] = achievementId
	bzz_query["icon"] = icon
	bzz_query["iconAssetId"] = iconAssetId
	bzz_query["title"] = title
	bzz_query["description"] = description
	bzz_query["goalCount"] = goalCount
	bzz_query["missionId"] = missionId
	bzz_query["gameId"] = gameId
	bzz_query["packId"] = packId
	bzz_query["gameLevelId"] = gameLevelId
	bzz_query["gameObjectId"] = gameObjectId
	bzz_query["scoreAllInstances"] = scoreAllInstances

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AchievementTierResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_achievement_tier_threaded(
	# achievementId: float   Eg: 789
	# the achievement id for adding a new tier
	achievementId: float,
	# scoreAllInstances: bool   Eg: true
	# score all instances
	scoreAllInstances: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# icon: String   Eg: BINARY_DATA_HERE
	# achievement tier icon image file
	icon = null,
	# iconAssetId: float   Eg: 789
	# the icon assetId, if icon is provided, icon will overrule
	iconAssetId = null,
	# title: String = ""   Eg: title_example
	# the title of the achievement tier
	title = "",
	# description: String = ""   Eg: description_example
	# the description of the achievement tier
	description = "",
	# goalCount: float   Eg: 789
	# the count requirement for completing the achievement tier
	goalCount = null,
	# missionId: float   Eg: 789
	# The ID of the mission to associate with the achievement
	missionId = null,
	# gameId: float   Eg: 789
	# The ID of the game to associate with the achievement
	gameId = null,
	# packId: float   Eg: 789
	# The ID of the pack to associate with the achievement
	packId = null,
	# gameLevelId: float   Eg: 789
	# The ID of the game level to associate with the achievement
	gameLevelId = null,
	# gameObjectId: int   Eg: 56
	# The ID of the game object to associate with the achievement
	gameObjectId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_achievement_tier")
	bzz_callable.bind(
		achievementId,
		scoreAllInstances,
		deviceId,
		accountId,
		icon,
		iconAssetId,
		title,
		description,
		goalCount,
		missionId,
		gameId,
		packId,
		gameLevelId,
		gameObjectId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteAchievement → POST /achievement/delete
# Delete Achievement
#
# Deletes an achievement (for developer/retailer use). User must have permissions to the application the achievement was created for.
func delete_achievement(
	# achievementId: float   Eg: 789
	# The ID of the achievement
	achievementId: float,
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/achievement/delete"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["achievementId"] = achievementId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_achievement_threaded(
	# achievementId: float   Eg: 789
	# The ID of the achievement
	achievementId: float,
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_achievement")
	bzz_callable.bind(
		achievementId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteAchievementTier → POST /achievement/tier/delete
# Delete Achievement Tier
#
# Deletes an achievement tier (for developer/retailer use). User must have permissions to the application the achievement was created for.
func delete_achievement_tier(
	# achievementTierId: float   Eg: 789
	# the achievement id for deletion
	achievementTierId: float,
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required).
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/achievement/tier/delete"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["achievementTierId"] = achievementTierId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_achievement_tier_threaded(
	# achievementTierId: float   Eg: 789
	# the achievement id for deletion
	achievementTierId: float,
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required).
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_achievement_tier")
	bzz_callable.bind(
		achievementTierId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getAchievement → GET /achievement/get
# Get Achievement
#
# Get an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
func get_achievement(
	# achievementId: float   Eg: 789
	# The ID of the achievement
	achievementId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# achievementType: String = ""   Eg: achievementType_example
	# achievementType
	achievementType = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/achievement/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["achievementId"] = achievementId
	bzz_query["achievementType"] = achievementType

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AchievementTierResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_achievement_threaded(
	# achievementId: float   Eg: 789
	# The ID of the achievement
	achievementId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# achievementType: String = ""   Eg: achievementType_example
	# achievementType
	achievementType = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_achievement")
	bzz_callable.bind(
		achievementId,
		deviceId,
		accountId,
		achievementType,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getAchievementTier → POST /achievement/tier/get
# Gets an achievement tier
#
# Gets an achievement tier (for developer/retailer use). User must have permissions to the application the achievement is created for.
func get_achievement_tier(
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId: float,
	# achievementTierId: float   Eg: 789
	# the achievement tier id that is being retrieved
	achievementTierId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/achievement/tier/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["achievementTierId"] = achievementTierId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AchievementTierResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_achievement_tier_threaded(
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId: float,
	# achievementTierId: float   Eg: 789
	# the achievement tier id that is being retrieved
	achievementTierId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_achievement_tier")
	bzz_callable.bind(
		accountId,
		achievementTierId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getUserAchievements → GET /achievement/progress/get
# Get Achievement Progress
#
# Gets a list of user achievements.
func get_user_achievements(
	# returnNulls: bool = true   Eg: true
	# determines whether to return null fields in the response
	returnNulls: bool,
	# appKey: String = ""   Eg: appKey_example
	# the application key for filtering results by application
	appKey: String,
	# includeUndiscovered: bool = true   Eg: true
	# determines whether to return achievements that the user has not discovered yet
	includeUndiscovered: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# connectionAccountEmail: String = ""   Eg: connectionAccountEmail_example
	# the email of the account to view achievements
	connectionAccountEmail = "",
	# connectionAccountId: float   Eg: 789
	# the id of the account to view achievements
	connectionAccountId = null,
	# rankType: String = ""   Eg: rankType_example
	# filter results by achievement rankType
	rankType = "",
	# achievementType: String = ""   Eg: achievementType_example
	# filter results by achievement type
	achievementType = "",
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/achievement/progress/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["returnNulls"] = returnNulls
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["connectionAccountEmail"] = connectionAccountEmail
	bzz_query["connectionAccountId"] = connectionAccountId
	bzz_query["appKey"] = appKey
	bzz_query["rankType"] = rankType
	bzz_query["achievementType"] = achievementType
	bzz_query["includeUndiscovered"] = includeUndiscovered
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AchievementProgressResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_user_achievements_threaded(
	# returnNulls: bool = true   Eg: true
	# determines whether to return null fields in the response
	returnNulls: bool,
	# appKey: String = ""   Eg: appKey_example
	# the application key for filtering results by application
	appKey: String,
	# includeUndiscovered: bool = true   Eg: true
	# determines whether to return achievements that the user has not discovered yet
	includeUndiscovered: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# connectionAccountEmail: String = ""   Eg: connectionAccountEmail_example
	# the email of the account to view achievements
	connectionAccountEmail = "",
	# connectionAccountId: float   Eg: 789
	# the id of the account to view achievements
	connectionAccountId = null,
	# rankType: String = ""   Eg: rankType_example
	# filter results by achievement rankType
	rankType = "",
	# achievementType: String = ""   Eg: achievementType_example
	# filter results by achievement type
	achievementType = "",
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_user_achievements")
	bzz_callable.bind(
		returnNulls,
		appKey,
		includeUndiscovered,
		deviceId,
		accountId,
		connectionAccountEmail,
		connectionAccountId,
		rankType,
		achievementType,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation listAchievementTags → GET /achievement/tag/list
# List Achievement Tags
#
# List achievement tags by application
func list_achievement_tags(
	# appKey: String = ""   Eg: appKey_example
	# filter results by application key
	appKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/achievement/tag/list"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["appKey"] = appKey

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func list_achievement_tags_threaded(
	# appKey: String = ""   Eg: appKey_example
	# filter results by application key
	appKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "list_achievement_tags")
	bzz_callable.bind(
		appKey,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation listAchievements → GET /achievement/list
# List Achievements
#
# List achievements by billable.
func list_achievements(
	# sortField: String = ""   Eg: sortField_example
	# the field to sort by. See AchievementApiMap
	sortField: String,
	# descending: bool   Eg: true
	# determines whether the sorted list is in descending or ascending order
	descending: bool,
	# start: int   Eg: 56
	# the start index for pagination
	start: int,
	# limit: int   Eg: 56
	# the limit for pagination (has a hard limit of 1000)
	limit: int,
	# activeOnly: bool   Eg: true
	# Filter results to only return active achievements
	activeOnly: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# keyword: String = ""   Eg: keyword_example
	# the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)
	keyword = "",
	# achievementType: String = ""   Eg: achievementType_example
	# filter results by the achievementType (these are exact case sensitive matches)
	achievementType = "",
	# rankType: String = ""   Eg: rankType_example
	# filter results by the rankType (these are exact case sensitive matches)
	rankType = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/achievement/list"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["keyword"] = keyword
	bzz_query["achievementType"] = achievementType
	bzz_query["rankType"] = rankType
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["activeOnly"] = activeOnly

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AchievementShortResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func list_achievements_threaded(
	# sortField: String = ""   Eg: sortField_example
	# the field to sort by. See AchievementApiMap
	sortField: String,
	# descending: bool   Eg: true
	# determines whether the sorted list is in descending or ascending order
	descending: bool,
	# start: int   Eg: 56
	# the start index for pagination
	start: int,
	# limit: int   Eg: 56
	# the limit for pagination (has a hard limit of 1000)
	limit: int,
	# activeOnly: bool   Eg: true
	# Filter results to only return active achievements
	activeOnly: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# keyword: String = ""   Eg: keyword_example
	# the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)
	keyword = "",
	# achievementType: String = ""   Eg: achievementType_example
	# filter results by the achievementType (these are exact case sensitive matches)
	achievementType = "",
	# rankType: String = ""   Eg: rankType_example
	# filter results by the rankType (these are exact case sensitive matches)
	rankType = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "list_achievements")
	bzz_callable.bind(
		sortField,
		descending,
		start,
		limit,
		activeOnly,
		deviceId,
		accountId,
		appKey,
		keyword,
		achievementType,
		rankType,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchAchievements → GET /achievement/search
# Search Achievements
#
# Searches achievements by application for consumers.
func search_achievements(
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# sortField: String = "TITLE"   Eg: sortField_example
	# the field to sort by. See AchievementApiMap
	sortField: String,
	# descending: bool = false   Eg: true
	# determines whether the sorted list is in descending or ascending order
	descending: bool,
	# includeTiers: bool = false   Eg: true
	# return tiers, only applicable for version >3.18
	includeTiers: bool,
	# includeInactiveTiers: bool = false   Eg: true
	# return inactive tiers, only applicable when includeTiers is true, only applicable for version >3.18
	includeInactiveTiers: bool,
	# start: int = 0   Eg: 56
	# the start index for pagination
	start: int,
	# limit: int = 100   Eg: 56
	# the limit for pagination (has a hard limit of 1000)
	limit: int,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# keyword: String = ""   Eg: keyword_example
	# the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)
	keyword = "",
	# achievementType: String = ""   Eg: achievementType_example
	# filter results by the achievementType (these are exact case sensitive matches)
	achievementType = "",
	# rankType: String = ""   Eg: rankType_example
	# filter results by the rankType (these are exact case sensitive matches)
	rankType = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/achievement/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["keyword"] = keyword
	bzz_query["achievementType"] = achievementType
	bzz_query["rankType"] = rankType
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["includeTiers"] = includeTiers
	bzz_query["includeInactiveTiers"] = includeInactiveTiers
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AchievementShortResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_achievements_threaded(
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# sortField: String = "TITLE"   Eg: sortField_example
	# the field to sort by. See AchievementApiMap
	sortField: String,
	# descending: bool = false   Eg: true
	# determines whether the sorted list is in descending or ascending order
	descending: bool,
	# includeTiers: bool = false   Eg: true
	# return tiers, only applicable for version >3.18
	includeTiers: bool,
	# includeInactiveTiers: bool = false   Eg: true
	# return inactive tiers, only applicable when includeTiers is true, only applicable for version >3.18
	includeInactiveTiers: bool,
	# start: int = 0   Eg: 56
	# the start index for pagination
	start: int,
	# limit: int = 100   Eg: 56
	# the limit for pagination (has a hard limit of 1000)
	limit: int,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# keyword: String = ""   Eg: keyword_example
	# the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)
	keyword = "",
	# achievementType: String = ""   Eg: achievementType_example
	# filter results by the achievementType (these are exact case sensitive matches)
	achievementType = "",
	# rankType: String = ""   Eg: rankType_example
	# filter results by the rankType (these are exact case sensitive matches)
	rankType = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_achievements")
	bzz_callable.bind(
		appKey,
		sortField,
		descending,
		includeTiers,
		includeInactiveTiers,
		start,
		limit,
		deviceId,
		accountId,
		keyword,
		achievementType,
		rankType,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateAchievement → POST /achievement/update
# Update Achievement
#
# Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
func update_achievement(
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# achievementId: float   Eg: 789
	# the achievement ID for updating an existing achievement
	achievementId = null,
	# analyticsTag: String = ""   Eg: analyticsTag_example
	# the analytics tag that will trigger when a user's achievement count gets updated
	analyticsTag = "",
	# title: String = ""   Eg: title_example
	# the title of the achievement (255 character limit)
	title = "",
	# description: String = ""   Eg: description_example
	# the description of the achievement
	description = "",
	# rankType: String = ""   Eg: rankType_example
	# the rank type for updating leader boards
	rankType = "",
	# rankIncrement: int   Eg: 56
	# determines how much the rank count is incremented
	rankIncrement = null,
	# minIncrement: int   Eg: 56
	# restrict scores to be above or equal to this minimum value
	minIncrement = null,
	# nullMinIncrement: bool   Eg: true
	# enable to ignore usage of minIncrement
	nullMinIncrement = null,
	# maxIncrement: int   Eg: 56
	# restrict scores to be below or equal to this maximum value
	maxIncrement = null,
	# nullMaxIncrement: bool   Eg: true
	# enable to ignore usage of maxIncrement
	nullMaxIncrement = null,
	# validate: bool   Eg: true
	# determines whether the customId on analytics are used to validate a user's achievement progress.
	validate = null,
	# active: bool   Eg: true
	# if it's active or inactive
	active = null,
	# triggerDefinition: String = ""   Eg: triggerDefinition_example
	# if provided will define what triggers to run after a tier is completed
	triggerDefinition = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/achievement/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["achievementId"] = achievementId
	bzz_query["analyticsTag"] = analyticsTag
	bzz_query["title"] = title
	bzz_query["description"] = description
	bzz_query["rankType"] = rankType
	bzz_query["rankIncrement"] = rankIncrement
	bzz_query["minIncrement"] = minIncrement
	bzz_query["nullMinIncrement"] = nullMinIncrement
	bzz_query["maxIncrement"] = maxIncrement
	bzz_query["nullMaxIncrement"] = nullMaxIncrement
	bzz_query["validate"] = validate
	bzz_query["active"] = active
	bzz_query["triggerDefinition"] = triggerDefinition

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AchievementResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_achievement_threaded(
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# achievementId: float   Eg: 789
	# the achievement ID for updating an existing achievement
	achievementId = null,
	# analyticsTag: String = ""   Eg: analyticsTag_example
	# the analytics tag that will trigger when a user's achievement count gets updated
	analyticsTag = "",
	# title: String = ""   Eg: title_example
	# the title of the achievement (255 character limit)
	title = "",
	# description: String = ""   Eg: description_example
	# the description of the achievement
	description = "",
	# rankType: String = ""   Eg: rankType_example
	# the rank type for updating leader boards
	rankType = "",
	# rankIncrement: int   Eg: 56
	# determines how much the rank count is incremented
	rankIncrement = null,
	# minIncrement: int   Eg: 56
	# restrict scores to be above or equal to this minimum value
	minIncrement = null,
	# nullMinIncrement: bool   Eg: true
	# enable to ignore usage of minIncrement
	nullMinIncrement = null,
	# maxIncrement: int   Eg: 56
	# restrict scores to be below or equal to this maximum value
	maxIncrement = null,
	# nullMaxIncrement: bool   Eg: true
	# enable to ignore usage of maxIncrement
	nullMaxIncrement = null,
	# validate: bool   Eg: true
	# determines whether the customId on analytics are used to validate a user's achievement progress.
	validate = null,
	# active: bool   Eg: true
	# if it's active or inactive
	active = null,
	# triggerDefinition: String = ""   Eg: triggerDefinition_example
	# if provided will define what triggers to run after a tier is completed
	triggerDefinition = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_achievement")
	bzz_callable.bind(
		deviceId,
		accountId,
		achievementId,
		analyticsTag,
		title,
		description,
		rankType,
		rankIncrement,
		minIncrement,
		nullMinIncrement,
		maxIncrement,
		nullMaxIncrement,
		validate,
		active,
		triggerDefinition,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateAchievementTier → POST /achievement/tier/update
# Update Achievement Tier
#
# Updates a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
func update_achievement_tier(
	# achievementTierId: float   Eg: 789
	# the achievement tier id for updating
	achievementTierId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# icon: String   Eg: BINARY_DATA_HERE
	# achievement tier icon image file
	icon = null,
	# iconAssetId: float   Eg: 789
	# the icon assetId, if icon is provided, icon will overrule
	iconAssetId = null,
	# title: String = ""   Eg: title_example
	# the title of the achievement tier
	title = "",
	# description: String = ""   Eg: description_example
	# the description of the achievement tier
	description = "",
	# goalCount: float   Eg: 789
	# the count requirement for completing the achievement tier
	goalCount = null,
	# missionId: float   Eg: 789
	# The ID of the mission to associate with the achievement
	missionId = null,
	# gameId: float   Eg: 789
	# The ID of the game to associate with the achievement
	gameId = null,
	# packId: float   Eg: 789
	# The ID of the pack to associate with the achievement
	packId = null,
	# gameLevelId: float   Eg: 789
	# The ID of the game level to associate with the achievement
	gameLevelId = null,
	# gameObjectId: float   Eg: 789
	# The ID of the game object to associate with the achievement
	gameObjectId = null,
	# scoreAllInstances: bool   Eg: true
	# score all instances
	scoreAllInstances = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/achievement/tier/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["achievementTierId"] = achievementTierId
	bzz_query["icon"] = icon
	bzz_query["iconAssetId"] = iconAssetId
	bzz_query["title"] = title
	bzz_query["description"] = description
	bzz_query["goalCount"] = goalCount
	bzz_query["missionId"] = missionId
	bzz_query["gameId"] = gameId
	bzz_query["packId"] = packId
	bzz_query["gameLevelId"] = gameLevelId
	bzz_query["gameObjectId"] = gameObjectId
	bzz_query["scoreAllInstances"] = scoreAllInstances

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AchievementTierResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_achievement_tier_threaded(
	# achievementTierId: float   Eg: 789
	# the achievement tier id for updating
	achievementTierId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# icon: String   Eg: BINARY_DATA_HERE
	# achievement tier icon image file
	icon = null,
	# iconAssetId: float   Eg: 789
	# the icon assetId, if icon is provided, icon will overrule
	iconAssetId = null,
	# title: String = ""   Eg: title_example
	# the title of the achievement tier
	title = "",
	# description: String = ""   Eg: description_example
	# the description of the achievement tier
	description = "",
	# goalCount: float   Eg: 789
	# the count requirement for completing the achievement tier
	goalCount = null,
	# missionId: float   Eg: 789
	# The ID of the mission to associate with the achievement
	missionId = null,
	# gameId: float   Eg: 789
	# The ID of the game to associate with the achievement
	gameId = null,
	# packId: float   Eg: 789
	# The ID of the pack to associate with the achievement
	packId = null,
	# gameLevelId: float   Eg: 789
	# The ID of the game level to associate with the achievement
	gameLevelId = null,
	# gameObjectId: float   Eg: 789
	# The ID of the game object to associate with the achievement
	gameObjectId = null,
	# scoreAllInstances: bool   Eg: true
	# score all instances
	scoreAllInstances = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_achievement_tier")
	bzz_callable.bind(
		achievementTierId,
		deviceId,
		accountId,
		icon,
		iconAssetId,
		title,
		description,
		goalCount,
		missionId,
		gameId,
		packId,
		gameLevelId,
		gameObjectId,
		scoreAllInstances,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateUserAchievement → POST /achievement/progress/update
# Update Achievement Progress
#
# Update user achievement progress.
func update_user_achievement(
	# accountId: float   Eg: 789
	# the account id of the user
	accountId: float,
	# achievementId: float   Eg: 789
	# the achievement id (achievementId or tag required)
	achievementId = null,
	# tag: String = ""   Eg: tag_example
	# the analytic tag to identify an achievement (achievementId or tag required)
	tag = "",
	# customId: float   Eg: 789
	# a custom identifier used for validation
	customId = null,
	# increment: float   Eg: 789
	# the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement's rankIncrement value)
	increment = null,
	# startDate: float   Eg: 789
	# a custom start date that the client can set (not yet used in server logic)
	startDate = null,
	# endDate: float   Eg: 789
	# a custom end date that the client can set (not yet used in server logic)
	endDate = null,
	# returnProgress: bool   Eg: true
	# determines whether to return the achievement progress response
	returnProgress = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/achievement/progress/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["achievementId"] = achievementId
	bzz_query["tag"] = tag
	bzz_query["customId"] = customId
	bzz_query["increment"] = increment
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["returnProgress"] = returnProgress

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_user_achievement_threaded(
	# accountId: float   Eg: 789
	# the account id of the user
	accountId: float,
	# achievementId: float   Eg: 789
	# the achievement id (achievementId or tag required)
	achievementId = null,
	# tag: String = ""   Eg: tag_example
	# the analytic tag to identify an achievement (achievementId or tag required)
	tag = "",
	# customId: float   Eg: 789
	# a custom identifier used for validation
	customId = null,
	# increment: float   Eg: 789
	# the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement's rankIncrement value)
	increment = null,
	# startDate: float   Eg: 789
	# a custom start date that the client can set (not yet used in server logic)
	startDate = null,
	# endDate: float   Eg: 789
	# a custom end date that the client can set (not yet used in server logic)
	endDate = null,
	# returnProgress: bool   Eg: true
	# determines whether to return the achievement progress response
	returnProgress = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_user_achievement")
	bzz_callable.bind(
		accountId,
		achievementId,
		tag,
		customId,
		increment,
		startDate,
		endDate,
		returnProgress,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


