extends ApiBee
class_name ObjectStoreApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API ObjectStoreApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "ObjectStoreApi"


# Operation addField → POST /api/{version}/object/field/add
# Create Field
#
# Add a field to a specific object.  The field name should be camel   case with the first letter lower case, for example: myFieldName.  Duplicate   field names are not allowed.   The field name cannot be any of the following   reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE,   BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE,   CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE,   CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP,   CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE,   DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE,   DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE,   ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4,   FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY,   HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE,   INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER,   INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT,   LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG,   LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT,   MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND,   MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC,   ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION,   PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES,   REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN,   REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE,   SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION,   SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT,   SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT,   TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED,   UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY,   VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH,   ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW.     The following field names are reserved (cannot be used directly) and are automatically   included during object creation: ID, OBJECTID, CREATED, UPDATED, DELETED.   Additionally the field names must start with a letter or number.
func add_field(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key for updating an existing application
	appKey: String,
	# objectName: String = ""   Eg: objectName_example
	# The name of the object to add the field to
	objectName: String,
	# fieldName: String = ""   Eg: fieldName_example
	# field name The name of the field to add.
	fieldName: String,
	# fieldType: String = ""   Eg: fieldType_example
	# field type The field type to create, supported types are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY
	fieldType: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/object/field/add".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["objectName"] = objectName
	bzz_query["fieldName"] = fieldName
	bzz_query["fieldType"] = fieldType

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ObjectStoreResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func add_field_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key for updating an existing application
	appKey: String,
	# objectName: String = ""   Eg: objectName_example
	# The name of the object to add the field to
	objectName: String,
	# fieldName: String = ""   Eg: fieldName_example
	# field name The name of the field to add.
	fieldName: String,
	# fieldType: String = ""   Eg: fieldType_example
	# field type The field type to create, supported types are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY
	fieldType: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "add_field")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		objectName,
		fieldName,
		fieldType,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createData → POST /api/{version}/object/data/{objectName}
# Create Data
#
# Create a record for the specified object.  If the object does not exist then a new one will be created prior to inserting the record.  If any of the fields included does not exist for the object then they are added to the object. 
func create_data(
	# version: float   Eg: 3.16
	version: float,
	# objectName: String = ""   Eg: objectName_example
	# the name of the object to create data for
	objectName: String,
	# accountId: float   Eg: 789
	# the account id
	accountId = null,
	# body: String   Eg: body_example
	body = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/object/data/{objectName}".replace("{" + "version" + "}", _bzz_urlize_path_param(version)).replace("{" + "objectName" + "}", _bzz_urlize_path_param(objectName))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId

	var bzz_body = null
	bzz_body = body

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ObjectStoreResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_data_threaded(
	# version: float   Eg: 3.16
	version: float,
	# objectName: String = ""   Eg: objectName_example
	# the name of the object to create data for
	objectName: String,
	# accountId: float   Eg: 789
	# the account id
	accountId = null,
	# body: String   Eg: body_example
	body = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_data")
	bzz_callable.bind(
		version,
		objectName,
		accountId,
		body,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createObject → POST /api/{version}/object/create
# Create Object
#
# Create an Object Store table.  By default tables will have the columns: id, created, updated, deleted.  Names og objects should be camel case with the first letter capitalized, for example: MyTableName.   Duplicate object names are not allowed.   The object name cannot be any of the following reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE, BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE, CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE, CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP, CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE, DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE, DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE, ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4, FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY, HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE, INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER, INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT, LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG, LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT, MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND, MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC, ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION, PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES, REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN, REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE, SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION, SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT, SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT, TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED, UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY, VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH, ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW. 
func create_object(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key for updating an existing application
	appKey: String,
	# objectName: String = ""   Eg: objectName_example
	# The name of the object to create
	objectName: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/object/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["objectName"] = objectName

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ObjectStoreResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_object_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key for updating an existing application
	appKey: String,
	# objectName: String = ""   Eg: objectName_example
	# The name of the object to create
	objectName: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_object")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		objectName,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteData → DELETE /api/{version}/object/data/{objectName}/{objectId}
# Delete Data
#
# Delete a record for the specified object. Cannot be undone so use only when abolutely sure.
func delete_data(
	# version: float   Eg: 3.16
	version: float,
	# objectName: String = ""   Eg: objectName_example
	# The name of the object to search upon
	objectName: String,
	# objectId: String = ""   Eg: objectId_example
	# objectId The id of the record to return
	objectId: String,
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("DELETE")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/object/data/{objectName}/{objectId}".replace("{" + "version" + "}", _bzz_urlize_path_param(version)).replace("{" + "objectName" + "}", _bzz_urlize_path_param(objectName)).replace("{" + "objectId" + "}", _bzz_urlize_path_param(objectId))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ObjectStoreResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_data_threaded(
	# version: float   Eg: 3.16
	version: float,
	# objectName: String = ""   Eg: objectName_example
	# The name of the object to search upon
	objectName: String,
	# objectId: String = ""   Eg: objectId_example
	# objectId The id of the record to return
	objectId: String,
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_data")
	bzz_callable.bind(
		version,
		objectName,
		objectId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteField → POST /api/{version}/object/field/delete
# Delete Field
#
# Delete a field from an object.  This will remove the field, indexes,   and foreign keys associated with the field.   The following field names   are reserved and cannot be removed from the object: ID, OBJECTID, CREATED,   UPDATED, DELETED
func delete_field(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key for updating an existing application
	appKey: String,
	# objectName: String = ""   Eg: objectName_example
	# The name of the object to remove the field from
	objectName: String,
	# fieldName: String = ""   Eg: fieldName_example
	# field name The name of the field to remove.
	fieldName: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/object/field/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["objectName"] = objectName
	bzz_query["fieldName"] = fieldName

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ObjectStoreResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_field_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key for updating an existing application
	appKey: String,
	# objectName: String = ""   Eg: objectName_example
	# The name of the object to remove the field from
	objectName: String,
	# fieldName: String = ""   Eg: fieldName_example
	# field name The name of the field to remove.
	fieldName: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_field")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		objectName,
		fieldName,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteObject → POST /api/{version}/object/delete
# Delete Object
#
# Delete and Object in the store.  This will delete the table and clean up and foreign keys referencing it. Cannot be undone so use only when abolutely sure.
func delete_object(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# objectName: String = ""   Eg: objectName_example
	# the name of the object to delete
	objectName: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/object/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["objectName"] = objectName

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ObjectStoreResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_object_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# objectName: String = ""   Eg: objectName_example
	# the name of the object to delete
	objectName: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_object")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		objectName,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getData → GET /api/{version}/object/data/{objectName}/{objectId}
# Get Data
#
# Get a specific record from a specified object.
func get_data(
	# version: float   Eg: 3.16
	version: float,
	# objectName: String = ""   Eg: objectName_example
	# The name of the object to search upon
	objectName: String,
	# objectId: String = ""   Eg: objectId_example
	# objectId The id of the record to return
	objectId: String,
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId = null,
	# include: String = ""   Eg: include_example
	include = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/object/data/{objectName}/{objectId}".replace("{" + "version" + "}", _bzz_urlize_path_param(version)).replace("{" + "objectName" + "}", _bzz_urlize_path_param(objectName)).replace("{" + "objectId" + "}", _bzz_urlize_path_param(objectId))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["include"] = include

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ObjectStoreResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_data_threaded(
	# version: float   Eg: 3.16
	version: float,
	# objectName: String = ""   Eg: objectName_example
	# The name of the object to search upon
	objectName: String,
	# objectId: String = ""   Eg: objectId_example
	# objectId The id of the record to return
	objectId: String,
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId = null,
	# include: String = ""   Eg: include_example
	include = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_data")
	bzz_callable.bind(
		version,
		objectName,
		objectId,
		accountId,
		include,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getObject → GET /api/{version}/object/get
# Get Object
#
# Get the definition of an Object. Returns all field names, types, and current size. The types supported are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY.
func get_object(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key for updating an existing application
	appKey: String,
	# objectName: String = ""   Eg: objectName_example
	# The name of the object to get the definition for
	objectName: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/object/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["objectName"] = objectName

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ObjectStoreResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_object_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key for updating an existing application
	appKey: String,
	# objectName: String = ""   Eg: objectName_example
	# The name of the object to get the definition for
	objectName: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_object")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		objectName,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchData → GET /api/{version}/object/data/{objectName}
# Search Data
#
# Search for records given the specified criteria.  The criteria is a defined set of json values used to build a query
func search_data(
	# version: float   Eg: 3.16
	version: float,
	# objectName: String = ""   Eg: objectName_example
	# The name of the object to search upon
	objectName: String,
	# count: bool   Eg: true
	# If true just return the record count of the search. False (default) will return the actual records
	count: bool,
	# start: float   Eg: 789
	# The start of the pagination
	start: float,
	# limit: float   Eg: 789
	# The limit of the pagination
	limit: float,
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId = null,
	# criteria: String = ""   Eg: criteria_example
	# The search criteria
	criteria = "",
	# order: String = ""   Eg: order_example
	# The order of results; comma seperated list of field names. Illegal field names will be ignored. Direction by defualt is ascending. Prepend a minus to the field name to make that field descending.
	order = "",
	# include: String = ""   Eg: include_example
	include = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/object/data/{objectName}".replace("{" + "version" + "}", _bzz_urlize_path_param(version)).replace("{" + "objectName" + "}", _bzz_urlize_path_param(objectName))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["criteria"] = criteria
	bzz_query["count"] = count
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["order"] = order
	bzz_query["include"] = include

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ObjectStoreResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_data_threaded(
	# version: float   Eg: 3.16
	version: float,
	# objectName: String = ""   Eg: objectName_example
	# The name of the object to search upon
	objectName: String,
	# count: bool   Eg: true
	# If true just return the record count of the search. False (default) will return the actual records
	count: bool,
	# start: float   Eg: 789
	# The start of the pagination
	start: float,
	# limit: float   Eg: 789
	# The limit of the pagination
	limit: float,
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId = null,
	# criteria: String = ""   Eg: criteria_example
	# The search criteria
	criteria = "",
	# order: String = ""   Eg: order_example
	# The order of results; comma seperated list of field names. Illegal field names will be ignored. Direction by defualt is ascending. Prepend a minus to the field name to make that field descending.
	order = "",
	# include: String = ""   Eg: include_example
	include = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_data")
	bzz_callable.bind(
		version,
		objectName,
		count,
		start,
		limit,
		accountId,
		criteria,
		order,
		include,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchObject → GET /api/{version}/object/search
# Search Objects
#
# Search for Objects and return the list of names found.  Use this in conjunction with the object get service to present the current data model defined.
func search_object(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key for updating an existing application
	appKey: String,
	# start: float   Eg: 789
	# The start of the pagination
	start: float,
	# limit: float   Eg: 789
	# The limit of the pagination
	limit: float,
	# keyword: String = ""   Eg: keyword_example
	# The name of the object(s) to search for, can be a partial match
	keyword = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/object/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["keyword"] = keyword
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ObjectStoreResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_object_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key for updating an existing application
	appKey: String,
	# start: float   Eg: 789
	# The start of the pagination
	start: float,
	# limit: float   Eg: 789
	# The limit of the pagination
	limit: float,
	# keyword: String = ""   Eg: keyword_example
	# The name of the object(s) to search for, can be a partial match
	keyword = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_object")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		start,
		limit,
		keyword,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateData → PUT /api/{version}/object/data/{objectName}/{objectId}
# Update Data
#
# Update a record for the specified object.  If the object does not exist the request will be rejected, use the data create service for the first entry. If any of the fields included does not exist for the object then they are added to the object.
func update_data(
	# version: float   Eg: 3.16
	version: float,
	# objectName: String = ""   Eg: objectName_example
	# The name of the object to search upon
	objectName: String,
	# objectId: String = ""   Eg: objectId_example
	# objectId The id of the record to return
	objectId: String,
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId = null,
	# body: String   Eg: body_example
	body = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("PUT")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/object/data/{objectName}/{objectId}".replace("{" + "version" + "}", _bzz_urlize_path_param(version)).replace("{" + "objectName" + "}", _bzz_urlize_path_param(objectName)).replace("{" + "objectId" + "}", _bzz_urlize_path_param(objectId))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId

	var bzz_body = null
	bzz_body = body

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ObjectStoreResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_data_threaded(
	# version: float   Eg: 3.16
	version: float,
	# objectName: String = ""   Eg: objectName_example
	# The name of the object to search upon
	objectName: String,
	# objectId: String = ""   Eg: objectId_example
	# objectId The id of the record to return
	objectId: String,
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId = null,
	# body: String   Eg: body_example
	body = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_data")
	bzz_callable.bind(
		version,
		objectName,
		objectId,
		accountId,
		body,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


