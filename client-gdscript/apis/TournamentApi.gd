extends ApiBee
class_name TournamentApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API TournamentApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "TournamentApi"


# Operation createTournament → POST /api/{version}/tournament/create
# Create Tournament
#
# Create a tournament.
func create_tournament(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The appKey the tournament is created for.
	appKey: String,
	# title: String = ""   Eg: title_example
	# The title of the tournament
	title: String,
	# costToPlay: int   Eg: 56
	# The number of tickets required to pay to enter the tournament
	costToPlay: int,
	# startDate: float   Eg: 789
	# The date/time to start the tournament
	startDate: float,
	# subType: String = ""   Eg: subType_example
	# Custom string client apps can use for searching/filtering tournaments
	subType = "",
	# imageAssetId: float   Eg: 789
	# The asset ID to attach to the tournament
	imageAssetId = null,
	# secondsBetweenLevels: int = 600   Eg: 56
	# The number of seconds in between the start of each tournament game/group
	secondsBetweenLevels = 600,
	# secondsForTieBreaker: int = 600   Eg: 56
	# The number of seconds to extend the round end time in the case of a tie breaker
	secondsForTieBreaker = 600,
	# secondsBetweenPacks: int = 86400   Eg: 56
	# The number of seconds in between the start of each tournament round
	secondsBetweenPacks = 86400,
	# maximumLevelLength: int = 1800   Eg: 56
	# The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
	maximumLevelLength = 1800,
	# costToPlayType: String = ""   Eg: costToPlayType_example
	# The type of ticket required to pay
	costToPlayType = "",
	# minimumToPlay: int = 1   Eg: 56
	# The minimum number of players required to sign up for the tournament to be played
	minimumToPlay = 1,
	# startingLimit: int   Eg: 56
	# The starting number of players for a tournament (filled with AI's)
	startingLimit = null,
	# availableLimit: int   Eg: 56
	# The maximum number of players for a tournament (currently 128 but not enforced)
	availableLimit = null,
	# description: String = ""   Eg: description_example
	# The description of the tournament
	description = "",
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# audienceIds: String = ""   Eg: audienceIds_example
	# The audiences associated with the tournament
	audienceIds = "",
	# active: bool   Eg: true
	# Activate/deactivate the tournament
	active = null,
	# enableBuyBack: bool = false   Eg: true
	# Determines whether to allow players to buy back into a tournament
	enableBuyBack = false,
	# offerIds: String = ""   Eg: offerIds_example
	# The list of offers to give as a reward beyond the tickets
	offerIds = "",
	# offerAssetId: float   Eg: 789
	# The artwork ID to attach to the reward tickets offers
	offerAssetId = null,
	# fixedReward: bool = false   Eg: true
	# If set then do not update the ticket reward, auto set to true if offerIds provided
	fixedReward = false,
	# splitReward: String = "ALL"   Eg: splitReward_example
	# Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
	splitReward = "ALL",
	# allocateTickets: bool   Eg: true
	# Flag to indicate owner should receive tickets for completed missions
	allocateTickets = null,
	# tournamentData: String = ""   Eg: tournamentData_example
	# A text based string that will be passed into each tournament setup to populate the content
	tournamentData = "",
	# missionType: String = "MULTISTAGE"   Eg: missionType_example
	# The style of tournament to build, options are: TOURNAMENT, POOLPLAY
	missionType = "MULTISTAGE",
	# visibility: String = "PUBLIC"   Eg: visibility_example
	# Sets the visibility flag for the tournament
	visibility = "PUBLIC",
	# preliminaryGroups: int = 1   Eg: 56
	# The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
	preliminaryGroups = 1,
	# preliminaryGroupAdvancements: String = "1"   Eg: preliminaryGroupAdvancements_example
	# This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
	preliminaryGroupAdvancements = "1",
	# enableMultipleEntries: bool = false   Eg: true
	# This determines if multiple submissions/entries are allowed in a multi-stage album tournament
	enableMultipleEntries = false,
	# enableMultipleVotes: bool = false   Eg: true
	# This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
	enableMultipleVotes = false,
	# featured: bool = false   Eg: true
	# This determines whether the tournament is \"featured\" or not
	featured = false,
	# winnerTag: String = ""   Eg: winnerTag_example
	# This sets what analytic tag is used when a winner is determined
	winnerTag = "",
	# tieTag: String = ""   Eg: tieTag_example
	# This sets what analytic tag is used when a tie has occurred
	tieTag = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/tournament/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["title"] = title
	bzz_query["subType"] = subType
	bzz_query["imageAssetId"] = imageAssetId
	bzz_query["secondsBetweenLevels"] = secondsBetweenLevels
	bzz_query["secondsForTieBreaker"] = secondsForTieBreaker
	bzz_query["secondsBetweenPacks"] = secondsBetweenPacks
	bzz_query["maximumLevelLength"] = maximumLevelLength
	bzz_query["costToPlay"] = costToPlay
	bzz_query["costToPlayType"] = costToPlayType
	bzz_query["minimumToPlay"] = minimumToPlay
	bzz_query["startingLimit"] = startingLimit
	bzz_query["availableLimit"] = availableLimit
	bzz_query["description"] = description
	bzz_query["metaData"] = metaData
	bzz_query["startDate"] = startDate
	bzz_query["audienceIds"] = audienceIds
	bzz_query["active"] = active
	bzz_query["enableBuyBack"] = enableBuyBack
	bzz_query["offerIds"] = offerIds
	bzz_query["offerAssetId"] = offerAssetId
	bzz_query["fixedReward"] = fixedReward
	bzz_query["splitReward"] = splitReward
	bzz_query["allocateTickets"] = allocateTickets
	bzz_query["tournamentData"] = tournamentData
	bzz_query["missionType"] = missionType
	bzz_query["visibility"] = visibility
	bzz_query["preliminaryGroups"] = preliminaryGroups
	bzz_query["preliminaryGroupAdvancements"] = preliminaryGroupAdvancements
	bzz_query["enableMultipleEntries"] = enableMultipleEntries
	bzz_query["enableMultipleVotes"] = enableMultipleVotes
	bzz_query["featured"] = featured
	bzz_query["winnerTag"] = winnerTag
	bzz_query["tieTag"] = tieTag

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = TournamentResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_tournament_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The appKey the tournament is created for.
	appKey: String,
	# title: String = ""   Eg: title_example
	# The title of the tournament
	title: String,
	# costToPlay: int   Eg: 56
	# The number of tickets required to pay to enter the tournament
	costToPlay: int,
	# startDate: float   Eg: 789
	# The date/time to start the tournament
	startDate: float,
	# subType: String = ""   Eg: subType_example
	# Custom string client apps can use for searching/filtering tournaments
	subType = "",
	# imageAssetId: float   Eg: 789
	# The asset ID to attach to the tournament
	imageAssetId = null,
	# secondsBetweenLevels: int = 600   Eg: 56
	# The number of seconds in between the start of each tournament game/group
	secondsBetweenLevels = 600,
	# secondsForTieBreaker: int = 600   Eg: 56
	# The number of seconds to extend the round end time in the case of a tie breaker
	secondsForTieBreaker = 600,
	# secondsBetweenPacks: int = 86400   Eg: 56
	# The number of seconds in between the start of each tournament round
	secondsBetweenPacks = 86400,
	# maximumLevelLength: int = 1800   Eg: 56
	# The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
	maximumLevelLength = 1800,
	# costToPlayType: String = ""   Eg: costToPlayType_example
	# The type of ticket required to pay
	costToPlayType = "",
	# minimumToPlay: int = 1   Eg: 56
	# The minimum number of players required to sign up for the tournament to be played
	minimumToPlay = 1,
	# startingLimit: int   Eg: 56
	# The starting number of players for a tournament (filled with AI's)
	startingLimit = null,
	# availableLimit: int   Eg: 56
	# The maximum number of players for a tournament (currently 128 but not enforced)
	availableLimit = null,
	# description: String = ""   Eg: description_example
	# The description of the tournament
	description = "",
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# audienceIds: String = ""   Eg: audienceIds_example
	# The audiences associated with the tournament
	audienceIds = "",
	# active: bool   Eg: true
	# Activate/deactivate the tournament
	active = null,
	# enableBuyBack: bool = false   Eg: true
	# Determines whether to allow players to buy back into a tournament
	enableBuyBack = false,
	# offerIds: String = ""   Eg: offerIds_example
	# The list of offers to give as a reward beyond the tickets
	offerIds = "",
	# offerAssetId: float   Eg: 789
	# The artwork ID to attach to the reward tickets offers
	offerAssetId = null,
	# fixedReward: bool = false   Eg: true
	# If set then do not update the ticket reward, auto set to true if offerIds provided
	fixedReward = false,
	# splitReward: String = "ALL"   Eg: splitReward_example
	# Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
	splitReward = "ALL",
	# allocateTickets: bool   Eg: true
	# Flag to indicate owner should receive tickets for completed missions
	allocateTickets = null,
	# tournamentData: String = ""   Eg: tournamentData_example
	# A text based string that will be passed into each tournament setup to populate the content
	tournamentData = "",
	# missionType: String = "MULTISTAGE"   Eg: missionType_example
	# The style of tournament to build, options are: TOURNAMENT, POOLPLAY
	missionType = "MULTISTAGE",
	# visibility: String = "PUBLIC"   Eg: visibility_example
	# Sets the visibility flag for the tournament
	visibility = "PUBLIC",
	# preliminaryGroups: int = 1   Eg: 56
	# The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
	preliminaryGroups = 1,
	# preliminaryGroupAdvancements: String = "1"   Eg: preliminaryGroupAdvancements_example
	# This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
	preliminaryGroupAdvancements = "1",
	# enableMultipleEntries: bool = false   Eg: true
	# This determines if multiple submissions/entries are allowed in a multi-stage album tournament
	enableMultipleEntries = false,
	# enableMultipleVotes: bool = false   Eg: true
	# This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
	enableMultipleVotes = false,
	# featured: bool = false   Eg: true
	# This determines whether the tournament is \"featured\" or not
	featured = false,
	# winnerTag: String = ""   Eg: winnerTag_example
	# This sets what analytic tag is used when a winner is determined
	winnerTag = "",
	# tieTag: String = ""   Eg: tieTag_example
	# This sets what analytic tag is used when a tie has occurred
	tieTag = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_tournament")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		title,
		costToPlay,
		startDate,
		subType,
		imageAssetId,
		secondsBetweenLevels,
		secondsForTieBreaker,
		secondsBetweenPacks,
		maximumLevelLength,
		costToPlayType,
		minimumToPlay,
		startingLimit,
		availableLimit,
		description,
		metaData,
		audienceIds,
		active,
		enableBuyBack,
		offerIds,
		offerAssetId,
		fixedReward,
		splitReward,
		allocateTickets,
		tournamentData,
		missionType,
		visibility,
		preliminaryGroups,
		preliminaryGroupAdvancements,
		enableMultipleEntries,
		enableMultipleVotes,
		featured,
		winnerTag,
		tieTag,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteTournament → POST /api/{version}/tournament/delete
# Delete Tournament
#
# Delete a tournament.
func delete_tournament(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# missionId: float   Eg: 789
	# the id of the mission to delete
	missionId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/tournament/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["missionId"] = missionId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_tournament_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# missionId: float   Eg: 789
	# the id of the mission to delete
	missionId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_tournament")
	bzz_callable.bind(
		version,
		accountId,
		missionId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getTournament → GET /api/{version}/tournament/get
# Get Tournament
#
# Get a tournament.
func get_tournament(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The id of the logged in user
	accountId: float,
	# missionId: float   Eg: 789
	# The id of the mission to return (either missionId or joinCode is required)
	missionId = null,
	# joinCode: String = ""   Eg: joinCode_example
	# Optional identifier for getting the tournament (either missionId or joinCode is required)
	joinCode = "",
	# includeScores: String = ""   Eg: includeScores_example
	# Determines which type of scores are returned. Possible values include: ALL, MINE
	includeScores = "",
	# objectPreviewSize: int = 50   Eg: 56
	# Determines the max number of game objects that will get returned for each game level response
	objectPreviewSize = 50,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/tournament/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["missionId"] = missionId
	bzz_query["joinCode"] = joinCode
	bzz_query["includeScores"] = includeScores
	bzz_query["objectPreviewSize"] = objectPreviewSize

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = TournamentResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_tournament_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The id of the logged in user
	accountId: float,
	# missionId: float   Eg: 789
	# The id of the mission to return (either missionId or joinCode is required)
	missionId = null,
	# joinCode: String = ""   Eg: joinCode_example
	# Optional identifier for getting the tournament (either missionId or joinCode is required)
	joinCode = "",
	# includeScores: String = ""   Eg: includeScores_example
	# Determines which type of scores are returned. Possible values include: ALL, MINE
	includeScores = "",
	# objectPreviewSize: int = 50   Eg: 56
	# Determines the max number of game objects that will get returned for each game level response
	objectPreviewSize = 50,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_tournament")
	bzz_callable.bind(
		version,
		accountId,
		missionId,
		joinCode,
		includeScores,
		objectPreviewSize,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchObjects → GET /api/{version}/tournament/object/search
# Search Tournament Objects
#
# Search on game objects of tournaments
func search_objects(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the account ID
	accountId: float,
	# gameLevelId: float   Eg: 789
	# the game level id to filter results by
	gameLevelId: float,
	# sortField: String = "PLAYER_SCORE_COUNT"   Eg: sortField_example
	# the field to sort by
	sortField = "PLAYER_SCORE_COUNT",
	# descending: bool = true   Eg: true
	# determines whether the sorted list is in descending or ascending order
	descending = true,
	# start: int = 0   Eg: 56
	# the start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# the limit for pagination
	limit = 20,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/tournament/object/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["gameLevelId"] = gameLevelId
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_objects_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the account ID
	accountId: float,
	# gameLevelId: float   Eg: 789
	# the game level id to filter results by
	gameLevelId: float,
	# sortField: String = "PLAYER_SCORE_COUNT"   Eg: sortField_example
	# the field to sort by
	sortField = "PLAYER_SCORE_COUNT",
	# descending: bool = true   Eg: true
	# determines whether the sorted list is in descending or ascending order
	descending = true,
	# start: int = 0   Eg: 56
	# the start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# the limit for pagination
	limit = 20,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_objects")
	bzz_callable.bind(
		version,
		accountId,
		gameLevelId,
		sortField,
		descending,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchRounds → GET /api/{version}/tournament/round/search
# Search Tournament Rounds
#
# Search for the user's tournament games.
func search_rounds(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the account ID
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# status: String = "ACCEPTED,ACTIVE"   Eg: status_example
	# comma separated list of statuses to filter results by
	status = "ACCEPTED,ACTIVE",
	# missionType: String = ""   Eg: missionType_example
	# The style of tournament to search for, options are: TOURNAMENT, POOLPLAY
	missionType = "",
	# currentOnly: bool = true   Eg: true
	# search for games that are flagged current only
	currentOnly = true,
	# visibilities: String = "PUBLIC"   Eg: visibilities_example
	# Filter tournament rounds by the mission visibility flag
	visibilities = "PUBLIC",
	# start: int = 0   Eg: 56
	# the start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# the limit for pagination
	limit = 20,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/tournament/round/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["status"] = status
	bzz_query["missionType"] = missionType
	bzz_query["currentOnly"] = currentOnly
	bzz_query["visibilities"] = visibilities
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_rounds_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the account ID
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# status: String = "ACCEPTED,ACTIVE"   Eg: status_example
	# comma separated list of statuses to filter results by
	status = "ACCEPTED,ACTIVE",
	# missionType: String = ""   Eg: missionType_example
	# The style of tournament to search for, options are: TOURNAMENT, POOLPLAY
	missionType = "",
	# currentOnly: bool = true   Eg: true
	# search for games that are flagged current only
	currentOnly = true,
	# visibilities: String = "PUBLIC"   Eg: visibilities_example
	# Filter tournament rounds by the mission visibility flag
	visibilities = "PUBLIC",
	# start: int = 0   Eg: 56
	# the start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# the limit for pagination
	limit = 20,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_rounds")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		status,
		missionType,
		currentOnly,
		visibilities,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchTournaments → GET /api/{version}/tournament/search
# Search Tournaments
#
# Search for tournaments
func search_tournaments(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key
	appKey: String,
	# keyword: String = ""   Eg: keyword_example
	# the keyword to search tournament on
	keyword = "",
	# subType: String = ""   Eg: subType_example
	# filter results by subType
	subType = "",
	# includeInactive: bool = false   Eg: true
	# whether to include inactives in the search or not
	includeInactive = false,
	# missionTypes: String = "MULTISTAGE,TOURNAMENT,POOLPLAY"   Eg: missionTypes_example
	# comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE
	missionTypes = "MULTISTAGE,TOURNAMENT,POOLPLAY",
	# filter: String = "UPCOMING"   Eg: filter_example
	# filter tournaments by the tournament's current state
	filter = "UPCOMING",
	# sortField: String = "START_DATE"   Eg: sortField_example
	# which field to sort on
	sortField = "START_DATE",
	# descending: bool   Eg: true
	# Determines whether to return results in descending order. The default value will be true if the filter is \"PAST\", otherwise the default value will be false.
	descending = null,
	# visibility: String = "PUBLIC"   Eg: visibility_example
	# Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE
	visibility = "PUBLIC",
	# start: int = 0   Eg: 56
	# Start the result set at some index.
	start = 0,
	# limit: int = 20   Eg: 56
	# Limit the result to some number
	limit = 20,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/tournament/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["keyword"] = keyword
	bzz_query["subType"] = subType
	bzz_query["includeInactive"] = includeInactive
	bzz_query["missionTypes"] = missionTypes
	bzz_query["filter"] = filter
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["visibility"] = visibility
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = MissionShortResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_tournaments_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key
	appKey: String,
	# keyword: String = ""   Eg: keyword_example
	# the keyword to search tournament on
	keyword = "",
	# subType: String = ""   Eg: subType_example
	# filter results by subType
	subType = "",
	# includeInactive: bool = false   Eg: true
	# whether to include inactives in the search or not
	includeInactive = false,
	# missionTypes: String = "MULTISTAGE,TOURNAMENT,POOLPLAY"   Eg: missionTypes_example
	# comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE
	missionTypes = "MULTISTAGE,TOURNAMENT,POOLPLAY",
	# filter: String = "UPCOMING"   Eg: filter_example
	# filter tournaments by the tournament's current state
	filter = "UPCOMING",
	# sortField: String = "START_DATE"   Eg: sortField_example
	# which field to sort on
	sortField = "START_DATE",
	# descending: bool   Eg: true
	# Determines whether to return results in descending order. The default value will be true if the filter is \"PAST\", otherwise the default value will be false.
	descending = null,
	# visibility: String = "PUBLIC"   Eg: visibility_example
	# Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE
	visibility = "PUBLIC",
	# start: int = 0   Eg: 56
	# Start the result set at some index.
	start = 0,
	# limit: int = 20   Eg: 56
	# Limit the result to some number
	limit = 20,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_tournaments")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		keyword,
		subType,
		includeInactive,
		missionTypes,
		filter,
		sortField,
		descending,
		visibility,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation submitTournamentScore → POST /api/{version}/tournament/score
# Submit Tournament Score
#
# Submit an array of scores for a tournament match. 
func submit_tournament_score(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user account ID.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key.
	appKey: String,
	# missionId: float   Eg: 789
	# The missionId to score for
	missionId: float,
	# gameId: float   Eg: 789
	# The gameId to score for
	gameId: float,
	# packId: float   Eg: 789
	# The packId to score for
	packId: float,
	# scores: String = ""   Eg: scores_example
	# a JSON Array of scores to submit for a tournament match ```json [   {     \"accountId\": 2,     \"points\": 3   },   {     \"accountId\": 1777662,     \"points\": 7   } ] ``` 
	scores: String,
	# gameLevelId: float   Eg: 789
	# The gameLevelId to score for
	gameLevelId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/tournament/score".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["missionId"] = missionId
	bzz_query["gameId"] = gameId
	bzz_query["packId"] = packId
	bzz_query["gameLevelId"] = gameLevelId
	bzz_query["scores"] = scores

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func submit_tournament_score_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user account ID.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key.
	appKey: String,
	# missionId: float   Eg: 789
	# The missionId to score for
	missionId: float,
	# gameId: float   Eg: 789
	# The gameId to score for
	gameId: float,
	# packId: float   Eg: 789
	# The packId to score for
	packId: float,
	# scores: String = ""   Eg: scores_example
	# a JSON Array of scores to submit for a tournament match ```json [   {     \"accountId\": 2,     \"points\": 3   },   {     \"accountId\": 1777662,     \"points\": 7   } ] ``` 
	scores: String,
	# gameLevelId: float   Eg: 789
	# The gameLevelId to score for
	gameLevelId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "submit_tournament_score")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		missionId,
		gameId,
		packId,
		scores,
		gameLevelId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation submitTournamentVote → POST /api/{version}/tournament/vote
# Submit a vote for a multi-stage album tournament.
#
# Submit a vote for a multi-stage album tournament.
func submit_tournament_vote(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application to target
	appKey: String,
	# missionId: float   Eg: 789
	# The tournament's primary id
	missionId: float,
	# gameObjectId: float   Eg: 789
	# The tournament game object the user wants to vote on
	gameObjectId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (optional)
	deviceId = "",
	# checkIfDeviceAlreadyVoted: bool = false   Eg: true
	# When true, check if the device already voted to prevent duplicate votes from the same device
	checkIfDeviceAlreadyVoted = false,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/tournament/vote".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["missionId"] = missionId
	bzz_query["gameObjectId"] = gameObjectId
	bzz_query["checkIfDeviceAlreadyVoted"] = checkIfDeviceAlreadyVoted

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func submit_tournament_vote_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application to target
	appKey: String,
	# missionId: float   Eg: 789
	# The tournament's primary id
	missionId: float,
	# gameObjectId: float   Eg: 789
	# The tournament game object the user wants to vote on
	gameObjectId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (optional)
	deviceId = "",
	# checkIfDeviceAlreadyVoted: bool = false   Eg: true
	# When true, check if the device already voted to prevent duplicate votes from the same device
	checkIfDeviceAlreadyVoted = false,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "submit_tournament_vote")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		missionId,
		gameObjectId,
		deviceId,
		checkIfDeviceAlreadyVoted,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation substituteTournamentPlayer → POST /api/{version}/tournament/substitute
# Substitute Tournament Player
#
# Service to replace the user's opponent in the current level - pack - mission with an AI account.
func substitute_tournament_player(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# missionId: float   Eg: 789
	# the id of the mission
	missionId: float,
	# packId: float   Eg: 789
	# the id of the pack
	packId: float,
	# gameLevelId: float   Eg: 789
	# the id of the game level
	gameLevelId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/tournament/substitute".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["missionId"] = missionId
	bzz_query["packId"] = packId
	bzz_query["gameLevelId"] = gameLevelId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func substitute_tournament_player_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# missionId: float   Eg: 789
	# the id of the mission
	missionId: float,
	# packId: float   Eg: 789
	# the id of the pack
	packId: float,
	# gameLevelId: float   Eg: 789
	# the id of the game level
	gameLevelId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "substitute_tournament_player")
	bzz_callable.bind(
		version,
		accountId,
		missionId,
		packId,
		gameLevelId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateTournament → POST /api/{version}/tournament/update
# Update Tournament
#
# Update a tournament.
func update_tournament(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# missionId: float   Eg: 789
	# The mission/tournament to update
	missionId: float,
	# title: String = ""   Eg: title_example
	# The title of the tournament
	title = "",
	# subType: String = ""   Eg: subType_example
	# Custom string client apps can use for searching/filtering missions
	subType = "",
	# imageAssetId: float   Eg: 789
	# The asset ID to attach to the tournament
	imageAssetId = null,
	# secondsBetweenLevels: int   Eg: 56
	# The number of seconds in between the start of each tournament game
	secondsBetweenLevels = null,
	# secondsForTieBreaker: int   Eg: 56
	# The number of seconds to extend the round end time in the case of a tie breaker
	secondsForTieBreaker = null,
	# secondsBetweenPacks: int   Eg: 56
	# The number of seconds in between the start of each tournament round
	secondsBetweenPacks = null,
	# maximumLevelLength: int   Eg: 56
	# The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
	maximumLevelLength = null,
	# costToPlay: int   Eg: 56
	# The number of tickets required to pay to enter the tournament
	costToPlay = null,
	# costToPlayType: String = ""   Eg: costToPlayType_example
	# The type of ticket required to pay
	costToPlayType = "",
	# minimumToPlay: int   Eg: 56
	# The minimum number of players required to sign up for the tournament to be played
	minimumToPlay = null,
	# startingLimit: int   Eg: 56
	# The starting number of players for a tournament (filled with AI's)
	startingLimit = null,
	# availableLimit: int   Eg: 56
	# The maximum number of players for a tournament (currently 128 but not enforced)
	availableLimit = null,
	# description: String = ""   Eg: description_example
	# The description of the tournament
	description = "",
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# startDate: float   Eg: 789
	# The date/time to start the tournament
	startDate = null,
	# audienceIds: String = ""   Eg: audienceIds_example
	# The audiences associated with the tournament
	audienceIds = "",
	# active: bool   Eg: true
	# Activate/deactivate the mission
	active = null,
	# enableBuyBack: bool   Eg: true
	# Determines whether to allow players to buy back into a tournament
	enableBuyBack = null,
	# offerIds: String = ""   Eg: offerIds_example
	# The list of offers to give as a reward beyond the tickets
	offerIds = "",
	# offerAssetId: float   Eg: 789
	# The artwork ID to attach to the reward offer
	offerAssetId = null,
	# fixedReward: bool   Eg: true
	# If set then do not update the ticket reward, auto set to true if offerIds provided
	fixedReward = null,
	# splitReward: String = ""   Eg: splitReward_example
	# Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
	splitReward = "",
	# allocateTickets: bool   Eg: true
	# Flag to indicate owner should receive tickets for completed missions
	allocateTickets = null,
	# tournamentData: String = ""   Eg: tournamentData_example
	# A text based string that will be passed into each tournament setup to populate the content
	tournamentData = "",
	# visibility: String = ""   Eg: visibility_example
	# Sets the visibility flag for the tournament
	visibility = "",
	# preliminaryGroups: int   Eg: 56
	# The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
	preliminaryGroups = null,
	# preliminaryGroupAdvancements: String = ""   Eg: preliminaryGroupAdvancements_example
	# This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
	preliminaryGroupAdvancements = "",
	# enableMultipleEntries: bool   Eg: true
	# This determines if multiple submissions/entries are allowed in a multi-stage album tournament
	enableMultipleEntries = null,
	# enableMultipleVotes: bool   Eg: true
	# This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
	enableMultipleVotes = null,
	# featured: bool   Eg: true
	# This determines whether the tournament is \"featured\" or not
	featured = null,
	# winnerTag: String = ""   Eg: winnerTag_example
	# This sets what analytic tag is used when a winner is determined
	winnerTag = "",
	# tieTag: String = ""   Eg: tieTag_example
	# This sets what analytic tag is used when a winner is determined
	tieTag = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/tournament/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["missionId"] = missionId
	bzz_query["title"] = title
	bzz_query["subType"] = subType
	bzz_query["imageAssetId"] = imageAssetId
	bzz_query["secondsBetweenLevels"] = secondsBetweenLevels
	bzz_query["secondsForTieBreaker"] = secondsForTieBreaker
	bzz_query["secondsBetweenPacks"] = secondsBetweenPacks
	bzz_query["maximumLevelLength"] = maximumLevelLength
	bzz_query["costToPlay"] = costToPlay
	bzz_query["costToPlayType"] = costToPlayType
	bzz_query["minimumToPlay"] = minimumToPlay
	bzz_query["startingLimit"] = startingLimit
	bzz_query["availableLimit"] = availableLimit
	bzz_query["description"] = description
	bzz_query["metaData"] = metaData
	bzz_query["startDate"] = startDate
	bzz_query["audienceIds"] = audienceIds
	bzz_query["active"] = active
	bzz_query["enableBuyBack"] = enableBuyBack
	bzz_query["offerIds"] = offerIds
	bzz_query["offerAssetId"] = offerAssetId
	bzz_query["fixedReward"] = fixedReward
	bzz_query["splitReward"] = splitReward
	bzz_query["allocateTickets"] = allocateTickets
	bzz_query["tournamentData"] = tournamentData
	bzz_query["visibility"] = visibility
	bzz_query["preliminaryGroups"] = preliminaryGroups
	bzz_query["preliminaryGroupAdvancements"] = preliminaryGroupAdvancements
	bzz_query["enableMultipleEntries"] = enableMultipleEntries
	bzz_query["enableMultipleVotes"] = enableMultipleVotes
	bzz_query["featured"] = featured
	bzz_query["winnerTag"] = winnerTag
	bzz_query["tieTag"] = tieTag

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = TournamentResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_tournament_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# missionId: float   Eg: 789
	# The mission/tournament to update
	missionId: float,
	# title: String = ""   Eg: title_example
	# The title of the tournament
	title = "",
	# subType: String = ""   Eg: subType_example
	# Custom string client apps can use for searching/filtering missions
	subType = "",
	# imageAssetId: float   Eg: 789
	# The asset ID to attach to the tournament
	imageAssetId = null,
	# secondsBetweenLevels: int   Eg: 56
	# The number of seconds in between the start of each tournament game
	secondsBetweenLevels = null,
	# secondsForTieBreaker: int   Eg: 56
	# The number of seconds to extend the round end time in the case of a tie breaker
	secondsForTieBreaker = null,
	# secondsBetweenPacks: int   Eg: 56
	# The number of seconds in between the start of each tournament round
	secondsBetweenPacks = null,
	# maximumLevelLength: int   Eg: 56
	# The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
	maximumLevelLength = null,
	# costToPlay: int   Eg: 56
	# The number of tickets required to pay to enter the tournament
	costToPlay = null,
	# costToPlayType: String = ""   Eg: costToPlayType_example
	# The type of ticket required to pay
	costToPlayType = "",
	# minimumToPlay: int   Eg: 56
	# The minimum number of players required to sign up for the tournament to be played
	minimumToPlay = null,
	# startingLimit: int   Eg: 56
	# The starting number of players for a tournament (filled with AI's)
	startingLimit = null,
	# availableLimit: int   Eg: 56
	# The maximum number of players for a tournament (currently 128 but not enforced)
	availableLimit = null,
	# description: String = ""   Eg: description_example
	# The description of the tournament
	description = "",
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# startDate: float   Eg: 789
	# The date/time to start the tournament
	startDate = null,
	# audienceIds: String = ""   Eg: audienceIds_example
	# The audiences associated with the tournament
	audienceIds = "",
	# active: bool   Eg: true
	# Activate/deactivate the mission
	active = null,
	# enableBuyBack: bool   Eg: true
	# Determines whether to allow players to buy back into a tournament
	enableBuyBack = null,
	# offerIds: String = ""   Eg: offerIds_example
	# The list of offers to give as a reward beyond the tickets
	offerIds = "",
	# offerAssetId: float   Eg: 789
	# The artwork ID to attach to the reward offer
	offerAssetId = null,
	# fixedReward: bool   Eg: true
	# If set then do not update the ticket reward, auto set to true if offerIds provided
	fixedReward = null,
	# splitReward: String = ""   Eg: splitReward_example
	# Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
	splitReward = "",
	# allocateTickets: bool   Eg: true
	# Flag to indicate owner should receive tickets for completed missions
	allocateTickets = null,
	# tournamentData: String = ""   Eg: tournamentData_example
	# A text based string that will be passed into each tournament setup to populate the content
	tournamentData = "",
	# visibility: String = ""   Eg: visibility_example
	# Sets the visibility flag for the tournament
	visibility = "",
	# preliminaryGroups: int   Eg: 56
	# The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
	preliminaryGroups = null,
	# preliminaryGroupAdvancements: String = ""   Eg: preliminaryGroupAdvancements_example
	# This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
	preliminaryGroupAdvancements = "",
	# enableMultipleEntries: bool   Eg: true
	# This determines if multiple submissions/entries are allowed in a multi-stage album tournament
	enableMultipleEntries = null,
	# enableMultipleVotes: bool   Eg: true
	# This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
	enableMultipleVotes = null,
	# featured: bool   Eg: true
	# This determines whether the tournament is \"featured\" or not
	featured = null,
	# winnerTag: String = ""   Eg: winnerTag_example
	# This sets what analytic tag is used when a winner is determined
	winnerTag = "",
	# tieTag: String = ""   Eg: tieTag_example
	# This sets what analytic tag is used when a winner is determined
	tieTag = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_tournament")
	bzz_callable.bind(
		version,
		accountId,
		missionId,
		title,
		subType,
		imageAssetId,
		secondsBetweenLevels,
		secondsForTieBreaker,
		secondsBetweenPacks,
		maximumLevelLength,
		costToPlay,
		costToPlayType,
		minimumToPlay,
		startingLimit,
		availableLimit,
		description,
		metaData,
		startDate,
		audienceIds,
		active,
		enableBuyBack,
		offerIds,
		offerAssetId,
		fixedReward,
		splitReward,
		allocateTickets,
		tournamentData,
		visibility,
		preliminaryGroups,
		preliminaryGroupAdvancements,
		enableMultipleEntries,
		enableMultipleVotes,
		featured,
		winnerTag,
		tieTag,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


