extends ApiBee
class_name MissionApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API MissionApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "MissionApi"


# Operation createMission → POST /api/{version}/mission/create
# Create Mission
#
# Create a user defined mission.
func create_mission(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# title: String = ""   Eg: title_example
	# The title of the mission
	title: String,
	# description: String = ""   Eg: description_example
	# The description of the mission
	description = "",
	# subType: String = ""   Eg: subType_example
	# Custom string client apps can use for searching/filtering missions
	subType = "",
	# startDate: float   Eg: 789
	# The date/time to start the mission, send 0 to unset
	startDate = null,
	# endDate: float   Eg: 789
	# The date/time to end the mission, send 0 to unset
	endDate = null,
	# active: bool   Eg: true
	# Activate/deactivate the mission
	active = null,
	# gameLevelIds: String = ""   Eg: gameLevelIds_example
	# the game level ids to include in the mission, comma separated
	gameLevelIds = "",
	# creativeIds: String = ""   Eg: creativeIds_example
	# creatives to associate with the mission
	creativeIds = "",
	# audienceIds: String = ""   Eg: audienceIds_example
	# audiences to associate with the mission
	audienceIds = "",
	# missionTask: String = ""   Eg: missionTask_example
	# This parameter is deprecated.
	missionTask = "",
	# formatType: String = ""   Eg: formatType_example
	# The string identifier for a mission format (this is not the missionFormatId)
	formatType = "",
	# offerId: float   Eg: 789
	# The offerId to give as a reward
	offerId = null,
	# balance: int   Eg: 1.2
	# Set the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited.
	balance = null,
	# advancedReporting: bool   Eg: true
	# Flag to mark the mission as eligible for advanced reporting
	advancedReporting = null,
	# allocateTickets: bool   Eg: true
	# Flag to indicate owner should receive tickets for completed missions
	allocateTickets = null,
	# ticketCount: float   Eg: 789
	# The number of tickets to reward
	ticketCount = null,
	# ticketType: String = ""   Eg: ticketType_example
	# The type of ticket to reward, null means default type
	ticketType = "",
	# points: float   Eg: 789
	# The number of points to award for completing a mission
	points = null,
	# metaData: String = ""   Eg: metaData_example
	# external custom client defined data
	metaData = "",
	# applicationIds: String = ""   Eg: applicationIds_example
	# Comma separated list of application ids
	applicationIds = "",
	# devices: String = ""   Eg: devices_example
	# Deprecated parameter for device names
	devices = "",
	# deviceIds: String = ""   Eg: deviceIds_example
	# Comma separated list of device ids
	deviceIds = "",
	# deviceVersions: String = ""   Eg: deviceVersions_example
	# Comma separated list of device version ranges
	deviceVersions = "",
	# locations: String = ""   Eg: locations_example
	# List of lat/long pairs for mission locations
	locations = "",
	# radius: String = ""   Eg: radius_example
	# Comma separated list of radii for locations
	radius = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/mission/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["title"] = title
	bzz_query["description"] = description
	bzz_query["subType"] = subType
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["active"] = active
	bzz_query["gameLevelIds"] = gameLevelIds
	bzz_query["creativeIds"] = creativeIds
	bzz_query["audienceIds"] = audienceIds
	bzz_query["missionTask"] = missionTask
	bzz_query["formatType"] = formatType
	bzz_query["offerId"] = offerId
	bzz_query["balance"] = balance
	bzz_query["advancedReporting"] = advancedReporting
	bzz_query["allocateTickets"] = allocateTickets
	bzz_query["ticketCount"] = ticketCount
	bzz_query["ticketType"] = ticketType
	bzz_query["points"] = points
	bzz_query["metaData"] = metaData
	bzz_query["applicationIds"] = applicationIds
	bzz_query["devices"] = devices
	bzz_query["deviceIds"] = deviceIds
	bzz_query["deviceVersions"] = deviceVersions
	bzz_query["locations"] = locations
	bzz_query["radius"] = radius

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = MissionResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_mission_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# title: String = ""   Eg: title_example
	# The title of the mission
	title: String,
	# description: String = ""   Eg: description_example
	# The description of the mission
	description = "",
	# subType: String = ""   Eg: subType_example
	# Custom string client apps can use for searching/filtering missions
	subType = "",
	# startDate: float   Eg: 789
	# The date/time to start the mission, send 0 to unset
	startDate = null,
	# endDate: float   Eg: 789
	# The date/time to end the mission, send 0 to unset
	endDate = null,
	# active: bool   Eg: true
	# Activate/deactivate the mission
	active = null,
	# gameLevelIds: String = ""   Eg: gameLevelIds_example
	# the game level ids to include in the mission, comma separated
	gameLevelIds = "",
	# creativeIds: String = ""   Eg: creativeIds_example
	# creatives to associate with the mission
	creativeIds = "",
	# audienceIds: String = ""   Eg: audienceIds_example
	# audiences to associate with the mission
	audienceIds = "",
	# missionTask: String = ""   Eg: missionTask_example
	# This parameter is deprecated.
	missionTask = "",
	# formatType: String = ""   Eg: formatType_example
	# The string identifier for a mission format (this is not the missionFormatId)
	formatType = "",
	# offerId: float   Eg: 789
	# The offerId to give as a reward
	offerId = null,
	# balance: int   Eg: 1.2
	# Set the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited.
	balance = null,
	# advancedReporting: bool   Eg: true
	# Flag to mark the mission as eligible for advanced reporting
	advancedReporting = null,
	# allocateTickets: bool   Eg: true
	# Flag to indicate owner should receive tickets for completed missions
	allocateTickets = null,
	# ticketCount: float   Eg: 789
	# The number of tickets to reward
	ticketCount = null,
	# ticketType: String = ""   Eg: ticketType_example
	# The type of ticket to reward, null means default type
	ticketType = "",
	# points: float   Eg: 789
	# The number of points to award for completing a mission
	points = null,
	# metaData: String = ""   Eg: metaData_example
	# external custom client defined data
	metaData = "",
	# applicationIds: String = ""   Eg: applicationIds_example
	# Comma separated list of application ids
	applicationIds = "",
	# devices: String = ""   Eg: devices_example
	# Deprecated parameter for device names
	devices = "",
	# deviceIds: String = ""   Eg: deviceIds_example
	# Comma separated list of device ids
	deviceIds = "",
	# deviceVersions: String = ""   Eg: deviceVersions_example
	# Comma separated list of device version ranges
	deviceVersions = "",
	# locations: String = ""   Eg: locations_example
	# List of lat/long pairs for mission locations
	locations = "",
	# radius: String = ""   Eg: radius_example
	# Comma separated list of radii for locations
	radius = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_mission")
	bzz_callable.bind(
		version,
		accountId,
		title,
		description,
		subType,
		startDate,
		endDate,
		active,
		gameLevelIds,
		creativeIds,
		audienceIds,
		missionTask,
		formatType,
		offerId,
		balance,
		advancedReporting,
		allocateTickets,
		ticketCount,
		ticketType,
		points,
		metaData,
		applicationIds,
		devices,
		deviceIds,
		deviceVersions,
		locations,
		radius,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteMission → POST /api/{version}/mission/delete
# Delete Mission
#
# Delete a mission.
func delete_mission(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# missionId: float   Eg: 789
	# the id of the mission to delete
	missionId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/mission/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["missionId"] = missionId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_mission_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# missionId: float   Eg: 789
	# the id of the mission to delete
	missionId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_mission")
	bzz_callable.bind(
		version,
		accountId,
		missionId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation findMissions → GET /api/{version}/mission/find
# Find Missions
#
# Get a set of ad filtered by the parameters provided.
func find_missions(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic.
	appKey: String,
	# suffix: String = ""   Eg: suffix_example
	# The type of mission to get, possible values are: click_banner, click_leaderboard, click_skyscraper, click_full, click_video, or click_zip
	suffix = "",
	# type: String = ""   Eg: type_example
	# The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix.
	type = "",
	# accountId: float   Eg: 789
	# The logged in user.
	accountId = null,
	# appVersion: String = ""   Eg: appVersion_example
	# The version of the application, will not return levels newer than the appVersion.
	appVersion = "",
	# latitude: int   Eg: 1.2
	# The current location of the requesting device
	latitude = null,
	# longitude: int   Eg: 1.2
	# The current location of the requesting device
	longitude = null,
	# device: String = ""   Eg: device_example
	# Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list.
	device = "",
	# deviceIdentifier: float   Eg: 789
	# The device ID of the requesting device, use /audience/devices for list
	deviceIdentifier = null,
	# deviceVersion: String = ""   Eg: deviceVersion_example
	# The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string.
	deviceVersion = "",
	# start: int   Eg: 56
	# The index into the record set to start with.
	start = null,
	# limit: int   Eg: 56
	# The total number of record to return.
	limit = null,
	# includeGameData: bool   Eg: true
	# Include the game level data with the mission.
	includeGameData = null,
	# includeAudiences: bool   Eg: true
	# If true then return the audience data in the response. Default is false.
	includeAudiences = null,
	# allocatesTickets: bool   Eg: true
	# If true/false only return missions whose game levels allocate (or don't allocate) tickets. Do not provide a value to return both.
	allocatesTickets = null,
	# some_randomize: bool   Eg: true
	# return a random set of results, default is true. If false returns in natural order.
	some_randomize = null,
	# targetedAdsOnly: bool   Eg: true
	# return only ads targeted to the specific app, no global ads.
	targetedAdsOnly = null,
	# missionIds: String = ""   Eg: missionIds_example
	# return only ads from the specified campaigns.
	missionIds = "",
	# audienceOperator: String = ""   Eg: audienceOperator_example
	# will return the items that have at least 1 or all of their audiences exist in the logged in user’s audiences, depending if the value is OR or AND
	audienceOperator = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/mission/find".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["appKey"] = appKey
	bzz_query["suffix"] = suffix
	bzz_query["type"] = type
	bzz_query["accountId"] = accountId
	bzz_query["appVersion"] = appVersion
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["device"] = device
	bzz_query["deviceIdentifier"] = deviceIdentifier
	bzz_query["deviceVersion"] = deviceVersion
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["includeGameData"] = includeGameData
	bzz_query["includeAudiences"] = includeAudiences
	bzz_query["allocatesTickets"] = allocatesTickets
	bzz_query["randomize"] = some_randomize
	bzz_query["targetedAdsOnly"] = targetedAdsOnly
	bzz_query["missionIds"] = missionIds
	bzz_query["audienceOperator"] = audienceOperator

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = MissionResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func find_missions_threaded(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic.
	appKey: String,
	# suffix: String = ""   Eg: suffix_example
	# The type of mission to get, possible values are: click_banner, click_leaderboard, click_skyscraper, click_full, click_video, or click_zip
	suffix = "",
	# type: String = ""   Eg: type_example
	# The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix.
	type = "",
	# accountId: float   Eg: 789
	# The logged in user.
	accountId = null,
	# appVersion: String = ""   Eg: appVersion_example
	# The version of the application, will not return levels newer than the appVersion.
	appVersion = "",
	# latitude: int   Eg: 1.2
	# The current location of the requesting device
	latitude = null,
	# longitude: int   Eg: 1.2
	# The current location of the requesting device
	longitude = null,
	# device: String = ""   Eg: device_example
	# Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list.
	device = "",
	# deviceIdentifier: float   Eg: 789
	# The device ID of the requesting device, use /audience/devices for list
	deviceIdentifier = null,
	# deviceVersion: String = ""   Eg: deviceVersion_example
	# The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string.
	deviceVersion = "",
	# start: int   Eg: 56
	# The index into the record set to start with.
	start = null,
	# limit: int   Eg: 56
	# The total number of record to return.
	limit = null,
	# includeGameData: bool   Eg: true
	# Include the game level data with the mission.
	includeGameData = null,
	# includeAudiences: bool   Eg: true
	# If true then return the audience data in the response. Default is false.
	includeAudiences = null,
	# allocatesTickets: bool   Eg: true
	# If true/false only return missions whose game levels allocate (or don't allocate) tickets. Do not provide a value to return both.
	allocatesTickets = null,
	# some_randomize: bool   Eg: true
	# return a random set of results, default is true. If false returns in natural order.
	some_randomize = null,
	# targetedAdsOnly: bool   Eg: true
	# return only ads targeted to the specific app, no global ads.
	targetedAdsOnly = null,
	# missionIds: String = ""   Eg: missionIds_example
	# return only ads from the specified campaigns.
	missionIds = "",
	# audienceOperator: String = ""   Eg: audienceOperator_example
	# will return the items that have at least 1 or all of their audiences exist in the logged in user’s audiences, depending if the value is OR or AND
	audienceOperator = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "find_missions")
	bzz_callable.bind(
		version,
		appKey,
		suffix,
		type,
		accountId,
		appVersion,
		latitude,
		longitude,
		device,
		deviceIdentifier,
		deviceVersion,
		start,
		limit,
		includeGameData,
		includeAudiences,
		allocatesTickets,
		some_randomize,
		targetedAdsOnly,
		missionIds,
		audienceOperator,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getMission → GET /api/{version}/mission/get
# Get Mission
#
# Get a mission.
func get_mission(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# missionId: float   Eg: 789
	# The id of the mission to return.
	missionId: float,
	# returnCreative: bool   Eg: true
	# Return creatives associated with the mission when true
	returnCreative = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/mission/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["missionId"] = missionId
	bzz_query["returnCreative"] = returnCreative

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = MissionResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_mission_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# missionId: float   Eg: 789
	# The id of the mission to return.
	missionId: float,
	# returnCreative: bool   Eg: true
	# Return creatives associated with the mission when true
	returnCreative = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_mission")
	bzz_callable.bind(
		version,
		accountId,
		missionId,
		returnCreative,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation importMission → POST /api/{version}/mission/import
# Import Mission
#
# Create a mission using a source item such as an offer location.
func import_mission(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# latitude: int   Eg: 1.2
	# The current location of the requesting device
	latitude: int,
	# longitude: int   Eg: 1.2
	# The current location of the requesting device
	longitude: int,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# keyword: String = ""   Eg: keyword_example
	# the keyword of the mission
	keyword = "",
	# start: int   Eg: 56
	# The starting index in the result set to return. Default is 0.
	start = null,
	# limit: int   Eg: 56
	# The total number of records to return. Default is 20.
	limit = null,
	# adSize: String = ""   Eg: adSize_example
	# the size of the ad
	adSize = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/mission/import".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["keyword"] = keyword
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["appKey"] = appKey
	bzz_query["adSize"] = adSize

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func import_mission_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# latitude: int   Eg: 1.2
	# The current location of the requesting device
	latitude: int,
	# longitude: int   Eg: 1.2
	# The current location of the requesting device
	longitude: int,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# keyword: String = ""   Eg: keyword_example
	# the keyword of the mission
	keyword = "",
	# start: int   Eg: 56
	# The starting index in the result set to return. Default is 0.
	start = null,
	# limit: int   Eg: 56
	# The total number of records to return. Default is 20.
	limit = null,
	# adSize: String = ""   Eg: adSize_example
	# the size of the ad
	adSize = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "import_mission")
	bzz_callable.bind(
		version,
		accountId,
		latitude,
		longitude,
		appKey,
		keyword,
		start,
		limit,
		adSize,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchMissionFormats → GET /api/{version}/mission/format/search
# Search Mission Formats
#
# Searches on pre-defined mission formats
func search_mission_formats(
	# version: float   Eg: 3.16
	version: float,
	# start: int   Eg: 56
	# The starting index in the result set to return. Default is 0.
	start: int,
	# limit: int   Eg: 56
	# The total number of records to return. Default is 20.
	limit: int,
	# activeOnly: bool   Eg: true
	# Determines whether to return only active results. Default is false.
	activeOnly: bool,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/mission/format/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["activeOnly"] = activeOnly

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = MissionFormatResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_mission_formats_threaded(
	# version: float   Eg: 3.16
	version: float,
	# start: int   Eg: 56
	# The starting index in the result set to return. Default is 0.
	start: int,
	# limit: int   Eg: 56
	# The total number of records to return. Default is 20.
	limit: int,
	# activeOnly: bool   Eg: true
	# Determines whether to return only active results. Default is false.
	activeOnly: bool,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_mission_formats")
	bzz_callable.bind(
		version,
		start,
		limit,
		activeOnly,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchMissions → GET /api/{version}/mission/search
# Search Missions
#
# Get the list missions available to the account.  
func search_missions(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# keyword: String = ""   Eg: keyword_example
	# Filter by keyword
	keyword = "",
	# subType: String = ""   Eg: subType_example
	# Custom string client apps can use for searching/filtering missions
	subType = "",
	# start: int   Eg: 56
	# The index into the record set to start with. Default is 0.
	start = null,
	# limit: int   Eg: 56
	# The total number of record to return. Default is 20, maximum is 100.
	limit = null,
	# includeGameData: bool   Eg: true
	# If true then return the game level data in the response. Default is false.
	includeGameData = null,
	# includeAudiences: bool   Eg: true
	# If true then return the audience data in the response. Default is false.
	includeAudiences = null,
	# includeInactive: bool   Eg: true
	# If true then include inactive missions. Default is false.
	includeInactive = null,
	# suffix: String = ""   Eg: suffix_example
	# A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml
	suffix = "",
	# sortField: String = ""   Eg: sortField_example
	# The field to sort the search on (for example TITLE)
	sortField = "",
	# descending: bool   Eg: true
	# Whether to sort in descending order (default true)
	descending = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/mission/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["keyword"] = keyword
	bzz_query["subType"] = subType
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["includeGameData"] = includeGameData
	bzz_query["includeAudiences"] = includeAudiences
	bzz_query["includeInactive"] = includeInactive
	bzz_query["suffix"] = suffix
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = MissionResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_missions_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# keyword: String = ""   Eg: keyword_example
	# Filter by keyword
	keyword = "",
	# subType: String = ""   Eg: subType_example
	# Custom string client apps can use for searching/filtering missions
	subType = "",
	# start: int   Eg: 56
	# The index into the record set to start with. Default is 0.
	start = null,
	# limit: int   Eg: 56
	# The total number of record to return. Default is 20, maximum is 100.
	limit = null,
	# includeGameData: bool   Eg: true
	# If true then return the game level data in the response. Default is false.
	includeGameData = null,
	# includeAudiences: bool   Eg: true
	# If true then return the audience data in the response. Default is false.
	includeAudiences = null,
	# includeInactive: bool   Eg: true
	# If true then include inactive missions. Default is false.
	includeInactive = null,
	# suffix: String = ""   Eg: suffix_example
	# A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml
	suffix = "",
	# sortField: String = ""   Eg: sortField_example
	# The field to sort the search on (for example TITLE)
	sortField = "",
	# descending: bool   Eg: true
	# Whether to sort in descending order (default true)
	descending = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_missions")
	bzz_callable.bind(
		version,
		accountId,
		keyword,
		subType,
		start,
		limit,
		includeGameData,
		includeAudiences,
		includeInactive,
		suffix,
		sortField,
		descending,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchMissionsByBillableEntity → GET /api/{version}/mission/searchByBillableEntity
# Search Missions by Billable Entity
#
# Use the accountId to determine the associated BillableEntity.  From there get a list of all accounts associated as managers.  Get the list missions owned by all associated managers.
func search_missions_by_billable_entity(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# keyword: String = ""   Eg: keyword_example
	# Filter by keyword
	keyword = "",
	# start: int   Eg: 56
	# The index into the record set to start with. Default is 0.
	start = null,
	# limit: int   Eg: 56
	# The total number of record to return. Default id 20.
	limit = null,
	# includeGameData: bool   Eg: true
	# If true then return the game level data in the response. Default is false.
	includeGameData = null,
	# includeAudiences: bool   Eg: true
	# If true then return the audience data in the response. Default is false.
	includeAudiences = null,
	# includeInactive: bool   Eg: true
	# If true then include inactive missions. Default is false.
	includeInactive = null,
	# suffix: String = ""   Eg: suffix_example
	# A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml
	suffix = "",
	# sortField: String = ""   Eg: sortField_example
	# The field to sort the search on (for example TITLE)
	sortField = "",
	# descending: bool   Eg: true
	# Whether to sort in descending order (default true)
	descending = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/mission/searchByBillableEntity".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["keyword"] = keyword
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["includeGameData"] = includeGameData
	bzz_query["includeAudiences"] = includeAudiences
	bzz_query["includeInactive"] = includeInactive
	bzz_query["suffix"] = suffix
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = MissionResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_missions_by_billable_entity_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# keyword: String = ""   Eg: keyword_example
	# Filter by keyword
	keyword = "",
	# start: int   Eg: 56
	# The index into the record set to start with. Default is 0.
	start = null,
	# limit: int   Eg: 56
	# The total number of record to return. Default id 20.
	limit = null,
	# includeGameData: bool   Eg: true
	# If true then return the game level data in the response. Default is false.
	includeGameData = null,
	# includeAudiences: bool   Eg: true
	# If true then return the audience data in the response. Default is false.
	includeAudiences = null,
	# includeInactive: bool   Eg: true
	# If true then include inactive missions. Default is false.
	includeInactive = null,
	# suffix: String = ""   Eg: suffix_example
	# A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml
	suffix = "",
	# sortField: String = ""   Eg: sortField_example
	# The field to sort the search on (for example TITLE)
	sortField = "",
	# descending: bool   Eg: true
	# Whether to sort in descending order (default true)
	descending = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_missions_by_billable_entity")
	bzz_callable.bind(
		version,
		accountId,
		keyword,
		start,
		limit,
		includeGameData,
		includeAudiences,
		includeInactive,
		suffix,
		sortField,
		descending,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateMission → POST /api/{version}/mission/update
# Update Mission
#
# Update a mission.
func update_mission(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# missionId: float   Eg: 789
	# The id of the mission to update.
	missionId: float,
	# title: String = ""   Eg: title_example
	# The title of the mission
	title = "",
	# description: String = ""   Eg: description_example
	# The description of the mission
	description = "",
	# subType: String = ""   Eg: subType_example
	# Custom string client apps can use for searching/filtering missions
	subType = "",
	# metaData: String = ""   Eg: metaData_example
	# external custom client defined data
	metaData = "",
	# startDate: float   Eg: 789
	# The date/time to start the mission, send 0 to unset
	startDate = null,
	# endDate: float   Eg: 789
	# The date/time to end the mission, send 0 to unset
	endDate = null,
	# active: bool   Eg: true
	# Activate/deactivate the mission
	active = null,
	# gameLevelIds: String = ""   Eg: gameLevelIds_example
	# the game level ids to include in the mission, comma separated
	gameLevelIds = "",
	# creativeIds: String = ""   Eg: creativeIds_example
	creativeIds = "",
	# audienceIds: String = ""   Eg: audienceIds_example
	audienceIds = "",
	# offerId: float   Eg: 789
	# The offerId to give as a reward
	offerId = null,
	# balance: int   Eg: 1.2
	# Replace the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited.
	balance = null,
	# advancedReporting: bool   Eg: true
	# Flag to mark the mission as eligible for advanced reporting
	advancedReporting = null,
	# allocateTickets: bool   Eg: true
	# Flag to indicate owner should receive tickets for completed missions
	allocateTickets = null,
	# ticketCount: float   Eg: 789
	# The number of tickets to reward
	ticketCount = null,
	# ticketType: String = ""   Eg: ticketType_example
	# The type of ticket to reward, null means default type
	ticketType = "",
	# points: float   Eg: 789
	# The number of points to award for completing a mission
	points = null,
	# applicationIds: String = ""   Eg: applicationIds_example
	# Comma separated list of application ids
	applicationIds = "",
	# devices: String = ""   Eg: devices_example
	# Deprecated parameter for device names
	devices = "",
	# deviceIds: String = ""   Eg: deviceIds_example
	# Comma separated list of device ids
	deviceIds = "",
	# deviceVersions: String = ""   Eg: deviceVersions_example
	# Comma separated list of device version ranges
	deviceVersions = "",
	# locations: String = ""   Eg: locations_example
	# List of lat/long pairs for mission locations
	locations = "",
	# radius: String = ""   Eg: radius_example
	# Comma separated list of radii for locations
	radius = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/mission/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["missionId"] = missionId
	bzz_query["title"] = title
	bzz_query["description"] = description
	bzz_query["subType"] = subType
	bzz_query["metaData"] = metaData
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["active"] = active
	bzz_query["gameLevelIds"] = gameLevelIds
	bzz_query["creativeIds"] = creativeIds
	bzz_query["audienceIds"] = audienceIds
	bzz_query["offerId"] = offerId
	bzz_query["balance"] = balance
	bzz_query["advancedReporting"] = advancedReporting
	bzz_query["allocateTickets"] = allocateTickets
	bzz_query["ticketCount"] = ticketCount
	bzz_query["ticketType"] = ticketType
	bzz_query["points"] = points
	bzz_query["applicationIds"] = applicationIds
	bzz_query["devices"] = devices
	bzz_query["deviceIds"] = deviceIds
	bzz_query["deviceVersions"] = deviceVersions
	bzz_query["locations"] = locations
	bzz_query["radius"] = radius

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = MissionResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_mission_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# missionId: float   Eg: 789
	# The id of the mission to update.
	missionId: float,
	# title: String = ""   Eg: title_example
	# The title of the mission
	title = "",
	# description: String = ""   Eg: description_example
	# The description of the mission
	description = "",
	# subType: String = ""   Eg: subType_example
	# Custom string client apps can use for searching/filtering missions
	subType = "",
	# metaData: String = ""   Eg: metaData_example
	# external custom client defined data
	metaData = "",
	# startDate: float   Eg: 789
	# The date/time to start the mission, send 0 to unset
	startDate = null,
	# endDate: float   Eg: 789
	# The date/time to end the mission, send 0 to unset
	endDate = null,
	# active: bool   Eg: true
	# Activate/deactivate the mission
	active = null,
	# gameLevelIds: String = ""   Eg: gameLevelIds_example
	# the game level ids to include in the mission, comma separated
	gameLevelIds = "",
	# creativeIds: String = ""   Eg: creativeIds_example
	creativeIds = "",
	# audienceIds: String = ""   Eg: audienceIds_example
	audienceIds = "",
	# offerId: float   Eg: 789
	# The offerId to give as a reward
	offerId = null,
	# balance: int   Eg: 1.2
	# Replace the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited.
	balance = null,
	# advancedReporting: bool   Eg: true
	# Flag to mark the mission as eligible for advanced reporting
	advancedReporting = null,
	# allocateTickets: bool   Eg: true
	# Flag to indicate owner should receive tickets for completed missions
	allocateTickets = null,
	# ticketCount: float   Eg: 789
	# The number of tickets to reward
	ticketCount = null,
	# ticketType: String = ""   Eg: ticketType_example
	# The type of ticket to reward, null means default type
	ticketType = "",
	# points: float   Eg: 789
	# The number of points to award for completing a mission
	points = null,
	# applicationIds: String = ""   Eg: applicationIds_example
	# Comma separated list of application ids
	applicationIds = "",
	# devices: String = ""   Eg: devices_example
	# Deprecated parameter for device names
	devices = "",
	# deviceIds: String = ""   Eg: deviceIds_example
	# Comma separated list of device ids
	deviceIds = "",
	# deviceVersions: String = ""   Eg: deviceVersions_example
	# Comma separated list of device version ranges
	deviceVersions = "",
	# locations: String = ""   Eg: locations_example
	# List of lat/long pairs for mission locations
	locations = "",
	# radius: String = ""   Eg: radius_example
	# Comma separated list of radii for locations
	radius = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_mission")
	bzz_callable.bind(
		version,
		accountId,
		missionId,
		title,
		description,
		subType,
		metaData,
		startDate,
		endDate,
		active,
		gameLevelIds,
		creativeIds,
		audienceIds,
		offerId,
		balance,
		advancedReporting,
		allocateTickets,
		ticketCount,
		ticketType,
		points,
		applicationIds,
		devices,
		deviceIds,
		deviceVersions,
		locations,
		radius,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


