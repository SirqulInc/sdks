extends ApiBee
class_name ApplicationConfigApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API ApplicationConfigApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "ApplicationConfigApi"


# Operation createApplicationConfig → POST /appconfig/create
# Create AppConfig
#
# Creates a new application configuration. If the configVersion provided already exists for the given app, an invalid response is returned and the application configuration won't be created.
func create_application_config(
	# accountId: float   Eg: 789
	# The account ID of the user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key that the newly created applicationConfig will be associated to
	appKey: String,
	# configVersion: String = ""   Eg: configVersion_example
	# The application configuration, has to be unique within the application
	configVersion: String,
	# assetId: float   Eg: 789
	# The json assetId that stores the configuration detail.
	assetId: float,
	# retailerId: float   Eg: 789
	# The retailer id for retailer specific configurations
	retailerId = null,
	# retailerLocationId: float   Eg: 789
	# The retailer location id for retailer location specific configurations
	retailerLocationId = null,
	# udid: String = ""   Eg: udid_example
	# The device udid for device specific configurations
	udid = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/appconfig/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["configVersion"] = configVersion
	bzz_query["assetId"] = assetId
	bzz_query["retailerId"] = retailerId
	bzz_query["retailerLocationId"] = retailerLocationId
	bzz_query["udid"] = udid

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ApplicationConfigResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_application_config_threaded(
	# accountId: float   Eg: 789
	# The account ID of the user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key that the newly created applicationConfig will be associated to
	appKey: String,
	# configVersion: String = ""   Eg: configVersion_example
	# The application configuration, has to be unique within the application
	configVersion: String,
	# assetId: float   Eg: 789
	# The json assetId that stores the configuration detail.
	assetId: float,
	# retailerId: float   Eg: 789
	# The retailer id for retailer specific configurations
	retailerId = null,
	# retailerLocationId: float   Eg: 789
	# The retailer location id for retailer location specific configurations
	retailerLocationId = null,
	# udid: String = ""   Eg: udid_example
	# The device udid for device specific configurations
	udid = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_application_config")
	bzz_callable.bind(
		accountId,
		appKey,
		configVersion,
		assetId,
		retailerId,
		retailerLocationId,
		udid,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteApplicationConfig → POST /appconfig/delete
# Delete AppConfig
#
# Mark the application configuration for deletion.
func delete_application_config(
	# accountId: float   Eg: 789
	# The account ID of the user
	accountId: float,
	# configId: float   Eg: 789
	# The config ID of the application configuration to delete
	configId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/appconfig/delete"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["configId"] = configId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_application_config_threaded(
	# accountId: float   Eg: 789
	# The account ID of the user
	accountId: float,
	# configId: float   Eg: 789
	# The config ID of the application configuration to delete
	configId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_application_config")
	bzz_callable.bind(
		accountId,
		configId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getApplicationConfig → GET /appconfig/get
# Get AppConfig
#
# Gets the appConfig data by the given configId. If appConfig cannot be found, it returns an invalid response.
func get_application_config(
	# accountId: float   Eg: 789
	# The account ID of the user
	accountId: float,
	# configId: float   Eg: 789
	# The config ID of the application configuration
	configId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/appconfig/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["configId"] = configId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ApplicationConfigResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_application_config_threaded(
	# accountId: float   Eg: 789
	# The account ID of the user
	accountId: float,
	# configId: float   Eg: 789
	# The config ID of the application configuration
	configId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_application_config")
	bzz_callable.bind(
		accountId,
		configId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getApplicationConfigByConfigVersion → GET /appconfig/getbyversion
# Get AppConfig by Version
#
# Gets the appConfig data by the given appKey and app configVersion number.If the appKey is is invalid or appConfig is not found, it returns an invalid response. 
func get_application_config_by_config_version(
	# appKey: String = ""   Eg: appKey_example
	# The application key
	appKey: String,
	# configVersion: String = ""   Eg: configVersion_example
	# The version of the application configuration
	configVersion: String,
	# retailerId: float   Eg: 789
	# Only returns the config that matches the given retailer
	retailerId = null,
	# retailerLocationId: float   Eg: 789
	# Only returns the config that matches the given retailer location
	retailerLocationId = null,
	# udid: String = ""   Eg: udid_example
	# Only returns only returns the config that matches the given device udid
	udid = "",
	# allowOlderVersions: bool = false   Eg: true
	# Determines whether to return older config versions if the exact version is not found. If this happens, will try to return the latest version.
	allowOlderVersions = false,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/appconfig/getbyversion"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["appKey"] = appKey
	bzz_query["configVersion"] = configVersion
	bzz_query["retailerId"] = retailerId
	bzz_query["retailerLocationId"] = retailerLocationId
	bzz_query["udid"] = udid
	bzz_query["allowOlderVersions"] = allowOlderVersions

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ApplicationConfigResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_application_config_by_config_version_threaded(
	# appKey: String = ""   Eg: appKey_example
	# The application key
	appKey: String,
	# configVersion: String = ""   Eg: configVersion_example
	# The version of the application configuration
	configVersion: String,
	# retailerId: float   Eg: 789
	# Only returns the config that matches the given retailer
	retailerId = null,
	# retailerLocationId: float   Eg: 789
	# Only returns the config that matches the given retailer location
	retailerLocationId = null,
	# udid: String = ""   Eg: udid_example
	# Only returns only returns the config that matches the given device udid
	udid = "",
	# allowOlderVersions: bool = false   Eg: true
	# Determines whether to return older config versions if the exact version is not found. If this happens, will try to return the latest version.
	allowOlderVersions = false,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_application_config_by_config_version")
	bzz_callable.bind(
		appKey,
		configVersion,
		retailerId,
		retailerLocationId,
		udid,
		allowOlderVersions,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchApplicationConfig → GET /appconfig/search
# Search AppConfigs
#
# Gets all versions of application configurations in a particular app by the given appKey.
func search_application_config(
	# accountId: float   Eg: 789
	# The account ID of the user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key to filter results by application Leaving this empty will return all application configurations for all applications (executive user only)
	appKey = "",
	# retailerId: float   Eg: 789
	# Only returns the configs that matches the given retailer
	retailerId = null,
	# retailerLocationId: float   Eg: 789
	# Only returns the configs that matches the given retailer location
	retailerLocationId = null,
	# udid: String = ""   Eg: udid_example
	# Only returns only returns the configs that matches the given device udid
	udid = "",
	# configVersion: String = ""   Eg: configVersion_example
	# Config Version
	configVersion = "",
	# sortField: String = "CONFIG_VERSION_INDEX"   Eg: sortField_example
	# Orders the results by: CREATED, UPDATED, ACTIVE, APPLICATION_ID,  APPLICATION_KEY, APPLICATION_NAME, RETAILER_NAME, RETAILER_ID, RETAILER_LOCATION_NAME,  RETAILER_LOCATION_ID, OFFER_TITLE, OFFER_ID, OFFER_LOCATION_ID, CONFIG_VERSION_MINOR,  CONFIG_VERSION_MAJOR, CONFIG_VERSION_INDEX 
	sortField = "CONFIG_VERSION_INDEX",
	# descending: bool = true   Eg: true
	# Determines whether the results are in descending or ascending order
	descending = true,
	# start: int = 0   Eg: 56
	# The start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# The limit for pagination (There is a hard limit of 100)
	limit = 20,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/appconfig/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["retailerId"] = retailerId
	bzz_query["retailerLocationId"] = retailerLocationId
	bzz_query["udid"] = udid
	bzz_query["configVersion"] = configVersion
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ApplicationConfigResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_application_config_threaded(
	# accountId: float   Eg: 789
	# The account ID of the user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key to filter results by application Leaving this empty will return all application configurations for all applications (executive user only)
	appKey = "",
	# retailerId: float   Eg: 789
	# Only returns the configs that matches the given retailer
	retailerId = null,
	# retailerLocationId: float   Eg: 789
	# Only returns the configs that matches the given retailer location
	retailerLocationId = null,
	# udid: String = ""   Eg: udid_example
	# Only returns only returns the configs that matches the given device udid
	udid = "",
	# configVersion: String = ""   Eg: configVersion_example
	# Config Version
	configVersion = "",
	# sortField: String = "CONFIG_VERSION_INDEX"   Eg: sortField_example
	# Orders the results by: CREATED, UPDATED, ACTIVE, APPLICATION_ID,  APPLICATION_KEY, APPLICATION_NAME, RETAILER_NAME, RETAILER_ID, RETAILER_LOCATION_NAME,  RETAILER_LOCATION_ID, OFFER_TITLE, OFFER_ID, OFFER_LOCATION_ID, CONFIG_VERSION_MINOR,  CONFIG_VERSION_MAJOR, CONFIG_VERSION_INDEX 
	sortField = "CONFIG_VERSION_INDEX",
	# descending: bool = true   Eg: true
	# Determines whether the results are in descending or ascending order
	descending = true,
	# start: int = 0   Eg: 56
	# The start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# The limit for pagination (There is a hard limit of 100)
	limit = 20,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_application_config")
	bzz_callable.bind(
		accountId,
		appKey,
		retailerId,
		retailerLocationId,
		udid,
		configVersion,
		sortField,
		descending,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateApplicationConfig → POST /appconfig/update
# Update AppConfig
#
# pdates an existing application configuration. If the configVersion provided already exists for the given app the application configuration won't be updated.
func update_application_config(
	# accountId: float   Eg: 789
	# The account ID of the user
	accountId: float,
	# configId: float   Eg: 789
	# The config ID of the application configuration to update
	configId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key that the updated applicationConfig will be associated to
	appKey = "",
	# configVersion: String = ""   Eg: configVersion_example
	# The application configuration, has to be unique within the application
	configVersion = "",
	# assetId: float   Eg: 789
	# The json assetId that stores the configuration detail.
	assetId = null,
	# retailerId: float   Eg: 789
	# The retailer id for retailer specific configurations
	retailerId = null,
	# retailerLocationId: float   Eg: 789
	# The retailer location id for retailer location specific configurations
	retailerLocationId = null,
	# udid: String = ""   Eg: udid_example
	# The device udid for device specific configurations
	udid = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/appconfig/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["configId"] = configId
	bzz_query["appKey"] = appKey
	bzz_query["configVersion"] = configVersion
	bzz_query["assetId"] = assetId
	bzz_query["retailerId"] = retailerId
	bzz_query["retailerLocationId"] = retailerLocationId
	bzz_query["udid"] = udid

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ApplicationConfigResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_application_config_threaded(
	# accountId: float   Eg: 789
	# The account ID of the user
	accountId: float,
	# configId: float   Eg: 789
	# The config ID of the application configuration to update
	configId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key that the updated applicationConfig will be associated to
	appKey = "",
	# configVersion: String = ""   Eg: configVersion_example
	# The application configuration, has to be unique within the application
	configVersion = "",
	# assetId: float   Eg: 789
	# The json assetId that stores the configuration detail.
	assetId = null,
	# retailerId: float   Eg: 789
	# The retailer id for retailer specific configurations
	retailerId = null,
	# retailerLocationId: float   Eg: 789
	# The retailer location id for retailer location specific configurations
	retailerLocationId = null,
	# udid: String = ""   Eg: udid_example
	# The device udid for device specific configurations
	udid = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_application_config")
	bzz_callable.bind(
		accountId,
		configId,
		appKey,
		configVersion,
		assetId,
		retailerId,
		retailerLocationId,
		udid,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


