extends ApiBee
class_name BillingInfoApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API BillingInfoApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "BillingInfoApi"


# Operation addPaymentMethod → POST /billing/update
# Update Payment Method
#
# Update a method of payment. If the paymentMethodId is not passed in then will update their default payment method.
func add_payment_method(
	# accountId: float   Eg: 789
	# The account used to perform the the request
	accountId: float,
	# paymentMethodId: float   Eg: 789
	# Payment Method Id
	paymentMethodId = null,
	# accountName: String = ""   Eg: accountName_example
	# the name of the account
	accountName = "",
	# firstName: String = ""   Eg: firstName_example
	# First Name that the account is filed as
	firstName = "",
	# lastName: String = ""   Eg: lastName_example
	# Last Name that the account is filed as
	lastName = "",
	# address: String = ""   Eg: address_example
	# Address that the account is filed as
	address = "",
	# city: String = ""   Eg: city_example
	# City that the account is filed as
	city = "",
	# state: String = ""   Eg: state_example
	# State that the account is filed as
	state = "",
	# postalCode: String = ""   Eg: postalCode_example
	# Postal Code that the account is filed as
	postalCode = "",
	# country: String = ""   Eg: country_example
	# Country that the account is filed as
	country = "",
	# phone: String = ""   Eg: phone_example
	# Phone that the account is filed as
	phone = "",
	# creditCardNumber: String = ""   Eg: creditCardNumber_example
	# The full credit card number to store on file
	creditCardNumber = "",
	# expirationDate: String = ""   Eg: expirationDate_example
	# The credit card expiration date YYYY-MM
	expirationDate = "",
	# ccv: String = ""   Eg: ccv_example
	# The 3 digit confirmation code
	ccv = "",
	# accountNumber: String = ""   Eg: accountNumber_example
	# The bank account number
	accountNumber = "",
	# bankName: String = ""   Eg: bankName_example
	# The bank name
	bankName = "",
	# routingNumber: String = ""   Eg: routingNumber_example
	# Routing Number
	routingNumber = "",
	# defaultPaymentMethod: bool   Eg: true
	# Default Payment Method
	defaultPaymentMethod = null,
	# paymentMethodNickname: String = ""   Eg: paymentMethodNickname_example
	# Payment Method Nickname
	paymentMethodNickname = "",
	# taxId: String = ""   Eg: taxId_example
	# Tax Id
	taxId = "",
	# providerCustomerProfileId: String = ""   Eg: providerCustomerProfileId_example
	# Provider customer profile Id
	providerCustomerProfileId = "",
	# providerPaymentProfileId: String = ""   Eg: providerPaymentProfileId_example
	# Provider customer payment profile Id
	providerPaymentProfileId = "",
	# metaData: String = ""   Eg: metaData_example
	# Meta Data
	metaData = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/billing/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["paymentMethodId"] = paymentMethodId
	bzz_query["accountName"] = accountName
	bzz_query["firstName"] = firstName
	bzz_query["lastName"] = lastName
	bzz_query["address"] = address
	bzz_query["city"] = city
	bzz_query["state"] = state
	bzz_query["postalCode"] = postalCode
	bzz_query["country"] = country
	bzz_query["phone"] = phone
	bzz_query["creditCardNumber"] = creditCardNumber
	bzz_query["expirationDate"] = expirationDate
	bzz_query["ccv"] = ccv
	bzz_query["accountNumber"] = accountNumber
	bzz_query["bankName"] = bankName
	bzz_query["routingNumber"] = routingNumber
	bzz_query["defaultPaymentMethod"] = defaultPaymentMethod
	bzz_query["paymentMethodNickname"] = paymentMethodNickname
	bzz_query["taxId"] = taxId
	bzz_query["providerCustomerProfileId"] = providerCustomerProfileId
	bzz_query["providerPaymentProfileId"] = providerPaymentProfileId
	bzz_query["metaData"] = metaData

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PaymentTypesResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func add_payment_method_threaded(
	# accountId: float   Eg: 789
	# The account used to perform the the request
	accountId: float,
	# paymentMethodId: float   Eg: 789
	# Payment Method Id
	paymentMethodId = null,
	# accountName: String = ""   Eg: accountName_example
	# the name of the account
	accountName = "",
	# firstName: String = ""   Eg: firstName_example
	# First Name that the account is filed as
	firstName = "",
	# lastName: String = ""   Eg: lastName_example
	# Last Name that the account is filed as
	lastName = "",
	# address: String = ""   Eg: address_example
	# Address that the account is filed as
	address = "",
	# city: String = ""   Eg: city_example
	# City that the account is filed as
	city = "",
	# state: String = ""   Eg: state_example
	# State that the account is filed as
	state = "",
	# postalCode: String = ""   Eg: postalCode_example
	# Postal Code that the account is filed as
	postalCode = "",
	# country: String = ""   Eg: country_example
	# Country that the account is filed as
	country = "",
	# phone: String = ""   Eg: phone_example
	# Phone that the account is filed as
	phone = "",
	# creditCardNumber: String = ""   Eg: creditCardNumber_example
	# The full credit card number to store on file
	creditCardNumber = "",
	# expirationDate: String = ""   Eg: expirationDate_example
	# The credit card expiration date YYYY-MM
	expirationDate = "",
	# ccv: String = ""   Eg: ccv_example
	# The 3 digit confirmation code
	ccv = "",
	# accountNumber: String = ""   Eg: accountNumber_example
	# The bank account number
	accountNumber = "",
	# bankName: String = ""   Eg: bankName_example
	# The bank name
	bankName = "",
	# routingNumber: String = ""   Eg: routingNumber_example
	# Routing Number
	routingNumber = "",
	# defaultPaymentMethod: bool   Eg: true
	# Default Payment Method
	defaultPaymentMethod = null,
	# paymentMethodNickname: String = ""   Eg: paymentMethodNickname_example
	# Payment Method Nickname
	paymentMethodNickname = "",
	# taxId: String = ""   Eg: taxId_example
	# Tax Id
	taxId = "",
	# providerCustomerProfileId: String = ""   Eg: providerCustomerProfileId_example
	# Provider customer profile Id
	providerCustomerProfileId = "",
	# providerPaymentProfileId: String = ""   Eg: providerPaymentProfileId_example
	# Provider customer payment profile Id
	providerPaymentProfileId = "",
	# metaData: String = ""   Eg: metaData_example
	# Meta Data
	metaData = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "add_payment_method")
	bzz_callable.bind(
		accountId,
		paymentMethodId,
		accountName,
		firstName,
		lastName,
		address,
		city,
		state,
		postalCode,
		country,
		phone,
		creditCardNumber,
		expirationDate,
		ccv,
		accountNumber,
		bankName,
		routingNumber,
		defaultPaymentMethod,
		paymentMethodNickname,
		taxId,
		providerCustomerProfileId,
		providerPaymentProfileId,
		metaData,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createPaymentMethod → POST /billing/create
# Create Payment Method
#
# Add a new method of payment.
func create_payment_method(
	# accountId: float   Eg: 789
	# The account used to perform the the request
	accountId: float,
	# accountName: String = ""   Eg: accountName_example
	# Account Name of the credit card user
	accountName = "",
	# firstName: String = ""   Eg: firstName_example
	# The first name on the credit card
	firstName = "",
	# lastName: String = ""   Eg: lastName_example
	# The last name on the credit card
	lastName = "",
	# address: String = ""   Eg: address_example
	# The billing address of the credit card
	address = "",
	# city: String = ""   Eg: city_example
	# The billing city of the credit card
	city = "",
	# state: String = ""   Eg: state_example
	# The billing state of the credit card
	state = "",
	# postalCode: String = ""   Eg: postalCode_example
	# The billing zip code of the credit card
	postalCode = "",
	# country: String = ""   Eg: country_example
	# Country of the credit card
	country = "",
	# phone: String = ""   Eg: phone_example
	# The billing phone of the credit card
	phone = "",
	# creditCardNumber: String = ""   Eg: creditCardNumber_example
	# The full credit card number to store on file
	creditCardNumber = "",
	# expirationDate: String = ""   Eg: expirationDate_example
	# The credit card expiration date YYYY-MM
	expirationDate = "",
	# ccv: String = ""   Eg: ccv_example
	# The 3 digit confirmation code
	ccv = "",
	# accountNumber: String = ""   Eg: accountNumber_example
	# The bank account number
	accountNumber = "",
	# bankName: String = ""   Eg: bankName_example
	# The bank name
	bankName = "",
	# routingNumber: String = ""   Eg: routingNumber_example
	# The bank routing number
	routingNumber = "",
	# paymentMethodNickname: String = ""   Eg: paymentMethodNickname_example
	# The nickname to give the payment method
	paymentMethodNickname = "",
	# taxId: String = ""   Eg: taxId_example
	# Tax Id
	taxId = "",
	# defaultPaymentMethod: bool = true   Eg: true
	# Whether this should be the default payment method
	defaultPaymentMethod = true,
	# authToken: String = ""   Eg: authToken_example
	# An authorization token for providers that provide this (like Amazon Payments)
	authToken = "",
	# provider: String = "AUTHORIZE_NET"   Eg: provider_example
	# The payment provider (see PaymentMethodProvider)
	provider = "AUTHORIZE_NET",
	# providerCustomerProfileId: String = ""   Eg: providerCustomerProfileId_example
	# Provider customer profile Id
	providerCustomerProfileId = "",
	# providerPaymentProfileId: String = ""   Eg: providerPaymentProfileId_example
	# Provider customer payment profile Id
	providerPaymentProfileId = "",
	# metaData: String = ""   Eg: metaData_example
	# Meta Data
	metaData = "",
	# appKey: String = ""   Eg: appKey_example
	# Application Key
	appKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/billing/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["accountName"] = accountName
	bzz_query["firstName"] = firstName
	bzz_query["lastName"] = lastName
	bzz_query["address"] = address
	bzz_query["city"] = city
	bzz_query["state"] = state
	bzz_query["postalCode"] = postalCode
	bzz_query["country"] = country
	bzz_query["phone"] = phone
	bzz_query["creditCardNumber"] = creditCardNumber
	bzz_query["expirationDate"] = expirationDate
	bzz_query["ccv"] = ccv
	bzz_query["accountNumber"] = accountNumber
	bzz_query["bankName"] = bankName
	bzz_query["routingNumber"] = routingNumber
	bzz_query["paymentMethodNickname"] = paymentMethodNickname
	bzz_query["taxId"] = taxId
	bzz_query["defaultPaymentMethod"] = defaultPaymentMethod
	bzz_query["authToken"] = authToken
	bzz_query["provider"] = provider
	bzz_query["providerCustomerProfileId"] = providerCustomerProfileId
	bzz_query["providerPaymentProfileId"] = providerPaymentProfileId
	bzz_query["metaData"] = metaData
	bzz_query["appKey"] = appKey

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PaymentTypesResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_payment_method_threaded(
	# accountId: float   Eg: 789
	# The account used to perform the the request
	accountId: float,
	# accountName: String = ""   Eg: accountName_example
	# Account Name of the credit card user
	accountName = "",
	# firstName: String = ""   Eg: firstName_example
	# The first name on the credit card
	firstName = "",
	# lastName: String = ""   Eg: lastName_example
	# The last name on the credit card
	lastName = "",
	# address: String = ""   Eg: address_example
	# The billing address of the credit card
	address = "",
	# city: String = ""   Eg: city_example
	# The billing city of the credit card
	city = "",
	# state: String = ""   Eg: state_example
	# The billing state of the credit card
	state = "",
	# postalCode: String = ""   Eg: postalCode_example
	# The billing zip code of the credit card
	postalCode = "",
	# country: String = ""   Eg: country_example
	# Country of the credit card
	country = "",
	# phone: String = ""   Eg: phone_example
	# The billing phone of the credit card
	phone = "",
	# creditCardNumber: String = ""   Eg: creditCardNumber_example
	# The full credit card number to store on file
	creditCardNumber = "",
	# expirationDate: String = ""   Eg: expirationDate_example
	# The credit card expiration date YYYY-MM
	expirationDate = "",
	# ccv: String = ""   Eg: ccv_example
	# The 3 digit confirmation code
	ccv = "",
	# accountNumber: String = ""   Eg: accountNumber_example
	# The bank account number
	accountNumber = "",
	# bankName: String = ""   Eg: bankName_example
	# The bank name
	bankName = "",
	# routingNumber: String = ""   Eg: routingNumber_example
	# The bank routing number
	routingNumber = "",
	# paymentMethodNickname: String = ""   Eg: paymentMethodNickname_example
	# The nickname to give the payment method
	paymentMethodNickname = "",
	# taxId: String = ""   Eg: taxId_example
	# Tax Id
	taxId = "",
	# defaultPaymentMethod: bool = true   Eg: true
	# Whether this should be the default payment method
	defaultPaymentMethod = true,
	# authToken: String = ""   Eg: authToken_example
	# An authorization token for providers that provide this (like Amazon Payments)
	authToken = "",
	# provider: String = "AUTHORIZE_NET"   Eg: provider_example
	# The payment provider (see PaymentMethodProvider)
	provider = "AUTHORIZE_NET",
	# providerCustomerProfileId: String = ""   Eg: providerCustomerProfileId_example
	# Provider customer profile Id
	providerCustomerProfileId = "",
	# providerPaymentProfileId: String = ""   Eg: providerPaymentProfileId_example
	# Provider customer payment profile Id
	providerPaymentProfileId = "",
	# metaData: String = ""   Eg: metaData_example
	# Meta Data
	metaData = "",
	# appKey: String = ""   Eg: appKey_example
	# Application Key
	appKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_payment_method")
	bzz_callable.bind(
		accountId,
		accountName,
		firstName,
		lastName,
		address,
		city,
		state,
		postalCode,
		country,
		phone,
		creditCardNumber,
		expirationDate,
		ccv,
		accountNumber,
		bankName,
		routingNumber,
		paymentMethodNickname,
		taxId,
		defaultPaymentMethod,
		authToken,
		provider,
		providerCustomerProfileId,
		providerPaymentProfileId,
		metaData,
		appKey,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createSmartContract → POST /billing/crypto/transfer
# Create Smart Contract
#
# Adds a smart contract.
func create_smart_contract(
	# accountId: float   Eg: 789
	# The account used to perform the the request
	accountId: float,
	# tokenName: String = ""   Eg: tokenName_example
	# The token name
	tokenName: String,
	# tokenSymbol: String = ""   Eg: tokenSymbol_example
	# The token symbol
	tokenSymbol: String,
	# paymentMethodId: float   Eg: 789
	# The payment method to return details on. If this is not set, then the user's default payment method will be returned.
	paymentMethodId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/billing/crypto/transfer"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["paymentMethodId"] = paymentMethodId
	bzz_query["tokenName"] = tokenName
	bzz_query["tokenSymbol"] = tokenSymbol

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PaymentTypesResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_smart_contract_threaded(
	# accountId: float   Eg: 789
	# The account used to perform the the request
	accountId: float,
	# tokenName: String = ""   Eg: tokenName_example
	# The token name
	tokenName: String,
	# tokenSymbol: String = ""   Eg: tokenSymbol_example
	# The token symbol
	tokenSymbol: String,
	# paymentMethodId: float   Eg: 789
	# The payment method to return details on. If this is not set, then the user's default payment method will be returned.
	paymentMethodId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_smart_contract")
	bzz_callable.bind(
		accountId,
		tokenName,
		tokenSymbol,
		paymentMethodId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getCryptoBalance → GET /billing/crypto/get
# Get Crypto Balances
#
# Get the cypto balance details for a user
func get_crypto_balance(
	# accountId: float   Eg: 789
	# The account used to perform the the request
	accountId: float,
	# ownerAccountId: float   Eg: 789
	# The account to retreive balances for
	ownerAccountId = null,
	# paymentMethodId: float   Eg: 789
	# The payment method to return details on. If this is not set, then the user's default payment method will be returned.
	paymentMethodId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/billing/crypto/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["ownerAccountId"] = ownerAccountId
	bzz_query["paymentMethodId"] = paymentMethodId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PaymentTypesResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_crypto_balance_threaded(
	# accountId: float   Eg: 789
	# The account used to perform the the request
	accountId: float,
	# ownerAccountId: float   Eg: 789
	# The account to retreive balances for
	ownerAccountId = null,
	# paymentMethodId: float   Eg: 789
	# The payment method to return details on. If this is not set, then the user's default payment method will be returned.
	paymentMethodId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_crypto_balance")
	bzz_callable.bind(
		accountId,
		ownerAccountId,
		paymentMethodId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getPaymentMethod → GET /billing/get
# Get Payment Method
#
# Get the details of the user's payment method or their current default method of payment
func get_payment_method(
	# accountId: float   Eg: 789
	# The account used to perform the the request
	accountId: float,
	# paymentMethodId: float   Eg: 789
	# The payment method to return details on. If this is not set, then the user's default payment method will be returned.
	paymentMethodId = null,
	# getCurrentBalance: bool   Eg: true
	# Determines whether to get the user's current balance for the requested payment method option (not all payment method options support this)
	getCurrentBalance = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/billing/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["paymentMethodId"] = paymentMethodId
	bzz_query["getCurrentBalance"] = getCurrentBalance

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PaymentTypesResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_payment_method_threaded(
	# accountId: float   Eg: 789
	# The account used to perform the the request
	accountId: float,
	# paymentMethodId: float   Eg: 789
	# The payment method to return details on. If this is not set, then the user's default payment method will be returned.
	paymentMethodId = null,
	# getCurrentBalance: bool   Eg: true
	# Determines whether to get the user's current balance for the requested payment method option (not all payment method options support this)
	getCurrentBalance = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_payment_method")
	bzz_callable.bind(
		accountId,
		paymentMethodId,
		getCurrentBalance,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchPaymentMethod → GET /billing/search
# Search Payment Methods
#
# Search the payment methods of an account
func search_payment_method(
	# accountId: float   Eg: 789
	# Account Id to search on
	accountId: float,
	# provider: String = "AUTHORIZE_NET"   Eg: provider_example
	# Provider to search on
	provider = "AUTHORIZE_NET",
	# type: String = ""   Eg: type_example
	# the type to search on
	type = "",
	# keyword: String = ""   Eg: keyword_example
	# the keyword to search on
	keyword = "",
	# sortField: String = "UPDATED"   Eg: sortField_example
	# the sort field to use for the search
	sortField = "UPDATED",
	# descending: bool = true   Eg: true
	# if the results should be in descending order
	descending = true,
	# start: int = 0   Eg: 56
	# the start of the search
	start = 0,
	# limit: int = 5   Eg: 56
	# the limit of the search
	limit = 5,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/billing/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["provider"] = provider
	bzz_query["type"] = type
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PaymentTypesResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_payment_method_threaded(
	# accountId: float   Eg: 789
	# Account Id to search on
	accountId: float,
	# provider: String = "AUTHORIZE_NET"   Eg: provider_example
	# Provider to search on
	provider = "AUTHORIZE_NET",
	# type: String = ""   Eg: type_example
	# the type to search on
	type = "",
	# keyword: String = ""   Eg: keyword_example
	# the keyword to search on
	keyword = "",
	# sortField: String = "UPDATED"   Eg: sortField_example
	# the sort field to use for the search
	sortField = "UPDATED",
	# descending: bool = true   Eg: true
	# if the results should be in descending order
	descending = true,
	# start: int = 0   Eg: 56
	# the start of the search
	start = 0,
	# limit: int = 5   Eg: 56
	# the limit of the search
	limit = 5,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_payment_method")
	bzz_callable.bind(
		accountId,
		provider,
		type,
		keyword,
		sortField,
		descending,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


