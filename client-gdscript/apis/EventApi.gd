extends ApiBee
class_name EventApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API EventApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "EventApi"


# Operation attendEvent → POST /api/{version}/event/attend
# Attend Event
#
#  Specify whether the user is attending an event at a particular location. This can also be used as a \"check-in\" action.
func attend_event(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id (deviceId or accountId required)
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# The application of where to send notifications about the attend action
	appKey = "",
	# listingId: float   Eg: 789
	# The scheduled broadcast or marketing experience id
	listingId = null,
	# retailerLocationId: float   Eg: 789
	# The retailer location where the event is being held
	retailerLocationId = null,
	# offerLocationId: float   Eg: 789
	# The actual event being held
	offerLocationId = null,
	# transactionId: float   Eg: 789
	# The wallet item to update the status of, if provided then ignore the listingId, retailerLocationId, and the offerLocationId
	transactionId = null,
	# status: int   Eg: 56
	# Sets whether the user is: undecided (0), attending (1), attending and checked in (2), or not attending (3)
	status = null,
	# latitude: int   Eg: 1.2
	# The location of the status update
	latitude = null,
	# longitude: int   Eg: 1.2
	# The location of the status update
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/event/attend".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["listingId"] = listingId
	bzz_query["retailerLocationId"] = retailerLocationId
	bzz_query["offerLocationId"] = offerLocationId
	bzz_query["transactionId"] = transactionId
	bzz_query["status"] = status
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OfferResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func attend_event_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id (deviceId or accountId required)
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# The application of where to send notifications about the attend action
	appKey = "",
	# listingId: float   Eg: 789
	# The scheduled broadcast or marketing experience id
	listingId = null,
	# retailerLocationId: float   Eg: 789
	# The retailer location where the event is being held
	retailerLocationId = null,
	# offerLocationId: float   Eg: 789
	# The actual event being held
	offerLocationId = null,
	# transactionId: float   Eg: 789
	# The wallet item to update the status of, if provided then ignore the listingId, retailerLocationId, and the offerLocationId
	transactionId = null,
	# status: int   Eg: 56
	# Sets whether the user is: undecided (0), attending (1), attending and checked in (2), or not attending (3)
	status = null,
	# latitude: int   Eg: 1.2
	# The location of the status update
	latitude = null,
	# longitude: int   Eg: 1.2
	# The location of the status update
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "attend_event")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		appKey,
		listingId,
		retailerLocationId,
		offerLocationId,
		transactionId,
		status,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createEvent → POST /api/{version}/event/create
# Create Event
#
# Create a private event to share with associates.
func create_event(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# title: String = ""   Eg: title_example
	# The event title
	title: String,
	# retailerLocationIds: String = ""   Eg: retailerLocationIds_example
	# The retailer location to have the event at
	retailerLocationIds = "",
	# subTitle: String = ""   Eg: subTitle_example
	# The event sub title
	subTitle = "",
	# details: String = ""   Eg: details_example
	# The event details
	details = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# The categories the associate the event with
	categoryIds = "",
	# filterIds: String = ""   Eg: filterIds_example
	# The filters the associate the event with
	filterIds = "",
	# active: bool   Eg: true
	# Is this event active
	active = null,
	# imageAssetId: float   Eg: 789
	# The image to show for the event
	imageAssetId = null,
	# redeemableStart: float   Eg: 789
	# The event start date/time
	redeemableStart = null,
	# redeemableEnd: float   Eg: 789
	# The event end date/time
	redeemableEnd = null,
	# metaData: String = ""   Eg: metaData_example
	# external custom client defined data
	metaData = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/event/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["retailerLocationIds"] = retailerLocationIds
	bzz_query["title"] = title
	bzz_query["subTitle"] = subTitle
	bzz_query["details"] = details
	bzz_query["categoryIds"] = categoryIds
	bzz_query["filterIds"] = filterIds
	bzz_query["active"] = active
	bzz_query["imageAssetId"] = imageAssetId
	bzz_query["redeemableStart"] = redeemableStart
	bzz_query["redeemableEnd"] = redeemableEnd
	bzz_query["metaData"] = metaData

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OfferResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_event_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# title: String = ""   Eg: title_example
	# The event title
	title: String,
	# retailerLocationIds: String = ""   Eg: retailerLocationIds_example
	# The retailer location to have the event at
	retailerLocationIds = "",
	# subTitle: String = ""   Eg: subTitle_example
	# The event sub title
	subTitle = "",
	# details: String = ""   Eg: details_example
	# The event details
	details = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# The categories the associate the event with
	categoryIds = "",
	# filterIds: String = ""   Eg: filterIds_example
	# The filters the associate the event with
	filterIds = "",
	# active: bool   Eg: true
	# Is this event active
	active = null,
	# imageAssetId: float   Eg: 789
	# The image to show for the event
	imageAssetId = null,
	# redeemableStart: float   Eg: 789
	# The event start date/time
	redeemableStart = null,
	# redeemableEnd: float   Eg: 789
	# The event end date/time
	redeemableEnd = null,
	# metaData: String = ""   Eg: metaData_example
	# external custom client defined data
	metaData = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_event")
	bzz_callable.bind(
		version,
		accountId,
		title,
		retailerLocationIds,
		subTitle,
		details,
		categoryIds,
		filterIds,
		active,
		imageAssetId,
		redeemableStart,
		redeemableEnd,
		metaData,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteEvent → POST /api/{version}/event/delete
# Delete Event
#
# Delete an event that the user has permissions to.
func delete_event(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# eventId: float   Eg: 789
	# the id of the event to update
	eventId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/event/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["eventId"] = eventId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_event_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# eventId: float   Eg: 789
	# the id of the event to update
	eventId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_event")
	bzz_callable.bind(
		version,
		accountId,
		eventId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getEvent → GET /api/{version}/event/get
# Get Event
#
# Get an event.
func get_event(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# eventId: float   Eg: 789
	# The id of the event to return
	eventId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/event/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["eventId"] = eventId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OfferResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_event_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# eventId: float   Eg: 789
	# The id of the event to return
	eventId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_event")
	bzz_callable.bind(
		version,
		accountId,
		eventId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchEventTransactions → GET /api/{version}/event/attendance/search
# Search Event Attendance
#
# Searches on event type transactions. This can be used to see who is attending an event.
func search_event_transactions(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# The application key
	appKey = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword to search for
	keyword = "",
	# retailerId: float   Eg: 789
	# Filter results for this retailer
	retailerId = null,
	# retailerLocationId: float   Eg: 789
	# Filter results for this retailer location
	retailerLocationId = null,
	# excludeRetailerLocationId: float   Eg: 789
	# Exclude results from this retailer location
	excludeRetailerLocationId = null,
	# listingId: float   Eg: 789
	# Filter results for this event listing
	listingId = null,
	# offerId: float   Eg: 789
	# Filter results for this offer
	offerId = null,
	# offerLocationId: float   Eg: 789
	# Filter results for this offer location
	offerLocationId = null,
	# customerAccountIds: String = ""   Eg: customerAccountIds_example
	# Filter results by accounts
	customerAccountIds = "",
	# affiliatedCategoryIds: String = ""   Eg: affiliatedCategoryIds_example
	# Comma separated list of category ids to determine whether the attendee is affiliated with the category
	affiliatedCategoryIds = "",
	# startDate: float   Eg: 789
	# Filter on attendance starting on or after this date (milliseconds since epoch)
	startDate = null,
	# endDate: float   Eg: 789
	# Filter on attendance starting on or before this date (milliseconds since epoch)
	endDate = null,
	# statuses: String = ""   Eg: statuses_example
	# Comma separated list of transaction statuses to filter on
	statuses = "",
	# sortField: String = ""   Eg: sortField_example
	# Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}
	sortField = "",
	# descending: bool   Eg: true
	# Determines whether the results are in descending order
	descending = null,
	# start: int   Eg: 56
	# The start index for pagination
	start = null,
	# limit: int   Eg: 56
	# The limit for pagination
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/event/attendance/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["keyword"] = keyword
	bzz_query["retailerId"] = retailerId
	bzz_query["retailerLocationId"] = retailerLocationId
	bzz_query["excludeRetailerLocationId"] = excludeRetailerLocationId
	bzz_query["listingId"] = listingId
	bzz_query["offerId"] = offerId
	bzz_query["offerLocationId"] = offerLocationId
	bzz_query["customerAccountIds"] = customerAccountIds
	bzz_query["affiliatedCategoryIds"] = affiliatedCategoryIds
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["statuses"] = statuses
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = EventAttendanceResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_event_transactions_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# The application key
	appKey = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword to search for
	keyword = "",
	# retailerId: float   Eg: 789
	# Filter results for this retailer
	retailerId = null,
	# retailerLocationId: float   Eg: 789
	# Filter results for this retailer location
	retailerLocationId = null,
	# excludeRetailerLocationId: float   Eg: 789
	# Exclude results from this retailer location
	excludeRetailerLocationId = null,
	# listingId: float   Eg: 789
	# Filter results for this event listing
	listingId = null,
	# offerId: float   Eg: 789
	# Filter results for this offer
	offerId = null,
	# offerLocationId: float   Eg: 789
	# Filter results for this offer location
	offerLocationId = null,
	# customerAccountIds: String = ""   Eg: customerAccountIds_example
	# Filter results by accounts
	customerAccountIds = "",
	# affiliatedCategoryIds: String = ""   Eg: affiliatedCategoryIds_example
	# Comma separated list of category ids to determine whether the attendee is affiliated with the category
	affiliatedCategoryIds = "",
	# startDate: float   Eg: 789
	# Filter on attendance starting on or after this date (milliseconds since epoch)
	startDate = null,
	# endDate: float   Eg: 789
	# Filter on attendance starting on or before this date (milliseconds since epoch)
	endDate = null,
	# statuses: String = ""   Eg: statuses_example
	# Comma separated list of transaction statuses to filter on
	statuses = "",
	# sortField: String = ""   Eg: sortField_example
	# Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}
	sortField = "",
	# descending: bool   Eg: true
	# Determines whether the results are in descending order
	descending = null,
	# start: int   Eg: 56
	# The start index for pagination
	start = null,
	# limit: int   Eg: 56
	# The limit for pagination
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_event_transactions")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		appKey,
		keyword,
		retailerId,
		retailerLocationId,
		excludeRetailerLocationId,
		listingId,
		offerId,
		offerLocationId,
		customerAccountIds,
		affiliatedCategoryIds,
		startDate,
		endDate,
		statuses,
		sortField,
		descending,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchEvents → GET /api/{version}/event/search
# Search Events
#
# Searches on events that the account has access to.
func search_events(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search
	keyword = "",
	# activeOnly: bool   Eg: true
	# Return only active results
	activeOnly = null,
	# categoryIds: String = ""   Eg: categoryIds_example
	# the IDs of the categories that this event is associated with
	categoryIds = "",
	# filterIds: String = ""   Eg: filterIds_example
	# the IDs of the filters that this event is associated with
	filterIds = "",
	# offerAudienceIds: String = ""   Eg: offerAudienceIds_example
	# Offer audience ids to filter on
	offerAudienceIds = "",
	# transactionAudienceIds: String = ""   Eg: transactionAudienceIds_example
	# Transaction audience ids to filter on
	transactionAudienceIds = "",
	# sortField: String = ""   Eg: sortField_example
	# The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY
	sortField = "",
	# descending: bool   Eg: true
	# The order to return the search results
	descending = null,
	# startDate: float   Eg: 789
	# Filter the events to return only those that start on or after the date
	startDate = null,
	# endDate: float   Eg: 789
	# Filter the events to return only those that start on or before the date
	endDate = null,
	# start: int   Eg: 56
	# The record to begin the return set on
	start = null,
	# limit: int   Eg: 56
	# The number of records to return
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/event/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["keyword"] = keyword
	bzz_query["activeOnly"] = activeOnly
	bzz_query["categoryIds"] = categoryIds
	bzz_query["filterIds"] = filterIds
	bzz_query["offerAudienceIds"] = offerAudienceIds
	bzz_query["transactionAudienceIds"] = transactionAudienceIds
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OfferShortResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_events_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search
	keyword = "",
	# activeOnly: bool   Eg: true
	# Return only active results
	activeOnly = null,
	# categoryIds: String = ""   Eg: categoryIds_example
	# the IDs of the categories that this event is associated with
	categoryIds = "",
	# filterIds: String = ""   Eg: filterIds_example
	# the IDs of the filters that this event is associated with
	filterIds = "",
	# offerAudienceIds: String = ""   Eg: offerAudienceIds_example
	# Offer audience ids to filter on
	offerAudienceIds = "",
	# transactionAudienceIds: String = ""   Eg: transactionAudienceIds_example
	# Transaction audience ids to filter on
	transactionAudienceIds = "",
	# sortField: String = ""   Eg: sortField_example
	# The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY
	sortField = "",
	# descending: bool   Eg: true
	# The order to return the search results
	descending = null,
	# startDate: float   Eg: 789
	# Filter the events to return only those that start on or after the date
	startDate = null,
	# endDate: float   Eg: 789
	# Filter the events to return only those that start on or before the date
	endDate = null,
	# start: int   Eg: 56
	# The record to begin the return set on
	start = null,
	# limit: int   Eg: 56
	# The number of records to return
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_events")
	bzz_callable.bind(
		version,
		accountId,
		keyword,
		activeOnly,
		categoryIds,
		filterIds,
		offerAudienceIds,
		transactionAudienceIds,
		sortField,
		descending,
		startDate,
		endDate,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateEvent → POST /api/{version}/event/update
# Update Event
#
# Update a private event to share with associates.
func update_event(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# eventId: float   Eg: 789
	# The id of the event to update
	eventId: float,
	# retailerLocationIds: String = ""   Eg: retailerLocationIds_example
	# The retailer location to have the event at
	retailerLocationIds = "",
	# title: String = ""   Eg: title_example
	# The event title
	title = "",
	# subTitle: String = ""   Eg: subTitle_example
	# The event sub title
	subTitle = "",
	# details: String = ""   Eg: details_example
	# The event details
	details = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# The categories the associate the event with
	categoryIds = "",
	# filterIds: String = ""   Eg: filterIds_example
	# The filters the associate the event with
	filterIds = "",
	# active: bool   Eg: true
	# Is this event active
	active = null,
	# imageAssetId: float   Eg: 789
	# The image to show for the event
	imageAssetId = null,
	# redeemableStart: float   Eg: 789
	# The event start date/time
	redeemableStart = null,
	# redeemableEnd: float   Eg: 789
	# The event end date/time
	redeemableEnd = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/event/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["eventId"] = eventId
	bzz_query["retailerLocationIds"] = retailerLocationIds
	bzz_query["title"] = title
	bzz_query["subTitle"] = subTitle
	bzz_query["details"] = details
	bzz_query["categoryIds"] = categoryIds
	bzz_query["filterIds"] = filterIds
	bzz_query["active"] = active
	bzz_query["imageAssetId"] = imageAssetId
	bzz_query["redeemableStart"] = redeemableStart
	bzz_query["redeemableEnd"] = redeemableEnd

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OfferResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_event_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# eventId: float   Eg: 789
	# The id of the event to update
	eventId: float,
	# retailerLocationIds: String = ""   Eg: retailerLocationIds_example
	# The retailer location to have the event at
	retailerLocationIds = "",
	# title: String = ""   Eg: title_example
	# The event title
	title = "",
	# subTitle: String = ""   Eg: subTitle_example
	# The event sub title
	subTitle = "",
	# details: String = ""   Eg: details_example
	# The event details
	details = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# The categories the associate the event with
	categoryIds = "",
	# filterIds: String = ""   Eg: filterIds_example
	# The filters the associate the event with
	filterIds = "",
	# active: bool   Eg: true
	# Is this event active
	active = null,
	# imageAssetId: float   Eg: 789
	# The image to show for the event
	imageAssetId = null,
	# redeemableStart: float   Eg: 789
	# The event start date/time
	redeemableStart = null,
	# redeemableEnd: float   Eg: 789
	# The event end date/time
	redeemableEnd = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_event")
	bzz_callable.bind(
		version,
		accountId,
		eventId,
		retailerLocationIds,
		title,
		subTitle,
		details,
		categoryIds,
		filterIds,
		active,
		imageAssetId,
		redeemableStart,
		redeemableEnd,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


