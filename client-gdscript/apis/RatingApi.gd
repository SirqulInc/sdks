extends ApiBee
class_name RatingApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API RatingApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "RatingApi"


# Operation createRating → POST /api/{version}/rating/create
# Create Rating
#
# This is used to leave rating on a ratable object (i.e. retailer locations). Each user can only rate on a ratable object once per category. If a user rates on the same object and category, the previous rating will be overwritten. Leaving a rating on a ratable object will be visible to everyone who has access to view the object.
func create_rating(
	# version: float   Eg: 3.16
	version: float,
	# ratableType: String = ""   Eg: ratableType_example
	# The ratable object type {RETAILER_LOCATION}
	ratableType: String,
	# ratableId: float   Eg: 789
	# The id of the ratable object
	ratableId: float,
	# ratingValue: int   Eg: 56
	# The integer value of 0-100
	ratingValue: int,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique device identifier that made the request (either deviceId or accountId must be used)
	deviceId = "",
	# accountId: float   Eg: 789
	# The unique accountId that made the request (either deviceId or accountId must be used)
	accountId = null,
	# categoryId: float   Eg: 789
	categoryId = null,
	# display: String = ""   Eg: display_example
	# A subject title for the user rating (limited to 255 characters)
	display = "",
	# description: String = ""   Eg: description_example
	# The description of the rating
	description = "",
	# locationDescription: String = ""   Eg: locationDescription_example
	# The description of the location
	locationDescription = "",
	# latitude: int   Eg: 1.2
	# The current location of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# The current location of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/rating/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["ratableType"] = ratableType
	bzz_query["ratableId"] = ratableId
	bzz_query["ratingValue"] = ratingValue
	bzz_query["categoryId"] = categoryId
	bzz_query["display"] = display
	bzz_query["description"] = description
	bzz_query["locationDescription"] = locationDescription
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = RatingResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_rating_threaded(
	# version: float   Eg: 3.16
	version: float,
	# ratableType: String = ""   Eg: ratableType_example
	# The ratable object type {RETAILER_LOCATION}
	ratableType: String,
	# ratableId: float   Eg: 789
	# The id of the ratable object
	ratableId: float,
	# ratingValue: int   Eg: 56
	# The integer value of 0-100
	ratingValue: int,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique device identifier that made the request (either deviceId or accountId must be used)
	deviceId = "",
	# accountId: float   Eg: 789
	# The unique accountId that made the request (either deviceId or accountId must be used)
	accountId = null,
	# categoryId: float   Eg: 789
	categoryId = null,
	# display: String = ""   Eg: display_example
	# A subject title for the user rating (limited to 255 characters)
	display = "",
	# description: String = ""   Eg: description_example
	# The description of the rating
	description = "",
	# locationDescription: String = ""   Eg: locationDescription_example
	# The description of the location
	locationDescription = "",
	# latitude: int   Eg: 1.2
	# The current location of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# The current location of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_rating")
	bzz_callable.bind(
		version,
		ratableType,
		ratableId,
		ratingValue,
		deviceId,
		accountId,
		categoryId,
		display,
		description,
		locationDescription,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteRating → POST /api/{version}/rating/delete
# Delete Rating
#
# Sets a rating as deleted.
func delete_rating(
	# version: float   Eg: 3.16
	version: float,
	# ratingId: float   Eg: 789
	# The ID of the rating to delete
	ratingId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique device identifier that made the request (either deviceId or accountId must be used)
	deviceId = "",
	# accountId: float   Eg: 789
	# The unique accountId that made the request (either deviceId or accountId must be used)
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/rating/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["ratingId"] = ratingId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_rating_threaded(
	# version: float   Eg: 3.16
	version: float,
	# ratingId: float   Eg: 789
	# The ID of the rating to delete
	ratingId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique device identifier that made the request (either deviceId or accountId must be used)
	deviceId = "",
	# accountId: float   Eg: 789
	# The unique accountId that made the request (either deviceId or accountId must be used)
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_rating")
	bzz_callable.bind(
		version,
		ratingId,
		deviceId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchLocationRatingIndexes → GET /api/{version}/location/rating/index/search
# Search Location Rating Indexes
#
# Search for retailer locations by averages near you.
func search_location_rating_indexes(
	# version: float   Eg: 3.16
	version: float,
	# categoryIds: String = ""   Eg: categoryIds_example
	# Comma separated list of category ids to filter the results by
	categoryIds = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search
	keyword = "",
	# locationType: String = ""   Eg: locationType_example
	# The type of location to filter the results by
	locationType = "",
	# sortField: String = ""   Eg: sortField_example
	# The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}
	sortField = "",
	# descending: bool   Eg: true
	# The order to return the search results
	descending = null,
	# start: int   Eg: 56
	# The record to begin the return set on
	start = null,
	# limit: int   Eg: 56
	# The number of records to return
	limit = null,
	# searchRange: int   Eg: 1.2
	# The search radius in kilometers to filter results
	searchRange = null,
	# latitude: int   Eg: 1.2
	# The current location of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# The current location of the user
	longitude = null,
	# returnOverallRating: bool   Eg: true
	# Determines whether to return the overall rating record instead
	returnOverallRating = null,
	# distanceUnit: String = ""   Eg: distanceUnit_example
	distanceUnit = "",
	# returnRetailer: bool   Eg: true
	# whether to return the retailer or not
	returnRetailer = null,
	# returnAssets: bool   Eg: true
	# whether to return the assets or not
	returnAssets = null,
	# returnOffers: bool   Eg: true
	# whether to return the offers or not
	returnOffers = null,
	# returnCategories: bool   Eg: true
	# whether to return the categories or not
	returnCategories = null,
	# returnFilters: bool   Eg: true
	# whether to return the filters or not
	returnFilters = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/location/rating/index/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["categoryIds"] = categoryIds
	bzz_query["keyword"] = keyword
	bzz_query["locationType"] = locationType
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["searchRange"] = searchRange
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["returnOverallRating"] = returnOverallRating
	bzz_query["distanceUnit"] = distanceUnit
	bzz_query["returnRetailer"] = returnRetailer
	bzz_query["returnAssets"] = returnAssets
	bzz_query["returnOffers"] = returnOffers
	bzz_query["returnCategories"] = returnCategories
	bzz_query["returnFilters"] = returnFilters

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = RatingIndexResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_location_rating_indexes_threaded(
	# version: float   Eg: 3.16
	version: float,
	# categoryIds: String = ""   Eg: categoryIds_example
	# Comma separated list of category ids to filter the results by
	categoryIds = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search
	keyword = "",
	# locationType: String = ""   Eg: locationType_example
	# The type of location to filter the results by
	locationType = "",
	# sortField: String = ""   Eg: sortField_example
	# The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}
	sortField = "",
	# descending: bool   Eg: true
	# The order to return the search results
	descending = null,
	# start: int   Eg: 56
	# The record to begin the return set on
	start = null,
	# limit: int   Eg: 56
	# The number of records to return
	limit = null,
	# searchRange: int   Eg: 1.2
	# The search radius in kilometers to filter results
	searchRange = null,
	# latitude: int   Eg: 1.2
	# The current location of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# The current location of the user
	longitude = null,
	# returnOverallRating: bool   Eg: true
	# Determines whether to return the overall rating record instead
	returnOverallRating = null,
	# distanceUnit: String = ""   Eg: distanceUnit_example
	distanceUnit = "",
	# returnRetailer: bool   Eg: true
	# whether to return the retailer or not
	returnRetailer = null,
	# returnAssets: bool   Eg: true
	# whether to return the assets or not
	returnAssets = null,
	# returnOffers: bool   Eg: true
	# whether to return the offers or not
	returnOffers = null,
	# returnCategories: bool   Eg: true
	# whether to return the categories or not
	returnCategories = null,
	# returnFilters: bool   Eg: true
	# whether to return the filters or not
	returnFilters = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_location_rating_indexes")
	bzz_callable.bind(
		version,
		categoryIds,
		keyword,
		locationType,
		sortField,
		descending,
		start,
		limit,
		searchRange,
		latitude,
		longitude,
		returnOverallRating,
		distanceUnit,
		returnRetailer,
		returnAssets,
		returnOffers,
		returnCategories,
		returnFilters,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchRatingIndexes → GET /api/{version}/rating/index/search
# Search Rating Indexes
#
# Search for ratable items by averages.
func search_rating_indexes(
	# version: float   Eg: 3.16
	version: float,
	# ratableType: String = ""   Eg: ratableType_example
	# Filter results by a ratable type {RETAILER_LOCATION}
	ratableType: String,
	# ratableIds: String = ""   Eg: ratableIds_example
	# Comma separated list of ratable ids to filter the resuts by
	ratableIds = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# Comma separated list of category ids to filter the results by
	categoryIds = "",
	# secondaryType: String = ""   Eg: secondaryType_example
	secondaryType = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search
	keyword = "",
	# sortField: String = ""   Eg: sortField_example
	# The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}
	sortField = "",
	# descending: bool   Eg: true
	# The order to return the search results
	descending = null,
	# start: int   Eg: 56
	# The record to begin the return set on
	start = null,
	# limit: int   Eg: 56
	# The number of records to return
	limit = null,
	# latitude: int   Eg: 1.2
	latitude = null,
	# longitude: int   Eg: 1.2
	longitude = null,
	# returnRatable: bool   Eg: true
	# Determines whether to return the ratable object in the response
	returnRatable = null,
	# returnOverallRating: bool   Eg: true
	# Determines whether to return the overall rating record instead
	returnOverallRating = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/rating/index/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["ratableType"] = ratableType
	bzz_query["ratableIds"] = ratableIds
	bzz_query["categoryIds"] = categoryIds
	bzz_query["secondaryType"] = secondaryType
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["returnRatable"] = returnRatable
	bzz_query["returnOverallRating"] = returnOverallRating

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = RatingIndexResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_rating_indexes_threaded(
	# version: float   Eg: 3.16
	version: float,
	# ratableType: String = ""   Eg: ratableType_example
	# Filter results by a ratable type {RETAILER_LOCATION}
	ratableType: String,
	# ratableIds: String = ""   Eg: ratableIds_example
	# Comma separated list of ratable ids to filter the resuts by
	ratableIds = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# Comma separated list of category ids to filter the results by
	categoryIds = "",
	# secondaryType: String = ""   Eg: secondaryType_example
	secondaryType = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search
	keyword = "",
	# sortField: String = ""   Eg: sortField_example
	# The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}
	sortField = "",
	# descending: bool   Eg: true
	# The order to return the search results
	descending = null,
	# start: int   Eg: 56
	# The record to begin the return set on
	start = null,
	# limit: int   Eg: 56
	# The number of records to return
	limit = null,
	# latitude: int   Eg: 1.2
	latitude = null,
	# longitude: int   Eg: 1.2
	longitude = null,
	# returnRatable: bool   Eg: true
	# Determines whether to return the ratable object in the response
	returnRatable = null,
	# returnOverallRating: bool   Eg: true
	# Determines whether to return the overall rating record instead
	returnOverallRating = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_rating_indexes")
	bzz_callable.bind(
		version,
		ratableType,
		ratableIds,
		categoryIds,
		secondaryType,
		keyword,
		sortField,
		descending,
		start,
		limit,
		latitude,
		longitude,
		returnRatable,
		returnOverallRating,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchRatings → GET /api/{version}/rating/search
# Search Ratings
#
# Search for ratings on a ratable object.
func search_ratings(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# filterAccountId: float   Eg: 789
	# Filter results for a particular account
	filterAccountId = null,
	# ratableType: String = ""   Eg: ratableType_example
	# The ratable object type {RETAILER_LOCATION}
	ratableType = "",
	# ratableId: float   Eg: 789
	# The id of the ratable object
	ratableId = null,
	# categoryIds: String = ""   Eg: categoryIds_example
	# Comma separated list of category ids to filter the results by
	categoryIds = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search
	keyword = "",
	# sortField: String = ""   Eg: sortField_example
	# The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, OWNER_DISPLAY, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, VALUE}
	sortField = "",
	# descending: bool   Eg: true
	# The order to return the search results
	descending = null,
	# start: int   Eg: 56
	# The record to begin the return set on
	start = null,
	# limit: int   Eg: 56
	# The number of records to return
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/rating/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["filterAccountId"] = filterAccountId
	bzz_query["ratableType"] = ratableType
	bzz_query["ratableId"] = ratableId
	bzz_query["categoryIds"] = categoryIds
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = RatingResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_ratings_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# filterAccountId: float   Eg: 789
	# Filter results for a particular account
	filterAccountId = null,
	# ratableType: String = ""   Eg: ratableType_example
	# The ratable object type {RETAILER_LOCATION}
	ratableType = "",
	# ratableId: float   Eg: 789
	# The id of the ratable object
	ratableId = null,
	# categoryIds: String = ""   Eg: categoryIds_example
	# Comma separated list of category ids to filter the results by
	categoryIds = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search
	keyword = "",
	# sortField: String = ""   Eg: sortField_example
	# The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, OWNER_DISPLAY, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, VALUE}
	sortField = "",
	# descending: bool   Eg: true
	# The order to return the search results
	descending = null,
	# start: int   Eg: 56
	# The record to begin the return set on
	start = null,
	# limit: int   Eg: 56
	# The number of records to return
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_ratings")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		filterAccountId,
		ratableType,
		ratableId,
		categoryIds,
		keyword,
		sortField,
		descending,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateRating → POST /api/{version}/rating/update
# Update Rating
#
# Update an existing rating. Only the creator of the rating have permission to update.
func update_rating(
	# version: float   Eg: 3.16
	version: float,
	# ratingId: float   Eg: 789
	# The id of the rating (Note: this is not the ratable object id)
	ratingId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique device identifier that made the request (either deviceId or accountId must be used)
	deviceId = "",
	# accountId: float   Eg: 789
	# The unique accountId that made the request (either deviceId or accountId must be used)
	accountId = null,
	# ratingValue: int   Eg: 56
	# The rating value to update
	ratingValue = null,
	# categoryId: float   Eg: 789
	categoryId = null,
	# display: String = ""   Eg: display_example
	# A subject title for the user rating (limited to 255 characters)
	display = "",
	# description: String = ""   Eg: description_example
	# The description of the rating
	description = "",
	# locationDescription: String = ""   Eg: locationDescription_example
	# The description of the location
	locationDescription = "",
	# latitude: int   Eg: 1.2
	# The current location of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# The current location of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/rating/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["ratingId"] = ratingId
	bzz_query["ratingValue"] = ratingValue
	bzz_query["categoryId"] = categoryId
	bzz_query["display"] = display
	bzz_query["description"] = description
	bzz_query["locationDescription"] = locationDescription
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = RatingResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_rating_threaded(
	# version: float   Eg: 3.16
	version: float,
	# ratingId: float   Eg: 789
	# The id of the rating (Note: this is not the ratable object id)
	ratingId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique device identifier that made the request (either deviceId or accountId must be used)
	deviceId = "",
	# accountId: float   Eg: 789
	# The unique accountId that made the request (either deviceId or accountId must be used)
	accountId = null,
	# ratingValue: int   Eg: 56
	# The rating value to update
	ratingValue = null,
	# categoryId: float   Eg: 789
	categoryId = null,
	# display: String = ""   Eg: display_example
	# A subject title for the user rating (limited to 255 characters)
	display = "",
	# description: String = ""   Eg: description_example
	# The description of the rating
	description = "",
	# locationDescription: String = ""   Eg: locationDescription_example
	# The description of the location
	locationDescription = "",
	# latitude: int   Eg: 1.2
	# The current location of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# The current location of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_rating")
	bzz_callable.bind(
		version,
		ratingId,
		deviceId,
		accountId,
		ratingValue,
		categoryId,
		display,
		description,
		locationDescription,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


