extends ApiBee
class_name OrsonApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API OrsonApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "OrsonApi"


# Operation addMovie → POST /api/{version}/orson/ai/addMovie
# Add Movie
#
# Add a movie to be indexed for Topics. Indexing a movie analyses the content and incorporates it into the topics model for future /topics calls. This does not store the movie file long-term.
func add_movie(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# movieName: String = ""   Eg: movieName_example
	# Movie Name
	movieName: String,
	# thirdPartyAccountId: String = ""   Eg: thirdPartyAccountId_example
	# A third-party account id that is meaningful to your systems
	thirdPartyAccountId = "",
	# tags: String = ""   Eg: tags_example
	# A user defined list (comma-delimited) of tags associated with the movie
	tags = "",
	# file: String   Eg: BINARY_DATA_HERE
	# An uploaded recording to analyze (Currently limited to 10MB)
	file = null,
	# url: String = ""   Eg: url_example
	# A recording file to download and analyze (Size limit: 1GB)
	url = "",
	# callback: String = ""   Eg: callback_example
	# When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
	callback = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/addMovie".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["thirdPartyAccountId"] = thirdPartyAccountId
	bzz_query["tags"] = tags
	bzz_query["movieName"] = movieName
	bzz_query["file"] = file
	bzz_query["url"] = url
	bzz_query["callback"] = callback

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiAddMovieResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func add_movie_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# movieName: String = ""   Eg: movieName_example
	# Movie Name
	movieName: String,
	# thirdPartyAccountId: String = ""   Eg: thirdPartyAccountId_example
	# A third-party account id that is meaningful to your systems
	thirdPartyAccountId = "",
	# tags: String = ""   Eg: tags_example
	# A user defined list (comma-delimited) of tags associated with the movie
	tags = "",
	# file: String   Eg: BINARY_DATA_HERE
	# An uploaded recording to analyze (Currently limited to 10MB)
	file = null,
	# url: String = ""   Eg: url_example
	# A recording file to download and analyze (Size limit: 1GB)
	url = "",
	# callback: String = ""   Eg: callback_example
	# When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
	callback = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "add_movie")
	bzz_callable.bind(
		version,
		accountId,
		movieName,
		thirdPartyAccountId,
		tags,
		file,
		url,
		callback,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation aiDocs → GET /api/{version}/orson/ai/docs
# Search Docs
#
# Takes in a text string representing one or more sentences and it returns a list of documents which are related to the provided document.
func ai_docs(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# doc: String = ""   Eg: doc_example
	# Doc
	doc: String,
	# returnTopics: bool   Eg: true
	# Return Topics
	returnTopics = null,
	# limit: int   Eg: 56
	# Limit
	limit = null,
	# offset: int   Eg: 56
	# Offset
	offset = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/docs".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["doc"] = doc
	bzz_query["return_topics"] = returnTopics
	bzz_query["limit"] = limit
	bzz_query["offset"] = offset

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiProtoResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func ai_docs_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# doc: String = ""   Eg: doc_example
	# Doc
	doc: String,
	# returnTopics: bool   Eg: true
	# Return Topics
	returnTopics = null,
	# limit: int   Eg: 56
	# Limit
	limit = null,
	# offset: int   Eg: 56
	# Offset
	offset = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "ai_docs")
	bzz_callable.bind(
		version,
		accountId,
		doc,
		returnTopics,
		limit,
		offset,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation aiFindImages → GET /api/{version}/orson/ai/img
# Find images
#
# Returns a list of URIs of images that match the text.
func ai_find_images(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# text: String = ""   Eg: text_example
	# Text
	text: String,
	# parseFlag: String = ""   Eg: parseFlag_example
	# Parse Flag
	parseFlag = "",
	# fetchFlag: String = ""   Eg: fetchFlag_example
	# Fetch Flag
	fetchFlag = "",
	# size: String = ""   Eg: size_example
	# Size
	size = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/img".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["text"] = text
	bzz_query["parse_flag"] = parseFlag
	bzz_query["fetch_flag"] = fetchFlag
	bzz_query["size"] = size

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiProtoResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func ai_find_images_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# text: String = ""   Eg: text_example
	# Text
	text: String,
	# parseFlag: String = ""   Eg: parseFlag_example
	# Parse Flag
	parseFlag = "",
	# fetchFlag: String = ""   Eg: fetchFlag_example
	# Fetch Flag
	fetchFlag = "",
	# size: String = ""   Eg: size_example
	# Size
	size = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "ai_find_images")
	bzz_callable.bind(
		version,
		accountId,
		text,
		parseFlag,
		fetchFlag,
		size,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation aiTags → GET /api/{version}/orson/ai/tags
# Search Tags
#
# Search the tags column of user provided tags using this endpoint.
func ai_tags(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# tags: String = ""   Eg: tags_example
	# Tags
	tags: String,
	# conditional: String = ""   Eg: conditional_example
	# Conditional
	conditional = "",
	# limit: int   Eg: 56
	# Limit
	limit = null,
	# offset: int   Eg: 56
	# Offset
	offset = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/tags".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["tags"] = tags
	bzz_query["conditional"] = conditional
	bzz_query["limit"] = limit
	bzz_query["offset"] = offset

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiProtoResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func ai_tags_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# tags: String = ""   Eg: tags_example
	# Tags
	tags: String,
	# conditional: String = ""   Eg: conditional_example
	# Conditional
	conditional = "",
	# limit: int   Eg: 56
	# Limit
	limit = null,
	# offset: int   Eg: 56
	# Offset
	offset = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "ai_tags")
	bzz_callable.bind(
		version,
		accountId,
		tags,
		conditional,
		limit,
		offset,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation aiText → GET /api/{version}/orson/ai/text
# Search Text
#
# Search the movie text column of movie text using this endpoint.
func ai_text(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# terms: String = ""   Eg: terms_example
	# Terms
	terms: String,
	# conditional: String = ""   Eg: conditional_example
	# Conditional
	conditional = "",
	# limit: int   Eg: 56
	# Limit
	limit = null,
	# offset: int   Eg: 56
	# Offset
	offset = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/text".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["terms"] = terms
	bzz_query["conditional"] = conditional
	bzz_query["limit"] = limit
	bzz_query["offset"] = offset

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiProtoResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func ai_text_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# terms: String = ""   Eg: terms_example
	# Terms
	terms: String,
	# conditional: String = ""   Eg: conditional_example
	# Conditional
	conditional = "",
	# limit: int   Eg: 56
	# Limit
	limit = null,
	# offset: int   Eg: 56
	# Offset
	offset = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "ai_text")
	bzz_callable.bind(
		version,
		accountId,
		terms,
		conditional,
		limit,
		offset,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation batch → POST /api/{version}/orson/ai/batch
# Batch Analysis
#
# Run several types of analysis on an audio or video file in a single API call, instead of calling several operations for the same file..
func batch(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# thirdPartyAccountId: String = ""   Eg: thirdPartyAccountId_example
	# A third-party account id that is meaningful to your systems
	thirdPartyAccountId = "",
	# limit: int   Eg: 56
	# The number of topics to return
	limit = null,
	# operations: String = ""   Eg: operations_example
	# The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions
	operations = "",
	# file: String   Eg: BINARY_DATA_HERE
	# An uploaded recording to analyze (Currently limited to 10MB)
	file = null,
	# url: String = ""   Eg: url_example
	# A recording file to download and analyze (Size limit: 1GB)
	url = "",
	# callback: String = ""   Eg: callback_example
	# When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
	callback = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/batch".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["thirdPartyAccountId"] = thirdPartyAccountId
	bzz_query["limit"] = limit
	bzz_query["operations"] = operations
	bzz_query["file"] = file
	bzz_query["url"] = url
	bzz_query["callback"] = callback

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiBatchResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func batch_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# thirdPartyAccountId: String = ""   Eg: thirdPartyAccountId_example
	# A third-party account id that is meaningful to your systems
	thirdPartyAccountId = "",
	# limit: int   Eg: 56
	# The number of topics to return
	limit = null,
	# operations: String = ""   Eg: operations_example
	# The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions
	operations = "",
	# file: String   Eg: BINARY_DATA_HERE
	# An uploaded recording to analyze (Currently limited to 10MB)
	file = null,
	# url: String = ""   Eg: url_example
	# A recording file to download and analyze (Size limit: 1GB)
	url = "",
	# callback: String = ""   Eg: callback_example
	# When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
	callback = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "batch")
	bzz_callable.bind(
		version,
		accountId,
		thirdPartyAccountId,
		limit,
		operations,
		file,
		url,
		callback,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createInstantEpisode → POST /api/{version}/orson/stories/episodes/instant
# Creates an instant episode
#
# Creates an instant episode for a given StoryStrip by providing all necessary inputs, interview recordings, and pictures, kicking off a render immediately.
func create_instant_episode(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# data: String = ""   Eg: data_example
	# Request Data String
	data: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/stories/episodes/instant".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["data"] = data

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonEpisodeResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_instant_episode_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# data: String = ""   Eg: data_example
	# Request Data String
	data: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_instant_episode")
	bzz_callable.bind(
		version,
		accountId,
		data,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createVoiceCanvas → POST /api/{version}/orson/ai/voiceCanvas
# Create VoiceCanvas images
#
# Create VoiceCanvas images for provided text, file upload, or file URL
func create_voice_canvas(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# dimensions: String = ""   Eg: dimensions_example
	# Enum: \"256x256\" \"512x512\" \"1024x1024\"
	dimensions: String,
	# thirdPartyAccountId: String = ""   Eg: thirdPartyAccountId_example
	# A third-party account id that is meaningful to your systems
	thirdPartyAccountId = "",
	# text: String = ""   Eg: text_example
	# Provide a transcript or previously extracted topics for image generation
	text = "",
	# file: String   Eg: BINARY_DATA_HERE
	# An uploaded recording to analyze (Currently limited to 10MB)
	file = null,
	# url: String = ""   Eg: url_example
	# A recording file to download and analyze (Size limit: 1GB)
	url = "",
	# parseFlag: bool   Eg: true
	# When false, uses the raw value from text instead of identifying topics to fetch/generate from
	parseFlag = null,
	# fetchFlag: bool   Eg: true
	# When true, fetches images instead of generating them
	fetchFlag = null,
	# callback: String = ""   Eg: callback_example
	# When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
	callback = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/voiceCanvas".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["thirdPartyAccountId"] = thirdPartyAccountId
	bzz_query["dimensions"] = dimensions
	bzz_query["text"] = text
	bzz_query["file"] = file
	bzz_query["url"] = url
	bzz_query["parseFlag"] = parseFlag
	bzz_query["fetchFlag"] = fetchFlag
	bzz_query["callback"] = callback

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiVoiceCanvasResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_voice_canvas_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# dimensions: String = ""   Eg: dimensions_example
	# Enum: \"256x256\" \"512x512\" \"1024x1024\"
	dimensions: String,
	# thirdPartyAccountId: String = ""   Eg: thirdPartyAccountId_example
	# A third-party account id that is meaningful to your systems
	thirdPartyAccountId = "",
	# text: String = ""   Eg: text_example
	# Provide a transcript or previously extracted topics for image generation
	text = "",
	# file: String   Eg: BINARY_DATA_HERE
	# An uploaded recording to analyze (Currently limited to 10MB)
	file = null,
	# url: String = ""   Eg: url_example
	# A recording file to download and analyze (Size limit: 1GB)
	url = "",
	# parseFlag: bool   Eg: true
	# When false, uses the raw value from text instead of identifying topics to fetch/generate from
	parseFlag = null,
	# fetchFlag: bool   Eg: true
	# When true, fetches images instead of generating them
	fetchFlag = null,
	# callback: String = ""   Eg: callback_example
	# When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
	callback = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_voice_canvas")
	bzz_callable.bind(
		version,
		accountId,
		dimensions,
		thirdPartyAccountId,
		text,
		file,
		url,
		parseFlag,
		fetchFlag,
		callback,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation emotion → POST /api/{version}/orson/ai/emotion
# Detect emotions
#
# Detects emotions in an audio or video recording.
func emotion(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# thirdPartyAccountId: String = ""   Eg: thirdPartyAccountId_example
	# A third-party account id that is meaningful to your systems
	thirdPartyAccountId = "",
	# file: String   Eg: BINARY_DATA_HERE
	# An uploaded recording to analyze (Currently limited to 10MB)
	file = null,
	# url: String = ""   Eg: url_example
	# A recording file to download and analyze (Size limit: 1GB)
	url = "",
	# callback: String = ""   Eg: callback_example
	# When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
	callback = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/emotion".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["thirdPartyAccountId"] = thirdPartyAccountId
	bzz_query["file"] = file
	bzz_query["url"] = url
	bzz_query["callback"] = callback

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiEmotionsResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func emotion_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# thirdPartyAccountId: String = ""   Eg: thirdPartyAccountId_example
	# A third-party account id that is meaningful to your systems
	thirdPartyAccountId = "",
	# file: String   Eg: BINARY_DATA_HERE
	# An uploaded recording to analyze (Currently limited to 10MB)
	file = null,
	# url: String = ""   Eg: url_example
	# A recording file to download and analyze (Size limit: 1GB)
	url = "",
	# callback: String = ""   Eg: callback_example
	# When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
	callback = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "emotion")
	bzz_callable.bind(
		version,
		accountId,
		thirdPartyAccountId,
		file,
		url,
		callback,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getAddMovieResult → GET /api/{version}/orson/ai/addMovie/{requestId}
# Get Add Movie Result
#
# Get the result of an in progress Add Movie request from an earlier POST.
func get_add_movie_result(
	# version: float   Eg: 3.16
	version: float,
	# requestId: String = ""   Eg: requestId_example
	# Orson Request Id
	requestId: String,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/addMovie/{requestId}".replace("{" + "version" + "}", _bzz_urlize_path_param(version)).replace("{" + "requestId" + "}", _bzz_urlize_path_param(requestId))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiAddMovieResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_add_movie_result_threaded(
	# version: float   Eg: 3.16
	version: float,
	# requestId: String = ""   Eg: requestId_example
	# Orson Request Id
	requestId: String,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_add_movie_result")
	bzz_callable.bind(
		version,
		requestId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getBatch → GET /api/{version}/orson/ai/batch/{requestId}
# Get Batch Analysis Results
#
# Gets the completed Video Batch results, if done, or an error or status update if not.
func get_batch(
	# version: float   Eg: 3.16
	version: float,
	# requestId: String = ""   Eg: requestId_example
	# Orson Request Id
	requestId: String,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/batch/{requestId}".replace("{" + "version" + "}", _bzz_urlize_path_param(version)).replace("{" + "requestId" + "}", _bzz_urlize_path_param(requestId))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiBatchResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_batch_threaded(
	# version: float   Eg: 3.16
	version: float,
	# requestId: String = ""   Eg: requestId_example
	# Orson Request Id
	requestId: String,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_batch")
	bzz_callable.bind(
		version,
		requestId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getEmotion → GET /api/{version}/orson/ai/emotion/{requestId}
# Get Emotion Results
#
# Checks the Emotion analysis and returns in progress, results, or error.
func get_emotion(
	# version: float   Eg: 3.16
	version: float,
	# requestId: String = ""   Eg: requestId_example
	# Orson Request Id
	requestId: String,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/emotion/{requestId}".replace("{" + "version" + "}", _bzz_urlize_path_param(version)).replace("{" + "requestId" + "}", _bzz_urlize_path_param(requestId))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiEmotionsResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_emotion_threaded(
	# version: float   Eg: 3.16
	version: float,
	# requestId: String = ""   Eg: requestId_example
	# Orson Request Id
	requestId: String,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_emotion")
	bzz_callable.bind(
		version,
		requestId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getEpisodeStatus → GET /api/{version}/orson/stories/episodes/{episodeId}/status
# Check episode status
#
# Gets a summary of the episode's status, including any renders.
func get_episode_status(
	# version: float   Eg: 3.16
	version: float,
	# episodeId: float   Eg: 789
	# Episode ID
	episodeId: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/stories/episodes/{episodeId}/status".replace("{" + "version" + "}", _bzz_urlize_path_param(version)).replace("{" + "episodeId" + "}", _bzz_urlize_path_param(episodeId))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonEpisodeResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_episode_status_threaded(
	# version: float   Eg: 3.16
	version: float,
	# episodeId: float   Eg: 789
	# Episode ID
	episodeId: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_episode_status")
	bzz_callable.bind(
		version,
		episodeId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getRenderStatus → GET /api/{version}/orson/stories/renders/{renderId}/status
# Check episode status
#
# Gets a summary of the episode's status, including any renders.
func get_render_status(
	# version: float   Eg: 3.16
	version: float,
	# renderId: String = ""   Eg: renderId_example
	# Render ID
	renderId: String,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/stories/renders/{renderId}/status".replace("{" + "version" + "}", _bzz_urlize_path_param(version)).replace("{" + "renderId" + "}", _bzz_urlize_path_param(renderId))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonRenderResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_render_status_threaded(
	# version: float   Eg: 3.16
	version: float,
	# renderId: String = ""   Eg: renderId_example
	# Render ID
	renderId: String,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_render_status")
	bzz_callable.bind(
		version,
		renderId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getSTT → GET /api/{version}/orson/ai/stt/{requestId}
# Get Speach to Text Result
#
# The results of the video transcription and optional translation.
func get_stt(
	# version: float   Eg: 3.16
	version: float,
	# requestId: String = ""   Eg: requestId_example
	# Orson Request Id
	requestId: String,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/stt/{requestId}".replace("{" + "version" + "}", _bzz_urlize_path_param(version)).replace("{" + "requestId" + "}", _bzz_urlize_path_param(requestId))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiSTTResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_stt_threaded(
	# version: float   Eg: 3.16
	version: float,
	# requestId: String = ""   Eg: requestId_example
	# Orson Request Id
	requestId: String,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_stt")
	bzz_callable.bind(
		version,
		requestId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getTTS → GET /api/{version}/orson/ai/tts/{requestId}
# Get Text to Speach Result
#
# Check the status of an in progress Text-to-Speech call or download the result.
func get_tts(
	# version: float   Eg: 3.16
	version: float,
	# requestId: String = ""   Eg: requestId_example
	# Orson Request Id
	requestId: String,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/tts/{requestId}".replace("{" + "version" + "}", _bzz_urlize_path_param(version)).replace("{" + "requestId" + "}", _bzz_urlize_path_param(requestId))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiTTSResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_tts_threaded(
	# version: float   Eg: 3.16
	version: float,
	# requestId: String = ""   Eg: requestId_example
	# Orson Request Id
	requestId: String,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_tts")
	bzz_callable.bind(
		version,
		requestId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getTechTune → GET /api/{version}/orson/ai/techTune/{requestId}
# Get TechTune Results
#
# Get a result or continue waiting for a pending request for TechTune analysis.
func get_tech_tune(
	# version: float   Eg: 3.16
	version: float,
	# requestId: String = ""   Eg: requestId_example
	# Orson Request Id
	requestId: String,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/techTune/{requestId}".replace("{" + "version" + "}", _bzz_urlize_path_param(version)).replace("{" + "requestId" + "}", _bzz_urlize_path_param(requestId))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiTechTuneResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_tech_tune_threaded(
	# version: float   Eg: 3.16
	version: float,
	# requestId: String = ""   Eg: requestId_example
	# Orson Request Id
	requestId: String,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_tech_tune")
	bzz_callable.bind(
		version,
		requestId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getTopics → GET /api/{version}/orson/ai/topics/{requestId}
# Get Topics
#
# Get the result of an in progress Topics Analysis from an earlier POST.
func get_topics(
	# version: float   Eg: 3.16
	version: float,
	# requestId: String = ""   Eg: requestId_example
	# Orson Request Id
	requestId: String,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/topics/{requestId}".replace("{" + "version" + "}", _bzz_urlize_path_param(version)).replace("{" + "requestId" + "}", _bzz_urlize_path_param(requestId))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiTopicsResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_topics_threaded(
	# version: float   Eg: 3.16
	version: float,
	# requestId: String = ""   Eg: requestId_example
	# Orson Request Id
	requestId: String,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_topics")
	bzz_callable.bind(
		version,
		requestId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getVoiceCanvas → GET /api/{version}/orson/ai/voiceCanvas/{requestId}
# Get VoiceCanvas images
#
# Get a result or continue waiting for a pending request for VoiceCanvas Images.
func get_voice_canvas(
	# version: float   Eg: 3.16
	version: float,
	# requestId: String = ""   Eg: requestId_example
	# Orson Request Id
	requestId: String,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/voiceCanvas/{requestId}".replace("{" + "version" + "}", _bzz_urlize_path_param(version)).replace("{" + "requestId" + "}", _bzz_urlize_path_param(requestId))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiVoiceCanvasResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_voice_canvas_threaded(
	# version: float   Eg: 3.16
	version: float,
	# requestId: String = ""   Eg: requestId_example
	# Orson Request Id
	requestId: String,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_voice_canvas")
	bzz_callable.bind(
		version,
		requestId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation startVideoRender → POST /api/{version}/orson/stories/renders
# Starts a StoryStitch video render
#
# Starts a StoryStitch video render to produce your final video, returning the status details.
func start_video_render(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# data: String = ""   Eg: data_example
	# Request Data String
	data: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/stories/renders".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["data"] = data

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonRenderResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func start_video_render_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# data: String = ""   Eg: data_example
	# Request Data String
	data: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "start_video_render")
	bzz_callable.bind(
		version,
		accountId,
		data,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation stt → POST /api/{version}/orson/ai/stt
# Speach to Text
#
# Accepts a movie URL or uploaded file and transcribes it. You also have the option to translate it into one of our additional supported languages.
func stt(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# thirdPartyAccountId: String = ""   Eg: thirdPartyAccountId_example
	# A third-party account id that is meaningful to your systems
	thirdPartyAccountId = "",
	# sourceLanguage: String = ""   Eg: sourceLanguage_example
	# Source Language
	sourceLanguage = "",
	# targetLanguage: String = ""   Eg: targetLanguage_example
	# Target Language
	targetLanguage = "",
	# file: String   Eg: BINARY_DATA_HERE
	# An uploaded recording to analyze (Currently limited to 10MB)
	file = null,
	# url: String = ""   Eg: url_example
	# A recording file to download and analyze (Size limit: 1GB)
	url = "",
	# callback: String = ""   Eg: callback_example
	# When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
	callback = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/stt".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["thirdPartyAccountId"] = thirdPartyAccountId
	bzz_query["sourceLanguage"] = sourceLanguage
	bzz_query["targetLanguage"] = targetLanguage
	bzz_query["file"] = file
	bzz_query["url"] = url
	bzz_query["callback"] = callback

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiSTTResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func stt_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# thirdPartyAccountId: String = ""   Eg: thirdPartyAccountId_example
	# A third-party account id that is meaningful to your systems
	thirdPartyAccountId = "",
	# sourceLanguage: String = ""   Eg: sourceLanguage_example
	# Source Language
	sourceLanguage = "",
	# targetLanguage: String = ""   Eg: targetLanguage_example
	# Target Language
	targetLanguage = "",
	# file: String   Eg: BINARY_DATA_HERE
	# An uploaded recording to analyze (Currently limited to 10MB)
	file = null,
	# url: String = ""   Eg: url_example
	# A recording file to download and analyze (Size limit: 1GB)
	url = "",
	# callback: String = ""   Eg: callback_example
	# When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
	callback = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "stt")
	bzz_callable.bind(
		version,
		accountId,
		thirdPartyAccountId,
		sourceLanguage,
		targetLanguage,
		file,
		url,
		callback,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation summarizeTopics → POST /api/{version}/orson/ai/topics
# Summarize Topics
#
# Takes in a string of text sentences (also known as a document) and returns a list of associated topics and their proximity score.
func summarize_topics(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# thirdPartyAccountId: String = ""   Eg: thirdPartyAccountId_example
	# A third-party account id that is meaningful to your systems
	thirdPartyAccountId = "",
	# doc: String = ""   Eg: doc_example
	# The text to get topics for.
	doc = "",
	# file: String   Eg: BINARY_DATA_HERE
	# An uploaded recording to analyze (Currently limited to 10MB)
	file = null,
	# url: String = ""   Eg: url_example
	# A recording file to download and analyze (Size limit: 1GB)
	url = "",
	# limit: int   Eg: 56
	# The number of results to return
	limit = null,
	# offset: int   Eg: 56
	# The starting offset into the total result set to start from
	offset = null,
	# callback: String = ""   Eg: callback_example
	# When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
	callback = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/topics".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["thirdPartyAccountId"] = thirdPartyAccountId
	bzz_query["doc"] = doc
	bzz_query["file"] = file
	bzz_query["url"] = url
	bzz_query["limit"] = limit
	bzz_query["offset"] = offset
	bzz_query["callback"] = callback

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiTopicsResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func summarize_topics_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# thirdPartyAccountId: String = ""   Eg: thirdPartyAccountId_example
	# A third-party account id that is meaningful to your systems
	thirdPartyAccountId = "",
	# doc: String = ""   Eg: doc_example
	# The text to get topics for.
	doc = "",
	# file: String   Eg: BINARY_DATA_HERE
	# An uploaded recording to analyze (Currently limited to 10MB)
	file = null,
	# url: String = ""   Eg: url_example
	# A recording file to download and analyze (Size limit: 1GB)
	url = "",
	# limit: int   Eg: 56
	# The number of results to return
	limit = null,
	# offset: int   Eg: 56
	# The starting offset into the total result set to start from
	offset = null,
	# callback: String = ""   Eg: callback_example
	# When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
	callback = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "summarize_topics")
	bzz_callable.bind(
		version,
		accountId,
		thirdPartyAccountId,
		doc,
		file,
		url,
		limit,
		offset,
		callback,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation techTune → POST /api/{version}/orson/ai/techTune
# Detect Technical Issues
#
# Analyses a movie file to detect technical issues, such as too few people in frame.
func tech_tune(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# numFacesExpected: int   Eg: 56
	# Number of expected faces
	numFacesExpected: int,
	# thirdPartyAccountId: String = ""   Eg: thirdPartyAccountId_example
	# A third-party account id that is meaningful to your systems
	thirdPartyAccountId = "",
	# file: String   Eg: BINARY_DATA_HERE
	# An uploaded recording to analyze (Currently limited to 10MB)
	file = null,
	# url: String = ""   Eg: url_example
	# A recording file to download and analyze (Size limit: 1GB)
	url = "",
	# callback: String = ""   Eg: callback_example
	# When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
	callback = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/techTune".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["thirdPartyAccountId"] = thirdPartyAccountId
	bzz_query["numFacesExpected"] = numFacesExpected
	bzz_query["file"] = file
	bzz_query["url"] = url
	bzz_query["callback"] = callback

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiTechTuneResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func tech_tune_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# numFacesExpected: int   Eg: 56
	# Number of expected faces
	numFacesExpected: int,
	# thirdPartyAccountId: String = ""   Eg: thirdPartyAccountId_example
	# A third-party account id that is meaningful to your systems
	thirdPartyAccountId = "",
	# file: String   Eg: BINARY_DATA_HERE
	# An uploaded recording to analyze (Currently limited to 10MB)
	file = null,
	# url: String = ""   Eg: url_example
	# A recording file to download and analyze (Size limit: 1GB)
	url = "",
	# callback: String = ""   Eg: callback_example
	# When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
	callback = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "tech_tune")
	bzz_callable.bind(
		version,
		accountId,
		numFacesExpected,
		thirdPartyAccountId,
		file,
		url,
		callback,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation tts → POST /api/{version}/orson/ai/tts
# Text to Speach
#
# Creates an audio file for the given text, with the option of language and voice selection.
func tts(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# text: String = ""   Eg: text_example
	# Text
	text: String,
	# thirdPartyAccountId: String = ""   Eg: thirdPartyAccountId_example
	# A third-party account id that is meaningful to your systems
	thirdPartyAccountId = "",
	# language: String = ""   Eg: language_example
	# The language to use for the speaker and incoming text
	language = "",
	# voice: String = ""   Eg: voice_example
	# A language-specific voice to use, or picks the language default if not provided
	voice = "",
	# callback: String = ""   Eg: callback_example
	# When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
	callback = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/orson/ai/tts".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["thirdPartyAccountId"] = thirdPartyAccountId
	bzz_query["text"] = text
	bzz_query["language"] = language
	bzz_query["voice"] = voice
	bzz_query["callback"] = callback

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrsonAiTTSResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func tts_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# Sirqul Account Id
	accountId: float,
	# text: String = ""   Eg: text_example
	# Text
	text: String,
	# thirdPartyAccountId: String = ""   Eg: thirdPartyAccountId_example
	# A third-party account id that is meaningful to your systems
	thirdPartyAccountId = "",
	# language: String = ""   Eg: language_example
	# The language to use for the speaker and incoming text
	language = "",
	# voice: String = ""   Eg: voice_example
	# A language-specific voice to use, or picks the language default if not provided
	voice = "",
	# callback: String = ""   Eg: callback_example
	# When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
	callback = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "tts")
	bzz_callable.bind(
		version,
		accountId,
		text,
		thirdPartyAccountId,
		language,
		voice,
		callback,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


