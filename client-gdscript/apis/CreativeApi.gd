extends ApiBee
class_name CreativeApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API CreativeApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "CreativeApi"


# Operation addPreview → POST /creative/addpreview
# Add Preview
#
# Enable this ad for preview for this account.
func add_preview(
	# accountId: float   Eg: 789
	# the id of the account
	accountId: float,
	# creativeId: float   Eg: 789
	# The id of the creative that want to enable preview. The type of the creative should be CONFIG, otherwise no action will be applied.
	creativeId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/creative/addpreview"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["creativeId"] = creativeId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func add_preview_threaded(
	# accountId: float   Eg: 789
	# the id of the account
	accountId: float,
	# creativeId: float   Eg: 789
	# The id of the creative that want to enable preview. The type of the creative should be CONFIG, otherwise no action will be applied.
	creativeId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "add_preview")
	bzz_callable.bind(
		accountId,
		creativeId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation adsFind → GET /ads/find
# Find Missions
#
# Get a set of ad filtered by the parameters provided.
func ads_find(
	# appKey: String = ""   Eg: appKey_example
	# The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic.
	appKey: String,
	# some_randomize: bool   Eg: true
	# return a random set of results, default is true. If false returns in nature order.
	some_randomize: bool,
	# targetedAdsOnly: bool   Eg: true
	# return only ads targets to the specific app, no global ads.
	targetedAdsOnly: bool,
	# type: String = ""   Eg: type_example
	# The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix.
	type = "",
	# accountId: float   Eg: 789
	# The logged in user.
	accountId = null,
	# appVersion: String = ""   Eg: appVersion_example
	# The version of the application, will not return levels newer than the appVersion.
	appVersion = "",
	# latitude: int   Eg: 1.2
	# The current location of the requesting device
	latitude = null,
	# longitude: int   Eg: 1.2
	# The current location of the requesting device
	longitude = null,
	# device: String = ""   Eg: device_example
	# Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list.
	device = "",
	# deviceIdentifier: float   Eg: 789
	# The device ID of the requesting device, use /audience/devices for list
	deviceIdentifier = null,
	# deviceVersion: String = ""   Eg: deviceVersion_example
	# The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string.
	deviceVersion = "",
	# start: int   Eg: 56
	# The index into the record set to start with.
	start = null,
	# limit: int   Eg: 56
	# The total number of record to return.
	limit = null,
	# includeAudiences: bool   Eg: true
	# If true then return the audience data in the response. Default is false.
	includeAudiences = null,
	# allocatesTickets: bool   Eg: true
	# If true/false only return missions whose game levels allocate (or don't allocate) tickets. Do not provide a value to return both.
	allocatesTickets = null,
	# missionIds: String = ""   Eg: missionIds_example
	# return only ads from the specified campaigns.
	missionIds = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/ads/find"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["appKey"] = appKey
	bzz_query["type"] = type
	bzz_query["accountId"] = accountId
	bzz_query["appVersion"] = appVersion
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["device"] = device
	bzz_query["deviceIdentifier"] = deviceIdentifier
	bzz_query["deviceVersion"] = deviceVersion
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["includeAudiences"] = includeAudiences
	bzz_query["allocatesTickets"] = allocatesTickets
	bzz_query["randomize"] = some_randomize
	bzz_query["targetedAdsOnly"] = targetedAdsOnly
	bzz_query["missionIds"] = missionIds

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = MissionResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func ads_find_threaded(
	# appKey: String = ""   Eg: appKey_example
	# The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic.
	appKey: String,
	# some_randomize: bool   Eg: true
	# return a random set of results, default is true. If false returns in nature order.
	some_randomize: bool,
	# targetedAdsOnly: bool   Eg: true
	# return only ads targets to the specific app, no global ads.
	targetedAdsOnly: bool,
	# type: String = ""   Eg: type_example
	# The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix.
	type = "",
	# accountId: float   Eg: 789
	# The logged in user.
	accountId = null,
	# appVersion: String = ""   Eg: appVersion_example
	# The version of the application, will not return levels newer than the appVersion.
	appVersion = "",
	# latitude: int   Eg: 1.2
	# The current location of the requesting device
	latitude = null,
	# longitude: int   Eg: 1.2
	# The current location of the requesting device
	longitude = null,
	# device: String = ""   Eg: device_example
	# Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list.
	device = "",
	# deviceIdentifier: float   Eg: 789
	# The device ID of the requesting device, use /audience/devices for list
	deviceIdentifier = null,
	# deviceVersion: String = ""   Eg: deviceVersion_example
	# The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string.
	deviceVersion = "",
	# start: int   Eg: 56
	# The index into the record set to start with.
	start = null,
	# limit: int   Eg: 56
	# The total number of record to return.
	limit = null,
	# includeAudiences: bool   Eg: true
	# If true then return the audience data in the response. Default is false.
	includeAudiences = null,
	# allocatesTickets: bool   Eg: true
	# If true/false only return missions whose game levels allocate (or don't allocate) tickets. Do not provide a value to return both.
	allocatesTickets = null,
	# missionIds: String = ""   Eg: missionIds_example
	# return only ads from the specified campaigns.
	missionIds = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "ads_find")
	bzz_callable.bind(
		appKey,
		some_randomize,
		targetedAdsOnly,
		type,
		accountId,
		appVersion,
		latitude,
		longitude,
		device,
		deviceIdentifier,
		deviceVersion,
		start,
		limit,
		includeAudiences,
		allocatesTickets,
		missionIds,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createCreative → POST /creative/create
# Create Creative
#
# Create a creative
func create_creative(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the level.
	name: String,
	# active: bool   Eg: true
	# If true set the game level as active. Default is false.
	active: bool,
	# waitForAsset: bool   Eg: true
	# determines whether the response will wait until the asset gets created
	waitForAsset: bool,
	# description: String = ""   Eg: description_example
	# The description of the level.
	description = "",
	# assetImageId: float   Eg: 789
	# The asset Id of the level image.
	assetImageId = null,
	# action: String = ""   Eg: action_example
	# This parameter is deprecated. deprecated use data field
	action = "",
	# data: String = ""   Eg: data_example
	# The creative data, json based format depending on type. If not using action then data is required.
	data = "",
	# suffix: String = ""   Eg: suffix_example
	# This parameter is deprecated. deprecated use type field
	suffix = "",
	# type: String = ""   Eg: type_example
	# The type of creative. If not using suffix then type is required.
	type = "",
	# balance: int   Eg: 1.2
	# Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.
	balance = null,
	# referenceId: float   Eg: 789
	# if creative related so some other content provided the id
	referenceId = null,
	# appVersion: String = ""   Eg: appVersion_example
	# The version of the application, will not return creatives newer than the appVersion. Only used when requesting application configuration creatives.
	appVersion = "",
	# missionId: float   Eg: 789
	# Assign the creative to a campaign for timing and audience matching.
	missionId = null,
	# offerId: float   Eg: 789
	# the id of the offer
	offerId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/creative/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["name"] = name
	bzz_query["description"] = description
	bzz_query["assetImageId"] = assetImageId
	bzz_query["action"] = action
	bzz_query["data"] = data
	bzz_query["suffix"] = suffix
	bzz_query["type"] = type
	bzz_query["balance"] = balance
	bzz_query["active"] = active
	bzz_query["referenceId"] = referenceId
	bzz_query["appVersion"] = appVersion
	bzz_query["missionId"] = missionId
	bzz_query["offerId"] = offerId
	bzz_query["waitForAsset"] = waitForAsset

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = CreativeResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_creative_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the level.
	name: String,
	# active: bool   Eg: true
	# If true set the game level as active. Default is false.
	active: bool,
	# waitForAsset: bool   Eg: true
	# determines whether the response will wait until the asset gets created
	waitForAsset: bool,
	# description: String = ""   Eg: description_example
	# The description of the level.
	description = "",
	# assetImageId: float   Eg: 789
	# The asset Id of the level image.
	assetImageId = null,
	# action: String = ""   Eg: action_example
	# This parameter is deprecated. deprecated use data field
	action = "",
	# data: String = ""   Eg: data_example
	# The creative data, json based format depending on type. If not using action then data is required.
	data = "",
	# suffix: String = ""   Eg: suffix_example
	# This parameter is deprecated. deprecated use type field
	suffix = "",
	# type: String = ""   Eg: type_example
	# The type of creative. If not using suffix then type is required.
	type = "",
	# balance: int   Eg: 1.2
	# Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.
	balance = null,
	# referenceId: float   Eg: 789
	# if creative related so some other content provided the id
	referenceId = null,
	# appVersion: String = ""   Eg: appVersion_example
	# The version of the application, will not return creatives newer than the appVersion. Only used when requesting application configuration creatives.
	appVersion = "",
	# missionId: float   Eg: 789
	# Assign the creative to a campaign for timing and audience matching.
	missionId = null,
	# offerId: float   Eg: 789
	# the id of the offer
	offerId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_creative")
	bzz_callable.bind(
		accountId,
		name,
		active,
		waitForAsset,
		description,
		assetImageId,
		action,
		data,
		suffix,
		type,
		balance,
		referenceId,
		appVersion,
		missionId,
		offerId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteCreative → POST /creative/delete
# Delete Creative
#
# Delete a creative
func delete_creative(
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# creativeId: float   Eg: 789
	# the id of the creative to delete
	creativeId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/creative/delete"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["creativeId"] = creativeId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_creative_threaded(
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# creativeId: float   Eg: 789
	# the id of the creative to delete
	creativeId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_creative")
	bzz_callable.bind(
		accountId,
		creativeId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getCreative → GET /creative/get
# Get Creative
#
# Get a creative
func get_creative(
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# creativeId: float   Eg: 789
	# the ID of the creative to get
	creativeId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/creative/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["creativeId"] = creativeId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = CreativeResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_creative_threaded(
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# creativeId: float   Eg: 789
	# the ID of the creative to get
	creativeId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_creative")
	bzz_callable.bind(
		accountId,
		creativeId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getCreativesByApplication → GET /creative/search
# Search Creatives
#
# Get a list of levels for an application, just those the account has permissions to view.
func get_creatives_by_application(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# start: int   Eg: 56
	# Start the result set at some index.
	start: int,
	# limit: int   Eg: 56
	# Limit the result to some number.
	limit: int,
	# missionId: float   Eg: 789
	# Creatives contained in the provided mission.
	missionId = null,
	# keyword: String = ""   Eg: keyword_example
	# Match the keyword to the owner name or level name.
	keyword = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/creative/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["missionId"] = missionId
	bzz_query["keyword"] = keyword
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = CreativeResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_creatives_by_application_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# start: int   Eg: 56
	# Start the result set at some index.
	start: int,
	# limit: int   Eg: 56
	# Limit the result to some number.
	limit: int,
	# missionId: float   Eg: 789
	# Creatives contained in the provided mission.
	missionId = null,
	# keyword: String = ""   Eg: keyword_example
	# Match the keyword to the owner name or level name.
	keyword = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_creatives_by_application")
	bzz_callable.bind(
		accountId,
		appKey,
		start,
		limit,
		missionId,
		keyword,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation removePreview → POST /creative/removepreview
# Remove Preview
#
# Remove this ad for preview for this account.
func remove_preview(
	# accountId: float   Eg: 789
	# the ID of the logged in user
	accountId: float,
	# creativeId: float   Eg: 789
	# the ID of the creative to remove preview
	creativeId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/creative/removepreview"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["creativeId"] = creativeId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func remove_preview_threaded(
	# accountId: float   Eg: 789
	# the ID of the logged in user
	accountId: float,
	# creativeId: float   Eg: 789
	# the ID of the creative to remove preview
	creativeId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "remove_preview")
	bzz_callable.bind(
		accountId,
		creativeId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateCreative → POST /creative/update
# Update Creative
#
# Update a creative
func update_creative(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# creativeId: float   Eg: 789
	# the creative Id to upate.
	creativeId: float,
	# name: String = ""   Eg: name_example
	# The name of the level.
	name = "",
	# description: String = ""   Eg: description_example
	# The description of the level.
	description = "",
	# assetImageId: float   Eg: 789
	# The asset Id of the level image.
	assetImageId = null,
	# action: String = ""   Eg: action_example
	# This parameter is deprecated. deprecated use data field
	action = "",
	# data: String = ""   Eg: data_example
	# The creative data, json based format depending on type
	data = "",
	# suffix: String = ""   Eg: suffix_example
	# This parameter is deprecated. deprecated use type field
	suffix = "",
	# type: String = ""   Eg: type_example
	# The type of creative.
	type = "",
	# balance: int   Eg: 1.2
	# Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.
	balance = null,
	# active: bool   Eg: true
	# If true set the game level as active. Default is false.
	active = null,
	# referenceId: float   Eg: 789
	# if creative related so some other content provided the id
	referenceId = null,
	# appVersion: String = ""   Eg: appVersion_example
	# The version of the application, will not return creatives newer than the appVersion. Only used when requesting application configuration creatives.
	appVersion = "",
	# missionId: float   Eg: 789
	# Assign the creative to a campaign for timing and audience matching.
	missionId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/creative/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["creativeId"] = creativeId
	bzz_query["name"] = name
	bzz_query["description"] = description
	bzz_query["assetImageId"] = assetImageId
	bzz_query["action"] = action
	bzz_query["data"] = data
	bzz_query["suffix"] = suffix
	bzz_query["type"] = type
	bzz_query["balance"] = balance
	bzz_query["active"] = active
	bzz_query["referenceId"] = referenceId
	bzz_query["appVersion"] = appVersion
	bzz_query["missionId"] = missionId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = CreativeResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_creative_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# creativeId: float   Eg: 789
	# the creative Id to upate.
	creativeId: float,
	# name: String = ""   Eg: name_example
	# The name of the level.
	name = "",
	# description: String = ""   Eg: description_example
	# The description of the level.
	description = "",
	# assetImageId: float   Eg: 789
	# The asset Id of the level image.
	assetImageId = null,
	# action: String = ""   Eg: action_example
	# This parameter is deprecated. deprecated use data field
	action = "",
	# data: String = ""   Eg: data_example
	# The creative data, json based format depending on type
	data = "",
	# suffix: String = ""   Eg: suffix_example
	# This parameter is deprecated. deprecated use type field
	suffix = "",
	# type: String = ""   Eg: type_example
	# The type of creative.
	type = "",
	# balance: int   Eg: 1.2
	# Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.
	balance = null,
	# active: bool   Eg: true
	# If true set the game level as active. Default is false.
	active = null,
	# referenceId: float   Eg: 789
	# if creative related so some other content provided the id
	referenceId = null,
	# appVersion: String = ""   Eg: appVersion_example
	# The version of the application, will not return creatives newer than the appVersion. Only used when requesting application configuration creatives.
	appVersion = "",
	# missionId: float   Eg: 789
	# Assign the creative to a campaign for timing and audience matching.
	missionId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_creative")
	bzz_callable.bind(
		accountId,
		creativeId,
		name,
		description,
		assetImageId,
		action,
		data,
		suffix,
		type,
		balance,
		active,
		referenceId,
		appVersion,
		missionId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


