extends ApiBee
class_name ThirdPartyCredentialsApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API ThirdPartyCredentialsApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "ThirdPartyCredentialsApi"


# Operation createCredential → POST /thirdparty/credential/create
# Create Credential
#
# This endpoint creates a third-party login for a Sirqul account. A third party login is a way for external systems (Third Party Networks) to link their own user accounts with a Sirqul account.   The thirdPartyId parameter is used to determine if the user already exists in Sirqul or not. This parameter needs to be unique for each user in the Third Party Network (identified by the networkUID parameter). Note that subsequent calls will update the user's third-party login credentials for the user with the same thirdPartyId and networkUID combination.    The thirdPartyToken parameter acts as a shared secret and used by client applications to log users into Sirqul without providing a Sirqul username and password. 
func create_credential(
	# thirdPartyId: String = ""   Eg: thirdPartyId_example
	# the third party user account id
	thirdPartyId: String,
	# thirdPartyToken: String = ""   Eg: thirdPartyToken_example
	# the access token to authenticate with (ex: username or fb token or phone number)
	thirdPartyToken: String,
	# networkUID: String = ""   Eg: networkUID_example
	# the access provider to authenticate against
	networkUID: String,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# accountId: float   Eg: 789
	# the unique id of the account that needs authenticating (optional for PHONE_V2)
	accountId = null,
	# deviceId: String = ""   Eg: deviceId_example
	# the unique id of the device making the request
	deviceId = "",
	# sessionId: String = ""   Eg: sessionId_example
	# the session id for the request
	sessionId = "",
	# thirdPartyName: String = ""   Eg: thirdPartyName_example
	# the third party user's display name
	thirdPartyName = "",
	# emailAddress: String = ""   Eg: emailAddress_example
	# optional email address associated with the third party account
	emailAddress = "",
	# signinOnlyMode: bool = false   Eg: true
	# when true will error out if can't find any accounts matching (signin only)
	signinOnlyMode = false,
	# responseFilters: String = ""   Eg: responseFilters_example
	# this determines how much of the profile should be returned, see ProfileFilters
	responseFilters = "",
	# latitude: int   Eg: 1.2
	# the latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the longitude of the user
	longitude = null,
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# thirdPartyRefreshToken: String = ""   Eg: thirdPartyRefreshToken_example
	# optional refresh token for the third party
	thirdPartyRefreshToken = "",
	# audienceIdsToAdd: String = ""   Eg: audienceIdsToAdd_example
	# audience ids to add to the account
	audienceIdsToAdd = "",
	# audienceIdsToRemove: String = ""   Eg: audienceIdsToRemove_example
	# audience ids to remove from the account
	audienceIdsToRemove = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/thirdparty/credential/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["deviceId"] = deviceId
	bzz_query["sessionId"] = sessionId
	bzz_query["thirdPartyId"] = thirdPartyId
	bzz_query["thirdPartyName"] = thirdPartyName
	bzz_query["thirdPartyToken"] = thirdPartyToken
	bzz_query["networkUID"] = networkUID
	bzz_query["appKey"] = appKey
	bzz_query["emailAddress"] = emailAddress
	bzz_query["signinOnlyMode"] = signinOnlyMode
	bzz_query["responseFilters"] = responseFilters
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["metaData"] = metaData
	bzz_query["thirdPartyRefreshToken"] = thirdPartyRefreshToken
	bzz_query["audienceIdsToAdd"] = audienceIdsToAdd
	bzz_query["audienceIdsToRemove"] = audienceIdsToRemove

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ProfileResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_credential_threaded(
	# thirdPartyId: String = ""   Eg: thirdPartyId_example
	# the third party user account id
	thirdPartyId: String,
	# thirdPartyToken: String = ""   Eg: thirdPartyToken_example
	# the access token to authenticate with (ex: username or fb token or phone number)
	thirdPartyToken: String,
	# networkUID: String = ""   Eg: networkUID_example
	# the access provider to authenticate against
	networkUID: String,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# accountId: float   Eg: 789
	# the unique id of the account that needs authenticating (optional for PHONE_V2)
	accountId = null,
	# deviceId: String = ""   Eg: deviceId_example
	# the unique id of the device making the request
	deviceId = "",
	# sessionId: String = ""   Eg: sessionId_example
	# the session id for the request
	sessionId = "",
	# thirdPartyName: String = ""   Eg: thirdPartyName_example
	# the third party user's display name
	thirdPartyName = "",
	# emailAddress: String = ""   Eg: emailAddress_example
	# optional email address associated with the third party account
	emailAddress = "",
	# signinOnlyMode: bool = false   Eg: true
	# when true will error out if can't find any accounts matching (signin only)
	signinOnlyMode = false,
	# responseFilters: String = ""   Eg: responseFilters_example
	# this determines how much of the profile should be returned, see ProfileFilters
	responseFilters = "",
	# latitude: int   Eg: 1.2
	# the latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the longitude of the user
	longitude = null,
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# thirdPartyRefreshToken: String = ""   Eg: thirdPartyRefreshToken_example
	# optional refresh token for the third party
	thirdPartyRefreshToken = "",
	# audienceIdsToAdd: String = ""   Eg: audienceIdsToAdd_example
	# audience ids to add to the account
	audienceIdsToAdd = "",
	# audienceIdsToRemove: String = ""   Eg: audienceIdsToRemove_example
	# audience ids to remove from the account
	audienceIdsToRemove = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_credential")
	bzz_callable.bind(
		thirdPartyId,
		thirdPartyToken,
		networkUID,
		appKey,
		accountId,
		deviceId,
		sessionId,
		thirdPartyName,
		emailAddress,
		signinOnlyMode,
		responseFilters,
		latitude,
		longitude,
		metaData,
		thirdPartyRefreshToken,
		audienceIdsToAdd,
		audienceIdsToRemove,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createNetwork → POST /thirdparty/network/create
# Create Network
#
# Creates a custom third party network.
func create_network(
	# accountId: float   Eg: 789
	# The account id making the request
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the network
	name: String,
	# enableIntrospection: bool   Eg: true
	# Whether the network uses introspection calls
	enableIntrospection: bool,
	# description: String = ""   Eg: description_example
	# The description of the network
	description = "",
	# introspectionMethod: String = ""   Eg: introspectionMethod_example
	# HTTP method to use for introspection calls (e.g., GET, POST)
	introspectionMethod = "",
	# introspectionURL: String = ""   Eg: introspectionURL_example
	# The HTTP URL of the introspection call
	introspectionURL = "",
	# introspectionParams: String = ""   Eg: introspectionParams_example
	# The parameters of the introspection call
	introspectionParams = "",
	# requiredRootField: String = ""   Eg: requiredRootField_example
	# Required response params
	requiredRootField = "",
	# enableMFA: bool   Eg: true
	# Whether this network uses MFA
	enableMFA = null,
	# sizeMFA: int   Eg: 56
	# Size of the MFA token
	sizeMFA = null,
	# shelfLifeMFA: int   Eg: 56
	# Shelf life (seconds) of the MFA token
	shelfLifeMFA = null,
	# oauthTokenURL: String = ""   Eg: oauthTokenURL_example
	# OAuth token endpoint URL
	oauthTokenURL = "",
	# oauthPrivateKey: String   Eg: BINARY_DATA_HERE
	# OAuth private key file (multipart)
	oauthPrivateKey = null,
	# oauthPublicKey: String   Eg: BINARY_DATA_HERE
	# OAuth public key file (multipart)
	oauthPublicKey = null,
	# oauthClientId: String = ""   Eg: oauthClientId_example
	# OAuth client id
	oauthClientId = "",
	# oauthSecretKey: String = ""   Eg: oauthSecretKey_example
	# OAuth secret key
	oauthSecretKey = "",
	# body: String   Eg: body_example
	body = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/thirdparty/network/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["name"] = name
	bzz_query["description"] = description
	bzz_query["enableIntrospection"] = enableIntrospection
	bzz_query["introspectionMethod"] = introspectionMethod
	bzz_query["introspectionURL"] = introspectionURL
	bzz_query["introspectionParams"] = introspectionParams
	bzz_query["requiredRootField"] = requiredRootField
	bzz_query["enableMFA"] = enableMFA
	bzz_query["sizeMFA"] = sizeMFA
	bzz_query["shelfLifeMFA"] = shelfLifeMFA
	bzz_query["oauthTokenURL"] = oauthTokenURL
	bzz_query["oauthPrivateKey"] = oauthPrivateKey
	bzz_query["oauthPublicKey"] = oauthPublicKey
	bzz_query["oauthClientId"] = oauthClientId
	bzz_query["oauthSecretKey"] = oauthSecretKey

	var bzz_body = null
	bzz_body = body

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ThirdPartyNetworkResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_network_threaded(
	# accountId: float   Eg: 789
	# The account id making the request
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the network
	name: String,
	# enableIntrospection: bool   Eg: true
	# Whether the network uses introspection calls
	enableIntrospection: bool,
	# description: String = ""   Eg: description_example
	# The description of the network
	description = "",
	# introspectionMethod: String = ""   Eg: introspectionMethod_example
	# HTTP method to use for introspection calls (e.g., GET, POST)
	introspectionMethod = "",
	# introspectionURL: String = ""   Eg: introspectionURL_example
	# The HTTP URL of the introspection call
	introspectionURL = "",
	# introspectionParams: String = ""   Eg: introspectionParams_example
	# The parameters of the introspection call
	introspectionParams = "",
	# requiredRootField: String = ""   Eg: requiredRootField_example
	# Required response params
	requiredRootField = "",
	# enableMFA: bool   Eg: true
	# Whether this network uses MFA
	enableMFA = null,
	# sizeMFA: int   Eg: 56
	# Size of the MFA token
	sizeMFA = null,
	# shelfLifeMFA: int   Eg: 56
	# Shelf life (seconds) of the MFA token
	shelfLifeMFA = null,
	# oauthTokenURL: String = ""   Eg: oauthTokenURL_example
	# OAuth token endpoint URL
	oauthTokenURL = "",
	# oauthPrivateKey: String   Eg: BINARY_DATA_HERE
	# OAuth private key file (multipart)
	oauthPrivateKey = null,
	# oauthPublicKey: String   Eg: BINARY_DATA_HERE
	# OAuth public key file (multipart)
	oauthPublicKey = null,
	# oauthClientId: String = ""   Eg: oauthClientId_example
	# OAuth client id
	oauthClientId = "",
	# oauthSecretKey: String = ""   Eg: oauthSecretKey_example
	# OAuth secret key
	oauthSecretKey = "",
	# body: String   Eg: body_example
	body = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_network")
	bzz_callable.bind(
		accountId,
		name,
		enableIntrospection,
		description,
		introspectionMethod,
		introspectionURL,
		introspectionParams,
		requiredRootField,
		enableMFA,
		sizeMFA,
		shelfLifeMFA,
		oauthTokenURL,
		oauthPrivateKey,
		oauthPublicKey,
		oauthClientId,
		oauthSecretKey,
		body,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteCredential → POST /thirdparty/credential/delete
# Delete Credential
#
# Delete a third party network on a Sirqul account.
func delete_credential(
	# accountId: float   Eg: 789
	# The account id of the user
	accountId: float,
	# networkUID: String = ""   Eg: networkUID_example
	# The third party network identifier
	networkUID: String,
	# thirdPartyId: String = ""   Eg: thirdPartyId_example
	# The third party user id
	thirdPartyId: String,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/thirdparty/credential/delete"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["networkUID"] = networkUID
	bzz_query["thirdPartyId"] = thirdPartyId
	bzz_query["appKey"] = appKey

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_credential_threaded(
	# accountId: float   Eg: 789
	# The account id of the user
	accountId: float,
	# networkUID: String = ""   Eg: networkUID_example
	# The third party network identifier
	networkUID: String,
	# thirdPartyId: String = ""   Eg: thirdPartyId_example
	# The third party user id
	thirdPartyId: String,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_credential")
	bzz_callable.bind(
		accountId,
		networkUID,
		thirdPartyId,
		appKey,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteNetwork → POST /thirdparty/network/delete
# Delete Network
#
# Marks a custom third party network as deleted. Only the network owners and managers have access to this.
func delete_network(
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# networkUID: String = ""   Eg: networkUID_example
	# The unique identifier for the third party network defined by Sirqul
	networkUID: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/thirdparty/network/delete"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["networkUID"] = networkUID

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_network_threaded(
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# networkUID: String = ""   Eg: networkUID_example
	# The unique identifier for the third party network defined by Sirqul
	networkUID: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_network")
	bzz_callable.bind(
		accountId,
		networkUID,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getCredential → POST /thirdparty/credential/get
# Get Credential
#
# Gets the account information given a third party token.
func get_credential(
	# networkUID: String = ""   Eg: networkUID_example
	# the access provider to authenticate against
	networkUID: String,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# accountId: float   Eg: 789
	# the unique account id of a specific account that will be bound to the third-party credentials
	accountId = null,
	# deviceId: String = ""   Eg: deviceId_example
	# the unique id of the device making the request
	deviceId = "",
	# sessionId: String = ""   Eg: sessionId_example
	# the session id for the request
	sessionId = "",
	# thirdPartyCredentialId: float   Eg: 789
	# the third-party credentials id from the response of the credential/create step
	thirdPartyCredentialId = null,
	# thirdPartyToken: String = ""   Eg: thirdPartyToken_example
	# the access token to authenticate with
	thirdPartyToken = "",
	# thirdPartySecret: String = ""   Eg: thirdPartySecret_example
	# the secret code to authenticate with (used for MFA)
	thirdPartySecret = "",
	# createNewAccount: bool = false   Eg: true
	# flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts
	createNewAccount = false,
	# responseFilters: String = ""   Eg: responseFilters_example
	# this determines how much of the profile should be returned, see ProfileFilters
	responseFilters = "",
	# latitude: int   Eg: 1.2
	# the latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the longitude of the user
	longitude = null,
	# audienceIdsToAdd: String = ""   Eg: audienceIdsToAdd_example
	# audience ids to add to the account
	audienceIdsToAdd = "",
	# audienceIdsToRemove: String = ""   Eg: audienceIdsToRemove_example
	# audience ids to remove from the account
	audienceIdsToRemove = "",
	# referralAccountId: float   Eg: 789
	# account id of the referrer (inviter-invitee relationship)
	referralAccountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/thirdparty/credential/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["deviceId"] = deviceId
	bzz_query["sessionId"] = sessionId
	bzz_query["thirdPartyCredentialId"] = thirdPartyCredentialId
	bzz_query["thirdPartyToken"] = thirdPartyToken
	bzz_query["thirdPartySecret"] = thirdPartySecret
	bzz_query["createNewAccount"] = createNewAccount
	bzz_query["networkUID"] = networkUID
	bzz_query["appKey"] = appKey
	bzz_query["responseFilters"] = responseFilters
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["audienceIdsToAdd"] = audienceIdsToAdd
	bzz_query["audienceIdsToRemove"] = audienceIdsToRemove
	bzz_query["referralAccountId"] = referralAccountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ProfileResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_credential_threaded(
	# networkUID: String = ""   Eg: networkUID_example
	# the access provider to authenticate against
	networkUID: String,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# accountId: float   Eg: 789
	# the unique account id of a specific account that will be bound to the third-party credentials
	accountId = null,
	# deviceId: String = ""   Eg: deviceId_example
	# the unique id of the device making the request
	deviceId = "",
	# sessionId: String = ""   Eg: sessionId_example
	# the session id for the request
	sessionId = "",
	# thirdPartyCredentialId: float   Eg: 789
	# the third-party credentials id from the response of the credential/create step
	thirdPartyCredentialId = null,
	# thirdPartyToken: String = ""   Eg: thirdPartyToken_example
	# the access token to authenticate with
	thirdPartyToken = "",
	# thirdPartySecret: String = ""   Eg: thirdPartySecret_example
	# the secret code to authenticate with (used for MFA)
	thirdPartySecret = "",
	# createNewAccount: bool = false   Eg: true
	# flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts
	createNewAccount = false,
	# responseFilters: String = ""   Eg: responseFilters_example
	# this determines how much of the profile should be returned, see ProfileFilters
	responseFilters = "",
	# latitude: int   Eg: 1.2
	# the latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the longitude of the user
	longitude = null,
	# audienceIdsToAdd: String = ""   Eg: audienceIdsToAdd_example
	# audience ids to add to the account
	audienceIdsToAdd = "",
	# audienceIdsToRemove: String = ""   Eg: audienceIdsToRemove_example
	# audience ids to remove from the account
	audienceIdsToRemove = "",
	# referralAccountId: float   Eg: 789
	# account id of the referrer (inviter-invitee relationship)
	referralAccountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_credential")
	bzz_callable.bind(
		networkUID,
		appKey,
		accountId,
		deviceId,
		sessionId,
		thirdPartyCredentialId,
		thirdPartyToken,
		thirdPartySecret,
		createNewAccount,
		responseFilters,
		latitude,
		longitude,
		audienceIdsToAdd,
		audienceIdsToRemove,
		referralAccountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getNetwork → GET /thirdparty/network/get
# Get Network
#
# Get the details of a third party network. Only the network owners and managers have access to this.
func get_network(
	# accountId: float   Eg: 789
	# The account id making the request
	accountId: float,
	# networkUID: String = ""   Eg: networkUID_example
	# The unique identifier for the third party network defined by Sirqul
	networkUID: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/thirdparty/network/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["networkUID"] = networkUID

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ThirdPartyNetworkResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_network_threaded(
	# accountId: float   Eg: 789
	# The account id making the request
	accountId: float,
	# networkUID: String = ""   Eg: networkUID_example
	# The unique identifier for the third party network defined by Sirqul
	networkUID: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_network")
	bzz_callable.bind(
		accountId,
		networkUID,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchCredentials → GET /thirdparty/credential/search
# Search Credentials
#
# Search on a user's linked third party networks.
func search_credentials(
	# accountId: float   Eg: 789
	# The account id of the user
	accountId: float,
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search on the third party name and network string
	keyword = "",
	# networkUID: String = ""   Eg: networkUID_example
	# The network UID to filter results with
	networkUID = "",
	# descending: bool   Eg: true
	# The order to return the search results
	descending = null,
	# start: int = 0   Eg: 56
	# The start of the pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# The limit of the pagination
	limit = 20,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/thirdparty/credential/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["keyword"] = keyword
	bzz_query["networkUID"] = networkUID
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ThirdPartyCredentialResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_credentials_threaded(
	# accountId: float   Eg: 789
	# The account id of the user
	accountId: float,
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search on the third party name and network string
	keyword = "",
	# networkUID: String = ""   Eg: networkUID_example
	# The network UID to filter results with
	networkUID = "",
	# descending: bool   Eg: true
	# The order to return the search results
	descending = null,
	# start: int = 0   Eg: 56
	# The start of the pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# The limit of the pagination
	limit = 20,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_credentials")
	bzz_callable.bind(
		accountId,
		keyword,
		networkUID,
		descending,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchNetworks → GET /thirdparty/network/search
# Search Networks
#
# Search on supported third party networks and custom networks from external users.
func search_networks(
	# accountId: float   Eg: 789
	# The account id making the request
	accountId: float,
	# sortField: String = ""   Eg: sortField_example
	# The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME
	sortField: String,
	# descending: bool   Eg: true
	# The order to return the search results
	descending: bool,
	# start: int   Eg: 56
	# The start of the pagination
	start: int,
	# limit: int   Eg: 56
	# The limit of the pagination
	limit: int,
	# activeOnly: bool   Eg: true
	# Return only active results
	activeOnly: bool,
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search on the network name and description fields
	keyword = "",
	# filterBillable: bool   Eg: true
	# Determines whether to only return applications that the user has access to
	filterBillable = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/thirdparty/network/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["activeOnly"] = activeOnly
	bzz_query["filterBillable"] = filterBillable

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ThirdPartyNetworkShortResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_networks_threaded(
	# accountId: float   Eg: 789
	# The account id making the request
	accountId: float,
	# sortField: String = ""   Eg: sortField_example
	# The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME
	sortField: String,
	# descending: bool   Eg: true
	# The order to return the search results
	descending: bool,
	# start: int   Eg: 56
	# The start of the pagination
	start: int,
	# limit: int   Eg: 56
	# The limit of the pagination
	limit: int,
	# activeOnly: bool   Eg: true
	# Return only active results
	activeOnly: bool,
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search on the network name and description fields
	keyword = "",
	# filterBillable: bool   Eg: true
	# Determines whether to only return applications that the user has access to
	filterBillable = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_networks")
	bzz_callable.bind(
		accountId,
		sortField,
		descending,
		start,
		limit,
		activeOnly,
		keyword,
		filterBillable,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation sendMFAChallenge → POST /thirdparty/credential/mfa/send
# Send MFA Challenge
#
# Sends an MFA challenge (SMS or Email) for networks with MFA enabled.
func send_mfa_challenge(
	# networkUID: String = ""   Eg: networkUID_example
	# the third party network provider that has MFA enabled
	networkUID: String,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# thirdPartyToken: String = ""   Eg: thirdPartyToken_example
	# the access token to authenticate with
	thirdPartyToken = "",
	# thirdPartyCredentialId: float   Eg: 789
	# optional id of the existing third party credential
	thirdPartyCredentialId = null,
	# deviceId: String = ""   Eg: deviceId_example
	# the unique id of the device making the request
	deviceId = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/thirdparty/credential/mfa/send"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["thirdPartyToken"] = thirdPartyToken
	bzz_query["thirdPartyCredentialId"] = thirdPartyCredentialId
	bzz_query["networkUID"] = networkUID
	bzz_query["appKey"] = appKey
	bzz_query["deviceId"] = deviceId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func send_mfa_challenge_threaded(
	# networkUID: String = ""   Eg: networkUID_example
	# the third party network provider that has MFA enabled
	networkUID: String,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# thirdPartyToken: String = ""   Eg: thirdPartyToken_example
	# the access token to authenticate with
	thirdPartyToken = "",
	# thirdPartyCredentialId: float   Eg: 789
	# optional id of the existing third party credential
	thirdPartyCredentialId = null,
	# deviceId: String = ""   Eg: deviceId_example
	# the unique id of the device making the request
	deviceId = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "send_mfa_challenge")
	bzz_callable.bind(
		networkUID,
		appKey,
		thirdPartyToken,
		thirdPartyCredentialId,
		deviceId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateCredential → POST /thirdparty/credential/update
# Update Credential
#
# Updates a third-party login for an account.
func update_credential(
	# networkUID: String = ""   Eg: networkUID_example
	# the access provider to authenticate against
	networkUID: String,
	# thirdPartyId: String = ""   Eg: thirdPartyId_example
	# the third party user account id
	thirdPartyId: String,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# deviceId: String = ""   Eg: deviceId_example
	# the unique id of the device making the request
	deviceId = "",
	# thirdPartyName: String = ""   Eg: thirdPartyName_example
	# the third party user name
	thirdPartyName = "",
	# thirdPartyToken: String = ""   Eg: thirdPartyToken_example
	# the access token to authenticate with (ex: username or fb token)
	thirdPartyToken = "",
	# responseFilters: String = ""   Eg: responseFilters_example
	# this determines how much of the profile should be returned, see ProfileFilters
	responseFilters = "",
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# thirdPartyRefreshToken: String = ""   Eg: thirdPartyRefreshToken_example
	# optional refresh token for the third party
	thirdPartyRefreshToken = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/thirdparty/credential/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["networkUID"] = networkUID
	bzz_query["thirdPartyId"] = thirdPartyId
	bzz_query["thirdPartyName"] = thirdPartyName
	bzz_query["thirdPartyToken"] = thirdPartyToken
	bzz_query["appKey"] = appKey
	bzz_query["responseFilters"] = responseFilters
	bzz_query["metaData"] = metaData
	bzz_query["thirdPartyRefreshToken"] = thirdPartyRefreshToken

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ProfileResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_credential_threaded(
	# networkUID: String = ""   Eg: networkUID_example
	# the access provider to authenticate against
	networkUID: String,
	# thirdPartyId: String = ""   Eg: thirdPartyId_example
	# the third party user account id
	thirdPartyId: String,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# deviceId: String = ""   Eg: deviceId_example
	# the unique id of the device making the request
	deviceId = "",
	# thirdPartyName: String = ""   Eg: thirdPartyName_example
	# the third party user name
	thirdPartyName = "",
	# thirdPartyToken: String = ""   Eg: thirdPartyToken_example
	# the access token to authenticate with (ex: username or fb token)
	thirdPartyToken = "",
	# responseFilters: String = ""   Eg: responseFilters_example
	# this determines how much of the profile should be returned, see ProfileFilters
	responseFilters = "",
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# thirdPartyRefreshToken: String = ""   Eg: thirdPartyRefreshToken_example
	# optional refresh token for the third party
	thirdPartyRefreshToken = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_credential")
	bzz_callable.bind(
		networkUID,
		thirdPartyId,
		appKey,
		deviceId,
		thirdPartyName,
		thirdPartyToken,
		responseFilters,
		metaData,
		thirdPartyRefreshToken,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateNetwork → POST /thirdparty/network/update
# Update Network
#
# Updates a custom third party network. Only the network owners and managers have access to this.
func update_network(
	# accountId: float   Eg: 789
	# The account id making the request
	accountId: float,
	# networkUID: String = ""   Eg: networkUID_example
	# The unique identifier for the third party network defined by Sirqul
	networkUID: String,
	# name: String = ""   Eg: name_example
	# The name of the network
	name = "",
	# description: String = ""   Eg: description_example
	# The description of the network
	description = "",
	# enableIntrospection: bool   Eg: true
	# Whether the network uses introspection calls
	enableIntrospection = null,
	# introspectionMethod: String = ""   Eg: introspectionMethod_example
	# HTTP method to use for introspection calls (e.g., GET, POST)
	introspectionMethod = "",
	# introspectionURL: String = ""   Eg: introspectionURL_example
	# The HTTP URL of the introspection call
	introspectionURL = "",
	# introspectionParams: String = ""   Eg: introspectionParams_example
	# The parameters of the introspection call
	introspectionParams = "",
	# requiredRootField: String = ""   Eg: requiredRootField_example
	# Required response params
	requiredRootField = "",
	# enableMFA: bool   Eg: true
	# Whether this network uses MFA
	enableMFA = null,
	# sizeMFA: int   Eg: 56
	# Size of the MFA token
	sizeMFA = null,
	# shelfLifeMFA: int   Eg: 56
	# Shelf life (seconds) of the MFA token
	shelfLifeMFA = null,
	# oauthTokenURL: String = ""   Eg: oauthTokenURL_example
	# OAuth token endpoint URL
	oauthTokenURL = "",
	# oauthPrivateKey: String   Eg: BINARY_DATA_HERE
	# OAuth private key file (multipart)
	oauthPrivateKey = null,
	# oauthPublicKey: String   Eg: BINARY_DATA_HERE
	# OAuth public key file (multipart)
	oauthPublicKey = null,
	# oauthClientId: String = ""   Eg: oauthClientId_example
	# OAuth client id
	oauthClientId = "",
	# oauthSecretKey: String = ""   Eg: oauthSecretKey_example
	# OAuth secret key
	oauthSecretKey = "",
	# body: String   Eg: body_example
	body = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/thirdparty/network/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["networkUID"] = networkUID
	bzz_query["name"] = name
	bzz_query["description"] = description
	bzz_query["enableIntrospection"] = enableIntrospection
	bzz_query["introspectionMethod"] = introspectionMethod
	bzz_query["introspectionURL"] = introspectionURL
	bzz_query["introspectionParams"] = introspectionParams
	bzz_query["requiredRootField"] = requiredRootField
	bzz_query["enableMFA"] = enableMFA
	bzz_query["sizeMFA"] = sizeMFA
	bzz_query["shelfLifeMFA"] = shelfLifeMFA
	bzz_query["oauthTokenURL"] = oauthTokenURL
	bzz_query["oauthPrivateKey"] = oauthPrivateKey
	bzz_query["oauthPublicKey"] = oauthPublicKey
	bzz_query["oauthClientId"] = oauthClientId
	bzz_query["oauthSecretKey"] = oauthSecretKey

	var bzz_body = null
	bzz_body = body

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ThirdPartyNetworkResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_network_threaded(
	# accountId: float   Eg: 789
	# The account id making the request
	accountId: float,
	# networkUID: String = ""   Eg: networkUID_example
	# The unique identifier for the third party network defined by Sirqul
	networkUID: String,
	# name: String = ""   Eg: name_example
	# The name of the network
	name = "",
	# description: String = ""   Eg: description_example
	# The description of the network
	description = "",
	# enableIntrospection: bool   Eg: true
	# Whether the network uses introspection calls
	enableIntrospection = null,
	# introspectionMethod: String = ""   Eg: introspectionMethod_example
	# HTTP method to use for introspection calls (e.g., GET, POST)
	introspectionMethod = "",
	# introspectionURL: String = ""   Eg: introspectionURL_example
	# The HTTP URL of the introspection call
	introspectionURL = "",
	# introspectionParams: String = ""   Eg: introspectionParams_example
	# The parameters of the introspection call
	introspectionParams = "",
	# requiredRootField: String = ""   Eg: requiredRootField_example
	# Required response params
	requiredRootField = "",
	# enableMFA: bool   Eg: true
	# Whether this network uses MFA
	enableMFA = null,
	# sizeMFA: int   Eg: 56
	# Size of the MFA token
	sizeMFA = null,
	# shelfLifeMFA: int   Eg: 56
	# Shelf life (seconds) of the MFA token
	shelfLifeMFA = null,
	# oauthTokenURL: String = ""   Eg: oauthTokenURL_example
	# OAuth token endpoint URL
	oauthTokenURL = "",
	# oauthPrivateKey: String   Eg: BINARY_DATA_HERE
	# OAuth private key file (multipart)
	oauthPrivateKey = null,
	# oauthPublicKey: String   Eg: BINARY_DATA_HERE
	# OAuth public key file (multipart)
	oauthPublicKey = null,
	# oauthClientId: String = ""   Eg: oauthClientId_example
	# OAuth client id
	oauthClientId = "",
	# oauthSecretKey: String = ""   Eg: oauthSecretKey_example
	# OAuth secret key
	oauthSecretKey = "",
	# body: String   Eg: body_example
	body = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_network")
	bzz_callable.bind(
		accountId,
		networkUID,
		name,
		description,
		enableIntrospection,
		introspectionMethod,
		introspectionURL,
		introspectionParams,
		requiredRootField,
		enableMFA,
		sizeMFA,
		shelfLifeMFA,
		oauthTokenURL,
		oauthPrivateKey,
		oauthPublicKey,
		oauthClientId,
		oauthSecretKey,
		body,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


