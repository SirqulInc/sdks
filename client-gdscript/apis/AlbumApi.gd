extends ApiBee
class_name AlbumApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API AlbumApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "AlbumApi"


# Operation addAlbumCollection → POST /api/{version}/album/create
# Create Album
#
# Create an Album.
func add_album_collection(
	# version: float   Eg: 3.16
	version: float,
	# title: String = ""   Eg: title_example
	# the title of the album
	title: String,
	# coverAssetNullable: bool   Eg: true
	# determines whether the cover image of the album can be empty, else will use the user's profile picture as the cover image
	coverAssetNullable: bool,
	# includeCoverInAssetList: bool   Eg: true
	# determines whether the cover image should be added to the album asset list
	includeCoverInAssetList: bool,
	# publicRead: bool   Eg: true
	# determines whether the album's participants has read permissions
	publicRead: bool,
	# publicWrite: bool   Eg: true
	# determines whether the album's participants has write permissions
	publicWrite: bool,
	# publicDelete: bool   Eg: true
	# determines whether the album's participants has delete permissions
	publicDelete: bool,
	# publicAdd: bool   Eg: true
	# determines whether the album's participants has add permissions
	publicAdd: bool,
	# anonymous: bool   Eg: true
	# determines whether the album is posted anonymously
	anonymous: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# assetsToAdd: String = ""   Eg: assetsToAdd_example
	# Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)
	assetsToAdd = "",
	# media: String   Eg: BINARY_DATA_HERE
	# a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)
	media = null,
	# mediaURL: String = ""   Eg: mediaURL_example
	# this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)
	mediaURL = "",
	# assetId: float   Eg: 789
	# The asset ID to set the album cover image
	assetId = null,
	# attachedMedia: String   Eg: BINARY_DATA_HERE
	# a MultipartFile containing an asset that the \"media\" file references. Example to upload a video: the \"media\" file should contain a screen capture of the video, and the \"attachedMedia\" should be the actual video.
	attachedMedia = null,
	# attachedMediaURL: String = ""   Eg: attachedMediaURL_example
	# this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc)
	attachedMediaURL = "",
	# startDate: float   Eg: 789
	# the start date
	startDate = null,
	# endDate: float   Eg: 789
	# the end date
	endDate = null,
	# tags: String = ""   Eg: tags_example
	# the tags
	tags = "",
	# description: String = ""   Eg: description_example
	# the description of the album
	description = "",
	# albumType: String = ""   Eg: albumType_example
	# a custom field used for aggregation and searching
	albumType = "",
	# albumTypeId: float   Eg: 789
	# a custom indexed number used for aggregation and searching
	albumTypeId = null,
	# subType: String = ""   Eg: subType_example
	# a custom string field used for aggregation and searching
	subType = "",
	# latitude: int   Eg: 1.2
	# latitude used to update the album's location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the album's location
	longitude = null,
	# locationDescription: String = ""   Eg: locationDescription_example
	# the location description
	locationDescription = "",
	# visibility: String = ""   Eg: visibility_example
	# the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
	visibility = "",
	# gameType: String = ""   Eg: gameType_example
	# @deprecated, use the appKey
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# cellPhone: String = ""   Eg: cellPhone_example
	# the cell phone number
	cellPhone = "",
	# streetAddress: String = ""   Eg: streetAddress_example
	# The street address of the location
	streetAddress = "",
	# streetAddress2: String = ""   Eg: streetAddress2_example
	# Additional address information (such as a suite number, floor number, building name, or PO Box)
	streetAddress2 = "",
	# city: String = ""   Eg: city_example
	# The city of the location
	city = "",
	# state: String = ""   Eg: state_example
	# The state of of the location
	state = "",
	# postalCode: String = ""   Eg: postalCode_example
	# The postal code of the location
	postalCode = "",
	# fullAddress: String = ""   Eg: fullAddress_example
	# The full address of the location which should include the street address, city, state, and postal code
	fullAddress = "",
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# comma separated category ids string associated with the Album
	categoryIds = "",
	# categoryFilterIds: String = ""   Eg: categoryFilterIds_example
	# comma separated filter ids string associated with the Album
	categoryFilterIds = "",
	# audienceIds: String = ""   Eg: audienceIds_example
	# comma separated audience ids string associated with the album
	audienceIds = "",
	# includeAllAppUsersAsMembers: bool   Eg: true
	# determines whether to include all app users as members (only admins of the app can do this)
	includeAllAppUsersAsMembers = null,
	# includeAudiencesAsMembers: bool   Eg: true
	# determines whether to include all users of the audiences as members (only admins of the app can do this)
	includeAudiencesAsMembers = null,
	# audienceOperator: String = ""   Eg: audienceOperator_example
	# determines whether to use ands or ors when using the audience list to add users
	audienceOperator = "",
	# approvalStatus: String = ""   Eg: approvalStatus_example
	# The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
	approvalStatus = "",
	# linkedObjectType: String = ""   Eg: linkedObjectType_example
	# sets a linked object so that it can be returned as part of the album response
	linkedObjectType = "",
	# linkedObjectId: float   Eg: 789
	# sets a linked object id so that it can be returned as part of the album response
	linkedObjectId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/album/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["title"] = title
	bzz_query["assetsToAdd"] = assetsToAdd
	bzz_query["media"] = media
	bzz_query["mediaURL"] = mediaURL
	bzz_query["assetId"] = assetId
	bzz_query["attachedMedia"] = attachedMedia
	bzz_query["attachedMediaURL"] = attachedMediaURL
	bzz_query["coverAssetNullable"] = coverAssetNullable
	bzz_query["includeCoverInAssetList"] = includeCoverInAssetList
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["tags"] = tags
	bzz_query["description"] = description
	bzz_query["albumType"] = albumType
	bzz_query["albumTypeId"] = albumTypeId
	bzz_query["subType"] = subType
	bzz_query["publicRead"] = publicRead
	bzz_query["publicWrite"] = publicWrite
	bzz_query["publicDelete"] = publicDelete
	bzz_query["publicAdd"] = publicAdd
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["locationDescription"] = locationDescription
	bzz_query["visibility"] = visibility
	bzz_query["gameType"] = gameType
	bzz_query["appKey"] = appKey
	bzz_query["cellPhone"] = cellPhone
	bzz_query["streetAddress"] = streetAddress
	bzz_query["streetAddress2"] = streetAddress2
	bzz_query["city"] = city
	bzz_query["state"] = state
	bzz_query["postalCode"] = postalCode
	bzz_query["fullAddress"] = fullAddress
	bzz_query["anonymous"] = anonymous
	bzz_query["metaData"] = metaData
	bzz_query["categoryIds"] = categoryIds
	bzz_query["categoryFilterIds"] = categoryFilterIds
	bzz_query["audienceIds"] = audienceIds
	bzz_query["includeAllAppUsersAsMembers"] = includeAllAppUsersAsMembers
	bzz_query["includeAudiencesAsMembers"] = includeAudiencesAsMembers
	bzz_query["audienceOperator"] = audienceOperator
	bzz_query["approvalStatus"] = approvalStatus
	bzz_query["linkedObjectType"] = linkedObjectType
	bzz_query["linkedObjectId"] = linkedObjectId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SearchResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func add_album_collection_threaded(
	# version: float   Eg: 3.16
	version: float,
	# title: String = ""   Eg: title_example
	# the title of the album
	title: String,
	# coverAssetNullable: bool   Eg: true
	# determines whether the cover image of the album can be empty, else will use the user's profile picture as the cover image
	coverAssetNullable: bool,
	# includeCoverInAssetList: bool   Eg: true
	# determines whether the cover image should be added to the album asset list
	includeCoverInAssetList: bool,
	# publicRead: bool   Eg: true
	# determines whether the album's participants has read permissions
	publicRead: bool,
	# publicWrite: bool   Eg: true
	# determines whether the album's participants has write permissions
	publicWrite: bool,
	# publicDelete: bool   Eg: true
	# determines whether the album's participants has delete permissions
	publicDelete: bool,
	# publicAdd: bool   Eg: true
	# determines whether the album's participants has add permissions
	publicAdd: bool,
	# anonymous: bool   Eg: true
	# determines whether the album is posted anonymously
	anonymous: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# assetsToAdd: String = ""   Eg: assetsToAdd_example
	# Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)
	assetsToAdd = "",
	# media: String   Eg: BINARY_DATA_HERE
	# a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)
	media = null,
	# mediaURL: String = ""   Eg: mediaURL_example
	# this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)
	mediaURL = "",
	# assetId: float   Eg: 789
	# The asset ID to set the album cover image
	assetId = null,
	# attachedMedia: String   Eg: BINARY_DATA_HERE
	# a MultipartFile containing an asset that the \"media\" file references. Example to upload a video: the \"media\" file should contain a screen capture of the video, and the \"attachedMedia\" should be the actual video.
	attachedMedia = null,
	# attachedMediaURL: String = ""   Eg: attachedMediaURL_example
	# this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc)
	attachedMediaURL = "",
	# startDate: float   Eg: 789
	# the start date
	startDate = null,
	# endDate: float   Eg: 789
	# the end date
	endDate = null,
	# tags: String = ""   Eg: tags_example
	# the tags
	tags = "",
	# description: String = ""   Eg: description_example
	# the description of the album
	description = "",
	# albumType: String = ""   Eg: albumType_example
	# a custom field used for aggregation and searching
	albumType = "",
	# albumTypeId: float   Eg: 789
	# a custom indexed number used for aggregation and searching
	albumTypeId = null,
	# subType: String = ""   Eg: subType_example
	# a custom string field used for aggregation and searching
	subType = "",
	# latitude: int   Eg: 1.2
	# latitude used to update the album's location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the album's location
	longitude = null,
	# locationDescription: String = ""   Eg: locationDescription_example
	# the location description
	locationDescription = "",
	# visibility: String = ""   Eg: visibility_example
	# the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
	visibility = "",
	# gameType: String = ""   Eg: gameType_example
	# @deprecated, use the appKey
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# cellPhone: String = ""   Eg: cellPhone_example
	# the cell phone number
	cellPhone = "",
	# streetAddress: String = ""   Eg: streetAddress_example
	# The street address of the location
	streetAddress = "",
	# streetAddress2: String = ""   Eg: streetAddress2_example
	# Additional address information (such as a suite number, floor number, building name, or PO Box)
	streetAddress2 = "",
	# city: String = ""   Eg: city_example
	# The city of the location
	city = "",
	# state: String = ""   Eg: state_example
	# The state of of the location
	state = "",
	# postalCode: String = ""   Eg: postalCode_example
	# The postal code of the location
	postalCode = "",
	# fullAddress: String = ""   Eg: fullAddress_example
	# The full address of the location which should include the street address, city, state, and postal code
	fullAddress = "",
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# comma separated category ids string associated with the Album
	categoryIds = "",
	# categoryFilterIds: String = ""   Eg: categoryFilterIds_example
	# comma separated filter ids string associated with the Album
	categoryFilterIds = "",
	# audienceIds: String = ""   Eg: audienceIds_example
	# comma separated audience ids string associated with the album
	audienceIds = "",
	# includeAllAppUsersAsMembers: bool   Eg: true
	# determines whether to include all app users as members (only admins of the app can do this)
	includeAllAppUsersAsMembers = null,
	# includeAudiencesAsMembers: bool   Eg: true
	# determines whether to include all users of the audiences as members (only admins of the app can do this)
	includeAudiencesAsMembers = null,
	# audienceOperator: String = ""   Eg: audienceOperator_example
	# determines whether to use ands or ors when using the audience list to add users
	audienceOperator = "",
	# approvalStatus: String = ""   Eg: approvalStatus_example
	# The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
	approvalStatus = "",
	# linkedObjectType: String = ""   Eg: linkedObjectType_example
	# sets a linked object so that it can be returned as part of the album response
	linkedObjectType = "",
	# linkedObjectId: float   Eg: 789
	# sets a linked object id so that it can be returned as part of the album response
	linkedObjectId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "add_album_collection")
	bzz_callable.bind(
		version,
		title,
		coverAssetNullable,
		includeCoverInAssetList,
		publicRead,
		publicWrite,
		publicDelete,
		publicAdd,
		anonymous,
		deviceId,
		accountId,
		assetsToAdd,
		media,
		mediaURL,
		assetId,
		attachedMedia,
		attachedMediaURL,
		startDate,
		endDate,
		tags,
		description,
		albumType,
		albumTypeId,
		subType,
		latitude,
		longitude,
		locationDescription,
		visibility,
		gameType,
		appKey,
		cellPhone,
		streetAddress,
		streetAddress2,
		city,
		state,
		postalCode,
		fullAddress,
		metaData,
		categoryIds,
		categoryFilterIds,
		audienceIds,
		includeAllAppUsersAsMembers,
		includeAudiencesAsMembers,
		audienceOperator,
		approvalStatus,
		linkedObjectType,
		linkedObjectId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation addAlbumUsers → POST /api/{version}/album/user/add
# Add Album Users
#
# Add users to an album as participants.
func add_album_users(
	# version: float   Eg: 3.16
	version: float,
	# albumId: float   Eg: 789
	# the album ID
	albumId: float,
	# includeFriendGroup: bool   Eg: true
	# determines whether to include all friends as participants
	includeFriendGroup: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# read: bool   Eg: true
	# determines whether the users being added have read permissions
	read = null,
	# write: bool   Eg: true
	# determines whether the users being added have write permissions
	write = null,
	# delete: bool   Eg: true
	# determines whether the users being added have delete permissions
	delete = null,
	# add: bool   Eg: true
	# determines whether the users being added have add permissions
	add = null,
	# connections: String = ""   Eg: connections_example
	# comma separated list of connection IDs
	connections = "",
	# connectionGroups: String = ""   Eg: connectionGroups_example
	# comma separated list of connection group IDs
	connectionGroups = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/album/user/add".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["albumId"] = albumId
	bzz_query["read"] = read
	bzz_query["write"] = write
	bzz_query["delete"] = delete
	bzz_query["add"] = add
	bzz_query["connections"] = connections
	bzz_query["connectionGroups"] = connectionGroups
	bzz_query["includeFriendGroup"] = includeFriendGroup

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func add_album_users_threaded(
	# version: float   Eg: 3.16
	version: float,
	# albumId: float   Eg: 789
	# the album ID
	albumId: float,
	# includeFriendGroup: bool   Eg: true
	# determines whether to include all friends as participants
	includeFriendGroup: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# read: bool   Eg: true
	# determines whether the users being added have read permissions
	read = null,
	# write: bool   Eg: true
	# determines whether the users being added have write permissions
	write = null,
	# delete: bool   Eg: true
	# determines whether the users being added have delete permissions
	delete = null,
	# add: bool   Eg: true
	# determines whether the users being added have add permissions
	add = null,
	# connections: String = ""   Eg: connections_example
	# comma separated list of connection IDs
	connections = "",
	# connectionGroups: String = ""   Eg: connectionGroups_example
	# comma separated list of connection group IDs
	connectionGroups = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "add_album_users")
	bzz_callable.bind(
		version,
		albumId,
		includeFriendGroup,
		deviceId,
		accountId,
		read,
		write,
		delete,
		add,
		connections,
		connectionGroups,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation approveAlbum → POST /api/{version}/album/approve
# Approve Album
#
# Sets the approval status of an Album.
func approve_album(
	# version: float   Eg: 3.16
	version: float,
	# albumId: float   Eg: 789
	# The ID of the album
	albumId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# A unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account ID of the user (deviceId or accountId required)
	accountId = null,
	# approvalStatus: String = ""   Eg: approvalStatus_example
	# The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
	approvalStatus = "",
	# verified: bool   Eg: true
	# Sets whether the album should be marked as \"verified\"
	verified = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/album/approve".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["albumId"] = albumId
	bzz_query["approvalStatus"] = approvalStatus
	bzz_query["verified"] = verified

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func approve_album_threaded(
	# version: float   Eg: 3.16
	version: float,
	# albumId: float   Eg: 789
	# The ID of the album
	albumId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# A unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account ID of the user (deviceId or accountId required)
	accountId = null,
	# approvalStatus: String = ""   Eg: approvalStatus_example
	# The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
	approvalStatus = "",
	# verified: bool   Eg: true
	# Sets whether the album should be marked as \"verified\"
	verified = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "approve_album")
	bzz_callable.bind(
		version,
		albumId,
		deviceId,
		accountId,
		approvalStatus,
		verified,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getAlbumCollection → GET /api/{version}/album/get
#  Get Album
#
# Get an Album.
func get_album_collection(
	# version: float   Eg: 3.16
	version: float,
	# returnNulls: bool   Eg: true
	# This parameter is deprecated.
	returnNulls: bool,
	# albumId: float   Eg: 789
	# the album to look up
	albumId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# likePreviewSize: int   Eg: 56
	# returns the last X likes. To search on and paginate the remaining likes - please use the \"/like/search\"Â endpoint.
	likePreviewSize = null,
	# assetPreviewSize: int   Eg: 56
	# returns the first X assets. To search on and paginate the remaining assets - please use the \"/assets/search\"Â endpoint.
	assetPreviewSize = null,
	# notePreviewSize: int   Eg: 56
	# returns the last X notes. To search on and paginate the remaining notes - please use the \"/note/search\" endpoint.
	notePreviewSize = null,
	# connectionPreviewSize: int   Eg: 56
	# returns the first X users/connections. To search on and paginate the remaining connections - please use the \"/permissions/search\" endpoint.
	connectionPreviewSize = null,
	# audiencePreviewSize: int   Eg: 56
	# returns the first X audiences. To search on and paginate the remaining audiences - please use the \"/audience/search\" endpoint.
	audiencePreviewSize = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/album/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["returnNulls"] = returnNulls
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["albumId"] = albumId
	bzz_query["likePreviewSize"] = likePreviewSize
	bzz_query["assetPreviewSize"] = assetPreviewSize
	bzz_query["notePreviewSize"] = notePreviewSize
	bzz_query["connectionPreviewSize"] = connectionPreviewSize
	bzz_query["audiencePreviewSize"] = audiencePreviewSize

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AlbumFullResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_album_collection_threaded(
	# version: float   Eg: 3.16
	version: float,
	# returnNulls: bool   Eg: true
	# This parameter is deprecated.
	returnNulls: bool,
	# albumId: float   Eg: 789
	# the album to look up
	albumId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# likePreviewSize: int   Eg: 56
	# returns the last X likes. To search on and paginate the remaining likes - please use the \"/like/search\"Â endpoint.
	likePreviewSize = null,
	# assetPreviewSize: int   Eg: 56
	# returns the first X assets. To search on and paginate the remaining assets - please use the \"/assets/search\"Â endpoint.
	assetPreviewSize = null,
	# notePreviewSize: int   Eg: 56
	# returns the last X notes. To search on and paginate the remaining notes - please use the \"/note/search\" endpoint.
	notePreviewSize = null,
	# connectionPreviewSize: int   Eg: 56
	# returns the first X users/connections. To search on and paginate the remaining connections - please use the \"/permissions/search\" endpoint.
	connectionPreviewSize = null,
	# audiencePreviewSize: int   Eg: 56
	# returns the first X audiences. To search on and paginate the remaining audiences - please use the \"/audience/search\" endpoint.
	audiencePreviewSize = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_album_collection")
	bzz_callable.bind(
		version,
		returnNulls,
		albumId,
		deviceId,
		accountId,
		likePreviewSize,
		assetPreviewSize,
		notePreviewSize,
		connectionPreviewSize,
		audiencePreviewSize,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation leaveAlbum → POST /api/{version}/album/user/leave
# Leave Album
#
#  Allows a user to leave an album (they are no longer considered a participant). The album creator cannot leave their own albums.
func leave_album(
	# version: float   Eg: 3.16
	version: float,
	# albumId: float   Eg: 789
	# the album ID
	albumId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/album/user/leave".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["albumId"] = albumId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func leave_album_threaded(
	# version: float   Eg: 3.16
	version: float,
	# albumId: float   Eg: 789
	# the album ID
	albumId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "leave_album")
	bzz_callable.bind(
		version,
		albumId,
		deviceId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation removeAlbum → POST /api/{version}/album/delete
# Delete Album
#
# Deletes an Album
func remove_album(
	# version: float   Eg: 3.16
	version: float,
	# albumId: float   Eg: 789
	# the album ID to delete
	albumId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/album/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["albumId"] = albumId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func remove_album_threaded(
	# version: float   Eg: 3.16
	version: float,
	# albumId: float   Eg: 789
	# the album ID to delete
	albumId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "remove_album")
	bzz_callable.bind(
		version,
		albumId,
		deviceId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation removeAlbumUsers → POST /api/{version}/album/user/delete
# Remove Album Users
#
# Remove participants of an album.
func remove_album_users(
	# version: float   Eg: 3.16
	version: float,
	# albumId: float   Eg: 789
	# the album ID
	albumId: float,
	# removeFriendGroup: bool   Eg: true
	# remove friend group
	removeFriendGroup: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# connections: String = ""   Eg: connections_example
	# comma separated list of connection IDs
	connections = "",
	# connectionGroups: String = ""   Eg: connectionGroups_example
	# comma separated list of connection group IDs
	connectionGroups = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/album/user/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["albumId"] = albumId
	bzz_query["connections"] = connections
	bzz_query["connectionGroups"] = connectionGroups
	bzz_query["removeFriendGroup"] = removeFriendGroup

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func remove_album_users_threaded(
	# version: float   Eg: 3.16
	version: float,
	# albumId: float   Eg: 789
	# the album ID
	albumId: float,
	# removeFriendGroup: bool   Eg: true
	# remove friend group
	removeFriendGroup: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# connections: String = ""   Eg: connections_example
	# comma separated list of connection IDs
	connections = "",
	# connectionGroups: String = ""   Eg: connectionGroups_example
	# comma separated list of connection group IDs
	connectionGroups = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "remove_album_users")
	bzz_callable.bind(
		version,
		albumId,
		removeFriendGroup,
		deviceId,
		accountId,
		connections,
		connectionGroups,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchAlbums → GET /api/{version}/album/search
# Search Albums
#
# Searches on Albums.
func search_albums(
	# version: float   Eg: 3.16
	version: float,
	# filter: String = ""   Eg: filter_example
	# a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user's followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. 
	filter: String,
	# albumTypeId: float   Eg: 789
	# id of custom albumType
	albumTypeId: float,
	# subType: String = ""   Eg: subType_example
	# filter albums with this album sub type
	subType: String,
	# includeInactive: bool   Eg: true
	# determines whether to return inactive albums
	includeInactive: bool,
	# sortField: String = ""   Eg: sortField_example
	# the field to sort by. See AlbumApiMap
	sortField: String,
	# descending: bool   Eg: true
	# determines whether the sorted list is in descending or ascending order
	descending: bool,
	# start: int   Eg: 56
	# the start index for pagination
	start: int,
	# limit: int   Eg: 56
	# the limit for pagination (There is a hard limit of 100)
	limit: int,
	# some_range: int   Eg: 1.2
	# the maximum range the album can be from the center (used when sortField=ALBUM_DISTANCE)
	some_range: int,
	# includeLiked: bool   Eg: true
	# returns whether or not the current logged in user has liked the album
	includeLiked: bool,
	# includeFavorited: bool   Eg: true
	# returns whether or not the current logged in user has favorited the album
	includeFavorited: bool,
	# includePermissions: bool   Eg: true
	# returns permission details on whether they have read/write/delete permissions etc (client app probably doesn't need this)
	includePermissions: bool,
	# likePreviewSize: int   Eg: 56
	# returns the last X likes
	likePreviewSize: int,
	# assetPreviewSize: int   Eg: 56
	# returns the first X assets
	assetPreviewSize: int,
	# notePreviewSize: int   Eg: 56
	# returns the last X notes
	notePreviewSize: int,
	# connectionPreviewSize: int   Eg: 56
	# returns the first X users/connections
	connectionPreviewSize: int,
	# audiencePreviewSize: int   Eg: 56
	# returns the first X audiences. To search on and paginate the remaining audiences, please use the \"/audience/search\" endpoint.
	audiencePreviewSize: int,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# connectionAccountId: float   Eg: 789
	# the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited.
	connectionAccountId = null,
	# ownerId: float   Eg: 789
	# search on albums that have been created by this account (that the user has permissions to)
	ownerId = null,
	# albumIds: String = ""   Eg: albumIds_example
	# search on album within a comma separated list of album IDs (this does not work with sortField=ALBUM_DISTANCE, or when stackSearch=true)
	albumIds = "",
	# excludeAlbumIds: String = ""   Eg: excludeAlbumIds_example
	# Only for CLOUDINDEX mode, exclude albums with ids matching this list
	excludeAlbumIds = "",
	# mediaId: float   Eg: 789
	# search on albums that are in a particular media offering
	mediaId = null,
	# keyword: String = ""   Eg: keyword_example
	# keyword search string
	keyword = "",
	# albumType: String = ""   Eg: albumType_example
	# filter albums with this album type
	albumType = "",
	# limitPerAlbumType: int   Eg: 56
	# When using multiple album types this sets a per-album-type limit (used with cloud index mode)
	limitPerAlbumType = null,
	# dateCreated: float   Eg: 789
	# return items that have been created before this date (time-stamp in milliseconds)
	dateCreated = null,
	# updatedSince: float   Eg: 789
	# return items that have been updated since this date (time-stamp in milliseconds)
	updatedSince = null,
	# updatedBefore: float   Eg: 789
	# return items that have been updated before this date (time-stamp in milliseconds)
	updatedBefore = null,
	# createdSince: float   Eg: 789
	# return items that have been created since this date (time-stamp in milliseconds)
	createdSince = null,
	# createdBefore: float   Eg: 789
	# return items that have been created before this date (time-stamp in milliseconds)
	createdBefore = null,
	# startedSince: float   Eg: 789
	# return items that have been started since this date (time-stamp in milliseconds)
	startedSince = null,
	# startedBefore: float   Eg: 789
	# return items that have been started before this date (time-stamp in milliseconds)
	startedBefore = null,
	# endedSince: float   Eg: 789
	# return items that have been ended since this date (time-stamp in milliseconds)
	endedSince = null,
	# endedBefore: float   Eg: 789
	# return items that have been ended before this date (time-stamp in milliseconds)
	endedBefore = null,
	# latitude: int   Eg: 1.2
	# the latitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)
	latitude = null,
	# longitude: int   Eg: 1.2
	# the longitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)
	longitude = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to.
	appKey = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# return results with categories matching this list
	categoryIds = "",
	# categoryFilterIds: String = ""   Eg: categoryFilterIds_example
	# return results with filters matching this list
	categoryFilterIds = "",
	# audienceIds: String = ""   Eg: audienceIds_example
	# return results with audiences matching this list
	audienceIds = "",
	# excludeAudienceIds: String = ""   Eg: excludeAudienceIds_example
	# exclude audiences with ids matching this list
	excludeAudienceIds = "",
	# includeCompletable: bool   Eg: true
	# returns the user's completable object for the album if it exists
	includeCompletable = null,
	# includeRating: bool   Eg: true
	# returns the user's rating for the album if it exists
	includeRating = null,
	# searchMode: String = ""   Eg: searchMode_example
	# The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default.
	searchMode = "",
	# stackSearch: bool   Eg: true
	# groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize
	stackSearch = null,
	# stackWindowSize: int   Eg: 56
	# size of each window for each stack
	stackWindowSize = null,
	# minStackPerPage: int   Eg: 56
	# The minimum number of stacks returned in a response. For example,  first call, minStackPerPage = 20, the API will return at least 20 results
	minStackPerPage = null,
	# stackPaginationIdentifier: String = ""   Eg: stackPaginationIdentifier_example
	# this is used to tell the system where it left off on the previous previous page, since we can't use start/limit for stackSearch
	stackPaginationIdentifier = "",
	# stackDetails: bool   Eg: true
	# set this to true when making the call to view the albums in the stack
	stackDetails = null,
	# flagCountMinimum: float   Eg: 789
	# Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)
	flagCountMinimum = null,
	# removeFlaggedContent: bool = true   Eg: true
	# return items that have flagCount >= flagThreshold (controls removal of flagged content)
	removeFlaggedContent = true,
	# verifiedFilter: bool   Eg: true
	# setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both)
	verifiedFilter = null,
	# linkedObjectType: String = ""   Eg: linkedObjectType_example
	# filter results by the linkedObjectType
	linkedObjectType = "",
	# linkedObjectId: float   Eg: 789
	# filter results by the linkedObjectId
	linkedObjectId = null,
	# orderAudienceId: float   Eg: 789
	# determines whether to use the order assigned via the /album/order/* api (which is tied to an audience)
	orderAudienceId = null,
	# ignoreDefaultAppFilter: bool   Eg: true
	# if true, ignore the application's default app filter when searching
	ignoreDefaultAppFilter = null,
	# searchExpression: String = ""   Eg: searchExpression_example
	# Advanced search expression to be used by the server
	searchExpression = "",
	# generateAlbums: bool   Eg: true
	# If true and results are empty, attempt to generate albums via templates
	generateAlbums = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/album/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["connectionAccountId"] = connectionAccountId
	bzz_query["ownerId"] = ownerId
	bzz_query["albumIds"] = albumIds
	bzz_query["excludeAlbumIds"] = excludeAlbumIds
	bzz_query["mediaId"] = mediaId
	bzz_query["keyword"] = keyword
	bzz_query["filter"] = filter
	bzz_query["albumType"] = albumType
	bzz_query["albumTypeId"] = albumTypeId
	bzz_query["subType"] = subType
	bzz_query["includeInactive"] = includeInactive
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["limitPerAlbumType"] = limitPerAlbumType
	bzz_query["dateCreated"] = dateCreated
	bzz_query["updatedSince"] = updatedSince
	bzz_query["updatedBefore"] = updatedBefore
	bzz_query["createdSince"] = createdSince
	bzz_query["createdBefore"] = createdBefore
	bzz_query["startedSince"] = startedSince
	bzz_query["startedBefore"] = startedBefore
	bzz_query["endedSince"] = endedSince
	bzz_query["endedBefore"] = endedBefore
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["range"] = some_range
	bzz_query["appKey"] = appKey
	bzz_query["categoryIds"] = categoryIds
	bzz_query["categoryFilterIds"] = categoryFilterIds
	bzz_query["audienceIds"] = audienceIds
	bzz_query["excludeAudienceIds"] = excludeAudienceIds
	bzz_query["includeLiked"] = includeLiked
	bzz_query["includeFavorited"] = includeFavorited
	bzz_query["includePermissions"] = includePermissions
	bzz_query["includeCompletable"] = includeCompletable
	bzz_query["includeRating"] = includeRating
	bzz_query["likePreviewSize"] = likePreviewSize
	bzz_query["assetPreviewSize"] = assetPreviewSize
	bzz_query["notePreviewSize"] = notePreviewSize
	bzz_query["connectionPreviewSize"] = connectionPreviewSize
	bzz_query["audiencePreviewSize"] = audiencePreviewSize
	bzz_query["searchMode"] = searchMode
	bzz_query["stackSearch"] = stackSearch
	bzz_query["stackWindowSize"] = stackWindowSize
	bzz_query["minStackPerPage"] = minStackPerPage
	bzz_query["stackPaginationIdentifier"] = stackPaginationIdentifier
	bzz_query["stackDetails"] = stackDetails
	bzz_query["flagCountMinimum"] = flagCountMinimum
	bzz_query["removeFlaggedContent"] = removeFlaggedContent
	bzz_query["verifiedFilter"] = verifiedFilter
	bzz_query["linkedObjectType"] = linkedObjectType
	bzz_query["linkedObjectId"] = linkedObjectId
	bzz_query["orderAudienceId"] = orderAudienceId
	bzz_query["ignoreDefaultAppFilter"] = ignoreDefaultAppFilter
	bzz_query["searchExpression"] = searchExpression
	bzz_query["generateAlbums"] = generateAlbums

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AlbumFullResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_albums_threaded(
	# version: float   Eg: 3.16
	version: float,
	# filter: String = ""   Eg: filter_example
	# a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user's followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. 
	filter: String,
	# albumTypeId: float   Eg: 789
	# id of custom albumType
	albumTypeId: float,
	# subType: String = ""   Eg: subType_example
	# filter albums with this album sub type
	subType: String,
	# includeInactive: bool   Eg: true
	# determines whether to return inactive albums
	includeInactive: bool,
	# sortField: String = ""   Eg: sortField_example
	# the field to sort by. See AlbumApiMap
	sortField: String,
	# descending: bool   Eg: true
	# determines whether the sorted list is in descending or ascending order
	descending: bool,
	# start: int   Eg: 56
	# the start index for pagination
	start: int,
	# limit: int   Eg: 56
	# the limit for pagination (There is a hard limit of 100)
	limit: int,
	# some_range: int   Eg: 1.2
	# the maximum range the album can be from the center (used when sortField=ALBUM_DISTANCE)
	some_range: int,
	# includeLiked: bool   Eg: true
	# returns whether or not the current logged in user has liked the album
	includeLiked: bool,
	# includeFavorited: bool   Eg: true
	# returns whether or not the current logged in user has favorited the album
	includeFavorited: bool,
	# includePermissions: bool   Eg: true
	# returns permission details on whether they have read/write/delete permissions etc (client app probably doesn't need this)
	includePermissions: bool,
	# likePreviewSize: int   Eg: 56
	# returns the last X likes
	likePreviewSize: int,
	# assetPreviewSize: int   Eg: 56
	# returns the first X assets
	assetPreviewSize: int,
	# notePreviewSize: int   Eg: 56
	# returns the last X notes
	notePreviewSize: int,
	# connectionPreviewSize: int   Eg: 56
	# returns the first X users/connections
	connectionPreviewSize: int,
	# audiencePreviewSize: int   Eg: 56
	# returns the first X audiences. To search on and paginate the remaining audiences, please use the \"/audience/search\" endpoint.
	audiencePreviewSize: int,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# connectionAccountId: float   Eg: 789
	# the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited.
	connectionAccountId = null,
	# ownerId: float   Eg: 789
	# search on albums that have been created by this account (that the user has permissions to)
	ownerId = null,
	# albumIds: String = ""   Eg: albumIds_example
	# search on album within a comma separated list of album IDs (this does not work with sortField=ALBUM_DISTANCE, or when stackSearch=true)
	albumIds = "",
	# excludeAlbumIds: String = ""   Eg: excludeAlbumIds_example
	# Only for CLOUDINDEX mode, exclude albums with ids matching this list
	excludeAlbumIds = "",
	# mediaId: float   Eg: 789
	# search on albums that are in a particular media offering
	mediaId = null,
	# keyword: String = ""   Eg: keyword_example
	# keyword search string
	keyword = "",
	# albumType: String = ""   Eg: albumType_example
	# filter albums with this album type
	albumType = "",
	# limitPerAlbumType: int   Eg: 56
	# When using multiple album types this sets a per-album-type limit (used with cloud index mode)
	limitPerAlbumType = null,
	# dateCreated: float   Eg: 789
	# return items that have been created before this date (time-stamp in milliseconds)
	dateCreated = null,
	# updatedSince: float   Eg: 789
	# return items that have been updated since this date (time-stamp in milliseconds)
	updatedSince = null,
	# updatedBefore: float   Eg: 789
	# return items that have been updated before this date (time-stamp in milliseconds)
	updatedBefore = null,
	# createdSince: float   Eg: 789
	# return items that have been created since this date (time-stamp in milliseconds)
	createdSince = null,
	# createdBefore: float   Eg: 789
	# return items that have been created before this date (time-stamp in milliseconds)
	createdBefore = null,
	# startedSince: float   Eg: 789
	# return items that have been started since this date (time-stamp in milliseconds)
	startedSince = null,
	# startedBefore: float   Eg: 789
	# return items that have been started before this date (time-stamp in milliseconds)
	startedBefore = null,
	# endedSince: float   Eg: 789
	# return items that have been ended since this date (time-stamp in milliseconds)
	endedSince = null,
	# endedBefore: float   Eg: 789
	# return items that have been ended before this date (time-stamp in milliseconds)
	endedBefore = null,
	# latitude: int   Eg: 1.2
	# the latitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)
	latitude = null,
	# longitude: int   Eg: 1.2
	# the longitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)
	longitude = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to.
	appKey = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# return results with categories matching this list
	categoryIds = "",
	# categoryFilterIds: String = ""   Eg: categoryFilterIds_example
	# return results with filters matching this list
	categoryFilterIds = "",
	# audienceIds: String = ""   Eg: audienceIds_example
	# return results with audiences matching this list
	audienceIds = "",
	# excludeAudienceIds: String = ""   Eg: excludeAudienceIds_example
	# exclude audiences with ids matching this list
	excludeAudienceIds = "",
	# includeCompletable: bool   Eg: true
	# returns the user's completable object for the album if it exists
	includeCompletable = null,
	# includeRating: bool   Eg: true
	# returns the user's rating for the album if it exists
	includeRating = null,
	# searchMode: String = ""   Eg: searchMode_example
	# The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default.
	searchMode = "",
	# stackSearch: bool   Eg: true
	# groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize
	stackSearch = null,
	# stackWindowSize: int   Eg: 56
	# size of each window for each stack
	stackWindowSize = null,
	# minStackPerPage: int   Eg: 56
	# The minimum number of stacks returned in a response. For example,  first call, minStackPerPage = 20, the API will return at least 20 results
	minStackPerPage = null,
	# stackPaginationIdentifier: String = ""   Eg: stackPaginationIdentifier_example
	# this is used to tell the system where it left off on the previous previous page, since we can't use start/limit for stackSearch
	stackPaginationIdentifier = "",
	# stackDetails: bool   Eg: true
	# set this to true when making the call to view the albums in the stack
	stackDetails = null,
	# flagCountMinimum: float   Eg: 789
	# Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)
	flagCountMinimum = null,
	# removeFlaggedContent: bool = true   Eg: true
	# return items that have flagCount >= flagThreshold (controls removal of flagged content)
	removeFlaggedContent = true,
	# verifiedFilter: bool   Eg: true
	# setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both)
	verifiedFilter = null,
	# linkedObjectType: String = ""   Eg: linkedObjectType_example
	# filter results by the linkedObjectType
	linkedObjectType = "",
	# linkedObjectId: float   Eg: 789
	# filter results by the linkedObjectId
	linkedObjectId = null,
	# orderAudienceId: float   Eg: 789
	# determines whether to use the order assigned via the /album/order/* api (which is tied to an audience)
	orderAudienceId = null,
	# ignoreDefaultAppFilter: bool   Eg: true
	# if true, ignore the application's default app filter when searching
	ignoreDefaultAppFilter = null,
	# searchExpression: String = ""   Eg: searchExpression_example
	# Advanced search expression to be used by the server
	searchExpression = "",
	# generateAlbums: bool   Eg: true
	# If true and results are empty, attempt to generate albums via templates
	generateAlbums = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_albums")
	bzz_callable.bind(
		version,
		filter,
		albumTypeId,
		subType,
		includeInactive,
		sortField,
		descending,
		start,
		limit,
		some_range,
		includeLiked,
		includeFavorited,
		includePermissions,
		likePreviewSize,
		assetPreviewSize,
		notePreviewSize,
		connectionPreviewSize,
		audiencePreviewSize,
		deviceId,
		accountId,
		connectionAccountId,
		ownerId,
		albumIds,
		excludeAlbumIds,
		mediaId,
		keyword,
		albumType,
		limitPerAlbumType,
		dateCreated,
		updatedSince,
		updatedBefore,
		createdSince,
		createdBefore,
		startedSince,
		startedBefore,
		endedSince,
		endedBefore,
		latitude,
		longitude,
		appKey,
		categoryIds,
		categoryFilterIds,
		audienceIds,
		excludeAudienceIds,
		includeCompletable,
		includeRating,
		searchMode,
		stackSearch,
		stackWindowSize,
		minStackPerPage,
		stackPaginationIdentifier,
		stackDetails,
		flagCountMinimum,
		removeFlaggedContent,
		verifiedFilter,
		linkedObjectType,
		linkedObjectId,
		orderAudienceId,
		ignoreDefaultAppFilter,
		searchExpression,
		generateAlbums,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateAlbumCollection → POST /api/{version}/album/update
# Update Album
#
# Update an Album.
func update_album_collection(
	# version: float   Eg: 3.16
	version: float,
	# albumId: float   Eg: 789
	# the ID of the album to update
	albumId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# assetsToAdd: String = ""   Eg: assetsToAdd_example
	# Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)
	assetsToAdd = "",
	# assetsToRemove: String = ""   Eg: assetsToRemove_example
	# Comma separated list of asset IDs to remove from the album's asset list
	assetsToRemove = "",
	# assetId: float   Eg: 789
	# the cover asset ID
	assetId = null,
	# media: String   Eg: BINARY_DATA_HERE
	# a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)
	media = null,
	# mediaURL: String = ""   Eg: mediaURL_example
	# this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)
	mediaURL = "",
	# active: bool   Eg: true
	# determines whether the album is active or inactive
	active = null,
	# title: String = ""   Eg: title_example
	# the title of the album
	title = "",
	# startDate: float   Eg: 789
	# the start date
	startDate = null,
	# endDate: float   Eg: 789
	# the end date
	endDate = null,
	# tags: String = ""   Eg: tags_example
	# the tags
	tags = "",
	# description: String = ""   Eg: description_example
	# the description of the album
	description = "",
	# albumType: String = ""   Eg: albumType_example
	# a custom field used for aggregation and searching
	albumType = "",
	# albumTypeId: float   Eg: 789
	# a custom indexed number used for aggregation and searching
	albumTypeId = null,
	# subType: String = ""   Eg: subType_example
	# a custom string field used for aggregation and searching
	subType = "",
	# publicRead: bool   Eg: true
	# determines whether the album's participants have read permissions
	publicRead = null,
	# publicWrite: bool   Eg: true
	# determines whether the album's participants have write permissions
	publicWrite = null,
	# publicDelete: bool   Eg: true
	# determines whether the album's participants have delete permissions
	publicDelete = null,
	# publicAdd: bool   Eg: true
	# determines whether the album's participants have add permissions
	publicAdd = null,
	# latitude: int   Eg: 1.2
	# latitude used to update the album's location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the album's location
	longitude = null,
	# locationDescription: String = ""   Eg: locationDescription_example
	# the location description
	locationDescription = "",
	# visibility: String = ""   Eg: visibility_example
	# the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
	visibility = "",
	# cellPhone: String = ""   Eg: cellPhone_example
	# the cell phone number
	cellPhone = "",
	# streetAddress: String = ""   Eg: streetAddress_example
	# The street address of the location
	streetAddress = "",
	# streetAddress2: String = ""   Eg: streetAddress2_example
	# Additional address information (such as a suite number, floor number, building name, or PO Box)
	streetAddress2 = "",
	# city: String = ""   Eg: city_example
	# The city of the location
	city = "",
	# state: String = ""   Eg: state_example
	# The state of of the location
	state = "",
	# postalCode: String = ""   Eg: postalCode_example
	# The postal code of the location
	postalCode = "",
	# fullAddress: String = ""   Eg: fullAddress_example
	# The full address of the location which should include the street address, city, state, and postal code
	fullAddress = "",
	# anonymous: bool   Eg: true
	# determines whether the album is posted anonymously
	anonymous = null,
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# comma separated category ids string associated with the Album
	categoryIds = "",
	# categoryFilterIds: String = ""   Eg: categoryFilterIds_example
	# comma separated filter ids string associated with the Album
	categoryFilterIds = "",
	# audienceIds: String = ""   Eg: audienceIds_example
	# comma separated audience ids string associated with the album
	audienceIds = "",
	# audienceIdsToAdd: String = ""   Eg: audienceIdsToAdd_example
	# comma separated audience ids to add to the album
	audienceIdsToAdd = "",
	# audienceIdsToRemove: String = ""   Eg: audienceIdsToRemove_example
	# comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd)
	audienceIdsToRemove = "",
	# includeAllAppUsersAsMembers: bool   Eg: true
	# determines whether to include all app users as members (only admins of the app can do this)
	includeAllAppUsersAsMembers = null,
	# includeAudiencesAsMembers: bool   Eg: true
	# determines whether to include all users of the audiences as members (only admins of the app can do this)
	includeAudiencesAsMembers = null,
	# audienceOperator: String = ""   Eg: audienceOperator_example
	# determines whether to use ands or ors when using the audience list to add users
	audienceOperator = "",
	# linkedObjectType: String = ""   Eg: linkedObjectType_example
	# sets a linked object so that it can be returned as part of the album response
	linkedObjectType = "",
	# linkedObjectId: float   Eg: 789
	# sets a linked object id so that it can be returned as part of the album response
	linkedObjectId = null,
	# indexNow: bool   Eg: true
	# determines whether the album should be indexed immediately
	indexNow = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/album/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["albumId"] = albumId
	bzz_query["assetsToAdd"] = assetsToAdd
	bzz_query["assetsToRemove"] = assetsToRemove
	bzz_query["assetId"] = assetId
	bzz_query["media"] = media
	bzz_query["mediaURL"] = mediaURL
	bzz_query["active"] = active
	bzz_query["title"] = title
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["tags"] = tags
	bzz_query["description"] = description
	bzz_query["albumType"] = albumType
	bzz_query["albumTypeId"] = albumTypeId
	bzz_query["subType"] = subType
	bzz_query["publicRead"] = publicRead
	bzz_query["publicWrite"] = publicWrite
	bzz_query["publicDelete"] = publicDelete
	bzz_query["publicAdd"] = publicAdd
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["locationDescription"] = locationDescription
	bzz_query["visibility"] = visibility
	bzz_query["cellPhone"] = cellPhone
	bzz_query["streetAddress"] = streetAddress
	bzz_query["streetAddress2"] = streetAddress2
	bzz_query["city"] = city
	bzz_query["state"] = state
	bzz_query["postalCode"] = postalCode
	bzz_query["fullAddress"] = fullAddress
	bzz_query["anonymous"] = anonymous
	bzz_query["metaData"] = metaData
	bzz_query["categoryIds"] = categoryIds
	bzz_query["categoryFilterIds"] = categoryFilterIds
	bzz_query["audienceIds"] = audienceIds
	bzz_query["audienceIdsToAdd"] = audienceIdsToAdd
	bzz_query["audienceIdsToRemove"] = audienceIdsToRemove
	bzz_query["includeAllAppUsersAsMembers"] = includeAllAppUsersAsMembers
	bzz_query["includeAudiencesAsMembers"] = includeAudiencesAsMembers
	bzz_query["audienceOperator"] = audienceOperator
	bzz_query["linkedObjectType"] = linkedObjectType
	bzz_query["linkedObjectId"] = linkedObjectId
	bzz_query["indexNow"] = indexNow

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AlbumResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_album_collection_threaded(
	# version: float   Eg: 3.16
	version: float,
	# albumId: float   Eg: 789
	# the ID of the album to update
	albumId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# assetsToAdd: String = ""   Eg: assetsToAdd_example
	# Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)
	assetsToAdd = "",
	# assetsToRemove: String = ""   Eg: assetsToRemove_example
	# Comma separated list of asset IDs to remove from the album's asset list
	assetsToRemove = "",
	# assetId: float   Eg: 789
	# the cover asset ID
	assetId = null,
	# media: String   Eg: BINARY_DATA_HERE
	# a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)
	media = null,
	# mediaURL: String = ""   Eg: mediaURL_example
	# this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)
	mediaURL = "",
	# active: bool   Eg: true
	# determines whether the album is active or inactive
	active = null,
	# title: String = ""   Eg: title_example
	# the title of the album
	title = "",
	# startDate: float   Eg: 789
	# the start date
	startDate = null,
	# endDate: float   Eg: 789
	# the end date
	endDate = null,
	# tags: String = ""   Eg: tags_example
	# the tags
	tags = "",
	# description: String = ""   Eg: description_example
	# the description of the album
	description = "",
	# albumType: String = ""   Eg: albumType_example
	# a custom field used for aggregation and searching
	albumType = "",
	# albumTypeId: float   Eg: 789
	# a custom indexed number used for aggregation and searching
	albumTypeId = null,
	# subType: String = ""   Eg: subType_example
	# a custom string field used for aggregation and searching
	subType = "",
	# publicRead: bool   Eg: true
	# determines whether the album's participants have read permissions
	publicRead = null,
	# publicWrite: bool   Eg: true
	# determines whether the album's participants have write permissions
	publicWrite = null,
	# publicDelete: bool   Eg: true
	# determines whether the album's participants have delete permissions
	publicDelete = null,
	# publicAdd: bool   Eg: true
	# determines whether the album's participants have add permissions
	publicAdd = null,
	# latitude: int   Eg: 1.2
	# latitude used to update the album's location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the album's location
	longitude = null,
	# locationDescription: String = ""   Eg: locationDescription_example
	# the location description
	locationDescription = "",
	# visibility: String = ""   Eg: visibility_example
	# the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
	visibility = "",
	# cellPhone: String = ""   Eg: cellPhone_example
	# the cell phone number
	cellPhone = "",
	# streetAddress: String = ""   Eg: streetAddress_example
	# The street address of the location
	streetAddress = "",
	# streetAddress2: String = ""   Eg: streetAddress2_example
	# Additional address information (such as a suite number, floor number, building name, or PO Box)
	streetAddress2 = "",
	# city: String = ""   Eg: city_example
	# The city of the location
	city = "",
	# state: String = ""   Eg: state_example
	# The state of of the location
	state = "",
	# postalCode: String = ""   Eg: postalCode_example
	# The postal code of the location
	postalCode = "",
	# fullAddress: String = ""   Eg: fullAddress_example
	# The full address of the location which should include the street address, city, state, and postal code
	fullAddress = "",
	# anonymous: bool   Eg: true
	# determines whether the album is posted anonymously
	anonymous = null,
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# comma separated category ids string associated with the Album
	categoryIds = "",
	# categoryFilterIds: String = ""   Eg: categoryFilterIds_example
	# comma separated filter ids string associated with the Album
	categoryFilterIds = "",
	# audienceIds: String = ""   Eg: audienceIds_example
	# comma separated audience ids string associated with the album
	audienceIds = "",
	# audienceIdsToAdd: String = ""   Eg: audienceIdsToAdd_example
	# comma separated audience ids to add to the album
	audienceIdsToAdd = "",
	# audienceIdsToRemove: String = ""   Eg: audienceIdsToRemove_example
	# comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd)
	audienceIdsToRemove = "",
	# includeAllAppUsersAsMembers: bool   Eg: true
	# determines whether to include all app users as members (only admins of the app can do this)
	includeAllAppUsersAsMembers = null,
	# includeAudiencesAsMembers: bool   Eg: true
	# determines whether to include all users of the audiences as members (only admins of the app can do this)
	includeAudiencesAsMembers = null,
	# audienceOperator: String = ""   Eg: audienceOperator_example
	# determines whether to use ands or ors when using the audience list to add users
	audienceOperator = "",
	# linkedObjectType: String = ""   Eg: linkedObjectType_example
	# sets a linked object so that it can be returned as part of the album response
	linkedObjectType = "",
	# linkedObjectId: float   Eg: 789
	# sets a linked object id so that it can be returned as part of the album response
	linkedObjectId = null,
	# indexNow: bool   Eg: true
	# determines whether the album should be indexed immediately
	indexNow = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_album_collection")
	bzz_callable.bind(
		version,
		albumId,
		deviceId,
		accountId,
		assetsToAdd,
		assetsToRemove,
		assetId,
		media,
		mediaURL,
		active,
		title,
		startDate,
		endDate,
		tags,
		description,
		albumType,
		albumTypeId,
		subType,
		publicRead,
		publicWrite,
		publicDelete,
		publicAdd,
		latitude,
		longitude,
		locationDescription,
		visibility,
		cellPhone,
		streetAddress,
		streetAddress2,
		city,
		state,
		postalCode,
		fullAddress,
		anonymous,
		metaData,
		categoryIds,
		categoryFilterIds,
		audienceIds,
		audienceIdsToAdd,
		audienceIdsToRemove,
		includeAllAppUsersAsMembers,
		includeAudiencesAsMembers,
		audienceOperator,
		linkedObjectType,
		linkedObjectId,
		indexNow,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


