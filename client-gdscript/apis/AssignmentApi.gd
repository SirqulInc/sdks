extends ApiBee
class_name AssignmentApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API AssignmentApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "AssignmentApi"


# Operation assigmentAssigneeAccountSearch → GET /assignment/assignee/search
# Search Assignment Assignees
#
# Search for avaiable users for creating or updating assignment.
func assigment_assignee_account_search(
	# accountId: float   Eg: 789
	# The account id sending the request
	accountId: float,
	# keyword: String = ""   Eg: keyword_example
	# The keyword to filter the returned results
	keyword = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/assignment/assignee/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["keyword"] = keyword

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AccountMiniResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func assigment_assignee_account_search_threaded(
	# accountId: float   Eg: 789
	# The account id sending the request
	accountId: float,
	# keyword: String = ""   Eg: keyword_example
	# The keyword to filter the returned results
	keyword = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "assigment_assignee_account_search")
	bzz_callable.bind(
		accountId,
		keyword,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation assignmentCreate → POST /assignment/create
# Create Assignment
#
# Create an assignment.
func assignment_create(
	# accountId: float   Eg: 789
	# the user account id
	accountId: float,
	# name: String = ""   Eg: name_example
	# the name for the assignment
	name: String,
	# assigneeAccountId: float   Eg: 789
	# the account id to assign to
	assigneeAccountId: float,
	# description: String = ""   Eg: description_example
	# the desciprtion for the assignment
	description = "",
	# retailerLocationId: float   Eg: 789
	# the retailer location id
	retailerLocationId = null,
	# tags: String = ""   Eg: tags_example
	# the tags
	tags = "",
	# active: bool   Eg: true
	# determines whether the assignment is active or inactive
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/assignment/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["name"] = name
	bzz_query["description"] = description
	bzz_query["assigneeAccountId"] = assigneeAccountId
	bzz_query["retailerLocationId"] = retailerLocationId
	bzz_query["tags"] = tags
	bzz_query["active"] = active

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AssignmentResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func assignment_create_threaded(
	# accountId: float   Eg: 789
	# the user account id
	accountId: float,
	# name: String = ""   Eg: name_example
	# the name for the assignment
	name: String,
	# assigneeAccountId: float   Eg: 789
	# the account id to assign to
	assigneeAccountId: float,
	# description: String = ""   Eg: description_example
	# the desciprtion for the assignment
	description = "",
	# retailerLocationId: float   Eg: 789
	# the retailer location id
	retailerLocationId = null,
	# tags: String = ""   Eg: tags_example
	# the tags
	tags = "",
	# active: bool   Eg: true
	# determines whether the assignment is active or inactive
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "assignment_create")
	bzz_callable.bind(
		accountId,
		name,
		assigneeAccountId,
		description,
		retailerLocationId,
		tags,
		active,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation assignmentDelete → POST /assignment/delete
# Delete Assignment
#
# Delete an assignment.
func assignment_delete(
	# accountId: float   Eg: 789
	# the user account id
	accountId: float,
	# assignmentId: float   Eg: 789
	# the assignment id
	assignmentId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/assignment/delete"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["assignmentId"] = assignmentId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func assignment_delete_threaded(
	# accountId: float   Eg: 789
	# the user account id
	accountId: float,
	# assignmentId: float   Eg: 789
	# the assignment id
	assignmentId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "assignment_delete")
	bzz_callable.bind(
		accountId,
		assignmentId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation assignmentGet → GET /assignment/get
# Get Assignment
#
# Get the details of an assignment.
func assignment_get(
	# accountId: float   Eg: 789
	# the user account id
	accountId: float,
	# assignmentId: float   Eg: 789
	# the assignment id
	assignmentId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/assignment/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["assignmentId"] = assignmentId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AssignmentResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func assignment_get_threaded(
	# accountId: float   Eg: 789
	# the user account id
	accountId: float,
	# assignmentId: float   Eg: 789
	# the assignment id
	assignmentId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "assignment_get")
	bzz_callable.bind(
		accountId,
		assignmentId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation assignmentSearch → GET /assignment/search
# Search Assignments
#
# Search for assignments by the given parameters.
func assignment_search(
	# accountId: float   Eg: 789
	# the account sending the request
	accountId: float,
	# sortField: String = ""   Eg: sortField_example
	# sort by table field
	sortField: String,
	# descending: bool   Eg: true
	# return results in descending order or not
	descending: bool,
	# activeOnly: bool   Eg: true
	# return active results only or not
	activeOnly: bool,
	# start: int   Eg: 56
	# The record to begin the return set on
	start: int,
	# limit: int   Eg: 56
	# The number of records to return
	limit: int,
	# creatorAccountId: float   Eg: 789
	# the creator of the assignment
	creatorAccountId = null,
	# assigneeAccountIds: String = ""   Eg: assigneeAccountIds_example
	# filter results by assignee accounts. If not provided, all assignments that are assigned to accounts that are managed by the requested account will be returned.
	assigneeAccountIds = "",
	# retailerLocationIds: String = ""   Eg: retailerLocationIds_example
	# filter results by retailer locations
	retailerLocationIds = "",
	# currentStatusType: String = ""   Eg: currentStatusType_example
	# filter results by assignment status
	currentStatusType = "",
	# keyword: String = ""   Eg: keyword_example
	# filter results by keyword search that matches the assignee, creator, or retailer location name
	keyword = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/assignment/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["creatorAccountId"] = creatorAccountId
	bzz_query["assigneeAccountIds"] = assigneeAccountIds
	bzz_query["retailerLocationIds"] = retailerLocationIds
	bzz_query["currentStatusType"] = currentStatusType
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["activeOnly"] = activeOnly
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AssignmentResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func assignment_search_threaded(
	# accountId: float   Eg: 789
	# the account sending the request
	accountId: float,
	# sortField: String = ""   Eg: sortField_example
	# sort by table field
	sortField: String,
	# descending: bool   Eg: true
	# return results in descending order or not
	descending: bool,
	# activeOnly: bool   Eg: true
	# return active results only or not
	activeOnly: bool,
	# start: int   Eg: 56
	# The record to begin the return set on
	start: int,
	# limit: int   Eg: 56
	# The number of records to return
	limit: int,
	# creatorAccountId: float   Eg: 789
	# the creator of the assignment
	creatorAccountId = null,
	# assigneeAccountIds: String = ""   Eg: assigneeAccountIds_example
	# filter results by assignee accounts. If not provided, all assignments that are assigned to accounts that are managed by the requested account will be returned.
	assigneeAccountIds = "",
	# retailerLocationIds: String = ""   Eg: retailerLocationIds_example
	# filter results by retailer locations
	retailerLocationIds = "",
	# currentStatusType: String = ""   Eg: currentStatusType_example
	# filter results by assignment status
	currentStatusType = "",
	# keyword: String = ""   Eg: keyword_example
	# filter results by keyword search that matches the assignee, creator, or retailer location name
	keyword = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "assignment_search")
	bzz_callable.bind(
		accountId,
		sortField,
		descending,
		activeOnly,
		start,
		limit,
		creatorAccountId,
		assigneeAccountIds,
		retailerLocationIds,
		currentStatusType,
		keyword,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation assignmentStatusCreate → POST /assignment/status/create
# Create Assignment Status
#
# Create an assignment status.
func assignment_status_create(
	# accountId: float   Eg: 789
	# the user account id
	accountId: float,
	# assignmentId: float   Eg: 789
	# the assignment id
	assignmentId: float,
	# scheduledNotificationId: float   Eg: 789
	# the scheduled notification id for reminders
	scheduledNotificationId = null,
	# toDo: String = ""   Eg: toDo_example
	# the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT
	toDo = "",
	# connection: String = ""   Eg: connection_example
	# the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED
	connection = "",
	# method: String = ""   Eg: method_example
	# the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL
	method = "",
	# status: String = ""   Eg: status_example
	# the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED
	status = "",
	# closure: String = ""   Eg: closure_example
	# the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB
	closure = "",
	# message: String = ""   Eg: message_example
	# the message from the assignee
	message = "",
	# followUp: float   Eg: 789
	# the date to follow up by
	followUp = null,
	# active: bool   Eg: true
	# determines whether the assignment status is active or inactive
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/assignment/status/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["assignmentId"] = assignmentId
	bzz_query["scheduledNotificationId"] = scheduledNotificationId
	bzz_query["toDo"] = toDo
	bzz_query["connection"] = connection
	bzz_query["method"] = method
	bzz_query["status"] = status
	bzz_query["closure"] = closure
	bzz_query["message"] = message
	bzz_query["followUp"] = followUp
	bzz_query["active"] = active

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AssignmentStatusResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func assignment_status_create_threaded(
	# accountId: float   Eg: 789
	# the user account id
	accountId: float,
	# assignmentId: float   Eg: 789
	# the assignment id
	assignmentId: float,
	# scheduledNotificationId: float   Eg: 789
	# the scheduled notification id for reminders
	scheduledNotificationId = null,
	# toDo: String = ""   Eg: toDo_example
	# the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT
	toDo = "",
	# connection: String = ""   Eg: connection_example
	# the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED
	connection = "",
	# method: String = ""   Eg: method_example
	# the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL
	method = "",
	# status: String = ""   Eg: status_example
	# the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED
	status = "",
	# closure: String = ""   Eg: closure_example
	# the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB
	closure = "",
	# message: String = ""   Eg: message_example
	# the message from the assignee
	message = "",
	# followUp: float   Eg: 789
	# the date to follow up by
	followUp = null,
	# active: bool   Eg: true
	# determines whether the assignment status is active or inactive
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "assignment_status_create")
	bzz_callable.bind(
		accountId,
		assignmentId,
		scheduledNotificationId,
		toDo,
		connection,
		method,
		status,
		closure,
		message,
		followUp,
		active,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation assignmentStatusDelete → POST /assignment/status/delete
# Deletes Assignment Status
#
# Deletes an assignment status.
func assignment_status_delete(
	# accountId: float   Eg: 789
	# the user account id
	accountId: float,
	# assignmentStatusId: float   Eg: 789
	# the assignment status id
	assignmentStatusId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/assignment/status/delete"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["assignmentStatusId"] = assignmentStatusId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func assignment_status_delete_threaded(
	# accountId: float   Eg: 789
	# the user account id
	accountId: float,
	# assignmentStatusId: float   Eg: 789
	# the assignment status id
	assignmentStatusId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "assignment_status_delete")
	bzz_callable.bind(
		accountId,
		assignmentStatusId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation assignmentStatusGet → GET /assignment/status/get
# Get Assignment Status
#
# Get an assignment status.
func assignment_status_get(
	# accountId: float   Eg: 789
	# the user account id
	accountId: float,
	# assignmentStatusId: float   Eg: 789
	# the assignment status id
	assignmentStatusId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/assignment/status/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["assignmentStatusId"] = assignmentStatusId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AssignmentStatusResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func assignment_status_get_threaded(
	# accountId: float   Eg: 789
	# the user account id
	accountId: float,
	# assignmentStatusId: float   Eg: 789
	# the assignment status id
	assignmentStatusId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "assignment_status_get")
	bzz_callable.bind(
		accountId,
		assignmentStatusId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation assignmentStatusSearch → GET /assignment/status/search
# Search Assignment Statuses
#
# Search on assignment statuses.
func assignment_status_search(
	# accountId: float   Eg: 789
	# the user account id
	accountId: float,
	# sortField: String = ""   Eg: sortField_example
	# the field to sort by. Possible values include: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, CURRENT_STATUS, TODO, CONNECTION, METHOD, STATUS, CLOSURE, MESSAGE, FOLLOW_UP
	sortField: String,
	# descending: bool   Eg: true
	# determines whether the sorted list is in descending or ascending order
	descending: bool,
	# activeOnly: bool   Eg: true
	# determines whether to only return active results
	activeOnly: bool,
	# start: int   Eg: 56
	# the start index for pagination
	start: int,
	# limit: int   Eg: 56
	# the limit for pagination
	limit: int,
	# assignmentId: float   Eg: 789
	# the assignment id
	assignmentId = null,
	# creatorAccountId: float   Eg: 789
	# filter results by the account who created the status
	creatorAccountId = null,
	# assigneeAccountId: float   Eg: 789
	# filter results by the assignee account
	assigneeAccountId = null,
	# retailerLocationId: float   Eg: 789
	# filter results by by retailer location
	retailerLocationId = null,
	# statusType: String = ""   Eg: statusType_example
	# filter results by the status type
	statusType = "",
	# keyword: String = ""   Eg: keyword_example
	# filter results by keyword search
	keyword = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/assignment/status/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["assignmentId"] = assignmentId
	bzz_query["creatorAccountId"] = creatorAccountId
	bzz_query["assigneeAccountId"] = assigneeAccountId
	bzz_query["retailerLocationId"] = retailerLocationId
	bzz_query["statusType"] = statusType
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["activeOnly"] = activeOnly
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AssignmentStatusResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func assignment_status_search_threaded(
	# accountId: float   Eg: 789
	# the user account id
	accountId: float,
	# sortField: String = ""   Eg: sortField_example
	# the field to sort by. Possible values include: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, CURRENT_STATUS, TODO, CONNECTION, METHOD, STATUS, CLOSURE, MESSAGE, FOLLOW_UP
	sortField: String,
	# descending: bool   Eg: true
	# determines whether the sorted list is in descending or ascending order
	descending: bool,
	# activeOnly: bool   Eg: true
	# determines whether to only return active results
	activeOnly: bool,
	# start: int   Eg: 56
	# the start index for pagination
	start: int,
	# limit: int   Eg: 56
	# the limit for pagination
	limit: int,
	# assignmentId: float   Eg: 789
	# the assignment id
	assignmentId = null,
	# creatorAccountId: float   Eg: 789
	# filter results by the account who created the status
	creatorAccountId = null,
	# assigneeAccountId: float   Eg: 789
	# filter results by the assignee account
	assigneeAccountId = null,
	# retailerLocationId: float   Eg: 789
	# filter results by by retailer location
	retailerLocationId = null,
	# statusType: String = ""   Eg: statusType_example
	# filter results by the status type
	statusType = "",
	# keyword: String = ""   Eg: keyword_example
	# filter results by keyword search
	keyword = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "assignment_status_search")
	bzz_callable.bind(
		accountId,
		sortField,
		descending,
		activeOnly,
		start,
		limit,
		assignmentId,
		creatorAccountId,
		assigneeAccountId,
		retailerLocationId,
		statusType,
		keyword,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation assignmentStatusUpdate → POST /assignment/status/update
# Update Assignment Status
#
# Updates an assignment status.
func assignment_status_update(
	# accountId: float   Eg: 789
	# the user account id
	accountId: float,
	# assignmentStatusId: float   Eg: 789
	# the assignment status id
	assignmentStatusId: float,
	# scheduledNotificationId: float   Eg: 789
	# the scheduled notification id for reminders
	scheduledNotificationId = null,
	# toDo: String = ""   Eg: toDo_example
	# the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT
	toDo = "",
	# connection: String = ""   Eg: connection_example
	# the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED
	connection = "",
	# method: String = ""   Eg: method_example
	# the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL
	method = "",
	# status: String = ""   Eg: status_example
	# the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED
	status = "",
	# closure: String = ""   Eg: closure_example
	# the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB
	closure = "",
	# message: String = ""   Eg: message_example
	# the message from the assignee
	message = "",
	# followUp: float   Eg: 789
	# the date to follow up by
	followUp = null,
	# active: bool   Eg: true
	# determines whether the assignment status is active or inactive
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/assignment/status/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["assignmentStatusId"] = assignmentStatusId
	bzz_query["scheduledNotificationId"] = scheduledNotificationId
	bzz_query["toDo"] = toDo
	bzz_query["connection"] = connection
	bzz_query["method"] = method
	bzz_query["status"] = status
	bzz_query["closure"] = closure
	bzz_query["message"] = message
	bzz_query["followUp"] = followUp
	bzz_query["active"] = active

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AssignmentStatusResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func assignment_status_update_threaded(
	# accountId: float   Eg: 789
	# the user account id
	accountId: float,
	# assignmentStatusId: float   Eg: 789
	# the assignment status id
	assignmentStatusId: float,
	# scheduledNotificationId: float   Eg: 789
	# the scheduled notification id for reminders
	scheduledNotificationId = null,
	# toDo: String = ""   Eg: toDo_example
	# the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT
	toDo = "",
	# connection: String = ""   Eg: connection_example
	# the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED
	connection = "",
	# method: String = ""   Eg: method_example
	# the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL
	method = "",
	# status: String = ""   Eg: status_example
	# the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED
	status = "",
	# closure: String = ""   Eg: closure_example
	# the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB
	closure = "",
	# message: String = ""   Eg: message_example
	# the message from the assignee
	message = "",
	# followUp: float   Eg: 789
	# the date to follow up by
	followUp = null,
	# active: bool   Eg: true
	# determines whether the assignment status is active or inactive
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "assignment_status_update")
	bzz_callable.bind(
		accountId,
		assignmentStatusId,
		scheduledNotificationId,
		toDo,
		connection,
		method,
		status,
		closure,
		message,
		followUp,
		active,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation assignmentUpdate → POST /assignment/update
# Update Assignment
#
# Updates an assignment.
func assignment_update(
	# accountId: float   Eg: 789
	# the user account id
	accountId: float,
	# assignmentId: float   Eg: 789
	# the assignment id
	assignmentId: float,
	# name: String = ""   Eg: name_example
	# the name of the assignment
	name = "",
	# description: String = ""   Eg: description_example
	# the description of the assignment
	description = "",
	# assigneeAccountId: float   Eg: 789
	# the account id to assign to
	assigneeAccountId = null,
	# retailerLocationId: float   Eg: 789
	# the retailer location id
	retailerLocationId = null,
	# tags: String = ""   Eg: tags_example
	# the tags
	tags = "",
	# active: bool   Eg: true
	# determines whether the assignment is active or inactive
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/assignment/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["assignmentId"] = assignmentId
	bzz_query["name"] = name
	bzz_query["description"] = description
	bzz_query["assigneeAccountId"] = assigneeAccountId
	bzz_query["retailerLocationId"] = retailerLocationId
	bzz_query["tags"] = tags
	bzz_query["active"] = active

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AssignmentResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func assignment_update_threaded(
	# accountId: float   Eg: 789
	# the user account id
	accountId: float,
	# assignmentId: float   Eg: 789
	# the assignment id
	assignmentId: float,
	# name: String = ""   Eg: name_example
	# the name of the assignment
	name = "",
	# description: String = ""   Eg: description_example
	# the description of the assignment
	description = "",
	# assigneeAccountId: float   Eg: 789
	# the account id to assign to
	assigneeAccountId = null,
	# retailerLocationId: float   Eg: 789
	# the retailer location id
	retailerLocationId = null,
	# tags: String = ""   Eg: tags_example
	# the tags
	tags = "",
	# active: bool   Eg: true
	# determines whether the assignment is active or inactive
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "assignment_update")
	bzz_callable.bind(
		accountId,
		assignmentId,
		name,
		description,
		assigneeAccountId,
		retailerLocationId,
		tags,
		active,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


