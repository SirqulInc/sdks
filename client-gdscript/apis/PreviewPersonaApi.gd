extends ApiBee
class_name PreviewPersonaApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API PreviewPersonaApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "PreviewPersonaApi"


# Operation createPersona → POST /persona/create
# Create Persona
#
# Creates a new persona. If the given params are null those attributes will be override by null.
func create_persona(
	# accountId: float   Eg: 789
	# the account ID of the user
	accountId: float,
	# title: String = ""   Eg: title_example
	# the title of the persona
	title: String,
	# previewAccounts: String = ""   Eg: previewAccounts_example
	# the accounts that are able to preview from this persona
	previewAccounts = "",
	# date: float   Eg: 789
	# the sepcified date that this persona is viewing the app
	date = null,
	# age: int   Eg: 56
	# the specified age of this persona
	age = null,
	# gender: String = ""   Eg: gender_example
	# the specified gender of this persona
	gender = "",
	# gameExperienceLevel: String = ""   Eg: gameExperienceLevel_example
	# the specified experience level of the persona
	gameExperienceLevel = "",
	# latitude: int   Eg: 1.2
	# the specified latitude of the persona
	latitude = null,
	# longitude: int   Eg: 1.2
	# the specified longitude of the persona
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/persona/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["title"] = title
	bzz_query["previewAccounts"] = previewAccounts
	bzz_query["date"] = date
	bzz_query["age"] = age
	bzz_query["gender"] = gender
	bzz_query["gameExperienceLevel"] = gameExperienceLevel
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PreviewPersonaResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_persona_threaded(
	# accountId: float   Eg: 789
	# the account ID of the user
	accountId: float,
	# title: String = ""   Eg: title_example
	# the title of the persona
	title: String,
	# previewAccounts: String = ""   Eg: previewAccounts_example
	# the accounts that are able to preview from this persona
	previewAccounts = "",
	# date: float   Eg: 789
	# the sepcified date that this persona is viewing the app
	date = null,
	# age: int   Eg: 56
	# the specified age of this persona
	age = null,
	# gender: String = ""   Eg: gender_example
	# the specified gender of this persona
	gender = "",
	# gameExperienceLevel: String = ""   Eg: gameExperienceLevel_example
	# the specified experience level of the persona
	gameExperienceLevel = "",
	# latitude: int   Eg: 1.2
	# the specified latitude of the persona
	latitude = null,
	# longitude: int   Eg: 1.2
	# the specified longitude of the persona
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_persona")
	bzz_callable.bind(
		accountId,
		title,
		previewAccounts,
		date,
		age,
		gender,
		gameExperienceLevel,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deletePersona → POST /persona/delete
# Delete Persona
#
# Mark the persona for deletion.
func delete_persona(
	# accountId: float   Eg: 789
	# the account id of the user
	accountId: float,
	# personaId: float   Eg: 789
	# the id of the persona to delete
	personaId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/persona/delete"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["personaId"] = personaId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_persona_threaded(
	# accountId: float   Eg: 789
	# the account id of the user
	accountId: float,
	# personaId: float   Eg: 789
	# the id of the persona to delete
	personaId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_persona")
	bzz_callable.bind(
		accountId,
		personaId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getPersonaList → GET /persona/get
# Get Persona
#
# Get the persona by the given persona ID. If the persona cannot be found, a invalid response is returned.
func get_persona_list(
	# accountId: float   Eg: 789
	# the account ID of the user
	accountId: float,
	# personaId: float   Eg: 789
	# the persona ID of the persona
	personaId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/persona/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["personaId"] = personaId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PreviewPersonaResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_persona_list_threaded(
	# accountId: float   Eg: 789
	# the account ID of the user
	accountId: float,
	# personaId: float   Eg: 789
	# the persona ID of the persona
	personaId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_persona_list")
	bzz_callable.bind(
		accountId,
		personaId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchPersona → GET /persona/search
# Search Personas
#
# Search for persona that the account owns by the given account ID.
func search_persona(
	# accountId: float   Eg: 789
	# the account ID of the user
	accountId: float,
	# start: int   Eg: 56
	# the start index for pagination
	start: int,
	# limit: int   Eg: 56
	# the limit for pagination (There is a hard limit of 100)
	limit: int,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/persona/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PreviewPersonaResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_persona_threaded(
	# accountId: float   Eg: 789
	# the account ID of the user
	accountId: float,
	# start: int   Eg: 56
	# the start index for pagination
	start: int,
	# limit: int   Eg: 56
	# the limit for pagination (There is a hard limit of 100)
	limit: int,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_persona")
	bzz_callable.bind(
		accountId,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updatePersona → POST /persona/update
# Update Persona
#
# Update the persona by the given personaId. If the given params are null those attributes will be override by null. If active is assigned, all other params will be ignored.
func update_persona(
	# accountId: float   Eg: 789
	# the account ID of the user
	accountId: float,
	# personaId: float   Eg: 789
	# the persona ID of the persona to update
	personaId: float,
	# title: String = ""   Eg: title_example
	# the title of the persona
	title = "",
	# previewAccounts: String = ""   Eg: previewAccounts_example
	# the accounts that are able to preview from this persona
	previewAccounts = "",
	# active: bool   Eg: true
	# the status of the persona, there can only be one active persona per account
	active = null,
	# date: float   Eg: 789
	# the sepcified date that this persona is viewing the app
	date = null,
	# age: int   Eg: 56
	# the specified age of this persona
	age = null,
	# gender: String = ""   Eg: gender_example
	# the specified gender of this persona
	gender = "",
	# gameExperienceLevel: String = ""   Eg: gameExperienceLevel_example
	# the specified experience level of the persona
	gameExperienceLevel = "",
	# latitude: int   Eg: 1.2
	# the specified latitude of the persona
	latitude = null,
	# longitude: int   Eg: 1.2
	# the specified longitude of the persona
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/persona/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["personaId"] = personaId
	bzz_query["title"] = title
	bzz_query["previewAccounts"] = previewAccounts
	bzz_query["active"] = active
	bzz_query["date"] = date
	bzz_query["age"] = age
	bzz_query["gender"] = gender
	bzz_query["gameExperienceLevel"] = gameExperienceLevel
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PreviewPersonaResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_persona_threaded(
	# accountId: float   Eg: 789
	# the account ID of the user
	accountId: float,
	# personaId: float   Eg: 789
	# the persona ID of the persona to update
	personaId: float,
	# title: String = ""   Eg: title_example
	# the title of the persona
	title = "",
	# previewAccounts: String = ""   Eg: previewAccounts_example
	# the accounts that are able to preview from this persona
	previewAccounts = "",
	# active: bool   Eg: true
	# the status of the persona, there can only be one active persona per account
	active = null,
	# date: float   Eg: 789
	# the sepcified date that this persona is viewing the app
	date = null,
	# age: int   Eg: 56
	# the specified age of this persona
	age = null,
	# gender: String = ""   Eg: gender_example
	# the specified gender of this persona
	gender = "",
	# gameExperienceLevel: String = ""   Eg: gameExperienceLevel_example
	# the specified experience level of the persona
	gameExperienceLevel = "",
	# latitude: int   Eg: 1.2
	# the specified latitude of the persona
	latitude = null,
	# longitude: int   Eg: 1.2
	# the specified longitude of the persona
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_persona")
	bzz_callable.bind(
		accountId,
		personaId,
		title,
		previewAccounts,
		active,
		date,
		age,
		gender,
		gameExperienceLevel,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


