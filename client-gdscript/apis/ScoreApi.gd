extends ApiBee
class_name ScoreApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API ScoreApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "ScoreApi"


# Operation createScore → POST /score/create
# Create Score
#
# Create a score.  The response object will contain a series of   coded messages detailing what items were completed, the score registered,   and any tickets allocated.  Scoring a  level could complete the pack it   is in, completing that pack could complete the game, which  in turn could   complete the mission.  This completion chain is indicated to the client   via  a list of {@link MessageResponse}.
func create_score(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The game application key to save the score for.
	appKey: String,
	# points: int   Eg: 56
	# The score
	points: int,
	# missionId: float   Eg: 789
	# The missionId to score for, ignore if not playing mission.
	missionId = null,
	# gameId: float   Eg: 789
	# The gameId to score for, ignore if not playing mission.
	gameId = null,
	# packId: float   Eg: 789
	# The packId to score for, send -2 if playing community levels.
	packId = null,
	# gameLevelId: float   Eg: 789
	# The gameLevelId to score for.
	gameLevelId = null,
	# gameObjectId: float   Eg: 789
	# The gameObjectId to score for, ignore if level based scoring.
	gameObjectId = null,
	# timeTaken: int   Eg: 56
	# The time taken to complete task
	timeTaken = null,
	# highest: bool   Eg: true
	highest = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/score/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["missionId"] = missionId
	bzz_query["gameId"] = gameId
	bzz_query["packId"] = packId
	bzz_query["gameLevelId"] = gameLevelId
	bzz_query["gameObjectId"] = gameObjectId
	bzz_query["points"] = points
	bzz_query["timeTaken"] = timeTaken
	bzz_query["highest"] = highest

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ScoreResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_score_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The game application key to save the score for.
	appKey: String,
	# points: int   Eg: 56
	# The score
	points: int,
	# missionId: float   Eg: 789
	# The missionId to score for, ignore if not playing mission.
	missionId = null,
	# gameId: float   Eg: 789
	# The gameId to score for, ignore if not playing mission.
	gameId = null,
	# packId: float   Eg: 789
	# The packId to score for, send -2 if playing community levels.
	packId = null,
	# gameLevelId: float   Eg: 789
	# The gameLevelId to score for.
	gameLevelId = null,
	# gameObjectId: float   Eg: 789
	# The gameObjectId to score for, ignore if level based scoring.
	gameObjectId = null,
	# timeTaken: int   Eg: 56
	# The time taken to complete task
	timeTaken = null,
	# highest: bool   Eg: true
	highest = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_score")
	bzz_callable.bind(
		accountId,
		appKey,
		points,
		missionId,
		gameId,
		packId,
		gameLevelId,
		gameObjectId,
		timeTaken,
		highest,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getScore → GET /score/get
# Get Score
#
# Get the high score for an item.  Pass in the full path IDs for the score.
func get_score(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The game application key to get the level for.
	appKey: String,
	# missionId: float   Eg: 789
	# The missionId to score for, null if not playing mission.
	missionId = null,
	# gameId: float   Eg: 789
	# The gameId to score for, null if not playing mission.
	gameId = null,
	# packId: float   Eg: 789
	# The packId to score for, null if playing community levels.
	packId = null,
	# gameLevelId: float   Eg: 789
	# The gameLevelId to score for.
	gameLevelId = null,
	# gameObjectId: float   Eg: 789
	# The gameObjectId to score for, null if level based scoring.
	gameObjectId = null,
	# scoreObjectType: String = ""   Eg: scoreObjectType_example
	# The object type to filter scores by (TicketObjectType)
	scoreObjectType = "",
	# scoreStatus: String = ""   Eg: scoreStatus_example
	# The status of the score to filter (ScoreStatus)
	scoreStatus = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/score/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["missionId"] = missionId
	bzz_query["gameId"] = gameId
	bzz_query["packId"] = packId
	bzz_query["gameLevelId"] = gameLevelId
	bzz_query["gameObjectId"] = gameObjectId
	bzz_query["scoreObjectType"] = scoreObjectType
	bzz_query["scoreStatus"] = scoreStatus

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ScoreResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_score_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The game application key to get the level for.
	appKey: String,
	# missionId: float   Eg: 789
	# The missionId to score for, null if not playing mission.
	missionId = null,
	# gameId: float   Eg: 789
	# The gameId to score for, null if not playing mission.
	gameId = null,
	# packId: float   Eg: 789
	# The packId to score for, null if playing community levels.
	packId = null,
	# gameLevelId: float   Eg: 789
	# The gameLevelId to score for.
	gameLevelId = null,
	# gameObjectId: float   Eg: 789
	# The gameObjectId to score for, null if level based scoring.
	gameObjectId = null,
	# scoreObjectType: String = ""   Eg: scoreObjectType_example
	# The object type to filter scores by (TicketObjectType)
	scoreObjectType = "",
	# scoreStatus: String = ""   Eg: scoreStatus_example
	# The status of the score to filter (ScoreStatus)
	scoreStatus = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_score")
	bzz_callable.bind(
		accountId,
		appKey,
		missionId,
		gameId,
		packId,
		gameLevelId,
		gameObjectId,
		scoreObjectType,
		scoreStatus,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchScores → GET /score/search
# Search Score
#
# Search the scores for an item.  Pass in the full path IDs for the scores.
func search_scores(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The game application key to get the level for.
	appKey: String,
	# missionId: float   Eg: 789
	# The missionId to score for, null if not playing mission.
	missionId = null,
	# gameId: float   Eg: 789
	# The gameId to score for, null if not playing mission.
	gameId = null,
	# packId: float   Eg: 789
	# The packId to score for, null if playing community levels.
	packId = null,
	# gameLevelId: float   Eg: 789
	# The gameLevelId to score for.
	gameLevelId = null,
	# gameObjectId: float   Eg: 789
	# The gameObjectId to score for, null if level based scoring.
	gameObjectId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/score/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["missionId"] = missionId
	bzz_query["gameId"] = gameId
	bzz_query["packId"] = packId
	bzz_query["gameLevelId"] = gameLevelId
	bzz_query["gameObjectId"] = gameObjectId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ScoreResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_scores_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The game application key to get the level for.
	appKey: String,
	# missionId: float   Eg: 789
	# The missionId to score for, null if not playing mission.
	missionId = null,
	# gameId: float   Eg: 789
	# The gameId to score for, null if not playing mission.
	gameId = null,
	# packId: float   Eg: 789
	# The packId to score for, null if playing community levels.
	packId = null,
	# gameLevelId: float   Eg: 789
	# The gameLevelId to score for.
	gameLevelId = null,
	# gameObjectId: float   Eg: 789
	# The gameObjectId to score for, null if level based scoring.
	gameObjectId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_scores")
	bzz_callable.bind(
		accountId,
		appKey,
		missionId,
		gameId,
		packId,
		gameLevelId,
		gameObjectId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


