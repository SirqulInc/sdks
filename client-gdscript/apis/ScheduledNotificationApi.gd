extends ApiBee
class_name ScheduledNotificationApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API ScheduledNotificationApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "ScheduledNotificationApi"


# Operation createScheduledNotification → POST /api/{version}/notification/schedule/create
# Create Scheduled Notification
#
# This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods
func create_scheduled_notification(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the scheduled notification
	name: String,
	# type: String = ""   Eg: type_example
	# The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
	type: String,
	# message: String = ""   Eg: message_example
	# The message to send
	message: String,
	# contentId: float   Eg: 789
	# The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	contentId = null,
	# contentName: String = ""   Eg: contentName_example
	# The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	contentName = "",
	# contentType: String = ""   Eg: contentType_example
	# The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	contentType = "",
	# parentId: float   Eg: 789
	# The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	parentId = null,
	# parentType: String = ""   Eg: parentType_example
	# The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	parentType = "",
	# appKey: String = ""   Eg: appKey_example
	# The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
	appKey = "",
	# groupingId: String = ""   Eg: groupingId_example
	# Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
	groupingId = "",
	# connectionGroupIds: String = ""   Eg: connectionGroupIds_example
	# The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
	connectionGroupIds = "",
	# connectionAccountIds: String = ""   Eg: connectionAccountIds_example
	# The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
	connectionAccountIds = "",
	# audienceId: float   Eg: 789
	# This parameter is deprecated. The audience used to generate the list of recipients
	audienceId = null,
	# audienceIds: String = ""   Eg: audienceIds_example
	# The audiences used to generate the list of recipients (comma separated list of audience IDs)
	audienceIds = "",
	# albumIds: String = ""   Eg: albumIds_example
	# The album ids to associate with the scheduled notification (comma separated list of album IDs)
	albumIds = "",
	# reportId: float   Eg: 789
	# The report used to generate the the list of recipients
	reportId = null,
	# reportParams: String = ""   Eg: reportParams_example
	# The parameters to supply to the report used to generate the the list of recipients
	reportParams = "",
	# endpointURL: String = ""   Eg: endpointURL_example
	# The URL for making an HTTP call
	endpointURL = "",
	# payload: String = ""   Eg: payload_example
	# The parameters for making an HTTP call
	payload = "",
	# scheduledDate: float   Eg: 789
	# The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
	scheduledDate = null,
	# startDate: float   Eg: 789
	# The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
	startDate = null,
	# endDate: float   Eg: 789
	# The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
	endDate = null,
	# cronExpression: String = ""   Eg: cronExpression_example
	# The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
	cronExpression = "",
	# cronType: String = ""   Eg: cronType_example
	# The cron expression type: UNIX, CRON4J, QUARTZ
	cronType = "",
	# metaData: String = ""   Eg: metaData_example
	# Additional metadata for the scheduled notification
	metaData = "",
	# conditionalInput: String = ""   Eg: conditionalInput_example
	# Json input representing conditional logic that has to be met before running the scheduled notification
	conditionalInput = "",
	# templateType: String = ""   Eg: templateType_example
	# This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
	templateType = "",
	# visibility: String = ""   Eg: visibility_example
	# Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
	visibility = "",
	# active: bool   Eg: true
	# Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is 'true'.
	active = null,
	# sendNow: bool   Eg: true
	sendNow = null,
	# eventType: String = "CUSTOM"   Eg: eventType_example
	# Sets the event type for the notification
	eventType = "CUSTOM",
	# deepLinkURI: String = ""   Eg: deepLinkURI_example
	# The payload deep link URI that can be used by the client app to direct users to a screen in the app
	deepLinkURI = "",
	# sendToAll: bool   Eg: true
	# Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
	sendToAll = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/schedule/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["name"] = name
	bzz_query["type"] = type
	bzz_query["message"] = message
	bzz_query["contentId"] = contentId
	bzz_query["contentName"] = contentName
	bzz_query["contentType"] = contentType
	bzz_query["parentId"] = parentId
	bzz_query["parentType"] = parentType
	bzz_query["appKey"] = appKey
	bzz_query["groupingId"] = groupingId
	bzz_query["connectionGroupIds"] = connectionGroupIds
	bzz_query["connectionAccountIds"] = connectionAccountIds
	bzz_query["audienceId"] = audienceId
	bzz_query["audienceIds"] = audienceIds
	bzz_query["albumIds"] = albumIds
	bzz_query["reportId"] = reportId
	bzz_query["reportParams"] = reportParams
	bzz_query["endpointURL"] = endpointURL
	bzz_query["payload"] = payload
	bzz_query["scheduledDate"] = scheduledDate
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["cronExpression"] = cronExpression
	bzz_query["cronType"] = cronType
	bzz_query["metaData"] = metaData
	bzz_query["conditionalInput"] = conditionalInput
	bzz_query["templateType"] = templateType
	bzz_query["visibility"] = visibility
	bzz_query["active"] = active
	bzz_query["sendNow"] = sendNow
	bzz_query["eventType"] = eventType
	bzz_query["deepLinkURI"] = deepLinkURI
	bzz_query["sendToAll"] = sendToAll

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ScheduledNotificationFullResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_scheduled_notification_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the scheduled notification
	name: String,
	# type: String = ""   Eg: type_example
	# The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
	type: String,
	# message: String = ""   Eg: message_example
	# The message to send
	message: String,
	# contentId: float   Eg: 789
	# The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	contentId = null,
	# contentName: String = ""   Eg: contentName_example
	# The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	contentName = "",
	# contentType: String = ""   Eg: contentType_example
	# The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	contentType = "",
	# parentId: float   Eg: 789
	# The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	parentId = null,
	# parentType: String = ""   Eg: parentType_example
	# The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	parentType = "",
	# appKey: String = ""   Eg: appKey_example
	# The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
	appKey = "",
	# groupingId: String = ""   Eg: groupingId_example
	# Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
	groupingId = "",
	# connectionGroupIds: String = ""   Eg: connectionGroupIds_example
	# The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
	connectionGroupIds = "",
	# connectionAccountIds: String = ""   Eg: connectionAccountIds_example
	# The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
	connectionAccountIds = "",
	# audienceId: float   Eg: 789
	# This parameter is deprecated. The audience used to generate the list of recipients
	audienceId = null,
	# audienceIds: String = ""   Eg: audienceIds_example
	# The audiences used to generate the list of recipients (comma separated list of audience IDs)
	audienceIds = "",
	# albumIds: String = ""   Eg: albumIds_example
	# The album ids to associate with the scheduled notification (comma separated list of album IDs)
	albumIds = "",
	# reportId: float   Eg: 789
	# The report used to generate the the list of recipients
	reportId = null,
	# reportParams: String = ""   Eg: reportParams_example
	# The parameters to supply to the report used to generate the the list of recipients
	reportParams = "",
	# endpointURL: String = ""   Eg: endpointURL_example
	# The URL for making an HTTP call
	endpointURL = "",
	# payload: String = ""   Eg: payload_example
	# The parameters for making an HTTP call
	payload = "",
	# scheduledDate: float   Eg: 789
	# The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
	scheduledDate = null,
	# startDate: float   Eg: 789
	# The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
	startDate = null,
	# endDate: float   Eg: 789
	# The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
	endDate = null,
	# cronExpression: String = ""   Eg: cronExpression_example
	# The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
	cronExpression = "",
	# cronType: String = ""   Eg: cronType_example
	# The cron expression type: UNIX, CRON4J, QUARTZ
	cronType = "",
	# metaData: String = ""   Eg: metaData_example
	# Additional metadata for the scheduled notification
	metaData = "",
	# conditionalInput: String = ""   Eg: conditionalInput_example
	# Json input representing conditional logic that has to be met before running the scheduled notification
	conditionalInput = "",
	# templateType: String = ""   Eg: templateType_example
	# This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
	templateType = "",
	# visibility: String = ""   Eg: visibility_example
	# Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
	visibility = "",
	# active: bool   Eg: true
	# Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is 'true'.
	active = null,
	# sendNow: bool   Eg: true
	sendNow = null,
	# eventType: String = "CUSTOM"   Eg: eventType_example
	# Sets the event type for the notification
	eventType = "CUSTOM",
	# deepLinkURI: String = ""   Eg: deepLinkURI_example
	# The payload deep link URI that can be used by the client app to direct users to a screen in the app
	deepLinkURI = "",
	# sendToAll: bool   Eg: true
	# Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
	sendToAll = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_scheduled_notification")
	bzz_callable.bind(
		version,
		accountId,
		name,
		type,
		message,
		contentId,
		contentName,
		contentType,
		parentId,
		parentType,
		appKey,
		groupingId,
		connectionGroupIds,
		connectionAccountIds,
		audienceId,
		audienceIds,
		albumIds,
		reportId,
		reportParams,
		endpointURL,
		payload,
		scheduledDate,
		startDate,
		endDate,
		cronExpression,
		cronType,
		metaData,
		conditionalInput,
		templateType,
		visibility,
		active,
		sendNow,
		eventType,
		deepLinkURI,
		sendToAll,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteScheduledNotification → POST /api/{version}/notification/schedule/delete
# Delete Scheduled Notification
#
# This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.
func delete_scheduled_notification(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# scheduledNotificationId: float   Eg: 789
	# the id of the scheduled notification to delete
	scheduledNotificationId: float,
	# deleteByGroupingId: bool   Eg: true
	# If set to true, also deletes Scheduled Notifications under the same account with the same groupingId.
	deleteByGroupingId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/schedule/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["scheduledNotificationId"] = scheduledNotificationId
	bzz_query["deleteByGroupingId"] = deleteByGroupingId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ScheduledNotificationFullResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_scheduled_notification_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# scheduledNotificationId: float   Eg: 789
	# the id of the scheduled notification to delete
	scheduledNotificationId: float,
	# deleteByGroupingId: bool   Eg: true
	# If set to true, also deletes Scheduled Notifications under the same account with the same groupingId.
	deleteByGroupingId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_scheduled_notification")
	bzz_callable.bind(
		version,
		accountId,
		scheduledNotificationId,
		deleteByGroupingId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getScheduledNotification → GET /api/{version}/notification/schedule/get
# Get Scheduled Notification
#
# Get a ScheduledNotification
func get_scheduled_notification(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the id of the account logged in
	accountId: float,
	# scheduledNotificationId: float   Eg: 789
	# the id of the scheduled notification to get
	scheduledNotificationId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/schedule/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["scheduledNotificationId"] = scheduledNotificationId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ScheduledNotificationFullResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_scheduled_notification_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the id of the account logged in
	accountId: float,
	# scheduledNotificationId: float   Eg: 789
	# the id of the scheduled notification to get
	scheduledNotificationId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_scheduled_notification")
	bzz_callable.bind(
		version,
		accountId,
		scheduledNotificationId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation scheduleNotificationListings → POST /api/{version}/notification/schedule/generate
# Generate Schedule Notifications
#
# Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.
func schedule_notification_listings(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application to target
	appKey: String,
	# reportName: String = ""   Eg: reportName_example
	# The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail
	reportName: String,
	# message: String = ""   Eg: message_example
	# The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in
	message: String,
	# offset: int   Eg: 56
	# Time in munites before the event starts to notify recipients
	offset: int,
	# recipientReportId: float   Eg: 789
	# The report id used to generate the recipient list
	recipientReportId: float,
	# reportParams: String = ""   Eg: reportParams_example
	# The parameters of the report used to identify events in a json structure, example: ```json {   \"string\": \"value\",   \"number\": 3.345,   \"date\": \"2014-05-01 00:00:00\" } ``` 
	reportParams = "",
	# type: String = ""   Eg: type_example
	# The type of scheduled notification; supported values are: MOBILE_NOTIFICATION
	type = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/schedule/generate".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["reportName"] = reportName
	bzz_query["reportParams"] = reportParams
	bzz_query["message"] = message
	bzz_query["offset"] = offset
	bzz_query["type"] = type
	bzz_query["recipientReportId"] = recipientReportId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func schedule_notification_listings_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application to target
	appKey: String,
	# reportName: String = ""   Eg: reportName_example
	# The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail
	reportName: String,
	# message: String = ""   Eg: message_example
	# The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in
	message: String,
	# offset: int   Eg: 56
	# Time in munites before the event starts to notify recipients
	offset: int,
	# recipientReportId: float   Eg: 789
	# The report id used to generate the recipient list
	recipientReportId: float,
	# reportParams: String = ""   Eg: reportParams_example
	# The parameters of the report used to identify events in a json structure, example: ```json {   \"string\": \"value\",   \"number\": 3.345,   \"date\": \"2014-05-01 00:00:00\" } ``` 
	reportParams = "",
	# type: String = ""   Eg: type_example
	# The type of scheduled notification; supported values are: MOBILE_NOTIFICATION
	type = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "schedule_notification_listings")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		reportName,
		message,
		offset,
		recipientReportId,
		reportParams,
		type,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchScheduledNotifications → GET /api/{version}/notification/schedule/search
# Search Scheduled Notifications
#
# This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.
func search_scheduled_notifications(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# groupingId: String = ""   Eg: groupingId_example
	# Filter results by a grouping identifier defined by the client
	groupingId = "",
	# audienceId: float   Eg: 789
	# Filter results by audience
	audienceId = null,
	# filter: String = ""   Eg: filter_example
	# a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications.
	filter = "",
	# types: String = ""   Eg: types_example
	# Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION
	types = "",
	# contentIds: String = ""   Eg: contentIds_example
	# search using content IDs
	contentIds = "",
	# contentTypes: String = ""   Eg: contentTypes_example
	# search using content types
	contentTypes = "",
	# parentIds: String = ""   Eg: parentIds_example
	# search using parent IDs
	parentIds = "",
	# parentTypes: String = ""   Eg: parentTypes_example
	# search using parent types
	parentTypes = "",
	# statuses: String = ""   Eg: statuses_example
	# Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending
	statuses = "",
	# templateTypes: String = ""   Eg: templateTypes_example
	templateTypes = "",
	# appKey: String = ""   Eg: appKey_example
	# Filter the list by a specific application
	appKey = "",
	# keyword: String = ""   Eg: keyword_example
	# Keyword search on the scheduled notification names.
	keyword = "",
	# sortField: String = ""   Eg: sortField_example
	# The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date
	sortField = "",
	# descending: bool   Eg: true
	# Determines whether the sorted list is in descending or ascending order
	descending = null,
	# start: int   Eg: 56
	# Start the result set at some index.
	start = null,
	# limit: int   Eg: 56
	# Limit the result to some number.
	limit = null,
	# activeOnly: bool   Eg: true
	# Determines whether to return only active results
	activeOnly = null,
	# groupByGroupingId: bool   Eg: true
	# Determines whether to group results with the same groupingId together.
	groupByGroupingId = null,
	# returnAudienceAccountCount: bool   Eg: true
	# If true, include audience account counts in the response
	returnAudienceAccountCount = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/schedule/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["groupingId"] = groupingId
	bzz_query["audienceId"] = audienceId
	bzz_query["filter"] = filter
	bzz_query["types"] = types
	bzz_query["contentIds"] = contentIds
	bzz_query["contentTypes"] = contentTypes
	bzz_query["parentIds"] = parentIds
	bzz_query["parentTypes"] = parentTypes
	bzz_query["statuses"] = statuses
	bzz_query["templateTypes"] = templateTypes
	bzz_query["appKey"] = appKey
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["activeOnly"] = activeOnly
	bzz_query["groupByGroupingId"] = groupByGroupingId
	bzz_query["returnAudienceAccountCount"] = returnAudienceAccountCount

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ScheduledNotificationFullResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_scheduled_notifications_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# groupingId: String = ""   Eg: groupingId_example
	# Filter results by a grouping identifier defined by the client
	groupingId = "",
	# audienceId: float   Eg: 789
	# Filter results by audience
	audienceId = null,
	# filter: String = ""   Eg: filter_example
	# a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications.
	filter = "",
	# types: String = ""   Eg: types_example
	# Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION
	types = "",
	# contentIds: String = ""   Eg: contentIds_example
	# search using content IDs
	contentIds = "",
	# contentTypes: String = ""   Eg: contentTypes_example
	# search using content types
	contentTypes = "",
	# parentIds: String = ""   Eg: parentIds_example
	# search using parent IDs
	parentIds = "",
	# parentTypes: String = ""   Eg: parentTypes_example
	# search using parent types
	parentTypes = "",
	# statuses: String = ""   Eg: statuses_example
	# Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending
	statuses = "",
	# templateTypes: String = ""   Eg: templateTypes_example
	templateTypes = "",
	# appKey: String = ""   Eg: appKey_example
	# Filter the list by a specific application
	appKey = "",
	# keyword: String = ""   Eg: keyword_example
	# Keyword search on the scheduled notification names.
	keyword = "",
	# sortField: String = ""   Eg: sortField_example
	# The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date
	sortField = "",
	# descending: bool   Eg: true
	# Determines whether the sorted list is in descending or ascending order
	descending = null,
	# start: int   Eg: 56
	# Start the result set at some index.
	start = null,
	# limit: int   Eg: 56
	# Limit the result to some number.
	limit = null,
	# activeOnly: bool   Eg: true
	# Determines whether to return only active results
	activeOnly = null,
	# groupByGroupingId: bool   Eg: true
	# Determines whether to group results with the same groupingId together.
	groupByGroupingId = null,
	# returnAudienceAccountCount: bool   Eg: true
	# If true, include audience account counts in the response
	returnAudienceAccountCount = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_scheduled_notifications")
	bzz_callable.bind(
		version,
		accountId,
		groupingId,
		audienceId,
		filter,
		types,
		contentIds,
		contentTypes,
		parentIds,
		parentTypes,
		statuses,
		templateTypes,
		appKey,
		keyword,
		sortField,
		descending,
		start,
		limit,
		activeOnly,
		groupByGroupingId,
		returnAudienceAccountCount,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateScheduledNotification → POST /api/{version}/notification/schedule/update
# Update Scheduled Notification
#
# This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.
func update_scheduled_notification(
	# version: float   Eg: 3.16
	version: float,
	# scheduledNotificationId: float   Eg: 789
	# The id of scheduled notification to update
	scheduledNotificationId: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the scheduled notification
	name = "",
	# type: String = ""   Eg: type_example
	# The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
	type = "",
	# message: String = ""   Eg: message_example
	# The message to send
	message = "",
	# payload: String = ""   Eg: payload_example
	# The parameters for making an HTTP call
	payload = "",
	# contentId: float   Eg: 789
	# The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	contentId = null,
	# contentName: String = ""   Eg: contentName_example
	# The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	contentName = "",
	# contentType: String = ""   Eg: contentType_example
	# The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	contentType = "",
	# parentId: float   Eg: 789
	# The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	parentId = null,
	# parentType: String = ""   Eg: parentType_example
	# The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	parentType = "",
	# appKey: String = ""   Eg: appKey_example
	# The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
	appKey = "",
	# groupingId: String = ""   Eg: groupingId_example
	# Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
	groupingId = "",
	# connectionGroupIds: String = ""   Eg: connectionGroupIds_example
	# The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
	connectionGroupIds = "",
	# connectionAccountIds: String = ""   Eg: connectionAccountIds_example
	# The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
	connectionAccountIds = "",
	# audienceId: float   Eg: 789
	# This parameter is deprecated. The audience used to generate the list of recipients
	audienceId = null,
	# audienceIds: String = ""   Eg: audienceIds_example
	# The audiences used to generate the list of recipients (comma separated list of audience IDs)
	audienceIds = "",
	# albumIds: String = ""   Eg: albumIds_example
	# The album ids to associate with the scheduled notification (comma separated list of album IDs)
	albumIds = "",
	# reportId: float   Eg: 789
	# The report used to generate the the list of recipients
	reportId = null,
	# reportParams: String = ""   Eg: reportParams_example
	# The parameters to supply to the report used to generate the the list of recipients
	reportParams = "",
	# endpointURL: String = ""   Eg: endpointURL_example
	# The URL for making an HTTP call
	endpointURL = "",
	# scheduledDate: float   Eg: 789
	# The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
	scheduledDate = null,
	# startDate: float   Eg: 789
	# The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
	startDate = null,
	# endDate: float   Eg: 789
	# The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
	endDate = null,
	# cronExpression: String = ""   Eg: cronExpression_example
	# The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
	cronExpression = "",
	# cronType: String = ""   Eg: cronType_example
	# The cron expression type: UNIX, CRON4J, QUARTZ
	cronType = "",
	# metaData: String = ""   Eg: metaData_example
	# Additional metadata for the scheduled notification
	metaData = "",
	# conditionalInput: String = ""   Eg: conditionalInput_example
	# Json input representing conditional logic that has to be met before running the scheduled notification
	conditionalInput = "",
	# templateType: String = ""   Eg: templateType_example
	# This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
	templateType = "",
	# visibility: String = ""   Eg: visibility_example
	# Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
	visibility = "",
	# active: bool   Eg: true
	# Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule.
	active = null,
	# errorMessage: String = ""   Eg: errorMessage_example
	# the error message associated with the scheduled notification
	errorMessage = "",
	# status: String = ""   Eg: status_example
	# the status of the scheduled notification
	status = "",
	# updateByGroupingId: bool   Eg: true
	# also updates ScheduledNotifications with the same groupingId and account
	updateByGroupingId = null,
	# sendNow: bool   Eg: true
	# whether to send the scheduled notification now or not
	sendNow = null,
	# eventType: String = "CUSTOM"   Eg: eventType_example
	# Sets the event type for the notification
	eventType = "CUSTOM",
	# deepLinkURI: String = ""   Eg: deepLinkURI_example
	# The payload deep link URI that can be used by the client app to direct users to a screen in the app
	deepLinkURI = "",
	# sendToAll: bool   Eg: true
	# Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
	sendToAll = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/schedule/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["scheduledNotificationId"] = scheduledNotificationId
	bzz_query["accountId"] = accountId
	bzz_query["name"] = name
	bzz_query["type"] = type
	bzz_query["message"] = message
	bzz_query["payload"] = payload
	bzz_query["contentId"] = contentId
	bzz_query["contentName"] = contentName
	bzz_query["contentType"] = contentType
	bzz_query["parentId"] = parentId
	bzz_query["parentType"] = parentType
	bzz_query["appKey"] = appKey
	bzz_query["groupingId"] = groupingId
	bzz_query["connectionGroupIds"] = connectionGroupIds
	bzz_query["connectionAccountIds"] = connectionAccountIds
	bzz_query["audienceId"] = audienceId
	bzz_query["audienceIds"] = audienceIds
	bzz_query["albumIds"] = albumIds
	bzz_query["reportId"] = reportId
	bzz_query["reportParams"] = reportParams
	bzz_query["endpointURL"] = endpointURL
	bzz_query["scheduledDate"] = scheduledDate
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["cronExpression"] = cronExpression
	bzz_query["cronType"] = cronType
	bzz_query["metaData"] = metaData
	bzz_query["conditionalInput"] = conditionalInput
	bzz_query["templateType"] = templateType
	bzz_query["visibility"] = visibility
	bzz_query["active"] = active
	bzz_query["errorMessage"] = errorMessage
	bzz_query["status"] = status
	bzz_query["updateByGroupingId"] = updateByGroupingId
	bzz_query["sendNow"] = sendNow
	bzz_query["eventType"] = eventType
	bzz_query["deepLinkURI"] = deepLinkURI
	bzz_query["sendToAll"] = sendToAll

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ScheduledNotificationFullResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_scheduled_notification_threaded(
	# version: float   Eg: 3.16
	version: float,
	# scheduledNotificationId: float   Eg: 789
	# The id of scheduled notification to update
	scheduledNotificationId: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the scheduled notification
	name = "",
	# type: String = ""   Eg: type_example
	# The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
	type = "",
	# message: String = ""   Eg: message_example
	# The message to send
	message = "",
	# payload: String = ""   Eg: payload_example
	# The parameters for making an HTTP call
	payload = "",
	# contentId: float   Eg: 789
	# The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	contentId = null,
	# contentName: String = ""   Eg: contentName_example
	# The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	contentName = "",
	# contentType: String = ""   Eg: contentType_example
	# The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	contentType = "",
	# parentId: float   Eg: 789
	# The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	parentId = null,
	# parentType: String = ""   Eg: parentType_example
	# The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
	parentType = "",
	# appKey: String = ""   Eg: appKey_example
	# The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
	appKey = "",
	# groupingId: String = ""   Eg: groupingId_example
	# Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
	groupingId = "",
	# connectionGroupIds: String = ""   Eg: connectionGroupIds_example
	# The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
	connectionGroupIds = "",
	# connectionAccountIds: String = ""   Eg: connectionAccountIds_example
	# The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
	connectionAccountIds = "",
	# audienceId: float   Eg: 789
	# This parameter is deprecated. The audience used to generate the list of recipients
	audienceId = null,
	# audienceIds: String = ""   Eg: audienceIds_example
	# The audiences used to generate the list of recipients (comma separated list of audience IDs)
	audienceIds = "",
	# albumIds: String = ""   Eg: albumIds_example
	# The album ids to associate with the scheduled notification (comma separated list of album IDs)
	albumIds = "",
	# reportId: float   Eg: 789
	# The report used to generate the the list of recipients
	reportId = null,
	# reportParams: String = ""   Eg: reportParams_example
	# The parameters to supply to the report used to generate the the list of recipients
	reportParams = "",
	# endpointURL: String = ""   Eg: endpointURL_example
	# The URL for making an HTTP call
	endpointURL = "",
	# scheduledDate: float   Eg: 789
	# The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
	scheduledDate = null,
	# startDate: float   Eg: 789
	# The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
	startDate = null,
	# endDate: float   Eg: 789
	# The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
	endDate = null,
	# cronExpression: String = ""   Eg: cronExpression_example
	# The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
	cronExpression = "",
	# cronType: String = ""   Eg: cronType_example
	# The cron expression type: UNIX, CRON4J, QUARTZ
	cronType = "",
	# metaData: String = ""   Eg: metaData_example
	# Additional metadata for the scheduled notification
	metaData = "",
	# conditionalInput: String = ""   Eg: conditionalInput_example
	# Json input representing conditional logic that has to be met before running the scheduled notification
	conditionalInput = "",
	# templateType: String = ""   Eg: templateType_example
	# This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
	templateType = "",
	# visibility: String = ""   Eg: visibility_example
	# Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
	visibility = "",
	# active: bool   Eg: true
	# Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule.
	active = null,
	# errorMessage: String = ""   Eg: errorMessage_example
	# the error message associated with the scheduled notification
	errorMessage = "",
	# status: String = ""   Eg: status_example
	# the status of the scheduled notification
	status = "",
	# updateByGroupingId: bool   Eg: true
	# also updates ScheduledNotifications with the same groupingId and account
	updateByGroupingId = null,
	# sendNow: bool   Eg: true
	# whether to send the scheduled notification now or not
	sendNow = null,
	# eventType: String = "CUSTOM"   Eg: eventType_example
	# Sets the event type for the notification
	eventType = "CUSTOM",
	# deepLinkURI: String = ""   Eg: deepLinkURI_example
	# The payload deep link URI that can be used by the client app to direct users to a screen in the app
	deepLinkURI = "",
	# sendToAll: bool   Eg: true
	# Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
	sendToAll = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_scheduled_notification")
	bzz_callable.bind(
		version,
		scheduledNotificationId,
		accountId,
		name,
		type,
		message,
		payload,
		contentId,
		contentName,
		contentType,
		parentId,
		parentType,
		appKey,
		groupingId,
		connectionGroupIds,
		connectionAccountIds,
		audienceId,
		audienceIds,
		albumIds,
		reportId,
		reportParams,
		endpointURL,
		scheduledDate,
		startDate,
		endDate,
		cronExpression,
		cronType,
		metaData,
		conditionalInput,
		templateType,
		visibility,
		active,
		errorMessage,
		status,
		updateByGroupingId,
		sendNow,
		eventType,
		deepLinkURI,
		sendToAll,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


