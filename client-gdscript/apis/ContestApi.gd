extends ApiBee
class_name ContestApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API ContestApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "ContestApi"


# Operation addOrUpdateAlbumContest → POST /consumer/album/contest
# Create or Update Contest
#
# Creates or updates a contest.
func add_or_update_album_contest(
	# publicRead: bool   Eg: true
	# determines whether the contest's participants has read permissions
	publicRead: bool,
	# publicWrite: bool   Eg: true
	# determines whether the contest's participants has write permissions
	publicWrite: bool,
	# publicDelete: bool   Eg: true
	# determines whether the contest's participants has delete permissions
	publicDelete: bool,
	# publicAdd: bool   Eg: true
	# determines whether the contest's participants has add permissions
	publicAdd: bool,
	# visibility: String = ""   Eg: visibility_example
	# the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
	visibility: String,
	# includeFriendGroup: bool   Eg: true
	# determines whether to include all friends as participants
	includeFriendGroup: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated. the application key
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# contestType: String = ""   Eg: contestType_example
	# a custom field used for aggregation and searching
	contestType = "",
	# albumContestId: float   Eg: 789
	# the album contest ID for updating (don't pass in if creating)
	albumContestId = null,
	# title: String = ""   Eg: title_example
	# the title of the contest
	title = "",
	# description: String = ""   Eg: description_example
	# the description of the contest
	description = "",
	# albumId1: float   Eg: 789
	# the album ID for the first album
	albumId1 = null,
	# removeAlbum1: bool   Eg: true
	# removes album1 from the contest
	removeAlbum1 = null,
	# albumId2: float   Eg: 789
	# the album ID for the second album
	albumId2 = null,
	# removeAlbum2: bool   Eg: true
	# removes album2 from the contest
	removeAlbum2 = null,
	# startDate: float   Eg: 789
	# the start date of the contest (time-stamp in milliseconds)
	startDate = null,
	# endDate: float   Eg: 789
	# the end date of the contest (time-stamp in milliseconds)
	endDate = null,
	# locationDescription: String = ""   Eg: locationDescription_example
	# the location description of the contest taking place
	locationDescription = "",
	# connectionIdsToAdd: String = ""   Eg: connectionIdsToAdd_example
	# comma separated list of connection IDs
	connectionIdsToAdd = "",
	# connectionGroupIdsToAdd: String = ""   Eg: connectionGroupIdsToAdd_example
	# comma separated list of connection group IDs
	connectionGroupIdsToAdd = "",
	# latitude: int   Eg: 1.2
	# latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/album/contest"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["gameType"] = gameType
	bzz_query["appKey"] = appKey
	bzz_query["contestType"] = contestType
	bzz_query["albumContestId"] = albumContestId
	bzz_query["title"] = title
	bzz_query["description"] = description
	bzz_query["albumId1"] = albumId1
	bzz_query["removeAlbum1"] = removeAlbum1
	bzz_query["albumId2"] = albumId2
	bzz_query["removeAlbum2"] = removeAlbum2
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["publicRead"] = publicRead
	bzz_query["publicWrite"] = publicWrite
	bzz_query["publicDelete"] = publicDelete
	bzz_query["publicAdd"] = publicAdd
	bzz_query["locationDescription"] = locationDescription
	bzz_query["visibility"] = visibility
	bzz_query["connectionIdsToAdd"] = connectionIdsToAdd
	bzz_query["connectionGroupIdsToAdd"] = connectionGroupIdsToAdd
	bzz_query["includeFriendGroup"] = includeFriendGroup
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AlbumContestResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func add_or_update_album_contest_threaded(
	# publicRead: bool   Eg: true
	# determines whether the contest's participants has read permissions
	publicRead: bool,
	# publicWrite: bool   Eg: true
	# determines whether the contest's participants has write permissions
	publicWrite: bool,
	# publicDelete: bool   Eg: true
	# determines whether the contest's participants has delete permissions
	publicDelete: bool,
	# publicAdd: bool   Eg: true
	# determines whether the contest's participants has add permissions
	publicAdd: bool,
	# visibility: String = ""   Eg: visibility_example
	# the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
	visibility: String,
	# includeFriendGroup: bool   Eg: true
	# determines whether to include all friends as participants
	includeFriendGroup: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated. the application key
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# contestType: String = ""   Eg: contestType_example
	# a custom field used for aggregation and searching
	contestType = "",
	# albumContestId: float   Eg: 789
	# the album contest ID for updating (don't pass in if creating)
	albumContestId = null,
	# title: String = ""   Eg: title_example
	# the title of the contest
	title = "",
	# description: String = ""   Eg: description_example
	# the description of the contest
	description = "",
	# albumId1: float   Eg: 789
	# the album ID for the first album
	albumId1 = null,
	# removeAlbum1: bool   Eg: true
	# removes album1 from the contest
	removeAlbum1 = null,
	# albumId2: float   Eg: 789
	# the album ID for the second album
	albumId2 = null,
	# removeAlbum2: bool   Eg: true
	# removes album2 from the contest
	removeAlbum2 = null,
	# startDate: float   Eg: 789
	# the start date of the contest (time-stamp in milliseconds)
	startDate = null,
	# endDate: float   Eg: 789
	# the end date of the contest (time-stamp in milliseconds)
	endDate = null,
	# locationDescription: String = ""   Eg: locationDescription_example
	# the location description of the contest taking place
	locationDescription = "",
	# connectionIdsToAdd: String = ""   Eg: connectionIdsToAdd_example
	# comma separated list of connection IDs
	connectionIdsToAdd = "",
	# connectionGroupIdsToAdd: String = ""   Eg: connectionGroupIdsToAdd_example
	# comma separated list of connection group IDs
	connectionGroupIdsToAdd = "",
	# latitude: int   Eg: 1.2
	# latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "add_or_update_album_contest")
	bzz_callable.bind(
		publicRead,
		publicWrite,
		publicDelete,
		publicAdd,
		visibility,
		includeFriendGroup,
		deviceId,
		accountId,
		gameType,
		appKey,
		contestType,
		albumContestId,
		title,
		description,
		albumId1,
		removeAlbum1,
		albumId2,
		removeAlbum2,
		startDate,
		endDate,
		locationDescription,
		connectionIdsToAdd,
		connectionGroupIdsToAdd,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation approveAlbumContest → POST /consumer/album/contest/approve
# Approve Contest
#
# Sets the approval status of a contest.
func approve_album_contest(
	# albumContestId: float   Eg: 789
	# The ID of the album contest
	albumContestId: float,
	# approvalStatus: String = ""   Eg: approvalStatus_example
	# The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
	approvalStatus: String,
	# deviceId: String = ""   Eg: deviceId_example
	# A unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account ID of the user (deviceId or accountId required)
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/album/contest/approve"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["albumContestId"] = albumContestId
	bzz_query["approvalStatus"] = approvalStatus

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func approve_album_contest_threaded(
	# albumContestId: float   Eg: 789
	# The ID of the album contest
	albumContestId: float,
	# approvalStatus: String = ""   Eg: approvalStatus_example
	# The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
	approvalStatus: String,
	# deviceId: String = ""   Eg: deviceId_example
	# A unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account ID of the user (deviceId or accountId required)
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "approve_album_contest")
	bzz_callable.bind(
		albumContestId,
		approvalStatus,
		deviceId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteContest → POST /consumer/album/contest/remove
# Delete Contest
#
# Deletes a contest.
func delete_contest(
	# albumContestId: float   Eg: 789
	# the album contest ID
	albumContestId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# latitude: int   Eg: 1.2
	# latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/album/contest/remove"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["albumContestId"] = albumContestId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_contest_threaded(
	# albumContestId: float   Eg: 789
	# the album contest ID
	albumContestId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# latitude: int   Eg: 1.2
	# latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_contest")
	bzz_callable.bind(
		albumContestId,
		deviceId,
		accountId,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getAlbumContest → GET /consumer/album/contest/get
# Get Contest
#
# Gets the contest object including the likes and notes
func get_album_contest(
	# albumContestId: float   Eg: 789
	# the album contest ID
	albumContestId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# latitude: int   Eg: 1.2
	# latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/album/contest/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["albumContestId"] = albumContestId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AlbumContestResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_album_contest_threaded(
	# albumContestId: float   Eg: 789
	# the album contest ID
	albumContestId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# latitude: int   Eg: 1.2
	# latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_album_contest")
	bzz_callable.bind(
		albumContestId,
		deviceId,
		accountId,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getAlbumContests → GET /consumer/album/contest/search
# Search Contests
#
# Searches on contests.
func get_album_contests(
	# filter: String = ""   Eg: filter_example
	# a comma separated list of Ownership
	filter: String,
	# sortField: String = ""   Eg: sortField_example
	# the field to sort by. See AlbumContestApiMap
	sortField: String,
	# descending: bool   Eg: true
	# determines whether the sorted list is in descending or ascending order
	descending: bool,
	# start: int   Eg: 56
	# the start index for pagination
	start: int,
	# limit: int   Eg: 56
	# the limit for pagination (there is a hard limit of 30)
	limit: int,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# appType: String = ""   Eg: appType_example
	# the application type
	appType = "",
	# contestType: String = ""   Eg: contestType_example
	# filter contests with this contest type
	contestType = "",
	# ownerId: float   Eg: 789
	# search on contests that have been created by this account (that the user has permissions to)
	ownerId = null,
	# q: String = ""   Eg: q_example
	# This parameter is deprecated.
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# keyword search string
	keyword = "",
	# i: int   Eg: 56
	# This parameter is deprecated.
	i = null,
	# l: int   Eg: 56
	# This parameter is deprecated.
	l = null,
	# dateCreated: float   Eg: 789
	# filter on items that have been created before this date
	dateCreated = null,
	# latitude: int   Eg: 1.2
	# latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/album/contest/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["gameType"] = gameType
	bzz_query["appKey"] = appKey
	bzz_query["appType"] = appType
	bzz_query["contestType"] = contestType
	bzz_query["ownerId"] = ownerId
	bzz_query["q"] = q
	bzz_query["keyword"] = keyword
	bzz_query["filter"] = filter
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["_i"] = i
	bzz_query["start"] = start
	bzz_query["_l"] = l
	bzz_query["limit"] = limit
	bzz_query["dateCreated"] = dateCreated
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AlbumContestListResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_album_contests_threaded(
	# filter: String = ""   Eg: filter_example
	# a comma separated list of Ownership
	filter: String,
	# sortField: String = ""   Eg: sortField_example
	# the field to sort by. See AlbumContestApiMap
	sortField: String,
	# descending: bool   Eg: true
	# determines whether the sorted list is in descending or ascending order
	descending: bool,
	# start: int   Eg: 56
	# the start index for pagination
	start: int,
	# limit: int   Eg: 56
	# the limit for pagination (there is a hard limit of 30)
	limit: int,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# appType: String = ""   Eg: appType_example
	# the application type
	appType = "",
	# contestType: String = ""   Eg: contestType_example
	# filter contests with this contest type
	contestType = "",
	# ownerId: float   Eg: 789
	# search on contests that have been created by this account (that the user has permissions to)
	ownerId = null,
	# q: String = ""   Eg: q_example
	# This parameter is deprecated.
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# keyword search string
	keyword = "",
	# i: int   Eg: 56
	# This parameter is deprecated.
	i = null,
	# l: int   Eg: 56
	# This parameter is deprecated.
	l = null,
	# dateCreated: float   Eg: 789
	# filter on items that have been created before this date
	dateCreated = null,
	# latitude: int   Eg: 1.2
	# latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_album_contests")
	bzz_callable.bind(
		filter,
		sortField,
		descending,
		start,
		limit,
		deviceId,
		accountId,
		gameType,
		appKey,
		appType,
		contestType,
		ownerId,
		q,
		keyword,
		i,
		l,
		dateCreated,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation voteOnAlbumContest → POST /consumer/album/contest/vote
# Vote on Contest
#
# Vote on a collection in a contest.
func vote_on_album_contest(
	# albumContestId: float   Eg: 789
	# the album contest ID
	albumContestId: float,
	# albumId: float   Eg: 789
	# the ID of the album to vote on
	albumId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# contestType: String = ""   Eg: contestType_example
	# a custom field used for aggregation and searching
	contestType = "",
	# latitude: int   Eg: 1.2
	# latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/album/contest/vote"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["albumContestId"] = albumContestId
	bzz_query["albumId"] = albumId
	bzz_query["contestType"] = contestType
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AlbumContestResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func vote_on_album_contest_threaded(
	# albumContestId: float   Eg: 789
	# the album contest ID
	albumContestId: float,
	# albumId: float   Eg: 789
	# the ID of the album to vote on
	albumId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# contestType: String = ""   Eg: contestType_example
	# a custom field used for aggregation and searching
	contestType = "",
	# latitude: int   Eg: 1.2
	# latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "vote_on_album_contest")
	bzz_callable.bind(
		albumContestId,
		albumId,
		deviceId,
		accountId,
		contestType,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


