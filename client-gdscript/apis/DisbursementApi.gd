extends ApiBee
class_name DisbursementApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API DisbursementApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "DisbursementApi"


# Operation checkDisbursements → GET /disbursement/check
# Check Disbursements
#
# Checks the status of a captured disbrusement to see if it has been settled.
func check_disbursements(
	# disbursementId: float   Eg: 789
	# the ID of the disbursement being checked on
	disbursementId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/disbursement/check"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["disbursementId"] = disbursementId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = DisbursementResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func check_disbursements_threaded(
	# disbursementId: float   Eg: 789
	# the ID of the disbursement being checked on
	disbursementId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "check_disbursements")
	bzz_callable.bind(
		disbursementId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createDisbursement → POST /disbursement/create
# Create Disbursement
#
# Creates a Disbursement for sending money to a retailer
func create_disbursement(
	# accountId: float   Eg: 789
	# the ID of the logging in user (must be an EXECUTIVE account)
	accountId: float,
	# receiverAccountId: float   Eg: 789
	# the ID of the account receiving the disbursement
	receiverAccountId: float,
	# originalSenderAccountId: float   Eg: 789
	# the ID of the original sender account
	originalSenderAccountId: float,
	# amount: float   Eg: 8.14
	# the dollar amount of the disbursement
	amount: float,
	# provider: String = ""   Eg: provider_example
	# the provider (e.g. Authorize.net, Bill.com, etc.)
	provider: String,
	# scheduledDate: float   Eg: 789
	# the date that the disbursement is scheduled to go out to the payment provider
	scheduledDate = null,
	# title: String = ""   Eg: title_example
	# a title given for the disbursement
	title = "",
	# comment: String = ""   Eg: comment_example
	# a comment that could be made for a disbursement
	comment = "",
	# externalId: String = ""   Eg: externalId_example
	# external ID, which can be used as a way to reference the disbursement
	externalId = "",
	# introspectionParams: String = ""   Eg: introspectionParams_example
	# This is for specifying parameters to make an http callback request for validating that the disbursement is valid
	introspectionParams = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/disbursement/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["receiverAccountId"] = receiverAccountId
	bzz_query["originalSenderAccountId"] = originalSenderAccountId
	bzz_query["amount"] = amount
	bzz_query["provider"] = provider
	bzz_query["scheduledDate"] = scheduledDate
	bzz_query["title"] = title
	bzz_query["comment"] = comment
	bzz_query["externalId"] = externalId
	bzz_query["introspectionParams"] = introspectionParams

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = DisbursementResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_disbursement_threaded(
	# accountId: float   Eg: 789
	# the ID of the logging in user (must be an EXECUTIVE account)
	accountId: float,
	# receiverAccountId: float   Eg: 789
	# the ID of the account receiving the disbursement
	receiverAccountId: float,
	# originalSenderAccountId: float   Eg: 789
	# the ID of the original sender account
	originalSenderAccountId: float,
	# amount: float   Eg: 8.14
	# the dollar amount of the disbursement
	amount: float,
	# provider: String = ""   Eg: provider_example
	# the provider (e.g. Authorize.net, Bill.com, etc.)
	provider: String,
	# scheduledDate: float   Eg: 789
	# the date that the disbursement is scheduled to go out to the payment provider
	scheduledDate = null,
	# title: String = ""   Eg: title_example
	# a title given for the disbursement
	title = "",
	# comment: String = ""   Eg: comment_example
	# a comment that could be made for a disbursement
	comment = "",
	# externalId: String = ""   Eg: externalId_example
	# external ID, which can be used as a way to reference the disbursement
	externalId = "",
	# introspectionParams: String = ""   Eg: introspectionParams_example
	# This is for specifying parameters to make an http callback request for validating that the disbursement is valid
	introspectionParams = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_disbursement")
	bzz_callable.bind(
		accountId,
		receiverAccountId,
		originalSenderAccountId,
		amount,
		provider,
		scheduledDate,
		title,
		comment,
		externalId,
		introspectionParams,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getDisbursement → GET /disbursement/get
# Get Disbursement
#
# Get Disbursement details
func get_disbursement(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# disbursementId: float   Eg: 789
	# the id of the disbursement
	disbursementId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/disbursement/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["disbursementId"] = disbursementId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = DisbursementResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_disbursement_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# disbursementId: float   Eg: 789
	# the id of the disbursement
	disbursementId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_disbursement")
	bzz_callable.bind(
		accountId,
		disbursementId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchDisbursements → GET /disbursement/search
# Search Disbursements
#
# Search Disbursements
func search_disbursements(
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# receiverAccountId: float   Eg: 789
	# filter results by the id of the account receiving the disbursement
	receiverAccountId = null,
	# statuses: String = ""   Eg: statuses_example
	# comma separated list of status values to search for, possilbe values include: NEW, APPROVED, VALIDATING, ERROR, AUTHORIZED, CAPTURED, SETTLED
	statuses = "",
	# providers: String = ""   Eg: providers_example
	# comma separated list of payment providers to search for, possbile values include: AUTHORIZE_NET, AMAZON_FPS, BILL_COM
	providers = "",
	# beforeDate: float   Eg: 789
	# the date for searching disbursements before it has been processed
	beforeDate = null,
	# afterDate: float   Eg: 789
	# the date for searching disbursements before it has been processed
	afterDate = null,
	# start: int = 0   Eg: 56
	# the start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# the limit per result set for pagination
	limit = 20,
	# activeOnly: bool = false   Eg: true
	# search on disbursements that are active only
	activeOnly = false,
	# externalId: String = ""   Eg: externalId_example
	# search results by this external ID (that can be used to reference the disbursement)
	externalId = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/disbursement/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["receiverAccountId"] = receiverAccountId
	bzz_query["statuses"] = statuses
	bzz_query["providers"] = providers
	bzz_query["beforeDate"] = beforeDate
	bzz_query["afterDate"] = afterDate
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["activeOnly"] = activeOnly
	bzz_query["externalId"] = externalId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = DisbursementResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_disbursements_threaded(
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# receiverAccountId: float   Eg: 789
	# filter results by the id of the account receiving the disbursement
	receiverAccountId = null,
	# statuses: String = ""   Eg: statuses_example
	# comma separated list of status values to search for, possilbe values include: NEW, APPROVED, VALIDATING, ERROR, AUTHORIZED, CAPTURED, SETTLED
	statuses = "",
	# providers: String = ""   Eg: providers_example
	# comma separated list of payment providers to search for, possbile values include: AUTHORIZE_NET, AMAZON_FPS, BILL_COM
	providers = "",
	# beforeDate: float   Eg: 789
	# the date for searching disbursements before it has been processed
	beforeDate = null,
	# afterDate: float   Eg: 789
	# the date for searching disbursements before it has been processed
	afterDate = null,
	# start: int = 0   Eg: 56
	# the start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# the limit per result set for pagination
	limit = 20,
	# activeOnly: bool = false   Eg: true
	# search on disbursements that are active only
	activeOnly = false,
	# externalId: String = ""   Eg: externalId_example
	# search results by this external ID (that can be used to reference the disbursement)
	externalId = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_disbursements")
	bzz_callable.bind(
		accountId,
		receiverAccountId,
		statuses,
		providers,
		beforeDate,
		afterDate,
		start,
		limit,
		activeOnly,
		externalId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateDisbursement → POST /disbursement/update
# Update Disbursement
#
# Update Disbursement
func update_disbursement(
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# disbursementId: float   Eg: 789
	# the id of the disbursement being updated
	disbursementId: float,
	# amount: float   Eg: 8.14
	# the disbursement dollar amount being updated
	amount = null,
	# provider: String = ""   Eg: provider_example
	# the payments and/or billing provider (e.g. Authorize.net, Bill.com, etc.)
	provider = "",
	# scheduledDate: float   Eg: 789
	# the date that the disbursement is scheduled to go out to the payment provider
	scheduledDate = null,
	# title: String = ""   Eg: title_example
	# the title given to the disbursement
	title = "",
	# comment: String = ""   Eg: comment_example
	# a comment that can be made on a disbursement
	comment = "",
	# externalId: String = ""   Eg: externalId_example
	# an external ID that can be used to reference the disbursement
	externalId = "",
	# retry: bool   Eg: true
	# determines whether to try sending the disbursement again in the case of a previous failure
	retry = null,
	# introspectionParams: String = ""   Eg: introspectionParams_example
	# for specifying parameters to make an http callback request for validating that the disbursement is valid
	introspectionParams = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/disbursement/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["disbursementId"] = disbursementId
	bzz_query["amount"] = amount
	bzz_query["provider"] = provider
	bzz_query["scheduledDate"] = scheduledDate
	bzz_query["title"] = title
	bzz_query["comment"] = comment
	bzz_query["externalId"] = externalId
	bzz_query["retry"] = retry
	bzz_query["introspectionParams"] = introspectionParams

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = DisbursementResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_disbursement_threaded(
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# disbursementId: float   Eg: 789
	# the id of the disbursement being updated
	disbursementId: float,
	# amount: float   Eg: 8.14
	# the disbursement dollar amount being updated
	amount = null,
	# provider: String = ""   Eg: provider_example
	# the payments and/or billing provider (e.g. Authorize.net, Bill.com, etc.)
	provider = "",
	# scheduledDate: float   Eg: 789
	# the date that the disbursement is scheduled to go out to the payment provider
	scheduledDate = null,
	# title: String = ""   Eg: title_example
	# the title given to the disbursement
	title = "",
	# comment: String = ""   Eg: comment_example
	# a comment that can be made on a disbursement
	comment = "",
	# externalId: String = ""   Eg: externalId_example
	# an external ID that can be used to reference the disbursement
	externalId = "",
	# retry: bool   Eg: true
	# determines whether to try sending the disbursement again in the case of a previous failure
	retry = null,
	# introspectionParams: String = ""   Eg: introspectionParams_example
	# for specifying parameters to make an http callback request for validating that the disbursement is valid
	introspectionParams = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_disbursement")
	bzz_callable.bind(
		accountId,
		disbursementId,
		amount,
		provider,
		scheduledDate,
		title,
		comment,
		externalId,
		retry,
		introspectionParams,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


