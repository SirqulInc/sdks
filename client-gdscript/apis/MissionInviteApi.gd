extends ApiBee
class_name MissionInviteApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API MissionInviteApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "MissionInviteApi"


# Operation createMissionInvite → POST /api/{version}/mission/invite/create
# Create Mission Invite
#
# Create the mission invite. An account can only be invited to a mission one time. For missions that require user submission and reviewing the permissionableType and permissionableId need to be provided.
func create_mission_invite(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required).
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required).
	accountId = null,
	# missionId: float   Eg: 789
	# The mission to find the invite for.
	missionId = null,
	# joinCode: String = ""   Eg: joinCode_example
	# code to be entered for user to join the mission
	joinCode = "",
	# includeGameData: bool   Eg: true
	# Include the game level data with the mission.
	includeGameData = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/mission/invite/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["missionId"] = missionId
	bzz_query["joinCode"] = joinCode
	bzz_query["includeGameData"] = includeGameData

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = MissionResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_mission_invite_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required).
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required).
	accountId = null,
	# missionId: float   Eg: 789
	# The mission to find the invite for.
	missionId = null,
	# joinCode: String = ""   Eg: joinCode_example
	# code to be entered for user to join the mission
	joinCode = "",
	# includeGameData: bool   Eg: true
	# Include the game level data with the mission.
	includeGameData = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_mission_invite")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		missionId,
		joinCode,
		includeGameData,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteMissionInvite → POST /api/{version}/mission/invite/delete
# Delete Mission Invite
#
# Update the mission invite status to quit.
func delete_mission_invite(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required).
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required).
	accountId = null,
	# missionId: float   Eg: 789
	# The mission to find the invite for (missionId or missionInviteId requried).
	missionId = null,
	# missionInviteId: float   Eg: 789
	# The mission invite id. This checks on the user's billable for permission (missionId or missionInviteId requried).
	missionInviteId = null,
	# includeGameData: bool   Eg: true
	# Include the game level data with the mission.
	includeGameData = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/mission/invite/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["missionId"] = missionId
	bzz_query["missionInviteId"] = missionInviteId
	bzz_query["includeGameData"] = includeGameData

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_mission_invite_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required).
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required).
	accountId = null,
	# missionId: float   Eg: 789
	# The mission to find the invite for (missionId or missionInviteId requried).
	missionId = null,
	# missionInviteId: float   Eg: 789
	# The mission invite id. This checks on the user's billable for permission (missionId or missionInviteId requried).
	missionInviteId = null,
	# includeGameData: bool   Eg: true
	# Include the game level data with the mission.
	includeGameData = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_mission_invite")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		missionId,
		missionInviteId,
		includeGameData,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getMissionInvite → GET /api/{version}/mission/invite/get
# Get Mission Invite
#
# Get the mission invite. An account can only be invited to a mission one time.
func get_mission_invite(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required).
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required).
	accountId = null,
	# missionId: float   Eg: 789
	# The mission to find the invite for (missionId or missionInviteId requried).
	missionId = null,
	# missionInviteId: float   Eg: 789
	# The mission invite id. This checks on the user's billable for permission (missionId or missionInviteId requried).
	missionInviteId = null,
	# includeGameData: bool   Eg: true
	# Include the game level data with the mission.
	includeGameData = null,
	# includeScores: String = ""   Eg: includeScores_example
	# include the scores with the mission
	includeScores = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/mission/invite/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["missionId"] = missionId
	bzz_query["missionInviteId"] = missionInviteId
	bzz_query["includeGameData"] = includeGameData
	bzz_query["includeScores"] = includeScores

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = MissionResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_mission_invite_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required).
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required).
	accountId = null,
	# missionId: float   Eg: 789
	# The mission to find the invite for (missionId or missionInviteId requried).
	missionId = null,
	# missionInviteId: float   Eg: 789
	# The mission invite id. This checks on the user's billable for permission (missionId or missionInviteId requried).
	missionInviteId = null,
	# includeGameData: bool   Eg: true
	# Include the game level data with the mission.
	includeGameData = null,
	# includeScores: String = ""   Eg: includeScores_example
	# include the scores with the mission
	includeScores = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_mission_invite")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		missionId,
		missionInviteId,
		includeGameData,
		includeScores,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchMissionInvites → GET /api/{version}/mission/invite/search
# Search Mission Invites
#
# Get a list of mission invites that the account has.
func search_mission_invites(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required).
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required).
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# the app to retrieve the data for, use your application key.
	appKey = "",
	# appVersion: String = ""   Eg: appVersion_example
	# the application version, used to version the game level data
	appVersion = "",
	# missionId: float   Eg: 789
	# the mission id to filter on
	missionId = null,
	# status: String = ""   Eg: status_example
	# The invite status to filter for, comma separated list {AVAILABLE, PENDING, UPDATED, ACCEPTED, ACTIVE, QUIT, COMPLETED, PENDING_REVIEW, REJECTED}
	status = "",
	# lastUpdated: float   Eg: 789
	# Only return invites that have been updated since this date/time (long)
	lastUpdated = null,
	# start: int   Eg: 56
	# The index into the record set to start with.
	start = null,
	# limit: int   Eg: 56
	# The total number of record to return.
	limit = null,
	# keyword: String = ""   Eg: keyword_example
	# the keyword to search on
	keyword = "",
	# missionTypes: String = ""   Eg: missionTypes_example
	missionTypes = "",
	# filterByBillable: bool   Eg: true
	# filter results by the account's billable
	filterByBillable = null,
	# includeGameData: bool   Eg: true
	# Include the game level data with the mission.
	includeGameData = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/mission/invite/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["appVersion"] = appVersion
	bzz_query["missionId"] = missionId
	bzz_query["status"] = status
	bzz_query["lastUpdated"] = lastUpdated
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["keyword"] = keyword
	bzz_query["missionTypes"] = missionTypes
	bzz_query["filterByBillable"] = filterByBillable
	bzz_query["includeGameData"] = includeGameData

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = MissionResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_mission_invites_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required).
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required).
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# the app to retrieve the data for, use your application key.
	appKey = "",
	# appVersion: String = ""   Eg: appVersion_example
	# the application version, used to version the game level data
	appVersion = "",
	# missionId: float   Eg: 789
	# the mission id to filter on
	missionId = null,
	# status: String = ""   Eg: status_example
	# The invite status to filter for, comma separated list {AVAILABLE, PENDING, UPDATED, ACCEPTED, ACTIVE, QUIT, COMPLETED, PENDING_REVIEW, REJECTED}
	status = "",
	# lastUpdated: float   Eg: 789
	# Only return invites that have been updated since this date/time (long)
	lastUpdated = null,
	# start: int   Eg: 56
	# The index into the record set to start with.
	start = null,
	# limit: int   Eg: 56
	# The total number of record to return.
	limit = null,
	# keyword: String = ""   Eg: keyword_example
	# the keyword to search on
	keyword = "",
	# missionTypes: String = ""   Eg: missionTypes_example
	missionTypes = "",
	# filterByBillable: bool   Eg: true
	# filter results by the account's billable
	filterByBillable = null,
	# includeGameData: bool   Eg: true
	# Include the game level data with the mission.
	includeGameData = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_mission_invites")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		appKey,
		appVersion,
		missionId,
		status,
		lastUpdated,
		start,
		limit,
		keyword,
		missionTypes,
		filterByBillable,
		includeGameData,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateMissionInvite → POST /api/{version}/mission/invite/update
# Update Mission Invite
#
# Update the mission invite status. An account can only be invited to a mission one time. For missions that require user submission and reviewing the permissionableType and permissionableId need to be provided.
func update_mission_invite(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required).
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required).
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# missionId: float   Eg: 789
	# The mission to find the invite for (missionId or missionInviteId requried).
	missionId = null,
	# missionInviteId: float   Eg: 789
	# The mission invite id. This checks on the user's billable for permission (missionId or missionInviteId requried).
	missionInviteId = null,
	# packId: float   Eg: 789
	# the pack id to find the invite for
	packId = null,
	# gameLevelId: float   Eg: 789
	# the game level id to find the invite for
	gameLevelId = null,
	# status: String = ""   Eg: status_example
	# The invite status to filter for, comma separated list {AVAILABLE, PENDING, UPDATED, ACCEPTED, ACTIVE, QUIT, COMPLETED, PENDING_REVIEW, REJECTED}
	status = "",
	# permissionableType: String = ""   Eg: permissionableType_example
	# This is the content type for missions that require user submission. Note that user submitted content must require a status of PENDING_REVIEW to be accpeted. {ACCOUNT, GAMELEVEL, COLLECTION, ALBUM_CONTEST, THEME_DESCRIPTOR, ALBUM}
	permissionableType = "",
	# permissionableId: float   Eg: 789
	# The id of the content being submitted.
	permissionableId = null,
	# includeGameData: bool   Eg: true
	# Include the game level data with the mission.
	includeGameData = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/mission/invite/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["missionId"] = missionId
	bzz_query["missionInviteId"] = missionInviteId
	bzz_query["packId"] = packId
	bzz_query["gameLevelId"] = gameLevelId
	bzz_query["status"] = status
	bzz_query["permissionableType"] = permissionableType
	bzz_query["permissionableId"] = permissionableId
	bzz_query["includeGameData"] = includeGameData

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = MissionResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_mission_invite_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required).
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required).
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# missionId: float   Eg: 789
	# The mission to find the invite for (missionId or missionInviteId requried).
	missionId = null,
	# missionInviteId: float   Eg: 789
	# The mission invite id. This checks on the user's billable for permission (missionId or missionInviteId requried).
	missionInviteId = null,
	# packId: float   Eg: 789
	# the pack id to find the invite for
	packId = null,
	# gameLevelId: float   Eg: 789
	# the game level id to find the invite for
	gameLevelId = null,
	# status: String = ""   Eg: status_example
	# The invite status to filter for, comma separated list {AVAILABLE, PENDING, UPDATED, ACCEPTED, ACTIVE, QUIT, COMPLETED, PENDING_REVIEW, REJECTED}
	status = "",
	# permissionableType: String = ""   Eg: permissionableType_example
	# This is the content type for missions that require user submission. Note that user submitted content must require a status of PENDING_REVIEW to be accpeted. {ACCOUNT, GAMELEVEL, COLLECTION, ALBUM_CONTEST, THEME_DESCRIPTOR, ALBUM}
	permissionableType = "",
	# permissionableId: float   Eg: 789
	# The id of the content being submitted.
	permissionableId = null,
	# includeGameData: bool   Eg: true
	# Include the game level data with the mission.
	includeGameData = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_mission_invite")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		appKey,
		missionId,
		missionInviteId,
		packId,
		gameLevelId,
		status,
		permissionableType,
		permissionableId,
		includeGameData,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


