extends ApiBee
class_name SecureAppApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API SecureAppApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "SecureAppApi"


# Operation createSecureApplication → POST /api/{version}/secure/application/create
# Create Secure Application
#
# Create a secure application record.
func create_secure_application(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The unique id of the user making the request
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application to secure
	appKey: String,
	# keyCert: String   Eg: BINARY_DATA_HERE
	keyCert: String,
	# trustStore: String   Eg: BINARY_DATA_HERE
	trustStore: String,
	# username: String = ""   Eg: username_example
	username: String,
	# password: String = ""   Eg: password_example
	password: String,
	# active: bool = true   Eg: true
	active = true,
	# biometricType: String = "FACIAL"   Eg: biometricType_example
	# The type of biometric, options are: - FINGERPRINT - IRIS - FACIAL
	biometricType = "FACIAL",
	# biometricPosition: String = "UNKNOWN"   Eg: biometricPosition_example
	# The position for the biometric file uploaded
	biometricPosition = "UNKNOWN",
	# biometricPosition2: String = "UNKNOWN"   Eg: biometricPosition2_example
	# The position for each the biometric2 file uploaded
	biometricPosition2 = "UNKNOWN",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/secure/application/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["active"] = active
	bzz_query["keyCert"] = keyCert
	bzz_query["trustStore"] = trustStore
	bzz_query["username"] = username
	bzz_query["password"] = password
	bzz_query["biometricType"] = biometricType
	bzz_query["biometricPosition"] = biometricPosition
	bzz_query["biometricPosition2"] = biometricPosition2

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_secure_application_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The unique id of the user making the request
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application to secure
	appKey: String,
	# keyCert: String   Eg: BINARY_DATA_HERE
	keyCert: String,
	# trustStore: String   Eg: BINARY_DATA_HERE
	trustStore: String,
	# username: String = ""   Eg: username_example
	username: String,
	# password: String = ""   Eg: password_example
	password: String,
	# active: bool = true   Eg: true
	active = true,
	# biometricType: String = "FACIAL"   Eg: biometricType_example
	# The type of biometric, options are: - FINGERPRINT - IRIS - FACIAL
	biometricType = "FACIAL",
	# biometricPosition: String = "UNKNOWN"   Eg: biometricPosition_example
	# The position for the biometric file uploaded
	biometricPosition = "UNKNOWN",
	# biometricPosition2: String = "UNKNOWN"   Eg: biometricPosition2_example
	# The position for each the biometric2 file uploaded
	biometricPosition2 = "UNKNOWN",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_secure_application")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		keyCert,
		trustStore,
		username,
		password,
		active,
		biometricType,
		biometricPosition,
		biometricPosition2,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteSecureApplication → POST /api/{version}/secure/application/delete
# Delete Secure Application
#
# Delete a secure application record.
func delete_secure_application(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The unique id of the user making the request
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application to secure
	appKey: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/secure/application/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_secure_application_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The unique id of the user making the request
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application to secure
	appKey: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_secure_application")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation loginSecure → POST /api/{version}/secure/login
# Login Clear
#
# Login via Clear.me. Creates a new account if logging in for the first time.
func login_secure(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application making the request, defines what type and position is required to make a secure login the request.
	appKey: String,
	# biometricFile: String   Eg: BINARY_DATA_HERE
	# The data file used to perform authentication
	biometricFile: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request
	deviceId = "",
	# biometricFile2: String   Eg: BINARY_DATA_HERE
	# The data file used to perform authentication
	biometricFile2 = null,
	# ageRestriction: int = 0   Eg: 56
	# Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.
	ageRestriction = 0,
	# returnProfile: bool = false   Eg: true
	# Determines whether to return a ProfileResponse on success, or a PaymentTypesResponse
	returnProfile = false,
	# responseFilters: String = "PROFILE"   Eg: responseFilters_example
	# If returnProfile is set to true, this determines how much of the profile should be returned, see ProfileFilters
	responseFilters = "PROFILE",
	# latitude: int   Eg: 1.2
	# Used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# Used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/secure/login".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["appKey"] = appKey
	bzz_query["biometricFile"] = biometricFile
	bzz_query["biometricFile2"] = biometricFile2
	bzz_query["ageRestriction"] = ageRestriction
	bzz_query["returnProfile"] = returnProfile
	bzz_query["responseFilters"] = responseFilters
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ProfileResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func login_secure_threaded(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application making the request, defines what type and position is required to make a secure login the request.
	appKey: String,
	# biometricFile: String   Eg: BINARY_DATA_HERE
	# The data file used to perform authentication
	biometricFile: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request
	deviceId = "",
	# biometricFile2: String   Eg: BINARY_DATA_HERE
	# The data file used to perform authentication
	biometricFile2 = null,
	# ageRestriction: int = 0   Eg: 56
	# Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.
	ageRestriction = 0,
	# returnProfile: bool = false   Eg: true
	# Determines whether to return a ProfileResponse on success, or a PaymentTypesResponse
	returnProfile = false,
	# responseFilters: String = "PROFILE"   Eg: responseFilters_example
	# If returnProfile is set to true, this determines how much of the profile should be returned, see ProfileFilters
	responseFilters = "PROFILE",
	# latitude: int   Eg: 1.2
	# Used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# Used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "login_secure")
	bzz_callable.bind(
		version,
		appKey,
		biometricFile,
		deviceId,
		biometricFile2,
		ageRestriction,
		returnProfile,
		responseFilters,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation purchaseSecure → POST /api/{version}/secure/purchase
# Purchase Clear
#
# Purchase via Clear.me. Creates a new account if purchasing for the first time.
func purchase_secure(
	# version: float   Eg: 3.16
	version: float,
	# body: PaymentRequest
	# The payment request object
	body: PaymentRequest,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/secure/purchase".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_consumable_by_server := ['application/json']
	var bzz_found_producible_mime := false
	for bzz_mime in BZZ_PRODUCIBLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_consumable_by_server:
			bzz_headers["Content-Type"] = bzz_mime
			bzz_found_producible_mime = true
			break
	if not bzz_found_producible_mime:
		var error := ApiError.new()
		error.identifier = "purchase_secure.headers.content_type"
		error.message = "That endpoint only accepts %s as content type(s) and none are supported by this client."
		on_failure.call(error)
		return
	var bzz_mimes_produced_by_server := ['application/json']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null
	bzz_body = body

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ProfileResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func purchase_secure_threaded(
	# version: float   Eg: 3.16
	version: float,
	# body: PaymentRequest
	# The payment request object
	body: PaymentRequest,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "purchase_secure")
	bzz_callable.bind(
		version,
		body,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation resetSecure → POST /api/{version}/secure/application/reset
# Rest Secure Application
#
# Reset a secure application client.
func reset_secure(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The unique id of the user making the request
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application to secure
	appKey: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/secure/application/reset".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func reset_secure_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The unique id of the user making the request
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application to secure
	appKey: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "reset_secure")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateSecureApplication → POST /api/{version}/secure/application/update
# Update Secure Application
#
# Update a secure application record.
func update_secure_application(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The unique id of the user making the request
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application to secure
	appKey: String,
	# active: bool   Eg: true
	active = null,
	# keyCert: String   Eg: BINARY_DATA_HERE
	keyCert = null,
	# trustStore: String   Eg: BINARY_DATA_HERE
	trustStore = null,
	# username: String = ""   Eg: username_example
	username = "",
	# password: String = ""   Eg: password_example
	password = "",
	# biometricType: String = ""   Eg: biometricType_example
	# The type of biometric, options are: - FINGERPRINT - IRIS - FACIAL
	biometricType = "",
	# biometricPosition: String = ""   Eg: biometricPosition_example
	# The position for the biometric file uploaded
	biometricPosition = "",
	# biometricPosition2: String = ""   Eg: biometricPosition2_example
	# The position for each the biometric2 file uploaded
	biometricPosition2 = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/secure/application/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["active"] = active
	bzz_query["keyCert"] = keyCert
	bzz_query["trustStore"] = trustStore
	bzz_query["username"] = username
	bzz_query["password"] = password
	bzz_query["biometricType"] = biometricType
	bzz_query["biometricPosition"] = biometricPosition
	bzz_query["biometricPosition2"] = biometricPosition2

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_secure_application_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The unique id of the user making the request
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application to secure
	appKey: String,
	# active: bool   Eg: true
	active = null,
	# keyCert: String   Eg: BINARY_DATA_HERE
	keyCert = null,
	# trustStore: String   Eg: BINARY_DATA_HERE
	trustStore = null,
	# username: String = ""   Eg: username_example
	username = "",
	# password: String = ""   Eg: password_example
	password = "",
	# biometricType: String = ""   Eg: biometricType_example
	# The type of biometric, options are: - FINGERPRINT - IRIS - FACIAL
	biometricType = "",
	# biometricPosition: String = ""   Eg: biometricPosition_example
	# The position for the biometric file uploaded
	biometricPosition = "",
	# biometricPosition2: String = ""   Eg: biometricPosition2_example
	# The position for each the biometric2 file uploaded
	biometricPosition2 = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_secure_application")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		active,
		keyCert,
		trustStore,
		username,
		password,
		biometricType,
		biometricPosition,
		biometricPosition2,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


