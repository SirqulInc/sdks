extends ApiBee
class_name TriggerApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API TriggerApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "TriggerApi"


# Operation createTrigger → POST /api/{version}/trigger/create
# Create Trigger
#
# Create a trigger
func create_trigger(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the trigger
	name: String,
	# appKey: String = ""   Eg: appKey_example
	# The application to target
	appKey = "",
	# groupingId: String = ""   Eg: groupingId_example
	# Client defined identifier for grouping triggers
	groupingId = "",
	# endpointURL: String = ""   Eg: endpointURL_example
	# The URL for making an HTTP call
	endpointURL = "",
	# payload: String = ""   Eg: payload_example
	# The parameters for making an HTTP call
	payload = "",
	# scheduledDate: float   Eg: 789
	# The date and time of the next trigger
	scheduledDate = null,
	# startDate: float   Eg: 789
	# The starting date of the trigger
	startDate = null,
	# endDate: float   Eg: 789
	# The ending date of the trigger
	endDate = null,
	# cronExpression: String = ""   Eg: cronExpression_example
	# The cron expression that represents the trigger's schedule
	cronExpression = "",
	# conditionalInput: String = ""   Eg: conditionalInput_example
	# Json input representing conditional logic that has to be met before running the trigger
	conditionalInput = "",
	# visibility: String = ""   Eg: visibility_example
	# The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
	visibility = "",
	# active: bool = true   Eg: true
	# Sets whether the Trigger is active or not (inactive Triggers are not processed)
	active = true,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/trigger/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["name"] = name
	bzz_query["appKey"] = appKey
	bzz_query["groupingId"] = groupingId
	bzz_query["endpointURL"] = endpointURL
	bzz_query["payload"] = payload
	bzz_query["scheduledDate"] = scheduledDate
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["cronExpression"] = cronExpression
	bzz_query["conditionalInput"] = conditionalInput
	bzz_query["visibility"] = visibility
	bzz_query["active"] = active

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = TriggerResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_trigger_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the trigger
	name: String,
	# appKey: String = ""   Eg: appKey_example
	# The application to target
	appKey = "",
	# groupingId: String = ""   Eg: groupingId_example
	# Client defined identifier for grouping triggers
	groupingId = "",
	# endpointURL: String = ""   Eg: endpointURL_example
	# The URL for making an HTTP call
	endpointURL = "",
	# payload: String = ""   Eg: payload_example
	# The parameters for making an HTTP call
	payload = "",
	# scheduledDate: float   Eg: 789
	# The date and time of the next trigger
	scheduledDate = null,
	# startDate: float   Eg: 789
	# The starting date of the trigger
	startDate = null,
	# endDate: float   Eg: 789
	# The ending date of the trigger
	endDate = null,
	# cronExpression: String = ""   Eg: cronExpression_example
	# The cron expression that represents the trigger's schedule
	cronExpression = "",
	# conditionalInput: String = ""   Eg: conditionalInput_example
	# Json input representing conditional logic that has to be met before running the trigger
	conditionalInput = "",
	# visibility: String = ""   Eg: visibility_example
	# The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
	visibility = "",
	# active: bool = true   Eg: true
	# Sets whether the Trigger is active or not (inactive Triggers are not processed)
	active = true,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_trigger")
	bzz_callable.bind(
		version,
		accountId,
		name,
		appKey,
		groupingId,
		endpointURL,
		payload,
		scheduledDate,
		startDate,
		endDate,
		cronExpression,
		conditionalInput,
		visibility,
		active,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteTrigger → POST /api/{version}/trigger/delete
# Delete Trigger
#
# Mark a trigger as deleted.
func delete_trigger(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# triggerId: float   Eg: 789
	# The id of the trigger to delete.
	triggerId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/trigger/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["triggerId"] = triggerId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_trigger_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# triggerId: float   Eg: 789
	# The id of the trigger to delete.
	triggerId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_trigger")
	bzz_callable.bind(
		version,
		accountId,
		triggerId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getTrigger → GET /api/{version}/trigger/get
# Get Trigger
#
# Get a trigger
func get_trigger(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# triggerId: float   Eg: 789
	# The id of the Trigger to return.
	triggerId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/trigger/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["triggerId"] = triggerId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = TriggerResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_trigger_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# triggerId: float   Eg: 789
	# The id of the Trigger to return.
	triggerId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_trigger")
	bzz_callable.bind(
		version,
		accountId,
		triggerId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchTriggers → GET /api/{version}/trigger/search
# Search Triggers
#
# Search for triggers
func search_triggers(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# groupingId: String = ""   Eg: groupingId_example
	# Filter results by a grouping identifier defined by the client
	groupingId = "",
	# filter: String = "MINE"   Eg: filter_example
	# A comma separated list of filters. * MINE - Return triggers that the user has created * SHARED - Return triggers that have been shared to the user * FOLLOWER - Return triggers that have been created by the user''s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return triggers that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC triggers that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC triggers regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all triggers that the user has liked * FEATURED - Return all triggers that have been featured * PENDING - Return all pending triggers 
	filter = "MINE",
	# statuses: String = "NEW,ERROR,COMPLETE,PROCESSING"   Eg: statuses_example
	# Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE
	statuses = "NEW,ERROR,COMPLETE,PROCESSING",
	# templateTypes: String = ""   Eg: templateTypes_example
	# Template Types
	templateTypes = "",
	# appKey: String = ""   Eg: appKey_example
	# Filter the list by a specific application
	appKey = "",
	# keyword: String = ""   Eg: keyword_example
	# Keyword search on the trigger names.
	keyword = "",
	# sortField: String = "CREATED"   Eg: sortField_example
	# The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE
	sortField = "CREATED",
	# descending: bool = true   Eg: true
	# Determines whether the sorted list is in descending or ascending order
	descending = true,
	# start: int = 0   Eg: 56
	# Start the result set at some index.
	start = 0,
	# limit: int = 20   Eg: 56
	# Limit the result to some number.
	limit = 20,
	# activeOnly: bool = true   Eg: true
	# Determines whether to return only active results
	activeOnly = true,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/trigger/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["groupingId"] = groupingId
	bzz_query["filter"] = filter
	bzz_query["statuses"] = statuses
	bzz_query["templateTypes"] = templateTypes
	bzz_query["appKey"] = appKey
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["activeOnly"] = activeOnly

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = TriggerResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_triggers_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# groupingId: String = ""   Eg: groupingId_example
	# Filter results by a grouping identifier defined by the client
	groupingId = "",
	# filter: String = "MINE"   Eg: filter_example
	# A comma separated list of filters. * MINE - Return triggers that the user has created * SHARED - Return triggers that have been shared to the user * FOLLOWER - Return triggers that have been created by the user''s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return triggers that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC triggers that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC triggers regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all triggers that the user has liked * FEATURED - Return all triggers that have been featured * PENDING - Return all pending triggers 
	filter = "MINE",
	# statuses: String = "NEW,ERROR,COMPLETE,PROCESSING"   Eg: statuses_example
	# Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE
	statuses = "NEW,ERROR,COMPLETE,PROCESSING",
	# templateTypes: String = ""   Eg: templateTypes_example
	# Template Types
	templateTypes = "",
	# appKey: String = ""   Eg: appKey_example
	# Filter the list by a specific application
	appKey = "",
	# keyword: String = ""   Eg: keyword_example
	# Keyword search on the trigger names.
	keyword = "",
	# sortField: String = "CREATED"   Eg: sortField_example
	# The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE
	sortField = "CREATED",
	# descending: bool = true   Eg: true
	# Determines whether the sorted list is in descending or ascending order
	descending = true,
	# start: int = 0   Eg: 56
	# Start the result set at some index.
	start = 0,
	# limit: int = 20   Eg: 56
	# Limit the result to some number.
	limit = 20,
	# activeOnly: bool = true   Eg: true
	# Determines whether to return only active results
	activeOnly = true,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_triggers")
	bzz_callable.bind(
		version,
		accountId,
		groupingId,
		filter,
		statuses,
		templateTypes,
		appKey,
		keyword,
		sortField,
		descending,
		start,
		limit,
		activeOnly,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateTrigger → POST /api/{version}/trigger/update
# Update Trigger
#
# Update a trigger
func update_trigger(
	# version: float   Eg: 3.16
	version: float,
	# triggerId: float   Eg: 789
	# The trigger to update
	triggerId: float,
	# accountId: float   Eg: 789
	# The logged in user
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the trigger
	name = "",
	# appKey: String = ""   Eg: appKey_example
	# The application to target
	appKey = "",
	# groupingId: String = ""   Eg: groupingId_example
	# Client defined identifier for grouping triggers
	groupingId = "",
	# endpointURL: String = ""   Eg: endpointURL_example
	# The URL for making an HTTP call
	endpointURL = "",
	# payload: String = ""   Eg: payload_example
	# The parameters for making an HTTP call
	payload = "",
	# scheduledDate: float   Eg: 789
	# The date and time of the next trigger
	scheduledDate = null,
	# startDate: float   Eg: 789
	# The starting date of the trigger
	startDate = null,
	# endDate: float   Eg: 789
	# The ending date of the trigger
	endDate = null,
	# cronExpression: String = ""   Eg: cronExpression_example
	# The cron expression that represents the trigger's schedule
	cronExpression = "",
	# conditionalInput: String = ""   Eg: conditionalInput_example
	# Json input representing conditional logic that has to be met before running the trigger
	conditionalInput = "",
	# visibility: String = ""   Eg: visibility_example
	# The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
	visibility = "",
	# active: bool   Eg: true
	# Sets whether the Trigger is active or not (inactive Triggers are not processed)
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/trigger/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["triggerId"] = triggerId
	bzz_query["accountId"] = accountId
	bzz_query["name"] = name
	bzz_query["appKey"] = appKey
	bzz_query["groupingId"] = groupingId
	bzz_query["endpointURL"] = endpointURL
	bzz_query["payload"] = payload
	bzz_query["scheduledDate"] = scheduledDate
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["cronExpression"] = cronExpression
	bzz_query["conditionalInput"] = conditionalInput
	bzz_query["visibility"] = visibility
	bzz_query["active"] = active

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = TriggerResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_trigger_threaded(
	# version: float   Eg: 3.16
	version: float,
	# triggerId: float   Eg: 789
	# The trigger to update
	triggerId: float,
	# accountId: float   Eg: 789
	# The logged in user
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the trigger
	name = "",
	# appKey: String = ""   Eg: appKey_example
	# The application to target
	appKey = "",
	# groupingId: String = ""   Eg: groupingId_example
	# Client defined identifier for grouping triggers
	groupingId = "",
	# endpointURL: String = ""   Eg: endpointURL_example
	# The URL for making an HTTP call
	endpointURL = "",
	# payload: String = ""   Eg: payload_example
	# The parameters for making an HTTP call
	payload = "",
	# scheduledDate: float   Eg: 789
	# The date and time of the next trigger
	scheduledDate = null,
	# startDate: float   Eg: 789
	# The starting date of the trigger
	startDate = null,
	# endDate: float   Eg: 789
	# The ending date of the trigger
	endDate = null,
	# cronExpression: String = ""   Eg: cronExpression_example
	# The cron expression that represents the trigger's schedule
	cronExpression = "",
	# conditionalInput: String = ""   Eg: conditionalInput_example
	# Json input representing conditional logic that has to be met before running the trigger
	conditionalInput = "",
	# visibility: String = ""   Eg: visibility_example
	# The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
	visibility = "",
	# active: bool   Eg: true
	# Sets whether the Trigger is active or not (inactive Triggers are not processed)
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_trigger")
	bzz_callable.bind(
		version,
		triggerId,
		accountId,
		name,
		appKey,
		groupingId,
		endpointURL,
		payload,
		scheduledDate,
		startDate,
		endDate,
		cronExpression,
		conditionalInput,
		visibility,
		active,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


