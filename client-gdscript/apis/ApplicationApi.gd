extends ApiBee
class_name ApplicationApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API ApplicationApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "ApplicationApi"


# Operation createApplication → POST /application/create
# Create Application
#
# Create an application record and one placement record for that application. You can create more placements for this application by using {@link createApplicationPlacement}.
func create_application(
	# appName: String = ""   Eg: appName_example
	# The name of the application
	appName: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# about: String = ""   Eg: about_example
	# The description of the application
	about = "",
	# bundleId: String = ""   Eg: bundleId_example
	# The application bundle identifier (format - com.company.appName)
	bundleId = "",
	# appIconAssetId: float   Eg: 789
	# The application icon asset id
	appIconAssetId = null,
	# appLogoAssetId: float   Eg: 789
	# The application logo asset id
	appLogoAssetId = null,
	# facebookAppId: String = ""   Eg: facebookAppId_example
	# The Facebook application id
	facebookAppId = "",
	# facebookAppSecret: String = ""   Eg: facebookAppSecret_example
	# The Facebook application secret
	facebookAppSecret = "",
	# googleApiKey: String = ""   Eg: googleApiKey_example
	# This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging
	googleApiKey = "",
	# updateEULADate: bool   Eg: true
	# Determines whether to update the EULA date
	updateEULADate = null,
	# eulaVersion: String = ""   Eg: eulaVersion_example
	# The EULA version
	eulaVersion = "",
	# landingPageUrl: String = ""   Eg: landingPageUrl_example
	# The landing page URL
	landingPageUrl = "",
	# showInActivities: bool   Eg: true
	# Determines whether to show the application in the activity feed
	showInActivities = null,
	# activityDescription: String = ""   Eg: activityDescription_example
	# The description of the application in the activity feed
	activityDescription = "",
	# inviteWelcomeText: String = ""   Eg: inviteWelcomeText_example
	# The text to display on the invite page
	inviteWelcomeText = "",
	# invitePageUrl: String = ""   Eg: invitePageUrl_example
	# The url to the application invite page
	invitePageUrl = "",
	# urlScheme: String = ""   Eg: urlScheme_example
	# The protocal the app uses to load the app via a browser
	urlScheme = "",
	# platforms: String = ""   Eg: platforms_example
	# A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` 
	platforms = "",
	# downloadUrls: String = ""   Eg: downloadUrls_example
	# Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  
	downloadUrls = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# List of categories to apply
	categoryIds = "",
	# scoringType: String = "GAME_LEVEL"   Eg: scoringType_example
	# The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT
	scoringType = "GAME_LEVEL",
	# hintCost: int = 11   Eg: 56
	# The cost of hints
	hintCost = 11,
	# maxScore: int = 125   Eg: 56
	# The maximum score that will be possible
	maxScore = 125,
	# ticketsPerPoint: float = 0.037   Eg: 3.4
	# The point-to-ticket conversion ratio
	ticketsPerPoint = 0.037,
	# hasGameData: bool = true   Eg: true
	# Determines whether the application uses services to save custom game objects
	hasGameData = true,
	# publicNotifications: bool   Eg: true
	# Public Notifications
	publicNotifications = null,
	# useMatchingAlgorithm: bool   Eg: true
	# Use Matching Algorithm
	useMatchingAlgorithm = null,
	# globalTickets: bool = false   Eg: true
	# Determines whether earned tickets are applied across all applications
	globalTickets = false,
	# buildVersion: float = 1   Eg: 3.4
	# The current build version of the application
	buildVersion = 1,
	# apiVersion: float   Eg: 3.4
	# The current API version the application uses
	apiVersion = null,
	# placementName: String = ""   Eg: placementName_example
	# The name of the placement
	placementName = "",
	# placementDescription: String = ""   Eg: placementDescription_example
	# The description of the placement
	placementDescription = "",
	# placementSize: String = ""   Eg: placementSize_example
	# The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)
	placementSize = "",
	# placementHeight: int   Eg: 56
	# The height of a custom ad size
	placementHeight = null,
	# placementWidth: int   Eg: 56
	# The width of a custom ad size
	placementWidth = null,
	# placementRefreshInterval: int   Eg: 56
	# The refresh interval in seconds
	placementRefreshInterval = null,
	# createObjectStore: bool = true   Eg: true
	# Generate a custom object store to use
	createObjectStore = true,
	# publicContentApproval: bool = false   Eg: true
	# Determine whether or not public content requires admin approval before it becomes public
	publicContentApproval = false,
	# productionMode: bool = false   Eg: true
	# Determines whether the application uses production or sandbox services
	productionMode = false,
	# minimumSessionLength: int   Eg: 56
	# Minimum Session Length
	minimumSessionLength = null,
	# sessionGapLength: int   Eg: 56
	# Session Gap Length
	sessionGapLength = null,
	# localAdsEnabled: bool = false   Eg: true
	# Local Ads Enabled
	localAdsEnabled = false,
	# sqootApiKey: String = ""   Eg: sqootApiKey_example
	# Sqoot Api Key
	sqootApiKey = "",
	# trilatProcessingType: String = "FINGERPRINT"   Eg: trilatProcessingType_example
	# Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT
	trilatProcessingType = "FINGERPRINT",
	# maxSampleSize: int   Eg: 56
	# Determines what the maximum sample size during trilateration
	maxSampleSize = null,
	# minRSSI: int   Eg: 1.2
	# Determines what the minimum acceptable RSSI value
	minRSSI = null,
	# modules: String = "ALL"   Eg: modules_example
	# List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL
	modules = "ALL",
	# authorizedCount: int = 1   Eg: 56
	# How many servers the license will support
	authorizedCount = 1,
	# authorizedServers: String = ""   Eg: authorizedServers_example
	# The list of ip addresses of servers the license will support, leave null for any server
	authorizedServers = "",
	# defaultTimezone: String = ""   Eg: defaultTimezone_example
	# Sets the default timezone for the app (used for leaderboards and other time specific content)
	defaultTimezone = "",
	# smtpPass: String = ""   Eg: smtpPass_example
	# SMTP Pass
	smtpPass = "",
	# metaData: String = ""   Eg: metaData_example
	# The application meta data. Defined by the client
	metaData = "",
	# placementMetaData: String = ""   Eg: placementMetaData_example
	# The ad placement meta data. Defined by the client
	placementMetaData = "",
	# ipsFloor: bool = false   Eg: true
	# Create floor tables for Ips
	ipsFloor = false,
	# enableAPNSBadge: bool = true   Eg: true
	# Enables setting the APNS badge value in the payload
	enableAPNSBadge = true,
	# includeInReport: bool = true   Eg: true
	# Enables using the application in session reports
	includeInReport = true,
	# defaultAppFilterId: float   Eg: 789
	# Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.
	defaultAppFilterId = null,
	# enableWelcomeEmail: bool   Eg: true
	# Enables whether the default welcome email will be sent for new app users
	enableWelcomeEmail = null,
	# appleAppId: String = ""   Eg: appleAppId_example
	# The Apple Application ID
	appleAppId = "",
	# appleTeamId: String = ""   Eg: appleTeamId_example
	# The Apple Team ID
	appleTeamId = "",
	# appleAuthKeyId: String = ""   Eg: appleAuthKeyId_example
	# The Apple Auth Key ID
	appleAuthKeyId = "",
	# appleAuthKey: String   Eg: BINARY_DATA_HERE
	# The Apple Auth Signin Key (p8) File
	appleAuthKey = null,
	# appleIssuerId: String = ""   Eg: appleIssuerId_example
	# The Apple Issuer ID
	appleIssuerId = "",
	# appStoreKeyId: String = ""   Eg: appStoreKeyId_example
	# The Apple App Store Key ID
	appStoreKeyId = "",
	# appStoreKey: String   Eg: BINARY_DATA_HERE
	# The Apple App Store Key (p8) File
	appStoreKey = null,
	# googlePrivateKeyFile: String   Eg: BINARY_DATA_HERE
	# This is the private key file for your Google service account.
	googlePrivateKeyFile = null,
	# authorizeNetApiKey: String = ""   Eg: authorizeNetApiKey_example
	# Authorize Net Api Key
	authorizeNetApiKey = "",
	# authorizeNetTransactionKey: String = ""   Eg: authorizeNetTransactionKey_example
	# Authorize Net Transaction Key
	authorizeNetTransactionKey = "",
	# emailSender: String = ""   Eg: emailSender_example
	# Email Sender
	emailSender = "",
	# smtpUser: String = ""   Eg: smtpUser_example
	# SMTP User
	smtpUser = "",
	# smtpHost: String = ""   Eg: smtpHost_example
	# SMTP Host
	smtpHost = "",
	# vatomBusinessId: String = ""   Eg: vatomBusinessId_example
	# Vatom Business Id
	vatomBusinessId = "",
	# vatomRestClientId: String = ""   Eg: vatomRestClientId_example
	# Vatom REST Client Id
	vatomRestClientId = "",
	# vatomRestSecretKey: String = ""   Eg: vatomRestSecretKey_example
	# Vatom Secret Key
	vatomRestSecretKey = "",
	# twilioAccountSID: String = ""   Eg: twilioAccountSID_example
	# Twilio Account SID
	twilioAccountSID = "",
	# twilioAuthToken: String = ""   Eg: twilioAuthToken_example
	# Twilio Auth Token
	twilioAuthToken = "",
	# twilioSenderPhoneNumber: String = ""   Eg: twilioSenderPhoneNumber_example
	# Twilio Sender Phone Number
	twilioSenderPhoneNumber = "",
	# openAISecretKey: String = ""   Eg: openAISecretKey_example
	# OpenAI Secret API Key
	openAISecretKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/application/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appName"] = appName
	bzz_query["about"] = about
	bzz_query["bundleId"] = bundleId
	bzz_query["appIconAssetId"] = appIconAssetId
	bzz_query["appLogoAssetId"] = appLogoAssetId
	bzz_query["facebookAppId"] = facebookAppId
	bzz_query["facebookAppSecret"] = facebookAppSecret
	bzz_query["googleApiKey"] = googleApiKey
	bzz_query["updateEULADate"] = updateEULADate
	bzz_query["eulaVersion"] = eulaVersion
	bzz_query["landingPageUrl"] = landingPageUrl
	bzz_query["showInActivities"] = showInActivities
	bzz_query["activityDescription"] = activityDescription
	bzz_query["inviteWelcomeText"] = inviteWelcomeText
	bzz_query["invitePageUrl"] = invitePageUrl
	bzz_query["urlScheme"] = urlScheme
	bzz_query["platforms"] = platforms
	bzz_query["downloadUrls"] = downloadUrls
	bzz_query["categoryIds"] = categoryIds
	bzz_query["scoringType"] = scoringType
	bzz_query["hintCost"] = hintCost
	bzz_query["maxScore"] = maxScore
	bzz_query["ticketsPerPoint"] = ticketsPerPoint
	bzz_query["hasGameData"] = hasGameData
	bzz_query["publicNotifications"] = publicNotifications
	bzz_query["useMatchingAlgorithm"] = useMatchingAlgorithm
	bzz_query["globalTickets"] = globalTickets
	bzz_query["buildVersion"] = buildVersion
	bzz_query["apiVersion"] = apiVersion
	bzz_query["placementName"] = placementName
	bzz_query["placementDescription"] = placementDescription
	bzz_query["placementSize"] = placementSize
	bzz_query["placementHeight"] = placementHeight
	bzz_query["placementWidth"] = placementWidth
	bzz_query["placementRefreshInterval"] = placementRefreshInterval
	bzz_query["createObjectStore"] = createObjectStore
	bzz_query["publicContentApproval"] = publicContentApproval
	bzz_query["productionMode"] = productionMode
	bzz_query["minimumSessionLength"] = minimumSessionLength
	bzz_query["sessionGapLength"] = sessionGapLength
	bzz_query["localAdsEnabled"] = localAdsEnabled
	bzz_query["sqootApiKey"] = sqootApiKey
	bzz_query["trilatProcessingType"] = trilatProcessingType
	bzz_query["maxSampleSize"] = maxSampleSize
	bzz_query["minRSSI"] = minRSSI
	bzz_query["modules"] = modules
	bzz_query["authorizedCount"] = authorizedCount
	bzz_query["authorizedServers"] = authorizedServers
	bzz_query["defaultTimezone"] = defaultTimezone
	bzz_query["smtpPass"] = smtpPass
	bzz_query["metaData"] = metaData
	bzz_query["placementMetaData"] = placementMetaData
	bzz_query["ipsFloor"] = ipsFloor
	bzz_query["enableAPNSBadge"] = enableAPNSBadge
	bzz_query["includeInReport"] = includeInReport
	bzz_query["defaultAppFilterId"] = defaultAppFilterId
	bzz_query["enableWelcomeEmail"] = enableWelcomeEmail
	bzz_query["appleAppId"] = appleAppId
	bzz_query["appleTeamId"] = appleTeamId
	bzz_query["appleAuthKeyId"] = appleAuthKeyId
	bzz_query["appleAuthKey"] = appleAuthKey
	bzz_query["appleIssuerId"] = appleIssuerId
	bzz_query["appStoreKeyId"] = appStoreKeyId
	bzz_query["appStoreKey"] = appStoreKey
	bzz_query["googlePrivateKeyFile"] = googlePrivateKeyFile
	bzz_query["authorizeNetApiKey"] = authorizeNetApiKey
	bzz_query["authorizeNetTransactionKey"] = authorizeNetTransactionKey
	bzz_query["emailSender"] = emailSender
	bzz_query["smtpUser"] = smtpUser
	bzz_query["smtpHost"] = smtpHost
	bzz_query["vatomBusinessId"] = vatomBusinessId
	bzz_query["vatomRestClientId"] = vatomRestClientId
	bzz_query["vatomRestSecretKey"] = vatomRestSecretKey
	bzz_query["twilioAccountSID"] = twilioAccountSID
	bzz_query["twilioAuthToken"] = twilioAuthToken
	bzz_query["twilioSenderPhoneNumber"] = twilioSenderPhoneNumber
	bzz_query["openAISecretKey"] = openAISecretKey

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ApplicationResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_application_threaded(
	# appName: String = ""   Eg: appName_example
	# The name of the application
	appName: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# about: String = ""   Eg: about_example
	# The description of the application
	about = "",
	# bundleId: String = ""   Eg: bundleId_example
	# The application bundle identifier (format - com.company.appName)
	bundleId = "",
	# appIconAssetId: float   Eg: 789
	# The application icon asset id
	appIconAssetId = null,
	# appLogoAssetId: float   Eg: 789
	# The application logo asset id
	appLogoAssetId = null,
	# facebookAppId: String = ""   Eg: facebookAppId_example
	# The Facebook application id
	facebookAppId = "",
	# facebookAppSecret: String = ""   Eg: facebookAppSecret_example
	# The Facebook application secret
	facebookAppSecret = "",
	# googleApiKey: String = ""   Eg: googleApiKey_example
	# This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging
	googleApiKey = "",
	# updateEULADate: bool   Eg: true
	# Determines whether to update the EULA date
	updateEULADate = null,
	# eulaVersion: String = ""   Eg: eulaVersion_example
	# The EULA version
	eulaVersion = "",
	# landingPageUrl: String = ""   Eg: landingPageUrl_example
	# The landing page URL
	landingPageUrl = "",
	# showInActivities: bool   Eg: true
	# Determines whether to show the application in the activity feed
	showInActivities = null,
	# activityDescription: String = ""   Eg: activityDescription_example
	# The description of the application in the activity feed
	activityDescription = "",
	# inviteWelcomeText: String = ""   Eg: inviteWelcomeText_example
	# The text to display on the invite page
	inviteWelcomeText = "",
	# invitePageUrl: String = ""   Eg: invitePageUrl_example
	# The url to the application invite page
	invitePageUrl = "",
	# urlScheme: String = ""   Eg: urlScheme_example
	# The protocal the app uses to load the app via a browser
	urlScheme = "",
	# platforms: String = ""   Eg: platforms_example
	# A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` 
	platforms = "",
	# downloadUrls: String = ""   Eg: downloadUrls_example
	# Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  
	downloadUrls = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# List of categories to apply
	categoryIds = "",
	# scoringType: String = "GAME_LEVEL"   Eg: scoringType_example
	# The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT
	scoringType = "GAME_LEVEL",
	# hintCost: int = 11   Eg: 56
	# The cost of hints
	hintCost = 11,
	# maxScore: int = 125   Eg: 56
	# The maximum score that will be possible
	maxScore = 125,
	# ticketsPerPoint: float = 0.037   Eg: 3.4
	# The point-to-ticket conversion ratio
	ticketsPerPoint = 0.037,
	# hasGameData: bool = true   Eg: true
	# Determines whether the application uses services to save custom game objects
	hasGameData = true,
	# publicNotifications: bool   Eg: true
	# Public Notifications
	publicNotifications = null,
	# useMatchingAlgorithm: bool   Eg: true
	# Use Matching Algorithm
	useMatchingAlgorithm = null,
	# globalTickets: bool = false   Eg: true
	# Determines whether earned tickets are applied across all applications
	globalTickets = false,
	# buildVersion: float = 1   Eg: 3.4
	# The current build version of the application
	buildVersion = 1,
	# apiVersion: float   Eg: 3.4
	# The current API version the application uses
	apiVersion = null,
	# placementName: String = ""   Eg: placementName_example
	# The name of the placement
	placementName = "",
	# placementDescription: String = ""   Eg: placementDescription_example
	# The description of the placement
	placementDescription = "",
	# placementSize: String = ""   Eg: placementSize_example
	# The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)
	placementSize = "",
	# placementHeight: int   Eg: 56
	# The height of a custom ad size
	placementHeight = null,
	# placementWidth: int   Eg: 56
	# The width of a custom ad size
	placementWidth = null,
	# placementRefreshInterval: int   Eg: 56
	# The refresh interval in seconds
	placementRefreshInterval = null,
	# createObjectStore: bool = true   Eg: true
	# Generate a custom object store to use
	createObjectStore = true,
	# publicContentApproval: bool = false   Eg: true
	# Determine whether or not public content requires admin approval before it becomes public
	publicContentApproval = false,
	# productionMode: bool = false   Eg: true
	# Determines whether the application uses production or sandbox services
	productionMode = false,
	# minimumSessionLength: int   Eg: 56
	# Minimum Session Length
	minimumSessionLength = null,
	# sessionGapLength: int   Eg: 56
	# Session Gap Length
	sessionGapLength = null,
	# localAdsEnabled: bool = false   Eg: true
	# Local Ads Enabled
	localAdsEnabled = false,
	# sqootApiKey: String = ""   Eg: sqootApiKey_example
	# Sqoot Api Key
	sqootApiKey = "",
	# trilatProcessingType: String = "FINGERPRINT"   Eg: trilatProcessingType_example
	# Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT
	trilatProcessingType = "FINGERPRINT",
	# maxSampleSize: int   Eg: 56
	# Determines what the maximum sample size during trilateration
	maxSampleSize = null,
	# minRSSI: int   Eg: 1.2
	# Determines what the minimum acceptable RSSI value
	minRSSI = null,
	# modules: String = "ALL"   Eg: modules_example
	# List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL
	modules = "ALL",
	# authorizedCount: int = 1   Eg: 56
	# How many servers the license will support
	authorizedCount = 1,
	# authorizedServers: String = ""   Eg: authorizedServers_example
	# The list of ip addresses of servers the license will support, leave null for any server
	authorizedServers = "",
	# defaultTimezone: String = ""   Eg: defaultTimezone_example
	# Sets the default timezone for the app (used for leaderboards and other time specific content)
	defaultTimezone = "",
	# smtpPass: String = ""   Eg: smtpPass_example
	# SMTP Pass
	smtpPass = "",
	# metaData: String = ""   Eg: metaData_example
	# The application meta data. Defined by the client
	metaData = "",
	# placementMetaData: String = ""   Eg: placementMetaData_example
	# The ad placement meta data. Defined by the client
	placementMetaData = "",
	# ipsFloor: bool = false   Eg: true
	# Create floor tables for Ips
	ipsFloor = false,
	# enableAPNSBadge: bool = true   Eg: true
	# Enables setting the APNS badge value in the payload
	enableAPNSBadge = true,
	# includeInReport: bool = true   Eg: true
	# Enables using the application in session reports
	includeInReport = true,
	# defaultAppFilterId: float   Eg: 789
	# Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.
	defaultAppFilterId = null,
	# enableWelcomeEmail: bool   Eg: true
	# Enables whether the default welcome email will be sent for new app users
	enableWelcomeEmail = null,
	# appleAppId: String = ""   Eg: appleAppId_example
	# The Apple Application ID
	appleAppId = "",
	# appleTeamId: String = ""   Eg: appleTeamId_example
	# The Apple Team ID
	appleTeamId = "",
	# appleAuthKeyId: String = ""   Eg: appleAuthKeyId_example
	# The Apple Auth Key ID
	appleAuthKeyId = "",
	# appleAuthKey: String   Eg: BINARY_DATA_HERE
	# The Apple Auth Signin Key (p8) File
	appleAuthKey = null,
	# appleIssuerId: String = ""   Eg: appleIssuerId_example
	# The Apple Issuer ID
	appleIssuerId = "",
	# appStoreKeyId: String = ""   Eg: appStoreKeyId_example
	# The Apple App Store Key ID
	appStoreKeyId = "",
	# appStoreKey: String   Eg: BINARY_DATA_HERE
	# The Apple App Store Key (p8) File
	appStoreKey = null,
	# googlePrivateKeyFile: String   Eg: BINARY_DATA_HERE
	# This is the private key file for your Google service account.
	googlePrivateKeyFile = null,
	# authorizeNetApiKey: String = ""   Eg: authorizeNetApiKey_example
	# Authorize Net Api Key
	authorizeNetApiKey = "",
	# authorizeNetTransactionKey: String = ""   Eg: authorizeNetTransactionKey_example
	# Authorize Net Transaction Key
	authorizeNetTransactionKey = "",
	# emailSender: String = ""   Eg: emailSender_example
	# Email Sender
	emailSender = "",
	# smtpUser: String = ""   Eg: smtpUser_example
	# SMTP User
	smtpUser = "",
	# smtpHost: String = ""   Eg: smtpHost_example
	# SMTP Host
	smtpHost = "",
	# vatomBusinessId: String = ""   Eg: vatomBusinessId_example
	# Vatom Business Id
	vatomBusinessId = "",
	# vatomRestClientId: String = ""   Eg: vatomRestClientId_example
	# Vatom REST Client Id
	vatomRestClientId = "",
	# vatomRestSecretKey: String = ""   Eg: vatomRestSecretKey_example
	# Vatom Secret Key
	vatomRestSecretKey = "",
	# twilioAccountSID: String = ""   Eg: twilioAccountSID_example
	# Twilio Account SID
	twilioAccountSID = "",
	# twilioAuthToken: String = ""   Eg: twilioAuthToken_example
	# Twilio Auth Token
	twilioAuthToken = "",
	# twilioSenderPhoneNumber: String = ""   Eg: twilioSenderPhoneNumber_example
	# Twilio Sender Phone Number
	twilioSenderPhoneNumber = "",
	# openAISecretKey: String = ""   Eg: openAISecretKey_example
	# OpenAI Secret API Key
	openAISecretKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_application")
	bzz_callable.bind(
		appName,
		deviceId,
		accountId,
		about,
		bundleId,
		appIconAssetId,
		appLogoAssetId,
		facebookAppId,
		facebookAppSecret,
		googleApiKey,
		updateEULADate,
		eulaVersion,
		landingPageUrl,
		showInActivities,
		activityDescription,
		inviteWelcomeText,
		invitePageUrl,
		urlScheme,
		platforms,
		downloadUrls,
		categoryIds,
		scoringType,
		hintCost,
		maxScore,
		ticketsPerPoint,
		hasGameData,
		publicNotifications,
		useMatchingAlgorithm,
		globalTickets,
		buildVersion,
		apiVersion,
		placementName,
		placementDescription,
		placementSize,
		placementHeight,
		placementWidth,
		placementRefreshInterval,
		createObjectStore,
		publicContentApproval,
		productionMode,
		minimumSessionLength,
		sessionGapLength,
		localAdsEnabled,
		sqootApiKey,
		trilatProcessingType,
		maxSampleSize,
		minRSSI,
		modules,
		authorizedCount,
		authorizedServers,
		defaultTimezone,
		smtpPass,
		metaData,
		placementMetaData,
		ipsFloor,
		enableAPNSBadge,
		includeInReport,
		defaultAppFilterId,
		enableWelcomeEmail,
		appleAppId,
		appleTeamId,
		appleAuthKeyId,
		appleAuthKey,
		appleIssuerId,
		appStoreKeyId,
		appStoreKey,
		googlePrivateKeyFile,
		authorizeNetApiKey,
		authorizeNetTransactionKey,
		emailSender,
		smtpUser,
		smtpHost,
		vatomBusinessId,
		vatomRestClientId,
		vatomRestSecretKey,
		twilioAccountSID,
		twilioAuthToken,
		twilioSenderPhoneNumber,
		openAISecretKey,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createApplicationPlacement → POST /application/placement/create
# Create Ad Placement
#
# Creates a new ad placement for an application.
func create_application_placement(
	# appKey: String = ""   Eg: appKey_example
	# The appKey of the application the ad placement is for
	appKey: String,
	# size: String = ""   Eg: size_example
	# The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM
	size: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# name: String = ""   Eg: name_example
	# The name of the placement
	name = "",
	# description: String = ""   Eg: description_example
	# The description of the placement
	description = "",
	# height: int   Eg: 56
	# The height of a custom ad size
	height = null,
	# width: int   Eg: 56
	# The width of a custom ad size
	width = null,
	# refreshInterval: int   Eg: 56
	# The refresh interval in seconds
	refreshInterval = null,
	# defaultImageId: float   Eg: 789
	# Default Image Id
	defaultImageId = null,
	# active: bool   Eg: true
	# Active
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/application/placement/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["name"] = name
	bzz_query["description"] = description
	bzz_query["size"] = size
	bzz_query["height"] = height
	bzz_query["width"] = width
	bzz_query["refreshInterval"] = refreshInterval
	bzz_query["defaultImageId"] = defaultImageId
	bzz_query["active"] = active

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PlacementResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_application_placement_threaded(
	# appKey: String = ""   Eg: appKey_example
	# The appKey of the application the ad placement is for
	appKey: String,
	# size: String = ""   Eg: size_example
	# The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM
	size: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# name: String = ""   Eg: name_example
	# The name of the placement
	name = "",
	# description: String = ""   Eg: description_example
	# The description of the placement
	description = "",
	# height: int   Eg: 56
	# The height of a custom ad size
	height = null,
	# width: int   Eg: 56
	# The width of a custom ad size
	width = null,
	# refreshInterval: int   Eg: 56
	# The refresh interval in seconds
	refreshInterval = null,
	# defaultImageId: float   Eg: 789
	# Default Image Id
	defaultImageId = null,
	# active: bool   Eg: true
	# Active
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_application_placement")
	bzz_callable.bind(
		appKey,
		size,
		deviceId,
		accountId,
		name,
		description,
		height,
		width,
		refreshInterval,
		defaultImageId,
		active,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteApplication → POST /application/delete
# Delete Application
#
# Set the deleted timestamp to current time. This effectively deletes the application since all queries should ignore any records with a deleted timestamp
func delete_application(
	# accountId: float   Eg: 789
	# The account used to perform the delete, must have rights to edit the application.
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# The key of the application to be deleted
	appKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/application/delete"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_application_threaded(
	# accountId: float   Eg: 789
	# The account used to perform the delete, must have rights to edit the application.
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# The key of the application to be deleted
	appKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_application")
	bzz_callable.bind(
		accountId,
		appKey,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteApplicationPlacement → POST /application/placement/delete
# Delete Ad Placement
#
# Deletes an ad placement for an application.
func delete_application_placement(
	# placementId: float   Eg: 789
	# The id of the placement to delete, the user must have rights to the application the ad placement is for
	placementId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/application/placement/delete"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["placementId"] = placementId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PlacementResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_application_placement_threaded(
	# placementId: float   Eg: 789
	# The id of the placement to delete, the user must have rights to the application the ad placement is for
	placementId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_application_placement")
	bzz_callable.bind(
		placementId,
		deviceId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getApplication → GET /application/get
# Get Application
#
# Get a specific application by appKey
func get_application(
	# appKey: String = ""   Eg: appKey_example
	# The key of the application
	appKey = "",
	# applicationId: float   Eg: 789
	# Application Id
	applicationId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/application/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["appKey"] = appKey
	bzz_query["applicationId"] = applicationId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ApplicationResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_application_threaded(
	# appKey: String = ""   Eg: appKey_example
	# The key of the application
	appKey = "",
	# applicationId: float   Eg: 789
	# Application Id
	applicationId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_application")
	bzz_callable.bind(
		appKey,
		applicationId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getApplicationPlacement → GET /application/placement/get
# Get Ad Placement
#
# Get details of an ad placement
func get_application_placement(
	# placementId: float   Eg: 789
	# The id of the placement
	placementId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/application/placement/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["placementId"] = placementId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PlacementResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_application_placement_threaded(
	# placementId: float   Eg: 789
	# The id of the placement
	placementId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_application_placement")
	bzz_callable.bind(
		placementId,
		deviceId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getApplicationVersions → GET /application/versions
# Get API versions
#
# Will return a comma separated list of numbers, newest first. For example: 3.0, 2.2, 2.1, 1.8
func get_application_versions(
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/application/versions"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_application_versions_threaded(
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_application_versions")
	bzz_callable.bind(
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getUniqueUsersByApp → GET /application/users
# Search Application Users
#
# Get a list of users per application
func get_unique_users_by_app(
	# appKey: String = ""   Eg: appKey_example
	# The application key
	appKey: String,
	# q: String = ""   Eg: q_example
	# Q
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search
	keyword = "",
	# since: float   Eg: 789
	# Return accounts that have been active after this date (UNIX time-stamp in milliseconds)
	since = null,
	# i: int   Eg: 56
	# the start of the index
	i = null,
	# start: int = 0   Eg: 56
	# The start of the pagination
	start = 0,
	# l: int   Eg: 56
	# the limit of the index
	l = null,
	# limit: int = 20   Eg: 56
	# The limit of the pagination
	limit = 20,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/application/users"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["appKey"] = appKey
	bzz_query["q"] = q
	bzz_query["keyword"] = keyword
	bzz_query["since"] = since
	bzz_query["_i"] = i
	bzz_query["start"] = start
	bzz_query["_l"] = l
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AccountListResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_unique_users_by_app_threaded(
	# appKey: String = ""   Eg: appKey_example
	# The application key
	appKey: String,
	# q: String = ""   Eg: q_example
	# Q
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search
	keyword = "",
	# since: float   Eg: 789
	# Return accounts that have been active after this date (UNIX time-stamp in milliseconds)
	since = null,
	# i: int   Eg: 56
	# the start of the index
	i = null,
	# start: int = 0   Eg: 56
	# The start of the pagination
	start = 0,
	# l: int   Eg: 56
	# the limit of the index
	l = null,
	# limit: int = 20   Eg: 56
	# The limit of the pagination
	limit = 20,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_unique_users_by_app")
	bzz_callable.bind(
		appKey,
		q,
		keyword,
		since,
		i,
		start,
		l,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation listApplications → GET /application/list
# List Applications
#
# List active applications matching the criteria (as a consumer)
func list_applications(
	# accountId: float   Eg: 789
	# The account id of the application owner/manager
	accountId = null,
	# q: String = ""   Eg: q_example
	# Q
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search for title, about, and description fields
	keyword = "",
	# platforms: String = ""   Eg: platforms_example
	# Deprecated, use deviceIds and deviceVersions
	platforms = "",
	# deviceIds: String = ""   Eg: deviceIds_example
	# The list of targeted device ids, comma separated; possible values are retreived via /api/{version/audience/devices com.sirqul.geoapps.common.service.AudienceApi#getDevices getDevices (pass in deviceId values)
	deviceIds = "",
	# deviceVersions: String = ""   Eg: deviceVersions_example
	# The list of targeted device version ranges that are aligned  with the provided devices list (see devices param for possible values),  comma separated; examples are: 2.3-X, 0-5.1.4, 4.3.1-6.1.4 where X  is no maximum and 0 is no minimum. 
	deviceVersions = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# The list of category ids to filter the list by
	categoryIds = "",
	# sortField: String = "UPDATED"   Eg: sortField_example
	# The column to sort the search on, possible values include: UPDATED (default), CREATED, TITLE
	sortField = "UPDATED",
	# hasAds: bool   Eg: true
	# Filter results on whether the application supports ads or not. Ignore this parameter to return all results.
	hasAds = null,
	# publicNotifications: bool   Eg: true
	# Filter results on whether the application is available for public trigger notifications
	publicNotifications = null,
	# filterBillable: bool   Eg: true
	# Determines whether to only return applications that the user has access to
	filterBillable = null,
	# filterContentAdmin: bool   Eg: true
	# Determines whether to only return applications that the user is a content admin of
	filterContentAdmin = null,
	# descending: bool = true   Eg: true
	# The order to return the search results
	descending = true,
	# i: int   Eg: 56
	# the start of the index
	i = null,
	# start: int = 0   Eg: 56
	# The start of the pagination
	start = 0,
	# l: int   Eg: 56
	# The limit of the index
	l = null,
	# limit: int = 20   Eg: 56
	# The limit of the pagination
	limit = 20,
	# applicationIds: String = ""   Eg: applicationIds_example
	# The list of application ids, comma separated. If provided will ignore all other params.
	applicationIds = "",
	# hasObjectStore: bool = false   Eg: true
	# Only include applications with a object store (default is false)
	hasObjectStore = false,
	# activeOnly: bool = true   Eg: true
	# Return only active results
	activeOnly = true,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/application/list"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["q"] = q
	bzz_query["keyword"] = keyword
	bzz_query["platforms"] = platforms
	bzz_query["deviceIds"] = deviceIds
	bzz_query["deviceVersions"] = deviceVersions
	bzz_query["categoryIds"] = categoryIds
	bzz_query["sortField"] = sortField
	bzz_query["hasAds"] = hasAds
	bzz_query["publicNotifications"] = publicNotifications
	bzz_query["filterBillable"] = filterBillable
	bzz_query["filterContentAdmin"] = filterContentAdmin
	bzz_query["descending"] = descending
	bzz_query["_i"] = i
	bzz_query["start"] = start
	bzz_query["_l"] = l
	bzz_query["limit"] = limit
	bzz_query["applicationIds"] = applicationIds
	bzz_query["hasObjectStore"] = hasObjectStore
	bzz_query["activeOnly"] = activeOnly

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ApplicationShortResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func list_applications_threaded(
	# accountId: float   Eg: 789
	# The account id of the application owner/manager
	accountId = null,
	# q: String = ""   Eg: q_example
	# Q
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search for title, about, and description fields
	keyword = "",
	# platforms: String = ""   Eg: platforms_example
	# Deprecated, use deviceIds and deviceVersions
	platforms = "",
	# deviceIds: String = ""   Eg: deviceIds_example
	# The list of targeted device ids, comma separated; possible values are retreived via /api/{version/audience/devices com.sirqul.geoapps.common.service.AudienceApi#getDevices getDevices (pass in deviceId values)
	deviceIds = "",
	# deviceVersions: String = ""   Eg: deviceVersions_example
	# The list of targeted device version ranges that are aligned  with the provided devices list (see devices param for possible values),  comma separated; examples are: 2.3-X, 0-5.1.4, 4.3.1-6.1.4 where X  is no maximum and 0 is no minimum. 
	deviceVersions = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# The list of category ids to filter the list by
	categoryIds = "",
	# sortField: String = "UPDATED"   Eg: sortField_example
	# The column to sort the search on, possible values include: UPDATED (default), CREATED, TITLE
	sortField = "UPDATED",
	# hasAds: bool   Eg: true
	# Filter results on whether the application supports ads or not. Ignore this parameter to return all results.
	hasAds = null,
	# publicNotifications: bool   Eg: true
	# Filter results on whether the application is available for public trigger notifications
	publicNotifications = null,
	# filterBillable: bool   Eg: true
	# Determines whether to only return applications that the user has access to
	filterBillable = null,
	# filterContentAdmin: bool   Eg: true
	# Determines whether to only return applications that the user is a content admin of
	filterContentAdmin = null,
	# descending: bool = true   Eg: true
	# The order to return the search results
	descending = true,
	# i: int   Eg: 56
	# the start of the index
	i = null,
	# start: int = 0   Eg: 56
	# The start of the pagination
	start = 0,
	# l: int   Eg: 56
	# The limit of the index
	l = null,
	# limit: int = 20   Eg: 56
	# The limit of the pagination
	limit = 20,
	# applicationIds: String = ""   Eg: applicationIds_example
	# The list of application ids, comma separated. If provided will ignore all other params.
	applicationIds = "",
	# hasObjectStore: bool = false   Eg: true
	# Only include applications with a object store (default is false)
	hasObjectStore = false,
	# activeOnly: bool = true   Eg: true
	# Return only active results
	activeOnly = true,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "list_applications")
	bzz_callable.bind(
		accountId,
		q,
		keyword,
		platforms,
		deviceIds,
		deviceVersions,
		categoryIds,
		sortField,
		hasAds,
		publicNotifications,
		filterBillable,
		filterContentAdmin,
		descending,
		i,
		start,
		l,
		limit,
		applicationIds,
		hasObjectStore,
		activeOnly,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchApplicationPlacement → GET /application/placement/search
# Search for Ad Placements
#
# Searches placements for an application.
func search_application_placement(
	# appKey: String = ""   Eg: appKey_example
	# The key of the application
	appKey: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# start: int = 0   Eg: 56
	# The start of the pagination
	start = 0,
	# limit: int = 100   Eg: 56
	# The limit of the pagination
	limit = 100,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/application/placement/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PlacementResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_application_placement_threaded(
	# appKey: String = ""   Eg: appKey_example
	# The key of the application
	appKey: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# start: int = 0   Eg: 56
	# The start of the pagination
	start = 0,
	# limit: int = 100   Eg: 56
	# The limit of the pagination
	limit = 100,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_application_placement")
	bzz_callable.bind(
		appKey,
		deviceId,
		accountId,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchApplicationSettings → GET /application/settings/search
# Search for Application Settings
#
# Returns a list of applications that the user has logged into before, and returns specific settings for that application and user
func search_application_settings(
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# connectionAccountId: float   Eg: 789
	# The account id used to view another person's account
	connectionAccountId = null,
	# keyword: String = ""   Eg: keyword_example
	# The string to search applications on
	keyword = "",
	# sortField: String = "APPLICATION_TITLE"   Eg: sortField_example
	# The column to sort the search on. Possible values include: CREATED, UPDATED, APPLICATION_TITLE
	sortField = "APPLICATION_TITLE",
	# descending: bool = false   Eg: true
	# The order to return the search results
	descending = false,
	# start: int = 0   Eg: 56
	# The start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# The limit per result set for pagination
	limit = 20,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/application/settings/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["connectionAccountId"] = connectionAccountId
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ApplicationSettingsResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_application_settings_threaded(
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# connectionAccountId: float   Eg: 789
	# The account id used to view another person's account
	connectionAccountId = null,
	# keyword: String = ""   Eg: keyword_example
	# The string to search applications on
	keyword = "",
	# sortField: String = "APPLICATION_TITLE"   Eg: sortField_example
	# The column to sort the search on. Possible values include: CREATED, UPDATED, APPLICATION_TITLE
	sortField = "APPLICATION_TITLE",
	# descending: bool = false   Eg: true
	# The order to return the search results
	descending = false,
	# start: int = 0   Eg: 56
	# The start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# The limit per result set for pagination
	limit = 20,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_application_settings")
	bzz_callable.bind(
		deviceId,
		accountId,
		connectionAccountId,
		keyword,
		sortField,
		descending,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchApplications → GET /application/search
# Search Applications
#
# Search for applications matching the criteria that the logged in user has access to
func search_applications(
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# latitude: int   Eg: 1.2
	# The location of the device
	latitude = null,
	# longitude: int   Eg: 1.2
	# The location of the device
	longitude = null,
	# q: String = ""   Eg: q_example
	# Q
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search
	keyword = "",
	# qSearchFields: String = "NAME,ABOUT,BILLABLE_ENTITY_NAME"   Eg: qSearchFields_example
	# The columns to applied the keyword search to
	qSearchFields = "NAME,ABOUT,BILLABLE_ENTITY_NAME",
	# sortField: String = "APPLICATION_ID"   Eg: sortField_example
	# The column to sort the search on
	sortField = "APPLICATION_ID",
	# descending: bool = false   Eg: true
	# The order to return the search results
	descending = false,
	# i: int   Eg: 56
	# the start of the index
	i = null,
	# start: int = 0   Eg: 56
	# The start of the pagination
	start = 0,
	# l: int   Eg: 56
	# the limit of the index
	l = null,
	# limit: int = 100   Eg: 56
	# The limit of the pagination
	limit = 100,
	# hasAds: bool   Eg: true
	# Filter results on whether the application supports ads or not. Ignore this parameter to return all results.
	hasAds = null,
	# publicNotifications: bool   Eg: true
	# Filter results on whether the application is available for public trigger notifications
	publicNotifications = null,
	# activeOnly: bool = false   Eg: true
	# Return only active results
	activeOnly = false,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/application/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["q"] = q
	bzz_query["keyword"] = keyword
	bzz_query["qSearchFields"] = qSearchFields
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["_i"] = i
	bzz_query["start"] = start
	bzz_query["_l"] = l
	bzz_query["limit"] = limit
	bzz_query["hasAds"] = hasAds
	bzz_query["publicNotifications"] = publicNotifications
	bzz_query["activeOnly"] = activeOnly

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ApplicationResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_applications_threaded(
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# latitude: int   Eg: 1.2
	# The location of the device
	latitude = null,
	# longitude: int   Eg: 1.2
	# The location of the device
	longitude = null,
	# q: String = ""   Eg: q_example
	# Q
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search
	keyword = "",
	# qSearchFields: String = "NAME,ABOUT,BILLABLE_ENTITY_NAME"   Eg: qSearchFields_example
	# The columns to applied the keyword search to
	qSearchFields = "NAME,ABOUT,BILLABLE_ENTITY_NAME",
	# sortField: String = "APPLICATION_ID"   Eg: sortField_example
	# The column to sort the search on
	sortField = "APPLICATION_ID",
	# descending: bool = false   Eg: true
	# The order to return the search results
	descending = false,
	# i: int   Eg: 56
	# the start of the index
	i = null,
	# start: int = 0   Eg: 56
	# The start of the pagination
	start = 0,
	# l: int   Eg: 56
	# the limit of the index
	l = null,
	# limit: int = 100   Eg: 56
	# The limit of the pagination
	limit = 100,
	# hasAds: bool   Eg: true
	# Filter results on whether the application supports ads or not. Ignore this parameter to return all results.
	hasAds = null,
	# publicNotifications: bool   Eg: true
	# Filter results on whether the application is available for public trigger notifications
	publicNotifications = null,
	# activeOnly: bool = false   Eg: true
	# Return only active results
	activeOnly = false,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_applications")
	bzz_callable.bind(
		deviceId,
		accountId,
		latitude,
		longitude,
		q,
		keyword,
		qSearchFields,
		sortField,
		descending,
		i,
		start,
		l,
		limit,
		hasAds,
		publicNotifications,
		activeOnly,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateApplication → POST /application/update
# Update Application
#
# Update an application record
func update_application(
	# appKey: String = ""   Eg: appKey_example
	# The application key for updating an existing application
	appKey: String,
	# appName: String = ""   Eg: appName_example
	# The name of the application
	appName: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# about: String = ""   Eg: about_example
	# The description of the application
	about = "",
	# bundleId: String = ""   Eg: bundleId_example
	# The application bundle identifier (format - com.company.appName)
	bundleId = "",
	# appIconAssetId: float   Eg: 789
	# The application icon asset id
	appIconAssetId = null,
	# appLogoAssetId: float   Eg: 789
	# The application logo asset id
	appLogoAssetId = null,
	# facebookAppId: String = ""   Eg: facebookAppId_example
	# The Facebook application id
	facebookAppId = "",
	# facebookAppSecret: String = ""   Eg: facebookAppSecret_example
	# The Facebook application secret
	facebookAppSecret = "",
	# googleApiKey: String = ""   Eg: googleApiKey_example
	# This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging
	googleApiKey = "",
	# updateEULADate: bool   Eg: true
	# Determines whether to update the EULA date
	updateEULADate = null,
	# eulaVersion: String = ""   Eg: eulaVersion_example
	# The EULA version
	eulaVersion = "",
	# landingPageUrl: String = ""   Eg: landingPageUrl_example
	# The landing page URL
	landingPageUrl = "",
	# showInActivities: bool   Eg: true
	# Determines whether to show the application in the activity feed
	showInActivities = null,
	# activityDescription: String = ""   Eg: activityDescription_example
	# The description of the application in the activity feed
	activityDescription = "",
	# inviteWelcomeText: String = ""   Eg: inviteWelcomeText_example
	# The text to display on the invite page
	inviteWelcomeText = "",
	# invitePageUrl: String = ""   Eg: invitePageUrl_example
	# The url to the application invite page
	invitePageUrl = "",
	# urlScheme: String = ""   Eg: urlScheme_example
	# The protocal the app uses to load the app via a browser
	urlScheme = "",
	# platforms: String = ""   Eg: platforms_example
	# A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` 
	platforms = "",
	# downloadUrls: String = ""   Eg: downloadUrls_example
	# Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  
	downloadUrls = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# List of categories to apply
	categoryIds = "",
	# scoringType: String = "GAME_LEVEL"   Eg: scoringType_example
	# The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT
	scoringType = "GAME_LEVEL",
	# hintCost: int = 11   Eg: 56
	# The cost of hints
	hintCost = 11,
	# maxScore: int = 125   Eg: 56
	# The maximum score that will be possible
	maxScore = 125,
	# ticketsPerPoint: float = 0.037   Eg: 3.4
	# The point-to-ticket conversion ratio
	ticketsPerPoint = 0.037,
	# hasGameData: bool = true   Eg: true
	# Determines whether the application uses services to save custom game objects
	hasGameData = true,
	# publicNotifications: bool   Eg: true
	# Public Notifications
	publicNotifications = null,
	# useMatchingAlgorithm: bool   Eg: true
	# Use Matching Algorithm
	useMatchingAlgorithm = null,
	# globalTickets: bool = false   Eg: true
	# Determines whether earned tickets are applied across all applications
	globalTickets = false,
	# buildVersion: float = 1   Eg: 3.4
	# The current build version of the application
	buildVersion = 1,
	# apiVersion: float   Eg: 3.4
	# The current API version the application uses
	apiVersion = null,
	# placementName: String = ""   Eg: placementName_example
	# The name of the placement
	placementName = "",
	# placementDescription: String = ""   Eg: placementDescription_example
	# The description of the placement
	placementDescription = "",
	# placementSize: String = ""   Eg: placementSize_example
	# The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)
	placementSize = "",
	# placementHeight: int   Eg: 56
	# The height of a custom ad size
	placementHeight = null,
	# placementWidth: int   Eg: 56
	# The width of a custom ad size
	placementWidth = null,
	# placementRefreshInterval: int   Eg: 56
	# The refresh interval in seconds
	placementRefreshInterval = null,
	# createObjectStore: bool = true   Eg: true
	# Generate a custom object store to use
	createObjectStore = true,
	# publicContentApproval: bool = false   Eg: true
	# Determine whether or not public content requires admin approval before it becomes public
	publicContentApproval = false,
	# productionMode: bool = false   Eg: true
	# Determines whether the application uses production or sandbox services
	productionMode = false,
	# minimumSessionLength: int   Eg: 56
	# Minimum Session Length
	minimumSessionLength = null,
	# sessionGapLength: int   Eg: 56
	# Session Gap Length
	sessionGapLength = null,
	# localAdsEnabled: bool = false   Eg: true
	# Local Ads Enabled
	localAdsEnabled = false,
	# sqootApiKey: String = ""   Eg: sqootApiKey_example
	# Sqoot Api Key
	sqootApiKey = "",
	# trilatProcessingType: String = "FINGERPRINT"   Eg: trilatProcessingType_example
	# Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT
	trilatProcessingType = "FINGERPRINT",
	# maxSampleSize: int   Eg: 56
	# Determines what the maximum sample size during trilateration
	maxSampleSize = null,
	# minRSSI: int   Eg: 1.2
	# Determines what the minimum acceptable RSSI value
	minRSSI = null,
	# modules: String = "ALL"   Eg: modules_example
	# List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL
	modules = "ALL",
	# authorizedCount: int = 1   Eg: 56
	# How many servers the license will support
	authorizedCount = 1,
	# authorizedServers: String = ""   Eg: authorizedServers_example
	# The list of ip addresses of servers the license will support, leave null for any server
	authorizedServers = "",
	# defaultTimezone: String = ""   Eg: defaultTimezone_example
	# Sets the default timezone for the app (used for leaderboards and other time specific content)
	defaultTimezone = "",
	# smtpPass: String = ""   Eg: smtpPass_example
	# SMTP Pass
	smtpPass = "",
	# metaData: String = ""   Eg: metaData_example
	# The application meta data. Defined by the client
	metaData = "",
	# placementMetaData: String = ""   Eg: placementMetaData_example
	# The ad placement meta data. Defined by the client
	placementMetaData = "",
	# ipsFloor: bool = false   Eg: true
	# Create floor tables for Ips
	ipsFloor = false,
	# enableAPNSBadge: bool = true   Eg: true
	# Enables setting the APNS badge value in the payload
	enableAPNSBadge = true,
	# includeInReport: bool = true   Eg: true
	# Enables using the application in session reports
	includeInReport = true,
	# defaultAppFilterId: float   Eg: 789
	# Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.
	defaultAppFilterId = null,
	# enableWelcomeEmail: bool   Eg: true
	# Enables whether the default welcome email will be sent for new app users
	enableWelcomeEmail = null,
	# appleAppId: String = ""   Eg: appleAppId_example
	# The Apple Application ID
	appleAppId = "",
	# appleTeamId: String = ""   Eg: appleTeamId_example
	# The Apple Team ID
	appleTeamId = "",
	# appleAuthKeyId: String = ""   Eg: appleAuthKeyId_example
	# The Apple Auth Key ID
	appleAuthKeyId = "",
	# appleAuthKey: String   Eg: BINARY_DATA_HERE
	# The Apple Auth Signin Key (p8) File
	appleAuthKey = null,
	# appleIssuerId: String = ""   Eg: appleIssuerId_example
	# The Apple Issuer ID
	appleIssuerId = "",
	# appStoreKeyId: String = ""   Eg: appStoreKeyId_example
	# The Apple App Store Key ID
	appStoreKeyId = "",
	# appStoreKey: String   Eg: BINARY_DATA_HERE
	# The Apple App Store Key (p8) File
	appStoreKey = null,
	# googlePrivateKeyFile: String   Eg: BINARY_DATA_HERE
	# This is the private key file for your Google service account.
	googlePrivateKeyFile = null,
	# authorizeNetApiKey: String = ""   Eg: authorizeNetApiKey_example
	# Authorize Net Api Key
	authorizeNetApiKey = "",
	# authorizeNetTransactionKey: String = ""   Eg: authorizeNetTransactionKey_example
	# Authorize Net Transaction Key
	authorizeNetTransactionKey = "",
	# emailSender: String = ""   Eg: emailSender_example
	# Email Sender
	emailSender = "",
	# smtpUser: String = ""   Eg: smtpUser_example
	# SMTP User
	smtpUser = "",
	# smtpHost: String = ""   Eg: smtpHost_example
	# SMTP Host
	smtpHost = "",
	# vatomBusinessId: String = ""   Eg: vatomBusinessId_example
	# Vatom Business Id
	vatomBusinessId = "",
	# vatomRestClientId: String = ""   Eg: vatomRestClientId_example
	# Vatom REST Client Id
	vatomRestClientId = "",
	# vatomRestSecretKey: String = ""   Eg: vatomRestSecretKey_example
	# Vatom Secret Key
	vatomRestSecretKey = "",
	# twilioAccountSID: String = ""   Eg: twilioAccountSID_example
	# Twilio Account SID
	twilioAccountSID = "",
	# twilioAuthToken: String = ""   Eg: twilioAuthToken_example
	# Twilio Auth Token
	twilioAuthToken = "",
	# twilioSenderPhoneNumber: String = ""   Eg: twilioSenderPhoneNumber_example
	# Twilio Sender Phone Number
	twilioSenderPhoneNumber = "",
	# openAISecretKey: String = ""   Eg: openAISecretKey_example
	# OpenAI Secret API Key
	openAISecretKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/application/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["appName"] = appName
	bzz_query["about"] = about
	bzz_query["bundleId"] = bundleId
	bzz_query["appIconAssetId"] = appIconAssetId
	bzz_query["appLogoAssetId"] = appLogoAssetId
	bzz_query["facebookAppId"] = facebookAppId
	bzz_query["facebookAppSecret"] = facebookAppSecret
	bzz_query["googleApiKey"] = googleApiKey
	bzz_query["updateEULADate"] = updateEULADate
	bzz_query["eulaVersion"] = eulaVersion
	bzz_query["landingPageUrl"] = landingPageUrl
	bzz_query["showInActivities"] = showInActivities
	bzz_query["activityDescription"] = activityDescription
	bzz_query["inviteWelcomeText"] = inviteWelcomeText
	bzz_query["invitePageUrl"] = invitePageUrl
	bzz_query["urlScheme"] = urlScheme
	bzz_query["platforms"] = platforms
	bzz_query["downloadUrls"] = downloadUrls
	bzz_query["categoryIds"] = categoryIds
	bzz_query["scoringType"] = scoringType
	bzz_query["hintCost"] = hintCost
	bzz_query["maxScore"] = maxScore
	bzz_query["ticketsPerPoint"] = ticketsPerPoint
	bzz_query["hasGameData"] = hasGameData
	bzz_query["publicNotifications"] = publicNotifications
	bzz_query["useMatchingAlgorithm"] = useMatchingAlgorithm
	bzz_query["globalTickets"] = globalTickets
	bzz_query["buildVersion"] = buildVersion
	bzz_query["apiVersion"] = apiVersion
	bzz_query["placementName"] = placementName
	bzz_query["placementDescription"] = placementDescription
	bzz_query["placementSize"] = placementSize
	bzz_query["placementHeight"] = placementHeight
	bzz_query["placementWidth"] = placementWidth
	bzz_query["placementRefreshInterval"] = placementRefreshInterval
	bzz_query["createObjectStore"] = createObjectStore
	bzz_query["publicContentApproval"] = publicContentApproval
	bzz_query["productionMode"] = productionMode
	bzz_query["minimumSessionLength"] = minimumSessionLength
	bzz_query["sessionGapLength"] = sessionGapLength
	bzz_query["localAdsEnabled"] = localAdsEnabled
	bzz_query["sqootApiKey"] = sqootApiKey
	bzz_query["trilatProcessingType"] = trilatProcessingType
	bzz_query["maxSampleSize"] = maxSampleSize
	bzz_query["minRSSI"] = minRSSI
	bzz_query["modules"] = modules
	bzz_query["authorizedCount"] = authorizedCount
	bzz_query["authorizedServers"] = authorizedServers
	bzz_query["defaultTimezone"] = defaultTimezone
	bzz_query["smtpPass"] = smtpPass
	bzz_query["metaData"] = metaData
	bzz_query["placementMetaData"] = placementMetaData
	bzz_query["ipsFloor"] = ipsFloor
	bzz_query["enableAPNSBadge"] = enableAPNSBadge
	bzz_query["includeInReport"] = includeInReport
	bzz_query["defaultAppFilterId"] = defaultAppFilterId
	bzz_query["enableWelcomeEmail"] = enableWelcomeEmail
	bzz_query["appleAppId"] = appleAppId
	bzz_query["appleTeamId"] = appleTeamId
	bzz_query["appleAuthKeyId"] = appleAuthKeyId
	bzz_query["appleAuthKey"] = appleAuthKey
	bzz_query["appleIssuerId"] = appleIssuerId
	bzz_query["appStoreKeyId"] = appStoreKeyId
	bzz_query["appStoreKey"] = appStoreKey
	bzz_query["googlePrivateKeyFile"] = googlePrivateKeyFile
	bzz_query["authorizeNetApiKey"] = authorizeNetApiKey
	bzz_query["authorizeNetTransactionKey"] = authorizeNetTransactionKey
	bzz_query["emailSender"] = emailSender
	bzz_query["smtpUser"] = smtpUser
	bzz_query["smtpHost"] = smtpHost
	bzz_query["vatomBusinessId"] = vatomBusinessId
	bzz_query["vatomRestClientId"] = vatomRestClientId
	bzz_query["vatomRestSecretKey"] = vatomRestSecretKey
	bzz_query["twilioAccountSID"] = twilioAccountSID
	bzz_query["twilioAuthToken"] = twilioAuthToken
	bzz_query["twilioSenderPhoneNumber"] = twilioSenderPhoneNumber
	bzz_query["openAISecretKey"] = openAISecretKey

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ApplicationResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_application_threaded(
	# appKey: String = ""   Eg: appKey_example
	# The application key for updating an existing application
	appKey: String,
	# appName: String = ""   Eg: appName_example
	# The name of the application
	appName: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# about: String = ""   Eg: about_example
	# The description of the application
	about = "",
	# bundleId: String = ""   Eg: bundleId_example
	# The application bundle identifier (format - com.company.appName)
	bundleId = "",
	# appIconAssetId: float   Eg: 789
	# The application icon asset id
	appIconAssetId = null,
	# appLogoAssetId: float   Eg: 789
	# The application logo asset id
	appLogoAssetId = null,
	# facebookAppId: String = ""   Eg: facebookAppId_example
	# The Facebook application id
	facebookAppId = "",
	# facebookAppSecret: String = ""   Eg: facebookAppSecret_example
	# The Facebook application secret
	facebookAppSecret = "",
	# googleApiKey: String = ""   Eg: googleApiKey_example
	# This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging
	googleApiKey = "",
	# updateEULADate: bool   Eg: true
	# Determines whether to update the EULA date
	updateEULADate = null,
	# eulaVersion: String = ""   Eg: eulaVersion_example
	# The EULA version
	eulaVersion = "",
	# landingPageUrl: String = ""   Eg: landingPageUrl_example
	# The landing page URL
	landingPageUrl = "",
	# showInActivities: bool   Eg: true
	# Determines whether to show the application in the activity feed
	showInActivities = null,
	# activityDescription: String = ""   Eg: activityDescription_example
	# The description of the application in the activity feed
	activityDescription = "",
	# inviteWelcomeText: String = ""   Eg: inviteWelcomeText_example
	# The text to display on the invite page
	inviteWelcomeText = "",
	# invitePageUrl: String = ""   Eg: invitePageUrl_example
	# The url to the application invite page
	invitePageUrl = "",
	# urlScheme: String = ""   Eg: urlScheme_example
	# The protocal the app uses to load the app via a browser
	urlScheme = "",
	# platforms: String = ""   Eg: platforms_example
	# A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` 
	platforms = "",
	# downloadUrls: String = ""   Eg: downloadUrls_example
	# Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  
	downloadUrls = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# List of categories to apply
	categoryIds = "",
	# scoringType: String = "GAME_LEVEL"   Eg: scoringType_example
	# The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT
	scoringType = "GAME_LEVEL",
	# hintCost: int = 11   Eg: 56
	# The cost of hints
	hintCost = 11,
	# maxScore: int = 125   Eg: 56
	# The maximum score that will be possible
	maxScore = 125,
	# ticketsPerPoint: float = 0.037   Eg: 3.4
	# The point-to-ticket conversion ratio
	ticketsPerPoint = 0.037,
	# hasGameData: bool = true   Eg: true
	# Determines whether the application uses services to save custom game objects
	hasGameData = true,
	# publicNotifications: bool   Eg: true
	# Public Notifications
	publicNotifications = null,
	# useMatchingAlgorithm: bool   Eg: true
	# Use Matching Algorithm
	useMatchingAlgorithm = null,
	# globalTickets: bool = false   Eg: true
	# Determines whether earned tickets are applied across all applications
	globalTickets = false,
	# buildVersion: float = 1   Eg: 3.4
	# The current build version of the application
	buildVersion = 1,
	# apiVersion: float   Eg: 3.4
	# The current API version the application uses
	apiVersion = null,
	# placementName: String = ""   Eg: placementName_example
	# The name of the placement
	placementName = "",
	# placementDescription: String = ""   Eg: placementDescription_example
	# The description of the placement
	placementDescription = "",
	# placementSize: String = ""   Eg: placementSize_example
	# The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)
	placementSize = "",
	# placementHeight: int   Eg: 56
	# The height of a custom ad size
	placementHeight = null,
	# placementWidth: int   Eg: 56
	# The width of a custom ad size
	placementWidth = null,
	# placementRefreshInterval: int   Eg: 56
	# The refresh interval in seconds
	placementRefreshInterval = null,
	# createObjectStore: bool = true   Eg: true
	# Generate a custom object store to use
	createObjectStore = true,
	# publicContentApproval: bool = false   Eg: true
	# Determine whether or not public content requires admin approval before it becomes public
	publicContentApproval = false,
	# productionMode: bool = false   Eg: true
	# Determines whether the application uses production or sandbox services
	productionMode = false,
	# minimumSessionLength: int   Eg: 56
	# Minimum Session Length
	minimumSessionLength = null,
	# sessionGapLength: int   Eg: 56
	# Session Gap Length
	sessionGapLength = null,
	# localAdsEnabled: bool = false   Eg: true
	# Local Ads Enabled
	localAdsEnabled = false,
	# sqootApiKey: String = ""   Eg: sqootApiKey_example
	# Sqoot Api Key
	sqootApiKey = "",
	# trilatProcessingType: String = "FINGERPRINT"   Eg: trilatProcessingType_example
	# Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT
	trilatProcessingType = "FINGERPRINT",
	# maxSampleSize: int   Eg: 56
	# Determines what the maximum sample size during trilateration
	maxSampleSize = null,
	# minRSSI: int   Eg: 1.2
	# Determines what the minimum acceptable RSSI value
	minRSSI = null,
	# modules: String = "ALL"   Eg: modules_example
	# List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL
	modules = "ALL",
	# authorizedCount: int = 1   Eg: 56
	# How many servers the license will support
	authorizedCount = 1,
	# authorizedServers: String = ""   Eg: authorizedServers_example
	# The list of ip addresses of servers the license will support, leave null for any server
	authorizedServers = "",
	# defaultTimezone: String = ""   Eg: defaultTimezone_example
	# Sets the default timezone for the app (used for leaderboards and other time specific content)
	defaultTimezone = "",
	# smtpPass: String = ""   Eg: smtpPass_example
	# SMTP Pass
	smtpPass = "",
	# metaData: String = ""   Eg: metaData_example
	# The application meta data. Defined by the client
	metaData = "",
	# placementMetaData: String = ""   Eg: placementMetaData_example
	# The ad placement meta data. Defined by the client
	placementMetaData = "",
	# ipsFloor: bool = false   Eg: true
	# Create floor tables for Ips
	ipsFloor = false,
	# enableAPNSBadge: bool = true   Eg: true
	# Enables setting the APNS badge value in the payload
	enableAPNSBadge = true,
	# includeInReport: bool = true   Eg: true
	# Enables using the application in session reports
	includeInReport = true,
	# defaultAppFilterId: float   Eg: 789
	# Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.
	defaultAppFilterId = null,
	# enableWelcomeEmail: bool   Eg: true
	# Enables whether the default welcome email will be sent for new app users
	enableWelcomeEmail = null,
	# appleAppId: String = ""   Eg: appleAppId_example
	# The Apple Application ID
	appleAppId = "",
	# appleTeamId: String = ""   Eg: appleTeamId_example
	# The Apple Team ID
	appleTeamId = "",
	# appleAuthKeyId: String = ""   Eg: appleAuthKeyId_example
	# The Apple Auth Key ID
	appleAuthKeyId = "",
	# appleAuthKey: String   Eg: BINARY_DATA_HERE
	# The Apple Auth Signin Key (p8) File
	appleAuthKey = null,
	# appleIssuerId: String = ""   Eg: appleIssuerId_example
	# The Apple Issuer ID
	appleIssuerId = "",
	# appStoreKeyId: String = ""   Eg: appStoreKeyId_example
	# The Apple App Store Key ID
	appStoreKeyId = "",
	# appStoreKey: String   Eg: BINARY_DATA_HERE
	# The Apple App Store Key (p8) File
	appStoreKey = null,
	# googlePrivateKeyFile: String   Eg: BINARY_DATA_HERE
	# This is the private key file for your Google service account.
	googlePrivateKeyFile = null,
	# authorizeNetApiKey: String = ""   Eg: authorizeNetApiKey_example
	# Authorize Net Api Key
	authorizeNetApiKey = "",
	# authorizeNetTransactionKey: String = ""   Eg: authorizeNetTransactionKey_example
	# Authorize Net Transaction Key
	authorizeNetTransactionKey = "",
	# emailSender: String = ""   Eg: emailSender_example
	# Email Sender
	emailSender = "",
	# smtpUser: String = ""   Eg: smtpUser_example
	# SMTP User
	smtpUser = "",
	# smtpHost: String = ""   Eg: smtpHost_example
	# SMTP Host
	smtpHost = "",
	# vatomBusinessId: String = ""   Eg: vatomBusinessId_example
	# Vatom Business Id
	vatomBusinessId = "",
	# vatomRestClientId: String = ""   Eg: vatomRestClientId_example
	# Vatom REST Client Id
	vatomRestClientId = "",
	# vatomRestSecretKey: String = ""   Eg: vatomRestSecretKey_example
	# Vatom Secret Key
	vatomRestSecretKey = "",
	# twilioAccountSID: String = ""   Eg: twilioAccountSID_example
	# Twilio Account SID
	twilioAccountSID = "",
	# twilioAuthToken: String = ""   Eg: twilioAuthToken_example
	# Twilio Auth Token
	twilioAuthToken = "",
	# twilioSenderPhoneNumber: String = ""   Eg: twilioSenderPhoneNumber_example
	# Twilio Sender Phone Number
	twilioSenderPhoneNumber = "",
	# openAISecretKey: String = ""   Eg: openAISecretKey_example
	# OpenAI Secret API Key
	openAISecretKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_application")
	bzz_callable.bind(
		appKey,
		appName,
		deviceId,
		accountId,
		about,
		bundleId,
		appIconAssetId,
		appLogoAssetId,
		facebookAppId,
		facebookAppSecret,
		googleApiKey,
		updateEULADate,
		eulaVersion,
		landingPageUrl,
		showInActivities,
		activityDescription,
		inviteWelcomeText,
		invitePageUrl,
		urlScheme,
		platforms,
		downloadUrls,
		categoryIds,
		scoringType,
		hintCost,
		maxScore,
		ticketsPerPoint,
		hasGameData,
		publicNotifications,
		useMatchingAlgorithm,
		globalTickets,
		buildVersion,
		apiVersion,
		placementName,
		placementDescription,
		placementSize,
		placementHeight,
		placementWidth,
		placementRefreshInterval,
		createObjectStore,
		publicContentApproval,
		productionMode,
		minimumSessionLength,
		sessionGapLength,
		localAdsEnabled,
		sqootApiKey,
		trilatProcessingType,
		maxSampleSize,
		minRSSI,
		modules,
		authorizedCount,
		authorizedServers,
		defaultTimezone,
		smtpPass,
		metaData,
		placementMetaData,
		ipsFloor,
		enableAPNSBadge,
		includeInReport,
		defaultAppFilterId,
		enableWelcomeEmail,
		appleAppId,
		appleTeamId,
		appleAuthKeyId,
		appleAuthKey,
		appleIssuerId,
		appStoreKeyId,
		appStoreKey,
		googlePrivateKeyFile,
		authorizeNetApiKey,
		authorizeNetTransactionKey,
		emailSender,
		smtpUser,
		smtpHost,
		vatomBusinessId,
		vatomRestClientId,
		vatomRestSecretKey,
		twilioAccountSID,
		twilioAuthToken,
		twilioSenderPhoneNumber,
		openAISecretKey,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateApplicationActive → POST /application/active
# Change Appliation Status
#
# Set the application's active flag to true/false. This effectively activates or deactivates the application.
func update_application_active(
	# accountId: float   Eg: 789
	# The account used to perform the delete, must have rights to edit the application.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The key of the application to be deleted
	appKey: String,
	# active: bool   Eg: true
	# If true then set to active, false otherwise
	active: bool,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/application/active"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["active"] = active

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_application_active_threaded(
	# accountId: float   Eg: 789
	# The account used to perform the delete, must have rights to edit the application.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The key of the application to be deleted
	appKey: String,
	# active: bool   Eg: true
	# If true then set to active, false otherwise
	active: bool,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_application_active")
	bzz_callable.bind(
		accountId,
		appKey,
		active,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateApplicationPlacement → POST /application/placement/update
# Update Ad Placement
#
# Updates an ad placement for an application.
func update_application_placement(
	# placementId: float   Eg: 789
	# The id of the placement to update, the user must have rights to the application the ad placement is for
	placementId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# name: String = ""   Eg: name_example
	# The name of the placement
	name = "",
	# description: String = ""   Eg: description_example
	# The description of the placement
	description = "",
	# size: String = ""   Eg: size_example
	# The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM
	size = "",
	# height: int   Eg: 56
	# The height of a custom ad size
	height = null,
	# width: int   Eg: 56
	# The width of a custom ad size
	width = null,
	# refreshInterval: int   Eg: 56
	# The refresh interval in seconds
	refreshInterval = null,
	# defaultImageId: float   Eg: 789
	# Default Image Id
	defaultImageId = null,
	# active: bool   Eg: true
	# Active
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/application/placement/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["placementId"] = placementId
	bzz_query["name"] = name
	bzz_query["description"] = description
	bzz_query["size"] = size
	bzz_query["height"] = height
	bzz_query["width"] = width
	bzz_query["refreshInterval"] = refreshInterval
	bzz_query["defaultImageId"] = defaultImageId
	bzz_query["active"] = active

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PlacementResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_application_placement_threaded(
	# placementId: float   Eg: 789
	# The id of the placement to update, the user must have rights to the application the ad placement is for
	placementId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# name: String = ""   Eg: name_example
	# The name of the placement
	name = "",
	# description: String = ""   Eg: description_example
	# The description of the placement
	description = "",
	# size: String = ""   Eg: size_example
	# The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM
	size = "",
	# height: int   Eg: 56
	# The height of a custom ad size
	height = null,
	# width: int   Eg: 56
	# The width of a custom ad size
	width = null,
	# refreshInterval: int   Eg: 56
	# The refresh interval in seconds
	refreshInterval = null,
	# defaultImageId: float   Eg: 789
	# Default Image Id
	defaultImageId = null,
	# active: bool   Eg: true
	# Active
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_application_placement")
	bzz_callable.bind(
		placementId,
		deviceId,
		accountId,
		name,
		description,
		size,
		height,
		width,
		refreshInterval,
		defaultImageId,
		active,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation uploadApplicationCertificate → POST /application/certificate/create
# Create Application Certificate
#
# Uploads a certificate for an application that the user has access to.
func upload_application_certificate(
	# appKey: String = ""   Eg: appKey_example
	# The key of the application
	appKey: String,
	# deviceId: String = ""   Eg: deviceId_example
	# Device Id
	deviceId = "",
	# accountId: float   Eg: 789
	# The account used to perform the delete, must have rights to edit the application.
	accountId = null,
	# certificate: String   Eg: BINARY_DATA_HERE
	# Certificate
	certificate = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/application/certificate/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["certificate"] = certificate

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func upload_application_certificate_threaded(
	# appKey: String = ""   Eg: appKey_example
	# The key of the application
	appKey: String,
	# deviceId: String = ""   Eg: deviceId_example
	# Device Id
	deviceId = "",
	# accountId: float   Eg: 789
	# The account used to perform the delete, must have rights to edit the application.
	accountId = null,
	# certificate: String   Eg: BINARY_DATA_HERE
	# Certificate
	certificate = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "upload_application_certificate")
	bzz_callable.bind(
		appKey,
		deviceId,
		accountId,
		certificate,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


