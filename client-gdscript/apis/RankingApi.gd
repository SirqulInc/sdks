extends ApiBee
class_name RankingApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API RankingApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "RankingApi"


# Operation getHistoricalRankings → GET /ranking/historical/search
# Search Historical Rankings
#
# Get historical leaderboard rankings by time-frame.
func get_historical_rankings(
	# appKey: String = ""   Eg: appKey_example
	# the application key for filtering results by application
	appKey: String,
	# rankType: String = ""   Eg: rankType_example
	# the rank type to return
	rankType: String,
	# startDate: float   Eg: 789
	# timestamp in milliseconds to filter results with
	startDate: float,
	# endDate: float   Eg: 789
	# timestamp in milliseconds to filter results with
	endDate: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user
	accountId = null,
	# sortField: String = "TOTAL"   Eg: sortField_example
	# determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST
	sortField = "TOTAL",
	# descending: bool = true   Eg: true
	# determines whether to return results in ascending or descending order
	descending = true,
	# start: int = 0   Eg: 56
	# the start index for pagination
	start = 0,
	# limit: int = 100   Eg: 56
	# the limit for pagination
	limit = 100,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/ranking/historical/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["rankType"] = rankType
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = RankFullResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_historical_rankings_threaded(
	# appKey: String = ""   Eg: appKey_example
	# the application key for filtering results by application
	appKey: String,
	# rankType: String = ""   Eg: rankType_example
	# the rank type to return
	rankType: String,
	# startDate: float   Eg: 789
	# timestamp in milliseconds to filter results with
	startDate: float,
	# endDate: float   Eg: 789
	# timestamp in milliseconds to filter results with
	endDate: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user
	accountId = null,
	# sortField: String = "TOTAL"   Eg: sortField_example
	# determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST
	sortField = "TOTAL",
	# descending: bool = true   Eg: true
	# determines whether to return results in ascending or descending order
	descending = true,
	# start: int = 0   Eg: 56
	# the start index for pagination
	start = 0,
	# limit: int = 100   Eg: 56
	# the limit for pagination
	limit = 100,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_historical_rankings")
	bzz_callable.bind(
		appKey,
		rankType,
		startDate,
		endDate,
		deviceId,
		accountId,
		sortField,
		descending,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getRankings → GET /ranking/search
# Search Rankings
#
# Get leader board rankings. This is an all in one endpoint that can return multiple ranking types and also the current user rank.
func get_rankings(
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key for filtering results by application (required for non-EXECUTIVE users)
	appKey = "",
	# q: String = ""   Eg: q_example
	# This parameter is deprecated.
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# keyword to search for
	keyword = "",
	# rankType: String = "POINTS,DOWNLOADS,INVITATIONS"   Eg: rankType_example
	# a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS
	rankType = "POINTS,DOWNLOADS,INVITATIONS",
	# leaderboardMode: String = "GLOBAL"   Eg: leaderboardMode_example
	# the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId
	leaderboardMode = "GLOBAL",
	# withinAccountIds: String = ""   Eg: withinAccountIds_example
	# comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts.
	withinAccountIds = "",
	# returnUserRank: bool = true   Eg: true
	# determines whether to return the user's current rank in the response. This can be turned off for sequential paginated requests.
	returnUserRank = true,
	# albumId: float   Eg: 789
	# album id to use when performing CUSTOM filters
	albumId = null,
	# audienceId: float   Eg: 789
	# audience id to use when performing CUSTOM filters
	audienceId = null,
	# sortField: String = "TOTAL"   Eg: sortField_example
	# determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score
	sortField = "TOTAL",
	# descending: bool = true   Eg: true
	# determines whether to return results in ascending or descending order
	descending = true,
	# i: int   Eg: 56
	# This parameter is deprecated.
	i = null,
	# start: int = 0   Eg: 56
	# the start index for pagination
	start = 0,
	# l: int   Eg: 56
	# This parameter is deprecated.
	l = null,
	# limit: int = 100   Eg: 56
	# the limit for pagination
	limit = 100,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/ranking/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["gameType"] = gameType
	bzz_query["appKey"] = appKey
	bzz_query["q"] = q
	bzz_query["keyword"] = keyword
	bzz_query["rankType"] = rankType
	bzz_query["leaderboardMode"] = leaderboardMode
	bzz_query["withinAccountIds"] = withinAccountIds
	bzz_query["returnUserRank"] = returnUserRank
	bzz_query["albumId"] = albumId
	bzz_query["audienceId"] = audienceId
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["_i"] = i
	bzz_query["start"] = start
	bzz_query["_l"] = l
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = RankFullResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_rankings_threaded(
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key for filtering results by application (required for non-EXECUTIVE users)
	appKey = "",
	# q: String = ""   Eg: q_example
	# This parameter is deprecated.
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# keyword to search for
	keyword = "",
	# rankType: String = "POINTS,DOWNLOADS,INVITATIONS"   Eg: rankType_example
	# a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS
	rankType = "POINTS,DOWNLOADS,INVITATIONS",
	# leaderboardMode: String = "GLOBAL"   Eg: leaderboardMode_example
	# the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId
	leaderboardMode = "GLOBAL",
	# withinAccountIds: String = ""   Eg: withinAccountIds_example
	# comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts.
	withinAccountIds = "",
	# returnUserRank: bool = true   Eg: true
	# determines whether to return the user's current rank in the response. This can be turned off for sequential paginated requests.
	returnUserRank = true,
	# albumId: float   Eg: 789
	# album id to use when performing CUSTOM filters
	albumId = null,
	# audienceId: float   Eg: 789
	# audience id to use when performing CUSTOM filters
	audienceId = null,
	# sortField: String = "TOTAL"   Eg: sortField_example
	# determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score
	sortField = "TOTAL",
	# descending: bool = true   Eg: true
	# determines whether to return results in ascending or descending order
	descending = true,
	# i: int   Eg: 56
	# This parameter is deprecated.
	i = null,
	# start: int = 0   Eg: 56
	# the start index for pagination
	start = 0,
	# l: int   Eg: 56
	# This parameter is deprecated.
	l = null,
	# limit: int = 100   Eg: 56
	# the limit for pagination
	limit = 100,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_rankings")
	bzz_callable.bind(
		deviceId,
		accountId,
		gameType,
		appKey,
		q,
		keyword,
		rankType,
		leaderboardMode,
		withinAccountIds,
		returnUserRank,
		albumId,
		audienceId,
		sortField,
		descending,
		i,
		start,
		l,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getUserRank → POST /ranking/personal/ranks
# Get Personal Rankings
#
# Returns the user's ranks for one or more rank types and modes.
func get_user_rank(
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key for filtering results by application (required)
	appKey = "",
	# rankType: String = ""   Eg: rankType_example
	# pass in all rankTypes and children rankTypes
	rankType = "",
	# returnUserRank: bool = false   Eg: true
	# determines whether to return the user's current rank in the response, for each rankType
	returnUserRank = false,
	# leaderboardMode: String = "GLOBAL"   Eg: leaderboardMode_example
	# the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM
	leaderboardMode = "GLOBAL",
	# sortField: String = "TOTAL"   Eg: sortField_example
	# determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST
	sortField = "TOTAL",
	# keyword: String = ""   Eg: keyword_example
	# keyword to search for (on rankType)
	keyword = "",
	# descending: bool = true   Eg: true
	# determines whether to return results in descending order
	descending = true,
	# start: int = 0   Eg: 56
	# the start index for pagination
	start = 0,
	# limit: int = 100   Eg: 56
	# the limit for pagination
	limit = 100,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/ranking/personal/ranks"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["rankType"] = rankType
	bzz_query["returnUserRank"] = returnUserRank
	bzz_query["leaderboardMode"] = leaderboardMode
	bzz_query["sortField"] = sortField
	bzz_query["keyword"] = keyword
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_user_rank_threaded(
	# deviceId: String = ""   Eg: deviceId_example
	# a unique id given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key for filtering results by application (required)
	appKey = "",
	# rankType: String = ""   Eg: rankType_example
	# pass in all rankTypes and children rankTypes
	rankType = "",
	# returnUserRank: bool = false   Eg: true
	# determines whether to return the user's current rank in the response, for each rankType
	returnUserRank = false,
	# leaderboardMode: String = "GLOBAL"   Eg: leaderboardMode_example
	# the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM
	leaderboardMode = "GLOBAL",
	# sortField: String = "TOTAL"   Eg: sortField_example
	# determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST
	sortField = "TOTAL",
	# keyword: String = ""   Eg: keyword_example
	# keyword to search for (on rankType)
	keyword = "",
	# descending: bool = true   Eg: true
	# determines whether to return results in descending order
	descending = true,
	# start: int = 0   Eg: 56
	# the start index for pagination
	start = 0,
	# limit: int = 100   Eg: 56
	# the limit for pagination
	limit = 100,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_user_rank")
	bzz_callable.bind(
		deviceId,
		accountId,
		appKey,
		rankType,
		returnUserRank,
		leaderboardMode,
		sortField,
		keyword,
		descending,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation overrideUserRank → POST /ranking/override
# Override User Rank
#
# Allows an admin of an application to override a user's scores for a leaderboard.
func override_user_rank(
	# accountId: float   Eg: 789
	# the logged in user's account id (must have permissions to manage data for the application)
	accountId: float,
	# ownerAccountId: float   Eg: 789
	# the end user's account id to override
	ownerAccountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key the leaderboard is for
	appKey: String,
	# rankType: String = ""   Eg: rankType_example
	# the rankType of the leaderboard
	rankType: String,
	# totalScore: float   Eg: 789
	# the total score to update
	totalScore = null,
	# totalCount: float   Eg: 789
	# the total count to update
	totalCount = null,
	# totalTime: float   Eg: 789
	# the total time to update
	totalTime = null,
	# dailyScore: float   Eg: 789
	# the daily score to update
	dailyScore = null,
	# dailyCount: float   Eg: 789
	# the daily count to update
	dailyCount = null,
	# dailyTime: float   Eg: 789
	# the daily time to update
	dailyTime = null,
	# weeklyScore: float   Eg: 789
	# the weekly score to update
	weeklyScore = null,
	# weeklyCount: float   Eg: 789
	# the weekly count to update
	weeklyCount = null,
	# weeklyTime: float   Eg: 789
	# the weekly time to update
	weeklyTime = null,
	# monthlyScore: float   Eg: 789
	# the monthly score to update
	monthlyScore = null,
	# monthlyCount: float   Eg: 789
	# the monthly count to update
	monthlyCount = null,
	# monthlyTime: float   Eg: 789
	# the monthly time to update
	monthlyTime = null,
	# topScore: float   Eg: 789
	# the top score to update
	topScore = null,
	# lowestScore: float   Eg: 789
	# the lowest score to update
	lowestScore = null,
	# streakCount: float   Eg: 789
	# the streak count to update
	streakCount = null,
	# streakBestCount: float   Eg: 789
	# the best streak count to update
	streakBestCount = null,
	# startDate: float   Eg: 789
	# the start date to update
	startDate = null,
	# endDate: float   Eg: 789
	# the end date to update
	endDate = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/ranking/override"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["ownerAccountId"] = ownerAccountId
	bzz_query["appKey"] = appKey
	bzz_query["rankType"] = rankType
	bzz_query["totalScore"] = totalScore
	bzz_query["totalCount"] = totalCount
	bzz_query["totalTime"] = totalTime
	bzz_query["dailyScore"] = dailyScore
	bzz_query["dailyCount"] = dailyCount
	bzz_query["dailyTime"] = dailyTime
	bzz_query["weeklyScore"] = weeklyScore
	bzz_query["weeklyCount"] = weeklyCount
	bzz_query["weeklyTime"] = weeklyTime
	bzz_query["monthlyScore"] = monthlyScore
	bzz_query["monthlyCount"] = monthlyCount
	bzz_query["monthlyTime"] = monthlyTime
	bzz_query["topScore"] = topScore
	bzz_query["lowestScore"] = lowestScore
	bzz_query["streakCount"] = streakCount
	bzz_query["streakBestCount"] = streakBestCount
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func override_user_rank_threaded(
	# accountId: float   Eg: 789
	# the logged in user's account id (must have permissions to manage data for the application)
	accountId: float,
	# ownerAccountId: float   Eg: 789
	# the end user's account id to override
	ownerAccountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key the leaderboard is for
	appKey: String,
	# rankType: String = ""   Eg: rankType_example
	# the rankType of the leaderboard
	rankType: String,
	# totalScore: float   Eg: 789
	# the total score to update
	totalScore = null,
	# totalCount: float   Eg: 789
	# the total count to update
	totalCount = null,
	# totalTime: float   Eg: 789
	# the total time to update
	totalTime = null,
	# dailyScore: float   Eg: 789
	# the daily score to update
	dailyScore = null,
	# dailyCount: float   Eg: 789
	# the daily count to update
	dailyCount = null,
	# dailyTime: float   Eg: 789
	# the daily time to update
	dailyTime = null,
	# weeklyScore: float   Eg: 789
	# the weekly score to update
	weeklyScore = null,
	# weeklyCount: float   Eg: 789
	# the weekly count to update
	weeklyCount = null,
	# weeklyTime: float   Eg: 789
	# the weekly time to update
	weeklyTime = null,
	# monthlyScore: float   Eg: 789
	# the monthly score to update
	monthlyScore = null,
	# monthlyCount: float   Eg: 789
	# the monthly count to update
	monthlyCount = null,
	# monthlyTime: float   Eg: 789
	# the monthly time to update
	monthlyTime = null,
	# topScore: float   Eg: 789
	# the top score to update
	topScore = null,
	# lowestScore: float   Eg: 789
	# the lowest score to update
	lowestScore = null,
	# streakCount: float   Eg: 789
	# the streak count to update
	streakCount = null,
	# streakBestCount: float   Eg: 789
	# the best streak count to update
	streakBestCount = null,
	# startDate: float   Eg: 789
	# the start date to update
	startDate = null,
	# endDate: float   Eg: 789
	# the end date to update
	endDate = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "override_user_rank")
	bzz_callable.bind(
		accountId,
		ownerAccountId,
		appKey,
		rankType,
		totalScore,
		totalCount,
		totalTime,
		dailyScore,
		dailyCount,
		dailyTime,
		weeklyScore,
		weeklyCount,
		weeklyTime,
		monthlyScore,
		monthlyCount,
		monthlyTime,
		topScore,
		lowestScore,
		streakCount,
		streakBestCount,
		startDate,
		endDate,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateRankings → POST /ranking/update
# Update Ranking
#
# Update the rank value 
func update_rankings(
	# accountId: float   Eg: 789
	# the account id of the user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key for filtering results by application
	appKey: String,
	# rankType: String = ""   Eg: rankType_example
	# a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS
	rankType: String,
	# increment: float = 1   Eg: 789
	# the value to increment
	increment = 1,
	# timeIncrement: float   Eg: 789
	# the time value to increment
	timeIncrement = null,
	# tag: String = ""   Eg: tag_example
	# the analytic tag for this achievement (used to validate scores)
	tag = "",
	# startDate: float   Eg: 789
	# custom date you can save along with the score for the user
	startDate = null,
	# endDate: float   Eg: 789
	# custom date you can save along with the score for the user
	endDate = null,
	# updateGlobal: bool   Eg: true
	# update the global rankings if true, default is false
	updateGlobal = null,
	# createLeaderboard: bool = false   Eg: true
	# create the leaderboard if it does not exist (default false)
	createLeaderboard = false,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/ranking/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["rankType"] = rankType
	bzz_query["increment"] = increment
	bzz_query["timeIncrement"] = timeIncrement
	bzz_query["tag"] = tag
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["updateGlobal"] = updateGlobal
	bzz_query["createLeaderboard"] = createLeaderboard

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_rankings_threaded(
	# accountId: float   Eg: 789
	# the account id of the user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key for filtering results by application
	appKey: String,
	# rankType: String = ""   Eg: rankType_example
	# a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS
	rankType: String,
	# increment: float = 1   Eg: 789
	# the value to increment
	increment = 1,
	# timeIncrement: float   Eg: 789
	# the time value to increment
	timeIncrement = null,
	# tag: String = ""   Eg: tag_example
	# the analytic tag for this achievement (used to validate scores)
	tag = "",
	# startDate: float   Eg: 789
	# custom date you can save along with the score for the user
	startDate = null,
	# endDate: float   Eg: 789
	# custom date you can save along with the score for the user
	endDate = null,
	# updateGlobal: bool   Eg: true
	# update the global rankings if true, default is false
	updateGlobal = null,
	# createLeaderboard: bool = false   Eg: true
	# create the leaderboard if it does not exist (default false)
	createLeaderboard = false,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_rankings")
	bzz_callable.bind(
		accountId,
		appKey,
		rankType,
		increment,
		timeIncrement,
		tag,
		startDate,
		endDate,
		updateGlobal,
		createLeaderboard,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


