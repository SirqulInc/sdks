extends ApiBee
class_name EmployeeApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API EmployeeApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "EmployeeApi"


# Operation assignEmployee → POST /employee/assign
# Assign Employee
#
# Assign An existing account to be an employee
func assign_employee(
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# managerAccountId: float   Eg: 789
	# The account id of the manager to assign under
	managerAccountId: float,
	# employeeAccountId: float   Eg: 789
	# The account id of the user to be assigned as employee
	employeeAccountId: float,
	# role: String = ""   Eg: role_example
	# The role to assign to the employee (e.g. RETAILER or RETAILER_LIMITED)
	role = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/employee/assign"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["managerAccountId"] = managerAccountId
	bzz_query["employeeAccountId"] = employeeAccountId
	bzz_query["role"] = role

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = EmployeeResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func assign_employee_threaded(
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# managerAccountId: float   Eg: 789
	# The account id of the manager to assign under
	managerAccountId: float,
	# employeeAccountId: float   Eg: 789
	# The account id of the user to be assigned as employee
	employeeAccountId: float,
	# role: String = ""   Eg: role_example
	# The role to assign to the employee (e.g. RETAILER or RETAILER_LIMITED)
	role = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "assign_employee")
	bzz_callable.bind(
		accountId,
		managerAccountId,
		employeeAccountId,
		role,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation assignToLocationEmployee → POST /employee/assignToLocation
# Assign Employee to Location
#
# Assign or unassign the account to a retailer location.
func assign_to_location_employee(
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# retailerLocationId: float   Eg: 789
	# The retailer location to apply the change to
	retailerLocationId: float,
	# employeeAccountId: float   Eg: 789
	# The account id of the user to apply the change to
	employeeAccountId = null,
	# assign: bool = true   Eg: true
	# If true (default) assign to the location, otherwise remove from the retailer
	assign = true,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/employee/assignToLocation"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["employeeAccountId"] = employeeAccountId
	bzz_query["retailerLocationId"] = retailerLocationId
	bzz_query["assign"] = assign

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func assign_to_location_employee_threaded(
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# retailerLocationId: float   Eg: 789
	# The retailer location to apply the change to
	retailerLocationId: float,
	# employeeAccountId: float   Eg: 789
	# The account id of the user to apply the change to
	employeeAccountId = null,
	# assign: bool = true   Eg: true
	# If true (default) assign to the location, otherwise remove from the retailer
	assign = true,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "assign_to_location_employee")
	bzz_callable.bind(
		accountId,
		retailerLocationId,
		employeeAccountId,
		assign,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createEmployee → POST /employee/create
# Create Employee
#
# Create a new account record with the provided information.
func create_employee(
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# managerAccountId: float   Eg: 789
	# The account id of the manager to assign under
	managerAccountId: float,
	# username: String = ""   Eg: username_example
	# The username/email for the new user. This must be unique across the entire the system.
	username: String,
	# password: String = ""   Eg: password_example
	# The password for the new user
	password: String,
	# name: String = ""   Eg: name_example
	# a name field
	name = "",
	# prefixName: String = ""   Eg: prefixName_example
	# The name prefix; Mr, Mrs, etc
	prefixName = "",
	# firstName: String = ""   Eg: firstName_example
	# The first name
	firstName = "",
	# middleName: String = ""   Eg: middleName_example
	# The middle name
	middleName = "",
	# lastName: String = ""   Eg: lastName_example
	# The last name
	lastName = "",
	# suffixName: String = ""   Eg: suffixName_example
	# The name suffix; Jr, Sr, III, etc
	suffixName = "",
	# title: String = ""   Eg: title_example
	# The title of the user
	title = "",
	# aboutUs: String = ""   Eg: aboutUs_example
	# Additional about/biography text
	aboutUs = "",
	# assetId: float   Eg: 789
	# the asset id to set the user's profile image
	assetId = null,
	# gender: String = ""   Eg: gender_example
	# The gender
	gender = "",
	# homePhone: String = ""   Eg: homePhone_example
	# The home phone number
	homePhone = "",
	# cellPhone: String = ""   Eg: cellPhone_example
	# The cellular phone number
	cellPhone = "",
	# cellPhoneCarrier: String = ""   Eg: cellPhoneCarrier_example
	# The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers.
	cellPhoneCarrier = "",
	# businessPhone: String = ""   Eg: businessPhone_example
	# The business phone number
	businessPhone = "",
	# emailAddress: String = ""   Eg: emailAddress_example
	# The user's contact email address (NOT the username)
	emailAddress = "",
	# streetAddress: String = ""   Eg: streetAddress_example
	# The street address of the user's contact location
	streetAddress = "",
	# streetAddress2: String = ""   Eg: streetAddress2_example
	# Additional address information (such as a suite number, floor number, building name, or PO Box)
	streetAddress2 = "",
	# city: String = ""   Eg: city_example
	# The city of the user's contact location
	city = "",
	# state: String = ""   Eg: state_example
	# The state of the user's contact location
	state = "",
	# zipcode: String = ""   Eg: zipcode_example
	# The zipcode of the user's contact location
	zipcode = "",
	# country: String = ""   Eg: country_example
	# The country of the user's contact location
	country = "",
	# role: String = ""   Eg: role_example
	# The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED
	role = "",
	# retailerLocationIds: String = ""   Eg: retailerLocationIds_example
	# the retailer location IDs the employee is associated with
	retailerLocationIds = "",
	# settingsAppKey: String = ""   Eg: settingsAppKey_example
	# Determines whether to return the application settings for the employee for a particular application
	settingsAppKey = "",
	# appBlob: String = ""   Eg: appBlob_example
	# external custom client defined data (per Application)
	appBlob = "",
	# assignedDeviceId: String = ""   Eg: assignedDeviceId_example
	# The device id to assign to the user (used for IPS beacon tracking)
	assignedDeviceId = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/employee/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["managerAccountId"] = managerAccountId
	bzz_query["username"] = username
	bzz_query["password"] = password
	bzz_query["name"] = name
	bzz_query["prefixName"] = prefixName
	bzz_query["firstName"] = firstName
	bzz_query["middleName"] = middleName
	bzz_query["lastName"] = lastName
	bzz_query["suffixName"] = suffixName
	bzz_query["title"] = title
	bzz_query["aboutUs"] = aboutUs
	bzz_query["assetId"] = assetId
	bzz_query["gender"] = gender
	bzz_query["homePhone"] = homePhone
	bzz_query["cellPhone"] = cellPhone
	bzz_query["cellPhoneCarrier"] = cellPhoneCarrier
	bzz_query["businessPhone"] = businessPhone
	bzz_query["emailAddress"] = emailAddress
	bzz_query["streetAddress"] = streetAddress
	bzz_query["streetAddress2"] = streetAddress2
	bzz_query["city"] = city
	bzz_query["state"] = state
	bzz_query["zipcode"] = zipcode
	bzz_query["country"] = country
	bzz_query["role"] = role
	bzz_query["retailerLocationIds"] = retailerLocationIds
	bzz_query["settingsAppKey"] = settingsAppKey
	bzz_query["appBlob"] = appBlob
	bzz_query["assignedDeviceId"] = assignedDeviceId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = EmployeeResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_employee_threaded(
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# managerAccountId: float   Eg: 789
	# The account id of the manager to assign under
	managerAccountId: float,
	# username: String = ""   Eg: username_example
	# The username/email for the new user. This must be unique across the entire the system.
	username: String,
	# password: String = ""   Eg: password_example
	# The password for the new user
	password: String,
	# name: String = ""   Eg: name_example
	# a name field
	name = "",
	# prefixName: String = ""   Eg: prefixName_example
	# The name prefix; Mr, Mrs, etc
	prefixName = "",
	# firstName: String = ""   Eg: firstName_example
	# The first name
	firstName = "",
	# middleName: String = ""   Eg: middleName_example
	# The middle name
	middleName = "",
	# lastName: String = ""   Eg: lastName_example
	# The last name
	lastName = "",
	# suffixName: String = ""   Eg: suffixName_example
	# The name suffix; Jr, Sr, III, etc
	suffixName = "",
	# title: String = ""   Eg: title_example
	# The title of the user
	title = "",
	# aboutUs: String = ""   Eg: aboutUs_example
	# Additional about/biography text
	aboutUs = "",
	# assetId: float   Eg: 789
	# the asset id to set the user's profile image
	assetId = null,
	# gender: String = ""   Eg: gender_example
	# The gender
	gender = "",
	# homePhone: String = ""   Eg: homePhone_example
	# The home phone number
	homePhone = "",
	# cellPhone: String = ""   Eg: cellPhone_example
	# The cellular phone number
	cellPhone = "",
	# cellPhoneCarrier: String = ""   Eg: cellPhoneCarrier_example
	# The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers.
	cellPhoneCarrier = "",
	# businessPhone: String = ""   Eg: businessPhone_example
	# The business phone number
	businessPhone = "",
	# emailAddress: String = ""   Eg: emailAddress_example
	# The user's contact email address (NOT the username)
	emailAddress = "",
	# streetAddress: String = ""   Eg: streetAddress_example
	# The street address of the user's contact location
	streetAddress = "",
	# streetAddress2: String = ""   Eg: streetAddress2_example
	# Additional address information (such as a suite number, floor number, building name, or PO Box)
	streetAddress2 = "",
	# city: String = ""   Eg: city_example
	# The city of the user's contact location
	city = "",
	# state: String = ""   Eg: state_example
	# The state of the user's contact location
	state = "",
	# zipcode: String = ""   Eg: zipcode_example
	# The zipcode of the user's contact location
	zipcode = "",
	# country: String = ""   Eg: country_example
	# The country of the user's contact location
	country = "",
	# role: String = ""   Eg: role_example
	# The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED
	role = "",
	# retailerLocationIds: String = ""   Eg: retailerLocationIds_example
	# the retailer location IDs the employee is associated with
	retailerLocationIds = "",
	# settingsAppKey: String = ""   Eg: settingsAppKey_example
	# Determines whether to return the application settings for the employee for a particular application
	settingsAppKey = "",
	# appBlob: String = ""   Eg: appBlob_example
	# external custom client defined data (per Application)
	appBlob = "",
	# assignedDeviceId: String = ""   Eg: assignedDeviceId_example
	# The device id to assign to the user (used for IPS beacon tracking)
	assignedDeviceId = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_employee")
	bzz_callable.bind(
		accountId,
		managerAccountId,
		username,
		password,
		name,
		prefixName,
		firstName,
		middleName,
		lastName,
		suffixName,
		title,
		aboutUs,
		assetId,
		gender,
		homePhone,
		cellPhone,
		cellPhoneCarrier,
		businessPhone,
		emailAddress,
		streetAddress,
		streetAddress2,
		city,
		state,
		zipcode,
		country,
		role,
		retailerLocationIds,
		settingsAppKey,
		appBlob,
		assignedDeviceId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteEmployee → POST /employee/delete
# Delete Employee
#
# Set the deleted date field which marks the record as deleted.
func delete_employee(
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# employeeAccountId: float   Eg: 789
	# the id of the employee to delete
	employeeAccountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/employee/delete"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["employeeAccountId"] = employeeAccountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_employee_threaded(
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# employeeAccountId: float   Eg: 789
	# the id of the employee to delete
	employeeAccountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_employee")
	bzz_callable.bind(
		accountId,
		employeeAccountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getEmployee → POST /employee/get
# Get Employee
#
# Get the account record for the account id provided.
func get_employee(
	# accountId: float   Eg: 789
	# the id of logged in user
	accountId: float,
	# employeeAccountId: float   Eg: 789
	# the id of the employee account to get
	employeeAccountId: float,
	# settingsAppKey: String = ""   Eg: settingsAppKey_example
	# Determines whether to return the application settings for the employee for a particular application
	settingsAppKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/employee/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["employeeAccountId"] = employeeAccountId
	bzz_query["settingsAppKey"] = settingsAppKey

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = EmployeeResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_employee_threaded(
	# accountId: float   Eg: 789
	# the id of logged in user
	accountId: float,
	# employeeAccountId: float   Eg: 789
	# the id of the employee account to get
	employeeAccountId: float,
	# settingsAppKey: String = ""   Eg: settingsAppKey_example
	# Determines whether to return the application settings for the employee for a particular application
	settingsAppKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_employee")
	bzz_callable.bind(
		accountId,
		employeeAccountId,
		settingsAppKey,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchEmployees → POST /employee/search
# Search Employees
#
# Use the accountId to determine the associated BillableEntity. From there get a list of all accounts associated as managers/employees.
func search_employees(
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# role: String = ""   Eg: role_example
	# The role to limit the search to: RETAILER or RETAILER_LIMITED. Leave empty to search on both roles.
	role = "",
	# retailerId: float   Eg: 789
	# Filters employees by retailer
	retailerId = null,
	# retailerLocationId: float   Eg: 789
	# Filter employees by retailer locations
	retailerLocationId = null,
	# q: String = ""   Eg: q_example
	# Deprecated parameter
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# an optional keyword to search on; ignored if empty
	keyword = "",
	# sortField: String = ""   Eg: sortField_example
	# The field to sort by. Possible values include: DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME
	sortField = "",
	# descending: bool = false   Eg: true
	# Determines whether the sorted list is in descending or ascending order
	descending = false,
	# i: int   Eg: 56
	# Deprecated parameter
	i = null,
	# start: int = 0   Eg: 56
	# Start the result set at some index
	start = 0,
	# l: int   Eg: 56
	# Deprecated parameter
	l = null,
	# limit: int = 20   Eg: 56
	# Limit the result to some number
	limit = 20,
	# activeOnly: bool = true   Eg: true
	# Filter results to only return active employees
	activeOnly = true,
	# managedOnly: bool   Eg: true
	# Filter results to only employees that you manage
	managedOnly = null,
	# settingsAppKey: String = ""   Eg: settingsAppKey_example
	# Determines whether to return the application settings for the employee for a particular application
	settingsAppKey = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# Comma separated list of category ids to filter results
	categoryIds = "",
	# query: String = ""   Eg: query_example
	# Legacy/reporting query parameter used for formatting employee responses
	query = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/employee/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["role"] = role
	bzz_query["retailerId"] = retailerId
	bzz_query["retailerLocationId"] = retailerLocationId
	bzz_query["q"] = q
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["_i"] = i
	bzz_query["start"] = start
	bzz_query["_l"] = l
	bzz_query["limit"] = limit
	bzz_query["activeOnly"] = activeOnly
	bzz_query["managedOnly"] = managedOnly
	bzz_query["settingsAppKey"] = settingsAppKey
	bzz_query["categoryIds"] = categoryIds
	bzz_query["query"] = query

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = EmployeeResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_employees_threaded(
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# role: String = ""   Eg: role_example
	# The role to limit the search to: RETAILER or RETAILER_LIMITED. Leave empty to search on both roles.
	role = "",
	# retailerId: float   Eg: 789
	# Filters employees by retailer
	retailerId = null,
	# retailerLocationId: float   Eg: 789
	# Filter employees by retailer locations
	retailerLocationId = null,
	# q: String = ""   Eg: q_example
	# Deprecated parameter
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# an optional keyword to search on; ignored if empty
	keyword = "",
	# sortField: String = ""   Eg: sortField_example
	# The field to sort by. Possible values include: DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME
	sortField = "",
	# descending: bool = false   Eg: true
	# Determines whether the sorted list is in descending or ascending order
	descending = false,
	# i: int   Eg: 56
	# Deprecated parameter
	i = null,
	# start: int = 0   Eg: 56
	# Start the result set at some index
	start = 0,
	# l: int   Eg: 56
	# Deprecated parameter
	l = null,
	# limit: int = 20   Eg: 56
	# Limit the result to some number
	limit = 20,
	# activeOnly: bool = true   Eg: true
	# Filter results to only return active employees
	activeOnly = true,
	# managedOnly: bool   Eg: true
	# Filter results to only employees that you manage
	managedOnly = null,
	# settingsAppKey: String = ""   Eg: settingsAppKey_example
	# Determines whether to return the application settings for the employee for a particular application
	settingsAppKey = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# Comma separated list of category ids to filter results
	categoryIds = "",
	# query: String = ""   Eg: query_example
	# Legacy/reporting query parameter used for formatting employee responses
	query = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_employees")
	bzz_callable.bind(
		accountId,
		role,
		retailerId,
		retailerLocationId,
		q,
		keyword,
		sortField,
		descending,
		i,
		start,
		l,
		limit,
		activeOnly,
		managedOnly,
		settingsAppKey,
		categoryIds,
		query,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation unassignEmployee → POST /employee/unassign
# Unassign Employee
#
# Unassign An existing account to be an employee
func unassign_employee(
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# employeeAccountId: float   Eg: 789
	# The account id of the user to be unassigned
	employeeAccountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/employee/unassign"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["employeeAccountId"] = employeeAccountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = EmployeeResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func unassign_employee_threaded(
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# employeeAccountId: float   Eg: 789
	# The account id of the user to be unassigned
	employeeAccountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "unassign_employee")
	bzz_callable.bind(
		accountId,
		employeeAccountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateEmployee → POST /employee/update
# Update Employee
#
# Update the account record with the provided information.
func update_employee(
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# employeeAccountId: float   Eg: 789
	# the id of the employee account
	employeeAccountId: float,
	# managerAccountId: float   Eg: 789
	# The account id of the manager to assign under
	managerAccountId = null,
	# name: String = ""   Eg: name_example
	# a name field
	name = "",
	# prefixName: String = ""   Eg: prefixName_example
	# The name prefix; Mr, Mrs, etc
	prefixName = "",
	# firstName: String = ""   Eg: firstName_example
	# The first name
	firstName = "",
	# middleName: String = ""   Eg: middleName_example
	# The middle name
	middleName = "",
	# lastName: String = ""   Eg: lastName_example
	# The last name
	lastName = "",
	# suffixName: String = ""   Eg: suffixName_example
	# The name suffix; Jr, Sr, III, etc
	suffixName = "",
	# title: String = ""   Eg: title_example
	# The title of the user
	title = "",
	# assetId: float   Eg: 789
	# the asset id to set the user's profile image
	assetId = null,
	# gender: String = ""   Eg: gender_example
	# The gender {MALE, FEMALE, ANY}
	gender = "",
	# homePhone: String = ""   Eg: homePhone_example
	# The home phone number
	homePhone = "",
	# cellPhone: String = ""   Eg: cellPhone_example
	# The cellular phone number
	cellPhone = "",
	# cellPhoneCarrier: String = ""   Eg: cellPhoneCarrier_example
	# The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers. Supported Carriers: {ATT, QWEST, T_MOBILE, VERIZON, SPRINT, VIRIGIN_MOBILE, NEXTEL, ALLTEL, METRO_PCS, POWERTEL, BOOST_MOBILE, SUNCOM, TRACFONE, US_CELLULAR}
	cellPhoneCarrier = "",
	# businessPhone: String = ""   Eg: businessPhone_example
	# The business phone number
	businessPhone = "",
	# emailAddress: String = ""   Eg: emailAddress_example
	# The user's contact email address (NOT the username)
	emailAddress = "",
	# streetAddress: String = ""   Eg: streetAddress_example
	# The street address of the user's contact location
	streetAddress = "",
	# streetAddress2: String = ""   Eg: streetAddress2_example
	# Additional address information (such as a suite number, floor number, building name, or PO Box)
	streetAddress2 = "",
	# city: String = ""   Eg: city_example
	# The city of the user's contact location
	city = "",
	# state: String = ""   Eg: state_example
	# The state of the user's contact location
	state = "",
	# zipcode: String = ""   Eg: zipcode_example
	# The zipcode of the user's contact location
	zipcode = "",
	# country: String = ""   Eg: country_example
	# The country of the user's contact location
	country = "",
	# role: String = ""   Eg: role_example
	# The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED
	role = "",
	# active: bool   Eg: true
	# Sets whether the employee is active or inactive
	active = null,
	# password: String = ""   Eg: password_example
	# Sets the password for the employee
	password = "",
	# retailerLocationIds: String = ""   Eg: retailerLocationIds_example
	# Sets which retailer locations the employee is assigned to
	retailerLocationIds = "",
	# settingsAppKey: String = ""   Eg: settingsAppKey_example
	# Determines whether to return the application settings for the employee for a particular application
	settingsAppKey = "",
	# appBlob: String = ""   Eg: appBlob_example
	# external custom client defined data (per Application)
	appBlob = "",
	# assignedDeviceId: String = ""   Eg: assignedDeviceId_example
	# The device id to assign to the user (used for IPS beacon tracking)
	assignedDeviceId = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/employee/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["employeeAccountId"] = employeeAccountId
	bzz_query["managerAccountId"] = managerAccountId
	bzz_query["name"] = name
	bzz_query["prefixName"] = prefixName
	bzz_query["firstName"] = firstName
	bzz_query["middleName"] = middleName
	bzz_query["lastName"] = lastName
	bzz_query["suffixName"] = suffixName
	bzz_query["title"] = title
	bzz_query["assetId"] = assetId
	bzz_query["gender"] = gender
	bzz_query["homePhone"] = homePhone
	bzz_query["cellPhone"] = cellPhone
	bzz_query["cellPhoneCarrier"] = cellPhoneCarrier
	bzz_query["businessPhone"] = businessPhone
	bzz_query["emailAddress"] = emailAddress
	bzz_query["streetAddress"] = streetAddress
	bzz_query["streetAddress2"] = streetAddress2
	bzz_query["city"] = city
	bzz_query["state"] = state
	bzz_query["zipcode"] = zipcode
	bzz_query["country"] = country
	bzz_query["role"] = role
	bzz_query["active"] = active
	bzz_query["password"] = password
	bzz_query["retailerLocationIds"] = retailerLocationIds
	bzz_query["settingsAppKey"] = settingsAppKey
	bzz_query["appBlob"] = appBlob
	bzz_query["assignedDeviceId"] = assignedDeviceId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = EmployeeResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_employee_threaded(
	# accountId: float   Eg: 789
	# The account id of the logged in user
	accountId: float,
	# employeeAccountId: float   Eg: 789
	# the id of the employee account
	employeeAccountId: float,
	# managerAccountId: float   Eg: 789
	# The account id of the manager to assign under
	managerAccountId = null,
	# name: String = ""   Eg: name_example
	# a name field
	name = "",
	# prefixName: String = ""   Eg: prefixName_example
	# The name prefix; Mr, Mrs, etc
	prefixName = "",
	# firstName: String = ""   Eg: firstName_example
	# The first name
	firstName = "",
	# middleName: String = ""   Eg: middleName_example
	# The middle name
	middleName = "",
	# lastName: String = ""   Eg: lastName_example
	# The last name
	lastName = "",
	# suffixName: String = ""   Eg: suffixName_example
	# The name suffix; Jr, Sr, III, etc
	suffixName = "",
	# title: String = ""   Eg: title_example
	# The title of the user
	title = "",
	# assetId: float   Eg: 789
	# the asset id to set the user's profile image
	assetId = null,
	# gender: String = ""   Eg: gender_example
	# The gender {MALE, FEMALE, ANY}
	gender = "",
	# homePhone: String = ""   Eg: homePhone_example
	# The home phone number
	homePhone = "",
	# cellPhone: String = ""   Eg: cellPhone_example
	# The cellular phone number
	cellPhone = "",
	# cellPhoneCarrier: String = ""   Eg: cellPhoneCarrier_example
	# The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers. Supported Carriers: {ATT, QWEST, T_MOBILE, VERIZON, SPRINT, VIRIGIN_MOBILE, NEXTEL, ALLTEL, METRO_PCS, POWERTEL, BOOST_MOBILE, SUNCOM, TRACFONE, US_CELLULAR}
	cellPhoneCarrier = "",
	# businessPhone: String = ""   Eg: businessPhone_example
	# The business phone number
	businessPhone = "",
	# emailAddress: String = ""   Eg: emailAddress_example
	# The user's contact email address (NOT the username)
	emailAddress = "",
	# streetAddress: String = ""   Eg: streetAddress_example
	# The street address of the user's contact location
	streetAddress = "",
	# streetAddress2: String = ""   Eg: streetAddress2_example
	# Additional address information (such as a suite number, floor number, building name, or PO Box)
	streetAddress2 = "",
	# city: String = ""   Eg: city_example
	# The city of the user's contact location
	city = "",
	# state: String = ""   Eg: state_example
	# The state of the user's contact location
	state = "",
	# zipcode: String = ""   Eg: zipcode_example
	# The zipcode of the user's contact location
	zipcode = "",
	# country: String = ""   Eg: country_example
	# The country of the user's contact location
	country = "",
	# role: String = ""   Eg: role_example
	# The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED
	role = "",
	# active: bool   Eg: true
	# Sets whether the employee is active or inactive
	active = null,
	# password: String = ""   Eg: password_example
	# Sets the password for the employee
	password = "",
	# retailerLocationIds: String = ""   Eg: retailerLocationIds_example
	# Sets which retailer locations the employee is assigned to
	retailerLocationIds = "",
	# settingsAppKey: String = ""   Eg: settingsAppKey_example
	# Determines whether to return the application settings for the employee for a particular application
	settingsAppKey = "",
	# appBlob: String = ""   Eg: appBlob_example
	# external custom client defined data (per Application)
	appBlob = "",
	# assignedDeviceId: String = ""   Eg: assignedDeviceId_example
	# The device id to assign to the user (used for IPS beacon tracking)
	assignedDeviceId = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_employee")
	bzz_callable.bind(
		accountId,
		employeeAccountId,
		managerAccountId,
		name,
		prefixName,
		firstName,
		middleName,
		lastName,
		suffixName,
		title,
		assetId,
		gender,
		homePhone,
		cellPhone,
		cellPhoneCarrier,
		businessPhone,
		emailAddress,
		streetAddress,
		streetAddress2,
		city,
		state,
		zipcode,
		country,
		role,
		active,
		password,
		retailerLocationIds,
		settingsAppKey,
		appBlob,
		assignedDeviceId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


