extends ApiBee
class_name PackApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API PackApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "PackApi"


# Operation createPack → POST /pack/create
# Create Pack
#
# Create a pack.
func create_pack(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# title: String = ""   Eg: title_example
	# The title of the pack
	title: String,
	# packOrder: float   Eg: 789
	# The order of the pack
	packOrder: float,
	# price: int   Eg: 56
	# The price in tickets to purchase this pack
	price: int,
	# highest: bool   Eg: true
	# The scoring is highest is best
	highest: bool,
	# allocateTickets: bool   Eg: true
	# Flag to indicate owner should receive tickets for completed packs
	allocateTickets: bool,
	# ticketCount: float   Eg: 789
	# The number of tickets to reward
	ticketCount: float,
	# description: String = ""   Eg: description_example
	# The description of the pack
	description = "",
	# searchTags: String = ""   Eg: searchTags_example
	# The tags for searching the pack, comma separated
	searchTags = "",
	# active: bool   Eg: true
	# Activate/deactivate the pack
	active = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# The application key used to identify the application
	appKey = "",
	# packType: String = ""   Eg: packType_example
	# The type of the pack
	packType = "",
	# sequenceType: String = ""   Eg: sequenceType_example
	# The type of game sequence of the pack
	sequenceType = "",
	# backgroundId: float   Eg: 789
	# The background asset id of the pack
	backgroundId = null,
	# imageId: float   Eg: 789
	# The image asset id of the pack
	imageId = null,
	# startDate: float   Eg: 789
	# The date/time to start the pack, send 0 to unset
	startDate = null,
	# endDate: float   Eg: 789
	# The date/time to end the pack, send 0 to unset
	endDate = null,
	# authorOverride: String = ""   Eg: authorOverride_example
	authorOverride = "",
	# priceType: String = ""   Eg: priceType_example
	# the type of ticket required to purchase this pack
	priceType = "",
	# gameLevelIds: String = ""   Eg: gameLevelIds_example
	# the game level ids to include in the pack, comma separated
	gameLevelIds = "",
	# inGame: bool   Eg: true
	inGame = null,
	# ticketType: String = ""   Eg: ticketType_example
	# The type of ticket to reward, null means default type
	ticketType = "",
	# points: float   Eg: 789
	# The number of points to award for completing a pack
	points = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/pack/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["title"] = title
	bzz_query["description"] = description
	bzz_query["searchTags"] = searchTags
	bzz_query["active"] = active
	bzz_query["gameType"] = gameType
	bzz_query["appKey"] = appKey
	bzz_query["packType"] = packType
	bzz_query["packOrder"] = packOrder
	bzz_query["sequenceType"] = sequenceType
	bzz_query["backgroundId"] = backgroundId
	bzz_query["imageId"] = imageId
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["authorOverride"] = authorOverride
	bzz_query["price"] = price
	bzz_query["priceType"] = priceType
	bzz_query["gameLevelIds"] = gameLevelIds
	bzz_query["inGame"] = inGame
	bzz_query["highest"] = highest
	bzz_query["allocateTickets"] = allocateTickets
	bzz_query["ticketCount"] = ticketCount
	bzz_query["ticketType"] = ticketType
	bzz_query["points"] = points

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PackResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_pack_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# title: String = ""   Eg: title_example
	# The title of the pack
	title: String,
	# packOrder: float   Eg: 789
	# The order of the pack
	packOrder: float,
	# price: int   Eg: 56
	# The price in tickets to purchase this pack
	price: int,
	# highest: bool   Eg: true
	# The scoring is highest is best
	highest: bool,
	# allocateTickets: bool   Eg: true
	# Flag to indicate owner should receive tickets for completed packs
	allocateTickets: bool,
	# ticketCount: float   Eg: 789
	# The number of tickets to reward
	ticketCount: float,
	# description: String = ""   Eg: description_example
	# The description of the pack
	description = "",
	# searchTags: String = ""   Eg: searchTags_example
	# The tags for searching the pack, comma separated
	searchTags = "",
	# active: bool   Eg: true
	# Activate/deactivate the pack
	active = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# The application key used to identify the application
	appKey = "",
	# packType: String = ""   Eg: packType_example
	# The type of the pack
	packType = "",
	# sequenceType: String = ""   Eg: sequenceType_example
	# The type of game sequence of the pack
	sequenceType = "",
	# backgroundId: float   Eg: 789
	# The background asset id of the pack
	backgroundId = null,
	# imageId: float   Eg: 789
	# The image asset id of the pack
	imageId = null,
	# startDate: float   Eg: 789
	# The date/time to start the pack, send 0 to unset
	startDate = null,
	# endDate: float   Eg: 789
	# The date/time to end the pack, send 0 to unset
	endDate = null,
	# authorOverride: String = ""   Eg: authorOverride_example
	authorOverride = "",
	# priceType: String = ""   Eg: priceType_example
	# the type of ticket required to purchase this pack
	priceType = "",
	# gameLevelIds: String = ""   Eg: gameLevelIds_example
	# the game level ids to include in the pack, comma separated
	gameLevelIds = "",
	# inGame: bool   Eg: true
	inGame = null,
	# ticketType: String = ""   Eg: ticketType_example
	# The type of ticket to reward, null means default type
	ticketType = "",
	# points: float   Eg: 789
	# The number of points to award for completing a pack
	points = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_pack")
	bzz_callable.bind(
		accountId,
		title,
		packOrder,
		price,
		highest,
		allocateTickets,
		ticketCount,
		description,
		searchTags,
		active,
		gameType,
		appKey,
		packType,
		sequenceType,
		backgroundId,
		imageId,
		startDate,
		endDate,
		authorOverride,
		priceType,
		gameLevelIds,
		inGame,
		ticketType,
		points,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deletePack → POST /pack/delete
# Delete Pack
#
# Delete a pack.
func delete_pack(
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# packId: float   Eg: 789
	# the id of the pack to delete
	packId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/pack/delete"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["packId"] = packId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_pack_threaded(
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# packId: float   Eg: 789
	# the id of the pack to delete
	packId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_pack")
	bzz_callable.bind(
		accountId,
		packId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getPack → GET /pack/get
# Get Pack
#
# Get a pack.
func get_pack(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# packId: float   Eg: 789
	# The id of the pack to return.
	packId: float,
	# includeGameData: bool   Eg: true
	# If true include the game level data, otherwise don't. default is false.
	includeGameData: bool,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/pack/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["packId"] = packId
	bzz_query["includeGameData"] = includeGameData

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PackResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_pack_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# packId: float   Eg: 789
	# The id of the pack to return.
	packId: float,
	# includeGameData: bool   Eg: true
	# If true include the game level data, otherwise don't. default is false.
	includeGameData: bool,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_pack")
	bzz_callable.bind(
		accountId,
		packId,
		includeGameData,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchPacks → GET /pack/search
# Search Packs
#
# Search on packs.
func search_packs(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# sortField: String = ""   Eg: sortField_example
	# The field to sort by. Possible values include: TITLE, DESCRIPTION, CREATED, UPDATED
	sortField: String,
	# descending: bool   Eg: true
	# Determines whether the sorted list is in descending or ascending order
	descending: bool,
	# keyword: String = ""   Eg: keyword_example
	# Keyword search on the pack name
	keyword = "",
	# packType: String = ""   Eg: packType_example
	# Filters results on pack type
	packType = "",
	# start: int   Eg: 56
	# Start the result set at some index.
	start = null,
	# limit: int   Eg: 56
	# Limit the result to some number.
	limit = null,
	# includeGameData: bool   Eg: true
	# Determines whether to include game data in the results
	includeGameData = null,
	# includeInactive: bool   Eg: true
	# Determines whether to include inactive results
	includeInactive = null,
	# appKey: String = ""   Eg: appKey_example
	# The application to filter results on
	appKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/pack/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["keyword"] = keyword
	bzz_query["packType"] = packType
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["includeGameData"] = includeGameData
	bzz_query["includeInactive"] = includeInactive
	bzz_query["appKey"] = appKey

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PackResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_packs_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# sortField: String = ""   Eg: sortField_example
	# The field to sort by. Possible values include: TITLE, DESCRIPTION, CREATED, UPDATED
	sortField: String,
	# descending: bool   Eg: true
	# Determines whether the sorted list is in descending or ascending order
	descending: bool,
	# keyword: String = ""   Eg: keyword_example
	# Keyword search on the pack name
	keyword = "",
	# packType: String = ""   Eg: packType_example
	# Filters results on pack type
	packType = "",
	# start: int   Eg: 56
	# Start the result set at some index.
	start = null,
	# limit: int   Eg: 56
	# Limit the result to some number.
	limit = null,
	# includeGameData: bool   Eg: true
	# Determines whether to include game data in the results
	includeGameData = null,
	# includeInactive: bool   Eg: true
	# Determines whether to include inactive results
	includeInactive = null,
	# appKey: String = ""   Eg: appKey_example
	# The application to filter results on
	appKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_packs")
	bzz_callable.bind(
		accountId,
		sortField,
		descending,
		keyword,
		packType,
		start,
		limit,
		includeGameData,
		includeInactive,
		appKey,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updatePack → POST /pack/update
# Update Pack
#
# Update a pack.
func update_pack(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# packId: float   Eg: 789
	# The id of the pack to update.
	packId: float,
	# allocateTickets: bool   Eg: true
	# Flag to indicate owner should receive tickets for completed packs
	allocateTickets: bool,
	# ticketCount: float   Eg: 789
	# The number of tickets to reward
	ticketCount: float,
	# title: String = ""   Eg: title_example
	# The title of the pack
	title = "",
	# description: String = ""   Eg: description_example
	# The description of the pack
	description = "",
	# searchTags: String = ""   Eg: searchTags_example
	# The tags for searching the pack, comma separated
	searchTags = "",
	# active: bool   Eg: true
	# Activate/deactivate the pack
	active = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# The application key used to identify the application
	appKey = "",
	# packType: String = ""   Eg: packType_example
	# The type of the pack
	packType = "",
	# packOrder: float   Eg: 789
	# The order of the pack
	packOrder = null,
	# sequenceType: String = ""   Eg: sequenceType_example
	# The type of game sequence of the pack
	sequenceType = "",
	# backgroundId: float   Eg: 789
	# The background asset id of the pack
	backgroundId = null,
	# imageId: float   Eg: 789
	# The image asset id of the pack
	imageId = null,
	# startDate: float   Eg: 789
	# The date/time to start the pack, send 0 to unset
	startDate = null,
	# endDate: float   Eg: 789
	# The date/time to end the pack, send 0 to unset
	endDate = null,
	# authorOverride: String = ""   Eg: authorOverride_example
	authorOverride = "",
	# price: int   Eg: 56
	# The price in tickets to purchase this pack
	price = null,
	# priceType: String = ""   Eg: priceType_example
	# the type of ticket required to purchase this pack
	priceType = "",
	# gameLevelIds: String = ""   Eg: gameLevelIds_example
	# the game level ids to include in the pack, comma separated
	gameLevelIds = "",
	# inGame: bool   Eg: true
	inGame = null,
	# highest: bool   Eg: true
	# The scoring is highest is best
	highest = null,
	# ticketType: String = ""   Eg: ticketType_example
	# The type of ticket to reward, null means default type
	ticketType = "",
	# points: float   Eg: 789
	# The number of points to award for completing a pack
	points = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/pack/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["packId"] = packId
	bzz_query["title"] = title
	bzz_query["description"] = description
	bzz_query["searchTags"] = searchTags
	bzz_query["active"] = active
	bzz_query["gameType"] = gameType
	bzz_query["appKey"] = appKey
	bzz_query["packType"] = packType
	bzz_query["packOrder"] = packOrder
	bzz_query["sequenceType"] = sequenceType
	bzz_query["backgroundId"] = backgroundId
	bzz_query["imageId"] = imageId
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["authorOverride"] = authorOverride
	bzz_query["price"] = price
	bzz_query["priceType"] = priceType
	bzz_query["gameLevelIds"] = gameLevelIds
	bzz_query["inGame"] = inGame
	bzz_query["highest"] = highest
	bzz_query["allocateTickets"] = allocateTickets
	bzz_query["ticketCount"] = ticketCount
	bzz_query["ticketType"] = ticketType
	bzz_query["points"] = points

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = PackResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_pack_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# packId: float   Eg: 789
	# The id of the pack to update.
	packId: float,
	# allocateTickets: bool   Eg: true
	# Flag to indicate owner should receive tickets for completed packs
	allocateTickets: bool,
	# ticketCount: float   Eg: 789
	# The number of tickets to reward
	ticketCount: float,
	# title: String = ""   Eg: title_example
	# The title of the pack
	title = "",
	# description: String = ""   Eg: description_example
	# The description of the pack
	description = "",
	# searchTags: String = ""   Eg: searchTags_example
	# The tags for searching the pack, comma separated
	searchTags = "",
	# active: bool   Eg: true
	# Activate/deactivate the pack
	active = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# The application key used to identify the application
	appKey = "",
	# packType: String = ""   Eg: packType_example
	# The type of the pack
	packType = "",
	# packOrder: float   Eg: 789
	# The order of the pack
	packOrder = null,
	# sequenceType: String = ""   Eg: sequenceType_example
	# The type of game sequence of the pack
	sequenceType = "",
	# backgroundId: float   Eg: 789
	# The background asset id of the pack
	backgroundId = null,
	# imageId: float   Eg: 789
	# The image asset id of the pack
	imageId = null,
	# startDate: float   Eg: 789
	# The date/time to start the pack, send 0 to unset
	startDate = null,
	# endDate: float   Eg: 789
	# The date/time to end the pack, send 0 to unset
	endDate = null,
	# authorOverride: String = ""   Eg: authorOverride_example
	authorOverride = "",
	# price: int   Eg: 56
	# The price in tickets to purchase this pack
	price = null,
	# priceType: String = ""   Eg: priceType_example
	# the type of ticket required to purchase this pack
	priceType = "",
	# gameLevelIds: String = ""   Eg: gameLevelIds_example
	# the game level ids to include in the pack, comma separated
	gameLevelIds = "",
	# inGame: bool   Eg: true
	inGame = null,
	# highest: bool   Eg: true
	# The scoring is highest is best
	highest = null,
	# ticketType: String = ""   Eg: ticketType_example
	# The type of ticket to reward, null means default type
	ticketType = "",
	# points: float   Eg: 789
	# The number of points to award for completing a pack
	points = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_pack")
	bzz_callable.bind(
		accountId,
		packId,
		allocateTickets,
		ticketCount,
		title,
		description,
		searchTags,
		active,
		gameType,
		appKey,
		packType,
		packOrder,
		sequenceType,
		backgroundId,
		imageId,
		startDate,
		endDate,
		authorOverride,
		price,
		priceType,
		gameLevelIds,
		inGame,
		highest,
		ticketType,
		points,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


