extends ApiBee
class_name FilterApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API FilterApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "FilterApi"


# Operation createFilter → POST /api/{version}/filter/create
# Create Filter
#
# Create a filter
func create_filter(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the user (must have permissions to the target application)
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the filter
	name: String,
	# appKey: String = ""   Eg: appKey_example
	# The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions)
	appKey = "",
	# parentFilterId: float   Eg: 789
	# The ID of the parent filter, if not provided then the parent filter will be null
	parentFilterId = null,
	# description: String = ""   Eg: description_example
	# The description of the filter
	description = "",
	# externalId: String = ""   Eg: externalId_example
	# A string identifier used by client applications to store external information
	externalId = "",
	# externalType: String = ""   Eg: externalType_example
	# A string type used by client applications to store external information
	externalType = "",
	# active: bool   Eg: true
	# Sets whether the filter is active or inactive (hidden from consumers)
	active = null,
	# metaData: String = ""   Eg: metaData_example
	# external custom client defined data
	metaData = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/filter/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["parentFilterId"] = parentFilterId
	bzz_query["name"] = name
	bzz_query["description"] = description
	bzz_query["externalId"] = externalId
	bzz_query["externalType"] = externalType
	bzz_query["active"] = active
	bzz_query["metaData"] = metaData

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = FilterTreeResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_filter_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the user (must have permissions to the target application)
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the filter
	name: String,
	# appKey: String = ""   Eg: appKey_example
	# The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions)
	appKey = "",
	# parentFilterId: float   Eg: 789
	# The ID of the parent filter, if not provided then the parent filter will be null
	parentFilterId = null,
	# description: String = ""   Eg: description_example
	# The description of the filter
	description = "",
	# externalId: String = ""   Eg: externalId_example
	# A string identifier used by client applications to store external information
	externalId = "",
	# externalType: String = ""   Eg: externalType_example
	# A string type used by client applications to store external information
	externalType = "",
	# active: bool   Eg: true
	# Sets whether the filter is active or inactive (hidden from consumers)
	active = null,
	# metaData: String = ""   Eg: metaData_example
	# external custom client defined data
	metaData = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_filter")
	bzz_callable.bind(
		version,
		accountId,
		name,
		appKey,
		parentFilterId,
		description,
		externalId,
		externalType,
		active,
		metaData,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteFilter → POST /api/{version}/filter/delete
# Delete Filter
#
# Delete a filter.
func delete_filter(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the user (must have permissions to the filter's assigned application)
	accountId: float,
	# filterId: float   Eg: 789
	# The ID of the filter to delete
	filterId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/filter/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["filterId"] = filterId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_filter_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the user (must have permissions to the filter's assigned application)
	accountId: float,
	# filterId: float   Eg: 789
	# The ID of the filter to delete
	filterId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_filter")
	bzz_callable.bind(
		version,
		accountId,
		filterId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getFilter → GET /api/{version}/filter/get
# Get Filter
#
# Get the details of a specific filter. Recursively include all child filters and their children.
func get_filter(
	# version: float   Eg: 3.16
	version: float,
	# filterId: float   Eg: 789
	# the id of the filter to get
	filterId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/filter/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["filterId"] = filterId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = FilterTreeResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_filter_threaded(
	# version: float   Eg: 3.16
	version: float,
	# filterId: float   Eg: 789
	# the id of the filter to get
	filterId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_filter")
	bzz_callable.bind(
		version,
		filterId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchFilters → GET /api/{version}/filter/search
# Search Filters
#
# Search for filters.
func search_filters(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the user
	accountId = null,
	# keyword: String = ""   Eg: keyword_example
	# The string to search on
	keyword = "",
	# appKey: String = ""   Eg: appKey_example
	# the appKey of the application to retrieve filters for
	appKey = "",
	# responseGroup: String = ""   Eg: responseGroup_example
	# The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.
	responseGroup = "",
	# rootOnly: bool   Eg: true
	# Restrict the search to only those filters with no parent filter assigned.
	rootOnly = null,
	# sortField: String = "DISPLAY"   Eg: sortField_example
	# The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY
	sortField = "DISPLAY",
	# descending: bool = false   Eg: true
	# The order to return the search results
	descending = false,
	# start: int = 0   Eg: 56
	# The record to begin the return set on
	start = 0,
	# limit: int = 20   Eg: 56
	# The number of records to return
	limit = 20,
	# activeOnly: bool = true   Eg: true
	# Determines whether to return only active categories
	activeOnly = true,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/filter/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["keyword"] = keyword
	bzz_query["appKey"] = appKey
	bzz_query["responseGroup"] = responseGroup
	bzz_query["rootOnly"] = rootOnly
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["activeOnly"] = activeOnly

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = FilterResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_filters_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the user
	accountId = null,
	# keyword: String = ""   Eg: keyword_example
	# The string to search on
	keyword = "",
	# appKey: String = ""   Eg: appKey_example
	# the appKey of the application to retrieve filters for
	appKey = "",
	# responseGroup: String = ""   Eg: responseGroup_example
	# The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.
	responseGroup = "",
	# rootOnly: bool   Eg: true
	# Restrict the search to only those filters with no parent filter assigned.
	rootOnly = null,
	# sortField: String = "DISPLAY"   Eg: sortField_example
	# The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY
	sortField = "DISPLAY",
	# descending: bool = false   Eg: true
	# The order to return the search results
	descending = false,
	# start: int = 0   Eg: 56
	# The record to begin the return set on
	start = 0,
	# limit: int = 20   Eg: 56
	# The number of records to return
	limit = 20,
	# activeOnly: bool = true   Eg: true
	# Determines whether to return only active categories
	activeOnly = true,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_filters")
	bzz_callable.bind(
		version,
		accountId,
		keyword,
		appKey,
		responseGroup,
		rootOnly,
		sortField,
		descending,
		start,
		limit,
		activeOnly,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateFilter → POST /api/{version}/filter/update
# Update Filter
#
# Update a filter.
func update_filter(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the user
	accountId: float,
	# filterId: float   Eg: 789
	# The ID of the filter to edit
	filterId: float,
	# parentFilterId: float   Eg: 789
	# The ID of the parent filter, if not provided then the parent filter will be null
	parentFilterId = null,
	# name: String = ""   Eg: name_example
	# The name of the filter
	name = "",
	# description: String = ""   Eg: description_example
	# The description of the filter
	description = "",
	# externalId: String = ""   Eg: externalId_example
	# A string identifier used by client applications to store external information
	externalId = "",
	# externalType: String = ""   Eg: externalType_example
	# A string type used by client applications to store external information
	externalType = "",
	# active: bool   Eg: true
	# Sets whether the filter is active or inactive (hidden from consumers)
	active = null,
	# metaData: String = ""   Eg: metaData_example
	# external custom client defined data
	metaData = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/filter/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["filterId"] = filterId
	bzz_query["parentFilterId"] = parentFilterId
	bzz_query["name"] = name
	bzz_query["description"] = description
	bzz_query["externalId"] = externalId
	bzz_query["externalType"] = externalType
	bzz_query["active"] = active
	bzz_query["metaData"] = metaData

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = FilterTreeResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_filter_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the user
	accountId: float,
	# filterId: float   Eg: 789
	# The ID of the filter to edit
	filterId: float,
	# parentFilterId: float   Eg: 789
	# The ID of the parent filter, if not provided then the parent filter will be null
	parentFilterId = null,
	# name: String = ""   Eg: name_example
	# The name of the filter
	name = "",
	# description: String = ""   Eg: description_example
	# The description of the filter
	description = "",
	# externalId: String = ""   Eg: externalId_example
	# A string identifier used by client applications to store external information
	externalId = "",
	# externalType: String = ""   Eg: externalType_example
	# A string type used by client applications to store external information
	externalType = "",
	# active: bool   Eg: true
	# Sets whether the filter is active or inactive (hidden from consumers)
	active = null,
	# metaData: String = ""   Eg: metaData_example
	# external custom client defined data
	metaData = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_filter")
	bzz_callable.bind(
		version,
		accountId,
		filterId,
		parentFilterId,
		name,
		description,
		externalId,
		externalType,
		active,
		metaData,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


