extends ApiBee
class_name NoteApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API NoteApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "NoteApi"


# Operation batchOperation → POST /api/{version}/note/batch
# Batch Note Operation
#
# Perform a batch operation on notes for a notable object (for example: DELETE_ALL_NOTES_IN_NOTABLE). 
func batch_operation(
	# version: float   Eg: 3.16
	version: float,
	# notableId: float   Eg: 789
	# The id of the notable object the batch operation will affect
	notableId: float,
	# notableType: String = ""   Eg: notableType_example
	# The notable object type (for example ALBUM, ASSET, OFFER, etc.)
	notableType: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# batchOperation: String = ""   Eg: batchOperation_example
	# The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional.
	batchOperation = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/note/batch".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["notableId"] = notableId
	bzz_query["notableType"] = notableType
	bzz_query["batchOperation"] = batchOperation

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func batch_operation_threaded(
	# version: float   Eg: 3.16
	version: float,
	# notableId: float   Eg: 789
	# The id of the notable object the batch operation will affect
	notableId: float,
	# notableType: String = ""   Eg: notableType_example
	# The notable object type (for example ALBUM, ASSET, OFFER, etc.)
	notableType: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# batchOperation: String = ""   Eg: batchOperation_example
	# The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional.
	batchOperation = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "batch_operation")
	bzz_callable.bind(
		version,
		notableId,
		notableType,
		deviceId,
		accountId,
		batchOperation,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createNote → POST /api/{version}/note/create
# Create Note
#
# This is used to leave a comment (note) on a notable object (i.e. albums, album contests, assets, game levels, offers, offer locations, retailers, retailer locations, and theme descriptors). Leaving a comment on a notable object will be visiable to everyone who has access to view the object.
func create_note(
	# version: float   Eg: 3.16
	version: float,
	# comment: String = ""   Eg: comment_example
	# The message the user wishes to leave a comment on
	comment: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique device identifier that made the request (either deviceId or accountId must be used)
	deviceId = "",
	# accountId: float   Eg: 789
	# The unique accountId that made the request (either deviceId or accountId must be used)
	accountId = null,
	# notableType: String = ""   Eg: notableType_example
	# The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}
	notableType = "",
	# notableId: float   Eg: 789
	# The id of the notable object
	notableId = null,
	# noteType: String = ""   Eg: noteType_example
	# The custom string defined by the client (used for differentiating various note types)
	noteType = "",
	# assetIds: String = ""   Eg: assetIds_example
	# A comma separated list of asset IDs to add with the note
	assetIds = "",
	# tags: String = ""   Eg: tags_example
	# search tags
	tags = "",
	# permissionableType: String = ""   Eg: permissionableType_example
	# This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
	permissionableType = "",
	# permissionableId: float   Eg: 789
	# The id of the permissionable object (for sending group notifications)
	permissionableId = null,
	# appKey: String = ""   Eg: appKey_example
	# The application key used to identify the application
	appKey = "",
	# locationDescription: String = ""   Eg: locationDescription_example
	# The description of the location
	locationDescription = "",
	# latitude: int   Eg: 1.2
	# The current location of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# The current location of the user
	longitude = null,
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# receiverAccountIds: String = ""   Eg: receiverAccountIds_example
	# Comma separated list of additional account IDs that will receive the note notifications
	receiverAccountIds = "",
	# returnFullResponse: bool   Eg: true
	# whether to return the full response or not
	returnFullResponse = null,
	# initializeAsset: bool   Eg: true
	# Check true if need to initialize an asset and assign to current note
	initializeAsset = null,
	# assetReturnNulls: bool   Eg: true
	# Return null fields for asset response when creating an asset
	assetReturnNulls = null,
	# assetAlbumId: float   Eg: 789
	# the album the asset will be added to (optional)
	assetAlbumId = null,
	# assetCollectionId: float   Eg: 789
	# the collection ID that the asset is associated with
	assetCollectionId = null,
	# assetAddToDefaultAlbum: String = ""   Eg: assetAddToDefaultAlbum_example
	# the default album to add the asset to
	assetAddToDefaultAlbum = "",
	# assetAddToMediaLibrary: bool   Eg: true
	# the media library to add the asset to
	assetAddToMediaLibrary = null,
	# assetVersionCode: int   Eg: 56
	# the version code of the asset
	assetVersionCode = null,
	# assetVersionName: String = ""   Eg: assetVersionName_example
	# the version name of the asset
	assetVersionName = "",
	# assetMetaData: String = ""   Eg: assetMetaData_example
	# the meta data of the asset
	assetMetaData = "",
	# assetCaption: String = ""   Eg: assetCaption_example
	# the caption of the asset
	assetCaption = "",
	# assetMedia: String   Eg: BINARY_DATA_HERE
	# the media of the asset
	assetMedia = null,
	# assetMediaUrl: String = ""   Eg: assetMediaUrl_example
	# the media URL of the asset
	assetMediaUrl = "",
	# assetMediaString: String = ""   Eg: assetMediaString_example
	# the media string of the asset
	assetMediaString = "",
	# assetMediaStringFileName: String = ""   Eg: assetMediaStringFileName_example
	# the media string file name of the asset
	assetMediaStringFileName = "",
	# assetMediaStringContentType: String = ""   Eg: assetMediaStringContentType_example
	# the media string content type of the asset
	assetMediaStringContentType = "",
	# assetAttachedMedia: String   Eg: BINARY_DATA_HERE
	# the attached media of the asset
	assetAttachedMedia = null,
	# assetAttachedMediaUrl: String = ""   Eg: assetAttachedMediaUrl_example
	# the attached media URL of the asset
	assetAttachedMediaUrl = "",
	# assetAttachedMediaString: String = ""   Eg: assetAttachedMediaString_example
	# the attached media string of the asset
	assetAttachedMediaString = "",
	# assetAttachedMediaStringFileName: String = ""   Eg: assetAttachedMediaStringFileName_example
	# the attached media string file name of the asset
	assetAttachedMediaStringFileName = "",
	# assetAttachedMediaStringContentType: String = ""   Eg: assetAttachedMediaStringContentType_example
	# the attached media string content type of the asset
	assetAttachedMediaStringContentType = "",
	# assetLocationDescription: String = ""   Eg: assetLocationDescription_example
	# the location description for the asset
	assetLocationDescription = "",
	# assetApp: String = ""   Eg: assetApp_example
	# the application for the asset
	assetApp = "",
	# assetSearchTags: String = ""   Eg: assetSearchTags_example
	# the search tags used for the asset
	assetSearchTags = "",
	# assetLatitude: int   Eg: 1.2
	# the latitude of the asset
	assetLatitude = null,
	# assetLongitude: float   Eg: 8.14
	# the longitude of the asset
	assetLongitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/note/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["notableType"] = notableType
	bzz_query["notableId"] = notableId
	bzz_query["comment"] = comment
	bzz_query["noteType"] = noteType
	bzz_query["assetIds"] = assetIds
	bzz_query["tags"] = tags
	bzz_query["permissionableType"] = permissionableType
	bzz_query["permissionableId"] = permissionableId
	bzz_query["appKey"] = appKey
	bzz_query["locationDescription"] = locationDescription
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["metaData"] = metaData
	bzz_query["receiverAccountIds"] = receiverAccountIds
	bzz_query["returnFullResponse"] = returnFullResponse
	bzz_query["initializeAsset"] = initializeAsset
	bzz_query["assetReturnNulls"] = assetReturnNulls
	bzz_query["assetAlbumId"] = assetAlbumId
	bzz_query["assetCollectionId"] = assetCollectionId
	bzz_query["assetAddToDefaultAlbum"] = assetAddToDefaultAlbum
	bzz_query["assetAddToMediaLibrary"] = assetAddToMediaLibrary
	bzz_query["assetVersionCode"] = assetVersionCode
	bzz_query["assetVersionName"] = assetVersionName
	bzz_query["assetMetaData"] = assetMetaData
	bzz_query["assetCaption"] = assetCaption
	bzz_query["assetMedia"] = assetMedia
	bzz_query["assetMediaUrl"] = assetMediaUrl
	bzz_query["assetMediaString"] = assetMediaString
	bzz_query["assetMediaStringFileName"] = assetMediaStringFileName
	bzz_query["assetMediaStringContentType"] = assetMediaStringContentType
	bzz_query["assetAttachedMedia"] = assetAttachedMedia
	bzz_query["assetAttachedMediaUrl"] = assetAttachedMediaUrl
	bzz_query["assetAttachedMediaString"] = assetAttachedMediaString
	bzz_query["assetAttachedMediaStringFileName"] = assetAttachedMediaStringFileName
	bzz_query["assetAttachedMediaStringContentType"] = assetAttachedMediaStringContentType
	bzz_query["assetLocationDescription"] = assetLocationDescription
	bzz_query["assetApp"] = assetApp
	bzz_query["assetSearchTags"] = assetSearchTags
	bzz_query["assetLatitude"] = assetLatitude
	bzz_query["assetLongitude"] = assetLongitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = NoteResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_note_threaded(
	# version: float   Eg: 3.16
	version: float,
	# comment: String = ""   Eg: comment_example
	# The message the user wishes to leave a comment on
	comment: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique device identifier that made the request (either deviceId or accountId must be used)
	deviceId = "",
	# accountId: float   Eg: 789
	# The unique accountId that made the request (either deviceId or accountId must be used)
	accountId = null,
	# notableType: String = ""   Eg: notableType_example
	# The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}
	notableType = "",
	# notableId: float   Eg: 789
	# The id of the notable object
	notableId = null,
	# noteType: String = ""   Eg: noteType_example
	# The custom string defined by the client (used for differentiating various note types)
	noteType = "",
	# assetIds: String = ""   Eg: assetIds_example
	# A comma separated list of asset IDs to add with the note
	assetIds = "",
	# tags: String = ""   Eg: tags_example
	# search tags
	tags = "",
	# permissionableType: String = ""   Eg: permissionableType_example
	# This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
	permissionableType = "",
	# permissionableId: float   Eg: 789
	# The id of the permissionable object (for sending group notifications)
	permissionableId = null,
	# appKey: String = ""   Eg: appKey_example
	# The application key used to identify the application
	appKey = "",
	# locationDescription: String = ""   Eg: locationDescription_example
	# The description of the location
	locationDescription = "",
	# latitude: int   Eg: 1.2
	# The current location of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# The current location of the user
	longitude = null,
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# receiverAccountIds: String = ""   Eg: receiverAccountIds_example
	# Comma separated list of additional account IDs that will receive the note notifications
	receiverAccountIds = "",
	# returnFullResponse: bool   Eg: true
	# whether to return the full response or not
	returnFullResponse = null,
	# initializeAsset: bool   Eg: true
	# Check true if need to initialize an asset and assign to current note
	initializeAsset = null,
	# assetReturnNulls: bool   Eg: true
	# Return null fields for asset response when creating an asset
	assetReturnNulls = null,
	# assetAlbumId: float   Eg: 789
	# the album the asset will be added to (optional)
	assetAlbumId = null,
	# assetCollectionId: float   Eg: 789
	# the collection ID that the asset is associated with
	assetCollectionId = null,
	# assetAddToDefaultAlbum: String = ""   Eg: assetAddToDefaultAlbum_example
	# the default album to add the asset to
	assetAddToDefaultAlbum = "",
	# assetAddToMediaLibrary: bool   Eg: true
	# the media library to add the asset to
	assetAddToMediaLibrary = null,
	# assetVersionCode: int   Eg: 56
	# the version code of the asset
	assetVersionCode = null,
	# assetVersionName: String = ""   Eg: assetVersionName_example
	# the version name of the asset
	assetVersionName = "",
	# assetMetaData: String = ""   Eg: assetMetaData_example
	# the meta data of the asset
	assetMetaData = "",
	# assetCaption: String = ""   Eg: assetCaption_example
	# the caption of the asset
	assetCaption = "",
	# assetMedia: String   Eg: BINARY_DATA_HERE
	# the media of the asset
	assetMedia = null,
	# assetMediaUrl: String = ""   Eg: assetMediaUrl_example
	# the media URL of the asset
	assetMediaUrl = "",
	# assetMediaString: String = ""   Eg: assetMediaString_example
	# the media string of the asset
	assetMediaString = "",
	# assetMediaStringFileName: String = ""   Eg: assetMediaStringFileName_example
	# the media string file name of the asset
	assetMediaStringFileName = "",
	# assetMediaStringContentType: String = ""   Eg: assetMediaStringContentType_example
	# the media string content type of the asset
	assetMediaStringContentType = "",
	# assetAttachedMedia: String   Eg: BINARY_DATA_HERE
	# the attached media of the asset
	assetAttachedMedia = null,
	# assetAttachedMediaUrl: String = ""   Eg: assetAttachedMediaUrl_example
	# the attached media URL of the asset
	assetAttachedMediaUrl = "",
	# assetAttachedMediaString: String = ""   Eg: assetAttachedMediaString_example
	# the attached media string of the asset
	assetAttachedMediaString = "",
	# assetAttachedMediaStringFileName: String = ""   Eg: assetAttachedMediaStringFileName_example
	# the attached media string file name of the asset
	assetAttachedMediaStringFileName = "",
	# assetAttachedMediaStringContentType: String = ""   Eg: assetAttachedMediaStringContentType_example
	# the attached media string content type of the asset
	assetAttachedMediaStringContentType = "",
	# assetLocationDescription: String = ""   Eg: assetLocationDescription_example
	# the location description for the asset
	assetLocationDescription = "",
	# assetApp: String = ""   Eg: assetApp_example
	# the application for the asset
	assetApp = "",
	# assetSearchTags: String = ""   Eg: assetSearchTags_example
	# the search tags used for the asset
	assetSearchTags = "",
	# assetLatitude: int   Eg: 1.2
	# the latitude of the asset
	assetLatitude = null,
	# assetLongitude: float   Eg: 8.14
	# the longitude of the asset
	assetLongitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_note")
	bzz_callable.bind(
		version,
		comment,
		deviceId,
		accountId,
		notableType,
		notableId,
		noteType,
		assetIds,
		tags,
		permissionableType,
		permissionableId,
		appKey,
		locationDescription,
		latitude,
		longitude,
		metaData,
		receiverAccountIds,
		returnFullResponse,
		initializeAsset,
		assetReturnNulls,
		assetAlbumId,
		assetCollectionId,
		assetAddToDefaultAlbum,
		assetAddToMediaLibrary,
		assetVersionCode,
		assetVersionName,
		assetMetaData,
		assetCaption,
		assetMedia,
		assetMediaUrl,
		assetMediaString,
		assetMediaStringFileName,
		assetMediaStringContentType,
		assetAttachedMedia,
		assetAttachedMediaUrl,
		assetAttachedMediaString,
		assetAttachedMediaStringFileName,
		assetAttachedMediaStringContentType,
		assetLocationDescription,
		assetApp,
		assetSearchTags,
		assetLatitude,
		assetLongitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteNote → POST /api/{version}/note/delete
# Delete Note
#
# Sets a comment (note) as deleted.
func delete_note(
	# version: float   Eg: 3.16
	version: float,
	# noteId: float   Eg: 789
	# The ID of the note to delete
	noteId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique device identifier that made the request (either deviceId or accountId must be used)
	deviceId = "",
	# accountId: float   Eg: 789
	# The unique accountId that made the request (either deviceId or accountId must be used)
	accountId = null,
	# latitude: int   Eg: 1.2
	# The current location of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# The current location of the user
	longitude = null,
	# appKey: String = ""   Eg: appKey_example
	# The application key used to identify the application
	appKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/note/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["noteId"] = noteId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["appKey"] = appKey

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_note_threaded(
	# version: float   Eg: 3.16
	version: float,
	# noteId: float   Eg: 789
	# The ID of the note to delete
	noteId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique device identifier that made the request (either deviceId or accountId must be used)
	deviceId = "",
	# accountId: float   Eg: 789
	# The unique accountId that made the request (either deviceId or accountId must be used)
	accountId = null,
	# latitude: int   Eg: 1.2
	# The current location of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# The current location of the user
	longitude = null,
	# appKey: String = ""   Eg: appKey_example
	# The application key used to identify the application
	appKey = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_note")
	bzz_callable.bind(
		version,
		noteId,
		deviceId,
		accountId,
		latitude,
		longitude,
		appKey,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getNote → POST /api/{version}/note/get
# Get Note
#
# Get for a note based on its Id.
func get_note(
	# version: float   Eg: 3.16
	version: float,
	# noteId: float   Eg: 789
	# the id of the note to get
	noteId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique device identifier that made the request (either deviceId or accountId must be used)
	deviceId = "",
	# accountId: float   Eg: 789
	# The unique accountId that made the request (either deviceId or accountId must be used)
	accountId = null,
	# returnFullResponse: bool   Eg: true
	# Determines whether to return the NoteFullResponse for the item
	returnFullResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/note/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["returnFullResponse"] = returnFullResponse
	bzz_query["noteId"] = noteId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_note_threaded(
	# version: float   Eg: 3.16
	version: float,
	# noteId: float   Eg: 789
	# the id of the note to get
	noteId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique device identifier that made the request (either deviceId or accountId must be used)
	deviceId = "",
	# accountId: float   Eg: 789
	# The unique accountId that made the request (either deviceId or accountId must be used)
	accountId = null,
	# returnFullResponse: bool   Eg: true
	# Determines whether to return the NoteFullResponse for the item
	returnFullResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_note")
	bzz_callable.bind(
		version,
		noteId,
		deviceId,
		accountId,
		returnFullResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchNotes → POST /api/{version}/note/search
# Search Notes
#
# Search for notes on a notable object.
func search_notes(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# notableType: String = ""   Eg: notableType_example
	# The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}
	notableType = "",
	# notableId: float   Eg: 789
	# The id of the notable object
	notableId = null,
	# noteTypes: String = ""   Eg: noteTypes_example
	# Comma separated list of noteType strings to filter results with
	noteTypes = "",
	# appKey: String = ""   Eg: appKey_example
	# The application key used to identify the application
	appKey = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search
	keyword = "",
	# flagCountMinimum: float   Eg: 789
	# return items that has flagCount >= flagCountMinimum if this is set, return all items, even ones with flagCount >= flagThreshold
	flagCountMinimum = null,
	# flagsExceedThreshold: bool   Eg: true
	# return items that has flagCount >= flagThreshold, which are hidden by default
	flagsExceedThreshold = null,
	# includeInactive: bool   Eg: true
	# include inactive in the result
	includeInactive = null,
	# sortField: String = ""   Eg: sortField_example
	# The column to sort the search on
	sortField = "",
	# descending: bool   Eg: true
	# The order to return the search results
	descending = null,
	# returnFullResponse: bool   Eg: true
	# Determines whether to return the NoteFullResponse for each search item
	returnFullResponse = null,
	# updatedSince: float   Eg: 789
	# return items that have been updated since this date (time-stamp in milliseconds)
	updatedSince = null,
	# updatedBefore: float   Eg: 789
	# return items that have been updated before this date (time-stamp in milliseconds)
	updatedBefore = null,
	# start: int   Eg: 56
	# The record to begin the return set on
	start = null,
	# limit: int   Eg: 56
	# The number of records to return
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/note/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["notableType"] = notableType
	bzz_query["notableId"] = notableId
	bzz_query["noteTypes"] = noteTypes
	bzz_query["appKey"] = appKey
	bzz_query["keyword"] = keyword
	bzz_query["flagCountMinimum"] = flagCountMinimum
	bzz_query["flagsExceedThreshold"] = flagsExceedThreshold
	bzz_query["includeInactive"] = includeInactive
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["returnFullResponse"] = returnFullResponse
	bzz_query["updatedSince"] = updatedSince
	bzz_query["updatedBefore"] = updatedBefore
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = NoteResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_notes_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# notableType: String = ""   Eg: notableType_example
	# The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}
	notableType = "",
	# notableId: float   Eg: 789
	# The id of the notable object
	notableId = null,
	# noteTypes: String = ""   Eg: noteTypes_example
	# Comma separated list of noteType strings to filter results with
	noteTypes = "",
	# appKey: String = ""   Eg: appKey_example
	# The application key used to identify the application
	appKey = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search
	keyword = "",
	# flagCountMinimum: float   Eg: 789
	# return items that has flagCount >= flagCountMinimum if this is set, return all items, even ones with flagCount >= flagThreshold
	flagCountMinimum = null,
	# flagsExceedThreshold: bool   Eg: true
	# return items that has flagCount >= flagThreshold, which are hidden by default
	flagsExceedThreshold = null,
	# includeInactive: bool   Eg: true
	# include inactive in the result
	includeInactive = null,
	# sortField: String = ""   Eg: sortField_example
	# The column to sort the search on
	sortField = "",
	# descending: bool   Eg: true
	# The order to return the search results
	descending = null,
	# returnFullResponse: bool   Eg: true
	# Determines whether to return the NoteFullResponse for each search item
	returnFullResponse = null,
	# updatedSince: float   Eg: 789
	# return items that have been updated since this date (time-stamp in milliseconds)
	updatedSince = null,
	# updatedBefore: float   Eg: 789
	# return items that have been updated before this date (time-stamp in milliseconds)
	updatedBefore = null,
	# start: int   Eg: 56
	# The record to begin the return set on
	start = null,
	# limit: int   Eg: 56
	# The number of records to return
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_notes")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		notableType,
		notableId,
		noteTypes,
		appKey,
		keyword,
		flagCountMinimum,
		flagsExceedThreshold,
		includeInactive,
		sortField,
		descending,
		returnFullResponse,
		updatedSince,
		updatedBefore,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateNote → POST /api/{version}/note/update
# Update Note
#
# Update an existing comment (note). Only the creator of the note have permission to update.
func update_note(
	# version: float   Eg: 3.16
	version: float,
	# noteId: float   Eg: 789
	# The id of the note, used when editing a comment
	noteId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique device identifier that made the request (either deviceId or accountId must be used)
	deviceId = "",
	# accountId: float   Eg: 789
	# The unique accountId that made the request (either deviceId or accountId must be used)
	accountId = null,
	# comment: String = ""   Eg: comment_example
	# The message the user wishes to leave a comment on
	comment = "",
	# noteType: String = ""   Eg: noteType_example
	# The custom string defined by the client (used for differentiating on various note types)
	noteType = "",
	# assetIds: String = ""   Eg: assetIds_example
	# A comma separated list of asset IDs to add with the note
	assetIds = "",
	# tags: String = ""   Eg: tags_example
	# search tags
	tags = "",
	# permissionableType: String = ""   Eg: permissionableType_example
	# This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
	permissionableType = "",
	# permissionableId: float   Eg: 789
	# The id of the permissionable object (for sending group notifications)
	permissionableId = null,
	# appKey: String = ""   Eg: appKey_example
	# The application key used to identify the application
	appKey = "",
	# locationDescription: String = ""   Eg: locationDescription_example
	# The description of the location
	locationDescription = "",
	# latitude: int   Eg: 1.2
	# The current location of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# The current location of the user
	longitude = null,
	# metaData: String = ""   Eg: metaData_example
	# meta data to update with the note
	metaData = "",
	# returnFullResponse: bool   Eg: true
	# whether to return the full response or not
	returnFullResponse = null,
	# active: bool   Eg: true
	# Sets the active flag for the note
	active = null,
	# updateAsset: bool   Eg: true
	# main flag for updating asset in note, must set to true if you want to update the note's asset
	updateAsset = null,
	# assetReturnNulls: bool   Eg: true
	# Return null fields for asset response when updating an asset
	assetReturnNulls = null,
	# assetAlbumId: float   Eg: 789
	# the album the asset will be added to (optional)
	assetAlbumId = null,
	# assetCollectionId: float   Eg: 789
	# the collection ID that the asset is associated with
	assetCollectionId = null,
	# assetAddToDefaultAlbum: String = ""   Eg: assetAddToDefaultAlbum_example
	# the default album to add the asset to
	assetAddToDefaultAlbum = "",
	# assetAddToMediaLibrary: bool   Eg: true
	# the media library to add the asset to
	assetAddToMediaLibrary = null,
	# assetVersionCode: int   Eg: 56
	# the version code of the asset
	assetVersionCode = null,
	# assetVersionName: String = ""   Eg: assetVersionName_example
	# the version name of the asset
	assetVersionName = "",
	# assetMetaData: String = ""   Eg: assetMetaData_example
	# the meta data of the asset
	assetMetaData = "",
	# assetCaption: String = ""   Eg: assetCaption_example
	# the caption of the asset
	assetCaption = "",
	# assetMedia: String   Eg: BINARY_DATA_HERE
	# the media of the asset
	assetMedia = null,
	# assetMediaUrl: String = ""   Eg: assetMediaUrl_example
	# the media URL of the asset
	assetMediaUrl = "",
	# assetMediaString: String = ""   Eg: assetMediaString_example
	# the media string of the asset
	assetMediaString = "",
	# assetMediaStringFileName: String = ""   Eg: assetMediaStringFileName_example
	# the media string file name of the asset
	assetMediaStringFileName = "",
	# assetMediaStringContentType: String = ""   Eg: assetMediaStringContentType_example
	# the media string content type of the asset
	assetMediaStringContentType = "",
	# assetAttachedMedia: String   Eg: BINARY_DATA_HERE
	# the attached media of the asset
	assetAttachedMedia = null,
	# assetAttachedMediaUrl: String = ""   Eg: assetAttachedMediaUrl_example
	# the attached media URL of the asset
	assetAttachedMediaUrl = "",
	# assetAttachedMediaString: String = ""   Eg: assetAttachedMediaString_example
	# the attached media string of the asset
	assetAttachedMediaString = "",
	# assetAttachedMediaStringFileName: String = ""   Eg: assetAttachedMediaStringFileName_example
	# the attached media string file name of the asset
	assetAttachedMediaStringFileName = "",
	# assetAttachedMediaStringContentType: String = ""   Eg: assetAttachedMediaStringContentType_example
	# the attached media string content type of the asset
	assetAttachedMediaStringContentType = "",
	# assetLocationDescription: String = ""   Eg: assetLocationDescription_example
	# the location description for the asset
	assetLocationDescription = "",
	# assetApp: String = ""   Eg: assetApp_example
	# the application for the asset
	assetApp = "",
	# assetSearchTags: String = ""   Eg: assetSearchTags_example
	# the search tags used for the asset
	assetSearchTags = "",
	# assetLatitude: int   Eg: 1.2
	# the latitude of the asset
	assetLatitude = null,
	# assetLongitude: int   Eg: 1.2
	# the longitude of the asset
	assetLongitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/note/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["noteId"] = noteId
	bzz_query["comment"] = comment
	bzz_query["noteType"] = noteType
	bzz_query["assetIds"] = assetIds
	bzz_query["tags"] = tags
	bzz_query["permissionableType"] = permissionableType
	bzz_query["permissionableId"] = permissionableId
	bzz_query["appKey"] = appKey
	bzz_query["locationDescription"] = locationDescription
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["metaData"] = metaData
	bzz_query["returnFullResponse"] = returnFullResponse
	bzz_query["active"] = active
	bzz_query["updateAsset"] = updateAsset
	bzz_query["assetReturnNulls"] = assetReturnNulls
	bzz_query["assetAlbumId"] = assetAlbumId
	bzz_query["assetCollectionId"] = assetCollectionId
	bzz_query["assetAddToDefaultAlbum"] = assetAddToDefaultAlbum
	bzz_query["assetAddToMediaLibrary"] = assetAddToMediaLibrary
	bzz_query["assetVersionCode"] = assetVersionCode
	bzz_query["assetVersionName"] = assetVersionName
	bzz_query["assetMetaData"] = assetMetaData
	bzz_query["assetCaption"] = assetCaption
	bzz_query["assetMedia"] = assetMedia
	bzz_query["assetMediaUrl"] = assetMediaUrl
	bzz_query["assetMediaString"] = assetMediaString
	bzz_query["assetMediaStringFileName"] = assetMediaStringFileName
	bzz_query["assetMediaStringContentType"] = assetMediaStringContentType
	bzz_query["assetAttachedMedia"] = assetAttachedMedia
	bzz_query["assetAttachedMediaUrl"] = assetAttachedMediaUrl
	bzz_query["assetAttachedMediaString"] = assetAttachedMediaString
	bzz_query["assetAttachedMediaStringFileName"] = assetAttachedMediaStringFileName
	bzz_query["assetAttachedMediaStringContentType"] = assetAttachedMediaStringContentType
	bzz_query["assetLocationDescription"] = assetLocationDescription
	bzz_query["assetApp"] = assetApp
	bzz_query["assetSearchTags"] = assetSearchTags
	bzz_query["assetLatitude"] = assetLatitude
	bzz_query["assetLongitude"] = assetLongitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = NoteResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_note_threaded(
	# version: float   Eg: 3.16
	version: float,
	# noteId: float   Eg: 789
	# The id of the note, used when editing a comment
	noteId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique device identifier that made the request (either deviceId or accountId must be used)
	deviceId = "",
	# accountId: float   Eg: 789
	# The unique accountId that made the request (either deviceId or accountId must be used)
	accountId = null,
	# comment: String = ""   Eg: comment_example
	# The message the user wishes to leave a comment on
	comment = "",
	# noteType: String = ""   Eg: noteType_example
	# The custom string defined by the client (used for differentiating on various note types)
	noteType = "",
	# assetIds: String = ""   Eg: assetIds_example
	# A comma separated list of asset IDs to add with the note
	assetIds = "",
	# tags: String = ""   Eg: tags_example
	# search tags
	tags = "",
	# permissionableType: String = ""   Eg: permissionableType_example
	# This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
	permissionableType = "",
	# permissionableId: float   Eg: 789
	# The id of the permissionable object (for sending group notifications)
	permissionableId = null,
	# appKey: String = ""   Eg: appKey_example
	# The application key used to identify the application
	appKey = "",
	# locationDescription: String = ""   Eg: locationDescription_example
	# The description of the location
	locationDescription = "",
	# latitude: int   Eg: 1.2
	# The current location of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# The current location of the user
	longitude = null,
	# metaData: String = ""   Eg: metaData_example
	# meta data to update with the note
	metaData = "",
	# returnFullResponse: bool   Eg: true
	# whether to return the full response or not
	returnFullResponse = null,
	# active: bool   Eg: true
	# Sets the active flag for the note
	active = null,
	# updateAsset: bool   Eg: true
	# main flag for updating asset in note, must set to true if you want to update the note's asset
	updateAsset = null,
	# assetReturnNulls: bool   Eg: true
	# Return null fields for asset response when updating an asset
	assetReturnNulls = null,
	# assetAlbumId: float   Eg: 789
	# the album the asset will be added to (optional)
	assetAlbumId = null,
	# assetCollectionId: float   Eg: 789
	# the collection ID that the asset is associated with
	assetCollectionId = null,
	# assetAddToDefaultAlbum: String = ""   Eg: assetAddToDefaultAlbum_example
	# the default album to add the asset to
	assetAddToDefaultAlbum = "",
	# assetAddToMediaLibrary: bool   Eg: true
	# the media library to add the asset to
	assetAddToMediaLibrary = null,
	# assetVersionCode: int   Eg: 56
	# the version code of the asset
	assetVersionCode = null,
	# assetVersionName: String = ""   Eg: assetVersionName_example
	# the version name of the asset
	assetVersionName = "",
	# assetMetaData: String = ""   Eg: assetMetaData_example
	# the meta data of the asset
	assetMetaData = "",
	# assetCaption: String = ""   Eg: assetCaption_example
	# the caption of the asset
	assetCaption = "",
	# assetMedia: String   Eg: BINARY_DATA_HERE
	# the media of the asset
	assetMedia = null,
	# assetMediaUrl: String = ""   Eg: assetMediaUrl_example
	# the media URL of the asset
	assetMediaUrl = "",
	# assetMediaString: String = ""   Eg: assetMediaString_example
	# the media string of the asset
	assetMediaString = "",
	# assetMediaStringFileName: String = ""   Eg: assetMediaStringFileName_example
	# the media string file name of the asset
	assetMediaStringFileName = "",
	# assetMediaStringContentType: String = ""   Eg: assetMediaStringContentType_example
	# the media string content type of the asset
	assetMediaStringContentType = "",
	# assetAttachedMedia: String   Eg: BINARY_DATA_HERE
	# the attached media of the asset
	assetAttachedMedia = null,
	# assetAttachedMediaUrl: String = ""   Eg: assetAttachedMediaUrl_example
	# the attached media URL of the asset
	assetAttachedMediaUrl = "",
	# assetAttachedMediaString: String = ""   Eg: assetAttachedMediaString_example
	# the attached media string of the asset
	assetAttachedMediaString = "",
	# assetAttachedMediaStringFileName: String = ""   Eg: assetAttachedMediaStringFileName_example
	# the attached media string file name of the asset
	assetAttachedMediaStringFileName = "",
	# assetAttachedMediaStringContentType: String = ""   Eg: assetAttachedMediaStringContentType_example
	# the attached media string content type of the asset
	assetAttachedMediaStringContentType = "",
	# assetLocationDescription: String = ""   Eg: assetLocationDescription_example
	# the location description for the asset
	assetLocationDescription = "",
	# assetApp: String = ""   Eg: assetApp_example
	# the application for the asset
	assetApp = "",
	# assetSearchTags: String = ""   Eg: assetSearchTags_example
	# the search tags used for the asset
	assetSearchTags = "",
	# assetLatitude: int   Eg: 1.2
	# the latitude of the asset
	assetLatitude = null,
	# assetLongitude: int   Eg: 1.2
	# the longitude of the asset
	assetLongitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_note")
	bzz_callable.bind(
		version,
		noteId,
		deviceId,
		accountId,
		comment,
		noteType,
		assetIds,
		tags,
		permissionableType,
		permissionableId,
		appKey,
		locationDescription,
		latitude,
		longitude,
		metaData,
		returnFullResponse,
		active,
		updateAsset,
		assetReturnNulls,
		assetAlbumId,
		assetCollectionId,
		assetAddToDefaultAlbum,
		assetAddToMediaLibrary,
		assetVersionCode,
		assetVersionName,
		assetMetaData,
		assetCaption,
		assetMedia,
		assetMediaUrl,
		assetMediaString,
		assetMediaStringFileName,
		assetMediaStringContentType,
		assetAttachedMedia,
		assetAttachedMediaUrl,
		assetAttachedMediaString,
		assetAttachedMediaStringFileName,
		assetAttachedMediaStringContentType,
		assetLocationDescription,
		assetApp,
		assetSearchTags,
		assetLatitude,
		assetLongitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


