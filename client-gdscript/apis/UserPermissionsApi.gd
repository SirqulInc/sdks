extends ApiBee
class_name UserPermissionsApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API UserPermissionsApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "UserPermissionsApi"


# Operation addUsersToPermissionable → POST /consumer/permissions/add
# Add User
#
# Adds a user to a permissionable object.
func add_users_to_permissionable(
	# permissionableType: String = ""   Eg: permissionableType_example
	# the permissionable type of the object
	permissionableType: String,
	# permissionableId: float   Eg: 789
	# the id of the permissionable object
	permissionableId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# read: bool = true   Eg: true
	# the read permission of the users/groups
	read = true,
	# write: bool = false   Eg: true
	# the write permission of the users/groups
	write = false,
	# delete: bool = false   Eg: true
	# the delete permission of the users/groups
	delete = false,
	# add: bool = false   Eg: true
	# the add permission of the users/groups
	add = false,
	# connectionIds: String = ""   Eg: connectionIds_example
	# a comma separated list of connection ids (NOT the account ids)
	connectionIds = "",
	# connectionAccountIds: String = ""   Eg: connectionAccountIds_example
	# a comma separated list of account ids
	connectionAccountIds = "",
	# connectionGroupIds: String = ""   Eg: connectionGroupIds_example
	# a comma separated list of connection group ids (these are groups made by the user)
	connectionGroupIds = "",
	# pending: bool = false   Eg: true
	# sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept)
	pending = false,
	# admin: bool   Eg: true
	# sets whether the added users will become admins or not
	admin = null,
	# includeFriendGroup: bool = false   Eg: true
	# flag to determine whether to include the built-in \"friends\" group
	includeFriendGroup = false,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	# audienceIds: String = ""   Eg: audienceIds_example
	# comma separated list of audience ids. This is a feature only available to the permissionable's application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used.
	audienceIds = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/permissions/add"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["permissionableType"] = permissionableType
	bzz_query["permissionableId"] = permissionableId
	bzz_query["read"] = read
	bzz_query["write"] = write
	bzz_query["delete"] = delete
	bzz_query["add"] = add
	bzz_query["connectionIds"] = connectionIds
	bzz_query["connectionAccountIds"] = connectionAccountIds
	bzz_query["connectionGroupIds"] = connectionGroupIds
	bzz_query["pending"] = pending
	bzz_query["admin"] = admin
	bzz_query["includeFriendGroup"] = includeFriendGroup
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["audienceIds"] = audienceIds

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func add_users_to_permissionable_threaded(
	# permissionableType: String = ""   Eg: permissionableType_example
	# the permissionable type of the object
	permissionableType: String,
	# permissionableId: float   Eg: 789
	# the id of the permissionable object
	permissionableId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# read: bool = true   Eg: true
	# the read permission of the users/groups
	read = true,
	# write: bool = false   Eg: true
	# the write permission of the users/groups
	write = false,
	# delete: bool = false   Eg: true
	# the delete permission of the users/groups
	delete = false,
	# add: bool = false   Eg: true
	# the add permission of the users/groups
	add = false,
	# connectionIds: String = ""   Eg: connectionIds_example
	# a comma separated list of connection ids (NOT the account ids)
	connectionIds = "",
	# connectionAccountIds: String = ""   Eg: connectionAccountIds_example
	# a comma separated list of account ids
	connectionAccountIds = "",
	# connectionGroupIds: String = ""   Eg: connectionGroupIds_example
	# a comma separated list of connection group ids (these are groups made by the user)
	connectionGroupIds = "",
	# pending: bool = false   Eg: true
	# sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept)
	pending = false,
	# admin: bool   Eg: true
	# sets whether the added users will become admins or not
	admin = null,
	# includeFriendGroup: bool = false   Eg: true
	# flag to determine whether to include the built-in \"friends\" group
	includeFriendGroup = false,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	# audienceIds: String = ""   Eg: audienceIds_example
	# comma separated list of audience ids. This is a feature only available to the permissionable's application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used.
	audienceIds = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "add_users_to_permissionable")
	bzz_callable.bind(
		permissionableType,
		permissionableId,
		deviceId,
		accountId,
		read,
		write,
		delete,
		add,
		connectionIds,
		connectionAccountIds,
		connectionGroupIds,
		pending,
		admin,
		includeFriendGroup,
		latitude,
		longitude,
		audienceIds,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation approvePermissionable → POST /permissionable/approve
# Approve Permissionable
#
# Sets the approval status of a permissionable object.
func approve_permissionable(
	# permissionableType: String = ""   Eg: permissionableType_example
	# The permissionable type of the object
	permissionableType: String,
	# permissionableId: float   Eg: 789
	# The id of the permissionable object
	permissionableId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# A unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account ID of the user (deviceId or accountId required)
	accountId = null,
	# approvalStatus: String = "APPROVED"   Eg: approvalStatus_example
	# The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
	approvalStatus = "APPROVED",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/permissionable/approve"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["permissionableType"] = permissionableType
	bzz_query["permissionableId"] = permissionableId
	bzz_query["approvalStatus"] = approvalStatus

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func approve_permissionable_threaded(
	# permissionableType: String = ""   Eg: permissionableType_example
	# The permissionable type of the object
	permissionableType: String,
	# permissionableId: float   Eg: 789
	# The id of the permissionable object
	permissionableId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# A unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account ID of the user (deviceId or accountId required)
	accountId = null,
	# approvalStatus: String = "APPROVED"   Eg: approvalStatus_example
	# The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
	approvalStatus = "APPROVED",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "approve_permissionable")
	bzz_callable.bind(
		permissionableType,
		permissionableId,
		deviceId,
		accountId,
		approvalStatus,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation leaveFromPermissionable → POST /consumer/permissions/leave
# Leave
#
# Used when the user wants to leave from someone else's permissionable object
func leave_from_permissionable(
	# permissionableType: String = ""   Eg: permissionableType_example
	# the permissionable type PermissionableType
	permissionableType: String,
	# permissionableId: float   Eg: 789
	# the id of the permissionable object
	permissionableId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/permissions/leave"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["permissionableType"] = permissionableType
	bzz_query["permissionableId"] = permissionableId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func leave_from_permissionable_threaded(
	# permissionableType: String = ""   Eg: permissionableType_example
	# the permissionable type PermissionableType
	permissionableType: String,
	# permissionableId: float   Eg: 789
	# the id of the permissionable object
	permissionableId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "leave_from_permissionable")
	bzz_callable.bind(
		permissionableType,
		permissionableId,
		deviceId,
		accountId,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation removeUsersFromPermissionable → POST /consumer/permissions/remove
# Remove User
#
# Used to remove someone (assuming they have permission) from a permissionable object
func remove_users_from_permissionable(
	# permissionableType: String = ""   Eg: permissionableType_example
	# the permissionable type of the object
	permissionableType: String,
	# permissionableId: float   Eg: 789
	# the id of the permissionable object
	permissionableId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# connectionIds: String = ""   Eg: connectionIds_example
	# a comma separated list of connection ids (NOT the account ids)
	connectionIds = "",
	# connectionAccountIds: String = ""   Eg: connectionAccountIds_example
	# a comma separated list of account ids
	connectionAccountIds = "",
	# connectionGroupIds: String = ""   Eg: connectionGroupIds_example
	# a comma separated list of connection group ids (these are groups made by the user)
	connectionGroupIds = "",
	# removeFriendGroup: bool = false   Eg: true
	# flag to determine whether to remove the built-in \"friends\" group
	removeFriendGroup = false,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	# audienceIds: String = ""   Eg: audienceIds_example
	# comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used.
	audienceIds = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/permissions/remove"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["permissionableType"] = permissionableType
	bzz_query["permissionableId"] = permissionableId
	bzz_query["connectionIds"] = connectionIds
	bzz_query["connectionAccountIds"] = connectionAccountIds
	bzz_query["connectionGroupIds"] = connectionGroupIds
	bzz_query["removeFriendGroup"] = removeFriendGroup
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["audienceIds"] = audienceIds

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func remove_users_from_permissionable_threaded(
	# permissionableType: String = ""   Eg: permissionableType_example
	# the permissionable type of the object
	permissionableType: String,
	# permissionableId: float   Eg: 789
	# the id of the permissionable object
	permissionableId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# connectionIds: String = ""   Eg: connectionIds_example
	# a comma separated list of connection ids (NOT the account ids)
	connectionIds = "",
	# connectionAccountIds: String = ""   Eg: connectionAccountIds_example
	# a comma separated list of account ids
	connectionAccountIds = "",
	# connectionGroupIds: String = ""   Eg: connectionGroupIds_example
	# a comma separated list of connection group ids (these are groups made by the user)
	connectionGroupIds = "",
	# removeFriendGroup: bool = false   Eg: true
	# flag to determine whether to remove the built-in \"friends\" group
	removeFriendGroup = false,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	# audienceIds: String = ""   Eg: audienceIds_example
	# comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used.
	audienceIds = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "remove_users_from_permissionable")
	bzz_callable.bind(
		permissionableType,
		permissionableId,
		deviceId,
		accountId,
		connectionIds,
		connectionAccountIds,
		connectionGroupIds,
		removeFriendGroup,
		latitude,
		longitude,
		audienceIds,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchPermissionables → GET /permissions/search
# Search Permissionables
#
# Search on UserPermissions
func search_permissionables(
	# deviceId: String = ""   Eg: deviceId_example
	# A unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account ID of the user (deviceId or accountId required)
	accountId = null,
	# connectionAccountId: float   Eg: 789
	# Filter results for a specific user account
	connectionAccountId = null,
	# connectionAccountIds: String = ""   Eg: connectionAccountIds_example
	# Comma separated list of account IDs to filter results with
	connectionAccountIds = "",
	# permissionableType: String = ""   Eg: permissionableType_example
	# Filter user permissions by the permissionable object type
	permissionableType = "",
	# permissionableId: float   Eg: 789
	# The id of the permissionable object to filter by
	permissionableId = null,
	# keyword: String = ""   Eg: keyword_example
	# Keyword to search within permissionable records
	keyword = "",
	# sortField: String = ""   Eg: sortField_example
	# Field to sort results on
	sortField = "",
	# descending: bool   Eg: true
	# Sort descending when true
	descending = null,
	# pending: bool   Eg: true
	# Return user permissions that are pending
	pending = null,
	# admin: bool   Eg: true
	# Return user permissions that are admins
	admin = null,
	# start: int = 0   Eg: 56
	# the start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# the limit for pagination
	limit = 20,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/permissions/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["connectionAccountId"] = connectionAccountId
	bzz_query["connectionAccountIds"] = connectionAccountIds
	bzz_query["permissionableType"] = permissionableType
	bzz_query["permissionableId"] = permissionableId
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["pending"] = pending
	bzz_query["admin"] = admin
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = UserPermissionsResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_permissionables_threaded(
	# deviceId: String = ""   Eg: deviceId_example
	# A unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account ID of the user (deviceId or accountId required)
	accountId = null,
	# connectionAccountId: float   Eg: 789
	# Filter results for a specific user account
	connectionAccountId = null,
	# connectionAccountIds: String = ""   Eg: connectionAccountIds_example
	# Comma separated list of account IDs to filter results with
	connectionAccountIds = "",
	# permissionableType: String = ""   Eg: permissionableType_example
	# Filter user permissions by the permissionable object type
	permissionableType = "",
	# permissionableId: float   Eg: 789
	# The id of the permissionable object to filter by
	permissionableId = null,
	# keyword: String = ""   Eg: keyword_example
	# Keyword to search within permissionable records
	keyword = "",
	# sortField: String = ""   Eg: sortField_example
	# Field to sort results on
	sortField = "",
	# descending: bool   Eg: true
	# Sort descending when true
	descending = null,
	# pending: bool   Eg: true
	# Return user permissions that are pending
	pending = null,
	# admin: bool   Eg: true
	# Return user permissions that are admins
	admin = null,
	# start: int = 0   Eg: 56
	# the start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# the limit for pagination
	limit = 20,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_permissionables")
	bzz_callable.bind(
		deviceId,
		accountId,
		connectionAccountId,
		connectionAccountIds,
		permissionableType,
		permissionableId,
		keyword,
		sortField,
		descending,
		pending,
		admin,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchPermissionablesFollowingDistance → GET /permissions/distancesearch
# Search Permissionables by Distnace
#
# Search on UserPermissions by distance
func search_permissionables_following_distance(
	# latitude: int   Eg: 1.2
	# The latitude of the current account
	latitude: int,
	# longitude: int   Eg: 1.2
	# The longitude of the current account
	longitude: int,
	# deviceId: String = ""   Eg: deviceId_example
	# A unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account ID of the user (deviceId or accountId required)
	accountId = null,
	# connectionAccountId: float   Eg: 789
	# Filter results for a specific user account
	connectionAccountId = null,
	# connectionAccountIds: String = ""   Eg: connectionAccountIds_example
	# Comma separated list of account IDs to filter results with
	connectionAccountIds = "",
	# permissionableType: String = ""   Eg: permissionableType_example
	# Filter user permissions by the permissionable object type
	permissionableType = "",
	# permissionableId: float   Eg: 789
	# The id of the permissionable object to filter by
	permissionableId = null,
	# searchRange: int = 5   Eg: 1.2
	# The search range in miles
	searchRange = 5,
	# keyword: String = ""   Eg: keyword_example
	# Keyword to search within permissionable records
	keyword = "",
	# pending: bool   Eg: true
	# Return user permissions that are pending
	pending = null,
	# admin: bool   Eg: true
	# Return user permissions that are admins
	admin = null,
	# start: int = 0   Eg: 56
	# The start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# The limit for pagination
	limit = 20,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/permissions/distancesearch"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["connectionAccountId"] = connectionAccountId
	bzz_query["connectionAccountIds"] = connectionAccountIds
	bzz_query["permissionableType"] = permissionableType
	bzz_query["permissionableId"] = permissionableId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["searchRange"] = searchRange
	bzz_query["keyword"] = keyword
	bzz_query["pending"] = pending
	bzz_query["admin"] = admin
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = UserPermissionsResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_permissionables_following_distance_threaded(
	# latitude: int   Eg: 1.2
	# The latitude of the current account
	latitude: int,
	# longitude: int   Eg: 1.2
	# The longitude of the current account
	longitude: int,
	# deviceId: String = ""   Eg: deviceId_example
	# A unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account ID of the user (deviceId or accountId required)
	accountId = null,
	# connectionAccountId: float   Eg: 789
	# Filter results for a specific user account
	connectionAccountId = null,
	# connectionAccountIds: String = ""   Eg: connectionAccountIds_example
	# Comma separated list of account IDs to filter results with
	connectionAccountIds = "",
	# permissionableType: String = ""   Eg: permissionableType_example
	# Filter user permissions by the permissionable object type
	permissionableType = "",
	# permissionableId: float   Eg: 789
	# The id of the permissionable object to filter by
	permissionableId = null,
	# searchRange: int = 5   Eg: 1.2
	# The search range in miles
	searchRange = 5,
	# keyword: String = ""   Eg: keyword_example
	# Keyword to search within permissionable records
	keyword = "",
	# pending: bool   Eg: true
	# Return user permissions that are pending
	pending = null,
	# admin: bool   Eg: true
	# Return user permissions that are admins
	admin = null,
	# start: int = 0   Eg: 56
	# The start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# The limit for pagination
	limit = 20,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_permissionables_following_distance")
	bzz_callable.bind(
		latitude,
		longitude,
		deviceId,
		accountId,
		connectionAccountId,
		connectionAccountIds,
		permissionableType,
		permissionableId,
		searchRange,
		keyword,
		pending,
		admin,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


