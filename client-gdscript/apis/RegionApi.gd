extends ApiBee
class_name RegionApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API RegionApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "RegionApi"


# Operation createRegion → POST /region/create
# Create Region
#
# Create a region.
func create_region(
	# accountId: float   Eg: 789
	# The id of the account sending the request
	accountId: float,
	# regionClass: String = ""   Eg: regionClass_example
	# RegionClass of this region
	regionClass: String,
	# shortName: String = ""   Eg: shortName_example
	# Short name of the region. This is optimized for search
	shortName: String,
	# fullName: String = ""   Eg: fullName_example
	# Full name of the region
	fullName = "",
	# parentIds: String = ""   Eg: parentIds_example
	# Comma separated region ids that are parents of this region
	parentIds = "",
	# childrenIds: String = ""   Eg: childrenIds_example
	# Comma separated region ids that are children of this region
	childrenIds = "",
	# postalCodeIds: String = ""   Eg: postalCodeIds_example
	# Comma separated postal code ids the region will include
	postalCodeIds = "",
	# locations: String = ""   Eg: locations_example
	# Sets of name,lat,long used to create new postal codes assigned to the region
	locations = "",
	# retailerLocationId: float   Eg: 789
	# the id of the retailer location that the region is being created for
	retailerLocationId = null,
	# visibility: String = ""   Eg: visibility_example
	# The Visibility of the region
	visibility = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# the categories that the region is assigned to
	categoryIds = "",
	# filterIds: String = ""   Eg: filterIds_example
	# the filters that the region is assigned to
	filterIds = "",
	# start: float   Eg: 789
	start = null,
	# end: float   Eg: 789
	end = null,
	# polygon: String = ""   Eg: polygon_example
	# the polygon generated for the region
	polygon = "",
	# metaData: String = ""   Eg: metaData_example
	# the meta data associated with the region
	metaData = "",
	# latitude: int   Eg: 1.2
	# the latitude of the region
	latitude = null,
	# longitude: int   Eg: 1.2
	# the longitude of the region
	longitude = null,
	# versionCode: int   Eg: 56
	# the version code
	versionCode = null,
	# root: bool   Eg: true
	# If this is a root region or not. If true means this region has no parent regions
	root = null,
	# active: bool   Eg: true
	# Active or inactive status of the region
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/region/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["regionClass"] = regionClass
	bzz_query["shortName"] = shortName
	bzz_query["fullName"] = fullName
	bzz_query["parentIds"] = parentIds
	bzz_query["childrenIds"] = childrenIds
	bzz_query["postalCodeIds"] = postalCodeIds
	bzz_query["locations"] = locations
	bzz_query["retailerLocationId"] = retailerLocationId
	bzz_query["visibility"] = visibility
	bzz_query["categoryIds"] = categoryIds
	bzz_query["filterIds"] = filterIds
	bzz_query["start"] = start
	bzz_query["end"] = end
	bzz_query["polygon"] = polygon
	bzz_query["metaData"] = metaData
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["versionCode"] = versionCode
	bzz_query["root"] = root
	bzz_query["active"] = active

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = RegionResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_region_threaded(
	# accountId: float   Eg: 789
	# The id of the account sending the request
	accountId: float,
	# regionClass: String = ""   Eg: regionClass_example
	# RegionClass of this region
	regionClass: String,
	# shortName: String = ""   Eg: shortName_example
	# Short name of the region. This is optimized for search
	shortName: String,
	# fullName: String = ""   Eg: fullName_example
	# Full name of the region
	fullName = "",
	# parentIds: String = ""   Eg: parentIds_example
	# Comma separated region ids that are parents of this region
	parentIds = "",
	# childrenIds: String = ""   Eg: childrenIds_example
	# Comma separated region ids that are children of this region
	childrenIds = "",
	# postalCodeIds: String = ""   Eg: postalCodeIds_example
	# Comma separated postal code ids the region will include
	postalCodeIds = "",
	# locations: String = ""   Eg: locations_example
	# Sets of name,lat,long used to create new postal codes assigned to the region
	locations = "",
	# retailerLocationId: float   Eg: 789
	# the id of the retailer location that the region is being created for
	retailerLocationId = null,
	# visibility: String = ""   Eg: visibility_example
	# The Visibility of the region
	visibility = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# the categories that the region is assigned to
	categoryIds = "",
	# filterIds: String = ""   Eg: filterIds_example
	# the filters that the region is assigned to
	filterIds = "",
	# start: float   Eg: 789
	start = null,
	# end: float   Eg: 789
	end = null,
	# polygon: String = ""   Eg: polygon_example
	# the polygon generated for the region
	polygon = "",
	# metaData: String = ""   Eg: metaData_example
	# the meta data associated with the region
	metaData = "",
	# latitude: int   Eg: 1.2
	# the latitude of the region
	latitude = null,
	# longitude: int   Eg: 1.2
	# the longitude of the region
	longitude = null,
	# versionCode: int   Eg: 56
	# the version code
	versionCode = null,
	# root: bool   Eg: true
	# If this is a root region or not. If true means this region has no parent regions
	root = null,
	# active: bool   Eg: true
	# Active or inactive status of the region
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_region")
	bzz_callable.bind(
		accountId,
		regionClass,
		shortName,
		fullName,
		parentIds,
		childrenIds,
		postalCodeIds,
		locations,
		retailerLocationId,
		visibility,
		categoryIds,
		filterIds,
		start,
		end,
		polygon,
		metaData,
		latitude,
		longitude,
		versionCode,
		root,
		active,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteRegion → POST /region/delete
# Delete Region
#
# Delete a region.
func delete_region(
	# accountId: float   Eg: 789
	# the id of the account logged in
	accountId: float,
	# regionId: float   Eg: 789
	# the id of the region
	regionId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/region/delete"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["regionId"] = regionId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = RegionResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_region_threaded(
	# accountId: float   Eg: 789
	# the id of the account logged in
	accountId: float,
	# regionId: float   Eg: 789
	# the id of the region
	regionId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_region")
	bzz_callable.bind(
		accountId,
		regionId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getRegion → GET /region/get
# Get Region
#
# Get a region.
func get_region(
	# regionId: float   Eg: 789
	# the id of the region to get
	regionId: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/region/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["regionId"] = regionId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = RegionResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_region_threaded(
	# regionId: float   Eg: 789
	# the id of the region to get
	regionId: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_region")
	bzz_callable.bind(
		regionId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchRegions → GET /region/search
# Search Regions
#
# Get the list of regions.
func search_regions(
	# accountId: float   Eg: 789
	# the owner account id of the region to be created
	accountId = null,
	# query: String = ""   Eg: query_example
	# This parameter is deprecated. deprecated - use \"keyword\"
	query = "",
	# keyword: String = ""   Eg: keyword_example
	# the keyword to filter results on
	keyword = "",
	# latitude: int   Eg: 1.2
	# the latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the longitude of the user
	longitude = null,
	# some_range: int   Eg: 1.2
	# the search radius
	some_range = null,
	# regionClass: String = ""   Eg: regionClass_example
	regionClass = "",
	# visibility: String = ""   Eg: visibility_example
	visibility = "",
	# searchMode: String = ""   Eg: searchMode_example
	# the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server
	searchMode = "",
	# sortField: String = ""   Eg: sortField_example
	# the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided.
	sortField = "",
	# descending: bool   Eg: true
	# determines if the results get ordered in descending order
	descending = null,
	# includeParent: bool   Eg: true
	# include the parent region or not
	includeParent = null,
	# includeChildren: bool   Eg: true
	# include the chidren regions or not
	includeChildren = null,
	# includePostalCodes: bool   Eg: true
	# include the postal codes associated with the region or not
	includePostalCodes = null,
	# categoryIds: String = ""   Eg: categoryIds_example
	# search on the categories associated with the region
	categoryIds = "",
	# filterIds: String = ""   Eg: filterIds_example
	# search on the filters associated with the region
	filterIds = "",
	# versionCode: int   Eg: 56
	# filter by a specific version code
	versionCode = null,
	# activeOnly: bool   Eg: true
	# filter to show only active results
	activeOnly = null,
	# showDeleted: bool   Eg: true
	# If showDeleted is true and activeOnly is false, will return regions that have been deleted
	showDeleted = null,
	# lastUpdatedSince: float   Eg: 789
	# only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\)
	lastUpdatedSince = null,
	# start: int   Eg: 56
	# the start index for pagination
	start = null,
	# limit: int   Eg: 56
	# the limit for pagination
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/region/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["query"] = query
	bzz_query["keyword"] = keyword
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["range"] = some_range
	bzz_query["regionClass"] = regionClass
	bzz_query["visibility"] = visibility
	bzz_query["searchMode"] = searchMode
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["includeParent"] = includeParent
	bzz_query["includeChildren"] = includeChildren
	bzz_query["includePostalCodes"] = includePostalCodes
	bzz_query["categoryIds"] = categoryIds
	bzz_query["filterIds"] = filterIds
	bzz_query["versionCode"] = versionCode
	bzz_query["activeOnly"] = activeOnly
	bzz_query["showDeleted"] = showDeleted
	bzz_query["lastUpdatedSince"] = lastUpdatedSince
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = RegionResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_regions_threaded(
	# accountId: float   Eg: 789
	# the owner account id of the region to be created
	accountId = null,
	# query: String = ""   Eg: query_example
	# This parameter is deprecated. deprecated - use \"keyword\"
	query = "",
	# keyword: String = ""   Eg: keyword_example
	# the keyword to filter results on
	keyword = "",
	# latitude: int   Eg: 1.2
	# the latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the longitude of the user
	longitude = null,
	# some_range: int   Eg: 1.2
	# the search radius
	some_range = null,
	# regionClass: String = ""   Eg: regionClass_example
	regionClass = "",
	# visibility: String = ""   Eg: visibility_example
	visibility = "",
	# searchMode: String = ""   Eg: searchMode_example
	# the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server
	searchMode = "",
	# sortField: String = ""   Eg: sortField_example
	# the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided.
	sortField = "",
	# descending: bool   Eg: true
	# determines if the results get ordered in descending order
	descending = null,
	# includeParent: bool   Eg: true
	# include the parent region or not
	includeParent = null,
	# includeChildren: bool   Eg: true
	# include the chidren regions or not
	includeChildren = null,
	# includePostalCodes: bool   Eg: true
	# include the postal codes associated with the region or not
	includePostalCodes = null,
	# categoryIds: String = ""   Eg: categoryIds_example
	# search on the categories associated with the region
	categoryIds = "",
	# filterIds: String = ""   Eg: filterIds_example
	# search on the filters associated with the region
	filterIds = "",
	# versionCode: int   Eg: 56
	# filter by a specific version code
	versionCode = null,
	# activeOnly: bool   Eg: true
	# filter to show only active results
	activeOnly = null,
	# showDeleted: bool   Eg: true
	# If showDeleted is true and activeOnly is false, will return regions that have been deleted
	showDeleted = null,
	# lastUpdatedSince: float   Eg: 789
	# only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\)
	lastUpdatedSince = null,
	# start: int   Eg: 56
	# the start index for pagination
	start = null,
	# limit: int   Eg: 56
	# the limit for pagination
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_regions")
	bzz_callable.bind(
		accountId,
		query,
		keyword,
		latitude,
		longitude,
		some_range,
		regionClass,
		visibility,
		searchMode,
		sortField,
		descending,
		includeParent,
		includeChildren,
		includePostalCodes,
		categoryIds,
		filterIds,
		versionCode,
		activeOnly,
		showDeleted,
		lastUpdatedSince,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateRegion → POST /region/update
# Update Region
#
# Update a region.
func update_region(
	# accountId: float   Eg: 789
	# The id of the account sending the request
	accountId: float,
	# regionId: float   Eg: 789
	# The id of the region to be updated
	regionId: float,
	# regionClass: String = ""   Eg: regionClass_example
	# RegionClass of this region
	regionClass = "",
	# shortName: String = ""   Eg: shortName_example
	# Short name of the region. This is optimized for search
	shortName = "",
	# fullName: String = ""   Eg: fullName_example
	# Full name of the region
	fullName = "",
	# parentIds: String = ""   Eg: parentIds_example
	# Comma separated region ids that are parents of this region
	parentIds = "",
	# childrenIds: String = ""   Eg: childrenIds_example
	# Comma separated region ids that are children of this region
	childrenIds = "",
	# postalCodeIds: String = ""   Eg: postalCodeIds_example
	# Comma separated postal code ids the region will include
	postalCodeIds = "",
	# locations: String = ""   Eg: locations_example
	# Sets of name,lat,long used to create new postal codes assigned to the region
	locations = "",
	# retailerLocationId: float   Eg: 789
	# the retailer location ID that the region is associated with
	retailerLocationId = null,
	# visibility: String = ""   Eg: visibility_example
	# The Visibility of the region
	visibility = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# the categories that the region is assigned to
	categoryIds = "",
	# filterIds: String = ""   Eg: filterIds_example
	# the filters that the region is assigned to
	filterIds = "",
	# start: float   Eg: 789
	start = null,
	# end: float   Eg: 789
	end = null,
	# polygon: String = ""   Eg: polygon_example
	# the polygon of the region
	polygon = "",
	# metaData: String = ""   Eg: metaData_example
	# the meta data of the region
	metaData = "",
	# latitude: int   Eg: 1.2
	# the latitude of the region
	latitude = null,
	# longitude: int   Eg: 1.2
	# the longitude of the region
	longitude = null,
	# versionCode: int   Eg: 56
	# the version code
	versionCode = null,
	# root: bool   Eg: true
	# If this is a root region or not. If true means this region has no parent regions
	root = null,
	# active: bool   Eg: true
	# Active or inactive status of the region
	active = null,
	# clearLists: bool   Eg: true
	# If true clear the children and postal code lists before add new ones, otherwise just append.
	clearLists = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/region/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["regionId"] = regionId
	bzz_query["regionClass"] = regionClass
	bzz_query["shortName"] = shortName
	bzz_query["fullName"] = fullName
	bzz_query["parentIds"] = parentIds
	bzz_query["childrenIds"] = childrenIds
	bzz_query["postalCodeIds"] = postalCodeIds
	bzz_query["locations"] = locations
	bzz_query["retailerLocationId"] = retailerLocationId
	bzz_query["visibility"] = visibility
	bzz_query["categoryIds"] = categoryIds
	bzz_query["filterIds"] = filterIds
	bzz_query["start"] = start
	bzz_query["end"] = end
	bzz_query["polygon"] = polygon
	bzz_query["metaData"] = metaData
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["versionCode"] = versionCode
	bzz_query["root"] = root
	bzz_query["active"] = active
	bzz_query["clearLists"] = clearLists

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = RegionResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_region_threaded(
	# accountId: float   Eg: 789
	# The id of the account sending the request
	accountId: float,
	# regionId: float   Eg: 789
	# The id of the region to be updated
	regionId: float,
	# regionClass: String = ""   Eg: regionClass_example
	# RegionClass of this region
	regionClass = "",
	# shortName: String = ""   Eg: shortName_example
	# Short name of the region. This is optimized for search
	shortName = "",
	# fullName: String = ""   Eg: fullName_example
	# Full name of the region
	fullName = "",
	# parentIds: String = ""   Eg: parentIds_example
	# Comma separated region ids that are parents of this region
	parentIds = "",
	# childrenIds: String = ""   Eg: childrenIds_example
	# Comma separated region ids that are children of this region
	childrenIds = "",
	# postalCodeIds: String = ""   Eg: postalCodeIds_example
	# Comma separated postal code ids the region will include
	postalCodeIds = "",
	# locations: String = ""   Eg: locations_example
	# Sets of name,lat,long used to create new postal codes assigned to the region
	locations = "",
	# retailerLocationId: float   Eg: 789
	# the retailer location ID that the region is associated with
	retailerLocationId = null,
	# visibility: String = ""   Eg: visibility_example
	# The Visibility of the region
	visibility = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# the categories that the region is assigned to
	categoryIds = "",
	# filterIds: String = ""   Eg: filterIds_example
	# the filters that the region is assigned to
	filterIds = "",
	# start: float   Eg: 789
	start = null,
	# end: float   Eg: 789
	end = null,
	# polygon: String = ""   Eg: polygon_example
	# the polygon of the region
	polygon = "",
	# metaData: String = ""   Eg: metaData_example
	# the meta data of the region
	metaData = "",
	# latitude: int   Eg: 1.2
	# the latitude of the region
	latitude = null,
	# longitude: int   Eg: 1.2
	# the longitude of the region
	longitude = null,
	# versionCode: int   Eg: 56
	# the version code
	versionCode = null,
	# root: bool   Eg: true
	# If this is a root region or not. If true means this region has no parent regions
	root = null,
	# active: bool   Eg: true
	# Active or inactive status of the region
	active = null,
	# clearLists: bool   Eg: true
	# If true clear the children and postal code lists before add new ones, otherwise just append.
	clearLists = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_region")
	bzz_callable.bind(
		accountId,
		regionId,
		regionClass,
		shortName,
		fullName,
		parentIds,
		childrenIds,
		postalCodeIds,
		locations,
		retailerLocationId,
		visibility,
		categoryIds,
		filterIds,
		start,
		end,
		polygon,
		metaData,
		latitude,
		longitude,
		versionCode,
		root,
		active,
		clearLists,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


