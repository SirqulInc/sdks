extends ApiBee
class_name PurchaseOrderApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API PurchaseOrderApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "PurchaseOrderApi"


# Operation createOrder → POST /api/{version}/order/create
# Create Order
#
# Creates a new purchase with some number of items associated with it. The purchase is added to the order that was created
func create_order(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application requesting the purchase
	appKey: String,
	# cart: String = ""   Eg: cart_example
	# ```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ``` 
	cart: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# description: String = ""   Eg: description_example
	# A description of the purchase
	description = "",
	# currencyType: String = "CASH"   Eg: currencyType_example
	# Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  
	currencyType = "CASH",
	# paymentMethodId: float   Eg: 789
	# Use a specific payment method (CASH), if not provided use default
	paymentMethodId = null,
	# externalOrderId: String = ""   Eg: externalOrderId_example
	# Store identifier from external system
	externalOrderId = "",
	# externalPaymentId: String = ""   Eg: externalPaymentId_example
	# Store identifier from external system
	externalPaymentId = "",
	# remoteRefType: String = ""   Eg: remoteRefType_example
	# Remote Reference type
	remoteRefType = "",
	# externalDate: float   Eg: 789
	# External Date
	externalDate = null,
	# promoCode: String = ""   Eg: promoCode_example
	# The Promo Code
	promoCode = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/order/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["description"] = description
	bzz_query["currencyType"] = currencyType
	bzz_query["cart"] = cart
	bzz_query["paymentMethodId"] = paymentMethodId
	bzz_query["externalOrderId"] = externalOrderId
	bzz_query["externalPaymentId"] = externalPaymentId
	bzz_query["remoteRefType"] = remoteRefType
	bzz_query["externalDate"] = externalDate
	bzz_query["promoCode"] = promoCode

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrderResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_order_threaded(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application requesting the purchase
	appKey: String,
	# cart: String = ""   Eg: cart_example
	# ```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ``` 
	cart: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# description: String = ""   Eg: description_example
	# A description of the purchase
	description = "",
	# currencyType: String = "CASH"   Eg: currencyType_example
	# Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  
	currencyType = "CASH",
	# paymentMethodId: float   Eg: 789
	# Use a specific payment method (CASH), if not provided use default
	paymentMethodId = null,
	# externalOrderId: String = ""   Eg: externalOrderId_example
	# Store identifier from external system
	externalOrderId = "",
	# externalPaymentId: String = ""   Eg: externalPaymentId_example
	# Store identifier from external system
	externalPaymentId = "",
	# remoteRefType: String = ""   Eg: remoteRefType_example
	# Remote Reference type
	remoteRefType = "",
	# externalDate: float   Eg: 789
	# External Date
	externalDate = null,
	# promoCode: String = ""   Eg: promoCode_example
	# The Promo Code
	promoCode = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_order")
	bzz_callable.bind(
		version,
		appKey,
		cart,
		deviceId,
		accountId,
		description,
		currencyType,
		paymentMethodId,
		externalOrderId,
		externalPaymentId,
		remoteRefType,
		externalDate,
		promoCode,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteOrder → POST /api/{version}/order/delete
# Delete Order
#
# Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.
func delete_order(
	# version: float   Eg: 3.16
	version: float,
	# orderId: float   Eg: 789
	# Order Id
	orderId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/order/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["orderId"] = orderId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_order_threaded(
	# version: float   Eg: 3.16
	version: float,
	# orderId: float   Eg: 789
	# Order Id
	orderId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_order")
	bzz_callable.bind(
		version,
		orderId,
		deviceId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getOrder → GET /api/{version}/order/get
# Get Order
#
# Get an order record
func get_order(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# orderId: float   Eg: 789
	# The order id to get details of, either orderId or externalOrderId must be provided
	orderId = null,
	# externalOrderId: String = ""   Eg: externalOrderId_example
	# The external order id to get details of, either orderId or externalOrderId must be provided
	externalOrderId = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/order/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["orderId"] = orderId
	bzz_query["externalOrderId"] = externalOrderId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrderResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_order_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# orderId: float   Eg: 789
	# The order id to get details of, either orderId or externalOrderId must be provided
	orderId = null,
	# externalOrderId: String = ""   Eg: externalOrderId_example
	# The external order id to get details of, either orderId or externalOrderId must be provided
	externalOrderId = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_order")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		orderId,
		externalOrderId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation previewOrder → POST /api/{version}/order/preview
# Preview Order
#
# Previews a purchase to see the total cost before making it.
func preview_order(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application requesting the purchase
	appKey: String,
	# cart: String = ""   Eg: cart_example
	# A JSON list of items to purchase
	cart: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# description: String = ""   Eg: description_example
	# A description of the purchase
	description = "",
	# currencyType: String = "CASH"   Eg: currencyType_example
	# Determines the method of purchasing offer. ```json {   \"VOID\": \"used for when there is no payment involved (ie. for updating the status of a purchase order)\",   \"CASH\": \"use card on file\",   \"POINTS\": \"use account balance\",   \"TICKETS\": \"use tickets\",   \"REFUND\": \"not allowed for a create, requires a paymentTransactionId\",   \"CREDIT\": \"add to the account balance\",   \"RELOAD\": \"charge a credit card then add to the account balance\" } ``` 
	currencyType = "CASH",
	# paymentMethodId: float   Eg: 789
	# Use a specific payment method (CASH), if not provided use default
	paymentMethodId = null,
	# externalOrderId: String = ""   Eg: externalOrderId_example
	# Store identifier from external system
	externalOrderId = "",
	# externalPaymentId: String = ""   Eg: externalPaymentId_example
	# Store identifier from external system
	externalPaymentId = "",
	# remoteRefType: String = ""   Eg: remoteRefType_example
	# Remote Reference type
	remoteRefType = "",
	# externalDate: float   Eg: 789
	# External Date
	externalDate = null,
	# promoCode: String = ""   Eg: promoCode_example
	# The Promo Code
	promoCode = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/order/preview".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["description"] = description
	bzz_query["currencyType"] = currencyType
	bzz_query["cart"] = cart
	bzz_query["paymentMethodId"] = paymentMethodId
	bzz_query["externalOrderId"] = externalOrderId
	bzz_query["externalPaymentId"] = externalPaymentId
	bzz_query["remoteRefType"] = remoteRefType
	bzz_query["externalDate"] = externalDate
	bzz_query["promoCode"] = promoCode

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrderResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func preview_order_threaded(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application requesting the purchase
	appKey: String,
	# cart: String = ""   Eg: cart_example
	# A JSON list of items to purchase
	cart: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# description: String = ""   Eg: description_example
	# A description of the purchase
	description = "",
	# currencyType: String = "CASH"   Eg: currencyType_example
	# Determines the method of purchasing offer. ```json {   \"VOID\": \"used for when there is no payment involved (ie. for updating the status of a purchase order)\",   \"CASH\": \"use card on file\",   \"POINTS\": \"use account balance\",   \"TICKETS\": \"use tickets\",   \"REFUND\": \"not allowed for a create, requires a paymentTransactionId\",   \"CREDIT\": \"add to the account balance\",   \"RELOAD\": \"charge a credit card then add to the account balance\" } ``` 
	currencyType = "CASH",
	# paymentMethodId: float   Eg: 789
	# Use a specific payment method (CASH), if not provided use default
	paymentMethodId = null,
	# externalOrderId: String = ""   Eg: externalOrderId_example
	# Store identifier from external system
	externalOrderId = "",
	# externalPaymentId: String = ""   Eg: externalPaymentId_example
	# Store identifier from external system
	externalPaymentId = "",
	# remoteRefType: String = ""   Eg: remoteRefType_example
	# Remote Reference type
	remoteRefType = "",
	# externalDate: float   Eg: 789
	# External Date
	externalDate = null,
	# promoCode: String = ""   Eg: promoCode_example
	# The Promo Code
	promoCode = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "preview_order")
	bzz_callable.bind(
		version,
		appKey,
		cart,
		deviceId,
		accountId,
		description,
		currencyType,
		paymentMethodId,
		externalOrderId,
		externalPaymentId,
		remoteRefType,
		externalDate,
		promoCode,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchOrders → GET /api/{version}/order/search
# Search Orders
#
# Search on active orders by customer
func search_orders(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application requesting the purchase
	appKey: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# start: int = 0   Eg: 56
	# The start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# The limit for pagination
	limit = 20,
	# descending: bool = true   Eg: true
	# Determines whether to return the resulting list in descending or ascending order
	descending = true,
	# activeOnly: bool = false   Eg: true
	# Only return active orders
	activeOnly = false,
	# ignoreCustomerFilter: bool = false   Eg: true
	# Determines whether to ignore the customer filter (requires an Admin/Exec account)
	ignoreCustomerFilter = false,
	# orderItemTypes: String = ""   Eg: orderItemTypes_example
	# Filter results by orderItemTypes
	orderItemTypes = "",
	# orderItemIds: String = ""   Eg: orderItemIds_example
	# Filter results by orderItemIds
	orderItemIds = "",
	# orderCustomTypes: String = ""   Eg: orderCustomTypes_example
	# Filter results by orderCustomTypes
	orderCustomTypes = "",
	# orderCustomIds: String = ""   Eg: orderCustomIds_example
	# Filter results by orderCustomIds
	orderCustomIds = "",
	# sortField: String = "ID"   Eg: sortField_example
	# Determines what to sort the results by
	sortField = "ID",
	# offerTypes: String = ""   Eg: offerTypes_example
	# Filter results by offer type
	offerTypes = "",
	# specialOfferTypes: String = ""   Eg: specialOfferTypes_example
	# Filter results by special offer type
	specialOfferTypes = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# Filter results by category Ids
	categoryIds = "",
	# filterIds: String = ""   Eg: filterIds_example
	# Filter results by filter Ids
	filterIds = "",
	# offerAudienceIds: String = ""   Eg: offerAudienceIds_example
	# Filter results by offer audience Ids
	offerAudienceIds = "",
	# transactionAudienceIds: String = ""   Eg: transactionAudienceIds_example
	# Filter results by transaction audience Ids
	transactionAudienceIds = "",
	# offerIds: String = ""   Eg: offerIds_example
	# Filter results by offer Ids
	offerIds = "",
	# offerLocationIds: String = ""   Eg: offerLocationIds_example
	# Filter results by offer location Ids
	offerLocationIds = "",
	# retailerIds: String = ""   Eg: retailerIds_example
	# Filter results by retailer Ids
	retailerIds = "",
	# retailerLocationIds: String = ""   Eg: retailerLocationIds_example
	# Filter results by retailer location Ids
	retailerLocationIds = "",
	# statuses: String = ""   Eg: statuses_example
	# Filter results by offer transaction status (0: non-redeemable, 1: redeemable, 2: redeemed, 3: user deleted, 4: unclaimed/rewarded, 5: membership active, 6: membership cancelled)
	statuses = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword to search for
	keyword = "",
	# redeemableStartDate: float   Eg: 789
	# Filter results by the offer redeemable date
	redeemableStartDate = null,
	# redeemableEndDate: float   Eg: 789
	# Filter results by the offer redeemable date
	redeemableEndDate = null,
	# startedSince: float   Eg: 789
	# Filter results by the offer start date
	startedSince = null,
	# startedBefore: float   Eg: 789
	# Filter results by the offer start date
	startedBefore = null,
	# endedSince: float   Eg: 789
	# Filter results by the offer end date
	endedSince = null,
	# endedBefore: float   Eg: 789
	# Filter results by the offer end date
	endedBefore = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/order/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["descending"] = descending
	bzz_query["activeOnly"] = activeOnly
	bzz_query["ignoreCustomerFilter"] = ignoreCustomerFilter
	bzz_query["orderItemTypes"] = orderItemTypes
	bzz_query["orderItemIds"] = orderItemIds
	bzz_query["orderCustomTypes"] = orderCustomTypes
	bzz_query["orderCustomIds"] = orderCustomIds
	bzz_query["sortField"] = sortField
	bzz_query["offerTypes"] = offerTypes
	bzz_query["specialOfferTypes"] = specialOfferTypes
	bzz_query["categoryIds"] = categoryIds
	bzz_query["filterIds"] = filterIds
	bzz_query["offerAudienceIds"] = offerAudienceIds
	bzz_query["transactionAudienceIds"] = transactionAudienceIds
	bzz_query["offerIds"] = offerIds
	bzz_query["offerLocationIds"] = offerLocationIds
	bzz_query["retailerIds"] = retailerIds
	bzz_query["retailerLocationIds"] = retailerLocationIds
	bzz_query["statuses"] = statuses
	bzz_query["keyword"] = keyword
	bzz_query["redeemableStartDate"] = redeemableStartDate
	bzz_query["redeemableEndDate"] = redeemableEndDate
	bzz_query["startedSince"] = startedSince
	bzz_query["startedBefore"] = startedBefore
	bzz_query["endedSince"] = endedSince
	bzz_query["endedBefore"] = endedBefore

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrderResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_orders_threaded(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application requesting the purchase
	appKey: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# start: int = 0   Eg: 56
	# The start index for pagination
	start = 0,
	# limit: int = 20   Eg: 56
	# The limit for pagination
	limit = 20,
	# descending: bool = true   Eg: true
	# Determines whether to return the resulting list in descending or ascending order
	descending = true,
	# activeOnly: bool = false   Eg: true
	# Only return active orders
	activeOnly = false,
	# ignoreCustomerFilter: bool = false   Eg: true
	# Determines whether to ignore the customer filter (requires an Admin/Exec account)
	ignoreCustomerFilter = false,
	# orderItemTypes: String = ""   Eg: orderItemTypes_example
	# Filter results by orderItemTypes
	orderItemTypes = "",
	# orderItemIds: String = ""   Eg: orderItemIds_example
	# Filter results by orderItemIds
	orderItemIds = "",
	# orderCustomTypes: String = ""   Eg: orderCustomTypes_example
	# Filter results by orderCustomTypes
	orderCustomTypes = "",
	# orderCustomIds: String = ""   Eg: orderCustomIds_example
	# Filter results by orderCustomIds
	orderCustomIds = "",
	# sortField: String = "ID"   Eg: sortField_example
	# Determines what to sort the results by
	sortField = "ID",
	# offerTypes: String = ""   Eg: offerTypes_example
	# Filter results by offer type
	offerTypes = "",
	# specialOfferTypes: String = ""   Eg: specialOfferTypes_example
	# Filter results by special offer type
	specialOfferTypes = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# Filter results by category Ids
	categoryIds = "",
	# filterIds: String = ""   Eg: filterIds_example
	# Filter results by filter Ids
	filterIds = "",
	# offerAudienceIds: String = ""   Eg: offerAudienceIds_example
	# Filter results by offer audience Ids
	offerAudienceIds = "",
	# transactionAudienceIds: String = ""   Eg: transactionAudienceIds_example
	# Filter results by transaction audience Ids
	transactionAudienceIds = "",
	# offerIds: String = ""   Eg: offerIds_example
	# Filter results by offer Ids
	offerIds = "",
	# offerLocationIds: String = ""   Eg: offerLocationIds_example
	# Filter results by offer location Ids
	offerLocationIds = "",
	# retailerIds: String = ""   Eg: retailerIds_example
	# Filter results by retailer Ids
	retailerIds = "",
	# retailerLocationIds: String = ""   Eg: retailerLocationIds_example
	# Filter results by retailer location Ids
	retailerLocationIds = "",
	# statuses: String = ""   Eg: statuses_example
	# Filter results by offer transaction status (0: non-redeemable, 1: redeemable, 2: redeemed, 3: user deleted, 4: unclaimed/rewarded, 5: membership active, 6: membership cancelled)
	statuses = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword to search for
	keyword = "",
	# redeemableStartDate: float   Eg: 789
	# Filter results by the offer redeemable date
	redeemableStartDate = null,
	# redeemableEndDate: float   Eg: 789
	# Filter results by the offer redeemable date
	redeemableEndDate = null,
	# startedSince: float   Eg: 789
	# Filter results by the offer start date
	startedSince = null,
	# startedBefore: float   Eg: 789
	# Filter results by the offer start date
	startedBefore = null,
	# endedSince: float   Eg: 789
	# Filter results by the offer end date
	endedSince = null,
	# endedBefore: float   Eg: 789
	# Filter results by the offer end date
	endedBefore = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_orders")
	bzz_callable.bind(
		version,
		appKey,
		deviceId,
		accountId,
		start,
		limit,
		descending,
		activeOnly,
		ignoreCustomerFilter,
		orderItemTypes,
		orderItemIds,
		orderCustomTypes,
		orderCustomIds,
		sortField,
		offerTypes,
		specialOfferTypes,
		categoryIds,
		filterIds,
		offerAudienceIds,
		transactionAudienceIds,
		offerIds,
		offerLocationIds,
		retailerIds,
		retailerLocationIds,
		statuses,
		keyword,
		redeemableStartDate,
		redeemableEndDate,
		startedSince,
		startedBefore,
		endedSince,
		endedBefore,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateOrder → POST /api/{version}/order/update
# Update Order
#
# Updates new purchase with some number of items associated with it. The orderId provided is used to retrieve the record and the payment is added to it.
func update_order(
	# version: float   Eg: 3.16
	version: float,
	# orderId: float   Eg: 789
	# The order to add the purchase to, leave null for new order.
	orderId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application requesting the purchase
	appKey: String,
	# cart: String = ""   Eg: cart_example
	# ```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ``` 
	cart: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# paymentTransactionId: float   Eg: 789
	# The payment transaction to apply the refund to
	paymentTransactionId = null,
	# description: String = ""   Eg: description_example
	# A description of the purchase
	description = "",
	# currencyType: String = "CASH"   Eg: currencyType_example
	# Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  
	currencyType = "CASH",
	# paymentMethodId: float   Eg: 789
	# Use a specific payment method (CASH), if not provided use default
	paymentMethodId = null,
	# externalPaymentId: String = ""   Eg: externalPaymentId_example
	# Store identifier from external system
	externalPaymentId = "",
	# externalDate: float   Eg: 789
	# External Date
	externalDate = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/order/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["orderId"] = orderId
	bzz_query["paymentTransactionId"] = paymentTransactionId
	bzz_query["appKey"] = appKey
	bzz_query["description"] = description
	bzz_query["currencyType"] = currencyType
	bzz_query["cart"] = cart
	bzz_query["paymentMethodId"] = paymentMethodId
	bzz_query["externalPaymentId"] = externalPaymentId
	bzz_query["externalDate"] = externalDate

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OrderResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_order_threaded(
	# version: float   Eg: 3.16
	version: float,
	# orderId: float   Eg: 789
	# The order to add the purchase to, leave null for new order.
	orderId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application requesting the purchase
	appKey: String,
	# cart: String = ""   Eg: cart_example
	# ```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ``` 
	cart: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# paymentTransactionId: float   Eg: 789
	# The payment transaction to apply the refund to
	paymentTransactionId = null,
	# description: String = ""   Eg: description_example
	# A description of the purchase
	description = "",
	# currencyType: String = "CASH"   Eg: currencyType_example
	# Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  
	currencyType = "CASH",
	# paymentMethodId: float   Eg: 789
	# Use a specific payment method (CASH), if not provided use default
	paymentMethodId = null,
	# externalPaymentId: String = ""   Eg: externalPaymentId_example
	# Store identifier from external system
	externalPaymentId = "",
	# externalDate: float   Eg: 789
	# External Date
	externalDate = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_order")
	bzz_callable.bind(
		version,
		orderId,
		appKey,
		cart,
		deviceId,
		accountId,
		paymentTransactionId,
		description,
		currencyType,
		paymentMethodId,
		externalPaymentId,
		externalDate,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


