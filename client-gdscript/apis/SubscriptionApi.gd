extends ApiBee
class_name SubscriptionApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API SubscriptionApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "SubscriptionApi"


# Operation createSubscription → POST /subscription/create
# Create Subscription
#
# Create a subscription for a billable entity.  Provide a planId, if not provided then the base plan will be assigned.
func create_subscription(
	# accountId: float   Eg: 789
	# The account used to perform the create, must be the responsible manager
	accountId: float,
	# planId: float   Eg: 789
	# The plan to subscribe to, if null use default plan
	planId = null,
	# promoCode: String = ""   Eg: promoCode_example
	# Set a promo code for a discount.
	promoCode = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/subscription/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["planId"] = planId
	bzz_query["promoCode"] = promoCode

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SubscriptionResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_subscription_threaded(
	# accountId: float   Eg: 789
	# The account used to perform the create, must be the responsible manager
	accountId: float,
	# planId: float   Eg: 789
	# The plan to subscribe to, if null use default plan
	planId = null,
	# promoCode: String = ""   Eg: promoCode_example
	# Set a promo code for a discount.
	promoCode = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_subscription")
	bzz_callable.bind(
		accountId,
		planId,
		promoCode,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteSubscription → POST /subscription/delete
# Delete Subscription
#
# Suspend the current subscription for the billable entity managed by the account.  The account must be the responsible manager to perform this action
func delete_subscription(
	# accountId: float   Eg: 789
	# The account used to perform the delete, must be the responsible manager
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/subscription/delete"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_subscription_threaded(
	# accountId: float   Eg: 789
	# The account used to perform the delete, must be the responsible manager
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_subscription")
	bzz_callable.bind(
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getSubscription → GET /subscription/get
# Get Subscription
#
# Use the accountId to determine the associated BillableEntity.  Then get the subscription.
func get_subscription(
	# accountId: float   Eg: 789
	# The account used to perform the lookup
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/subscription/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SubscriptionResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_subscription_threaded(
	# accountId: float   Eg: 789
	# The account used to perform the lookup
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_subscription")
	bzz_callable.bind(
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getSubscriptionPlan → GET /subscription/plan/get
# Get Subscription Plan
#
# Get the matched subscription plan
func get_subscription_plan(
	# planId: float   Eg: 789
	# The ID of the plan to get
	planId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/subscription/plan/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["planId"] = planId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SubscriptionPlanResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_subscription_plan_threaded(
	# planId: float   Eg: 789
	# The ID of the plan to get
	planId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_subscription_plan")
	bzz_callable.bind(
		planId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getSubscriptionPlans → GET /subscription/plan/list
# List Subscription Plans
#
# Get the matched subscription plan
func get_subscription_plans(
	# visible: bool   Eg: true
	# Include visible only (true), hidden only (false), or all (null)
	visible = null,
	# role: String = ""   Eg: role_example
	# The role the plan is targeted for, values are: DEVELOPER, RETAILER, ADVERTISER
	role = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/subscription/plan/list"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["visible"] = visible
	bzz_query["role"] = role

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SubscriptionPlanResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_subscription_plans_threaded(
	# visible: bool   Eg: true
	# Include visible only (true), hidden only (false), or all (null)
	visible = null,
	# role: String = ""   Eg: role_example
	# The role the plan is targeted for, values are: DEVELOPER, RETAILER, ADVERTISER
	role = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_subscription_plans")
	bzz_callable.bind(
		visible,
		role,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getSubscriptionUsage → GET /subscription/usage/get
# Get Subscription Usage
#
# Use the accountId to determine the associated BillableEntity.  Then get the application usage.
func get_subscription_usage(
	# accountId: float   Eg: 789
	# The account used to perform the lookup
	accountId: float,
	# applicationId: float   Eg: 789
	# Get for just 1 application instead of the BillableEntity
	applicationId = null,
	# start: float   Eg: 789
	# The start time frame
	start = null,
	# end: float   Eg: 789
	# The end time frame
	end = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/subscription/usage/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["applicationId"] = applicationId
	bzz_query["start"] = start
	bzz_query["end"] = end

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ApplicationUsageResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_subscription_usage_threaded(
	# accountId: float   Eg: 789
	# The account used to perform the lookup
	accountId: float,
	# applicationId: float   Eg: 789
	# Get for just 1 application instead of the BillableEntity
	applicationId = null,
	# start: float   Eg: 789
	# The start time frame
	start = null,
	# end: float   Eg: 789
	# The end time frame
	end = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_subscription_usage")
	bzz_callable.bind(
		accountId,
		applicationId,
		start,
		end,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateSubscription → POST /subscription/update
# Update Subscription
#
# Updates the subscription for the billable entity for an account
func update_subscription(
	# accountId: float   Eg: 789
	# The account used to perform the update, must be the responsible manager
	accountId: float,
	# planId: float   Eg: 789
	# The plan to subscribe to
	planId = null,
	# promoCode: String = ""   Eg: promoCode_example
	# Set a promo code for a discount.
	promoCode = "",
	# active: bool   Eg: true
	# Set active status
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/subscription/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["planId"] = planId
	bzz_query["promoCode"] = promoCode
	bzz_query["active"] = active

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SubscriptionResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_subscription_threaded(
	# accountId: float   Eg: 789
	# The account used to perform the update, must be the responsible manager
	accountId: float,
	# planId: float   Eg: 789
	# The plan to subscribe to
	planId = null,
	# promoCode: String = ""   Eg: promoCode_example
	# Set a promo code for a discount.
	promoCode = "",
	# active: bool   Eg: true
	# Set active status
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_subscription")
	bzz_callable.bind(
		accountId,
		planId,
		promoCode,
		active,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


