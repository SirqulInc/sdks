extends ApiBee
class_name AssetApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API AssetApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "AssetApi"


# Operation assetDownload → GET /asset/download/{filename}
# Download Asset
#
# Downloads an asset from the server for assets that have been uploaded to the server.
func asset_download(
	# filename: String = ""   Eg: filename_example
	# the filename in the following formats: {assetId}-{suffix}.{extension} | {assetId}.{extension} | {assetId}
	filename: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Validate param `filename` constraints
	var bzz_filename_regex := RegEx.new()
	bzz_filename_regex.compile("/.+/".trim_prefix('/').trim_suffix('/'))
	if not bzz_filename_regex.search(str(filename)):
		var error := ApiError.new()
		error.identifier = "asset_download.param.validation.pattern"
		error.message = "Invalid value for `filename`, must conform to the pattern `/.+/`."
		on_failure.call(error)
		return

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/asset/download/{filename}".replace("{" + "filename" + "}", _bzz_urlize_path_param(filename))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func asset_download_threaded(
	# filename: String = ""   Eg: filename_example
	# the filename in the following formats: {assetId}-{suffix}.{extension} | {assetId}.{extension} | {assetId}
	filename: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "asset_download")
	bzz_callable.bind(
		filename,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation assetMorph → POST /asset/morph
# Convert Offer to Creative
#
# Converts an offer image + text into a creative image.
func asset_morph(
	# offerId: float   Eg: 789
	# offer id used for inserting offer text/flavor
	offerId: float,
	# adSize: String = ""   Eg: adSize_example
	# the ad size used for selecting a format for the creative image
	adSize: String,
	# creativeId: float   Eg: 789
	# used for inserting the newly created image into
	creativeId = null,
	# width: int   Eg: 56
	# total width of the creative image
	width = null,
	# height: int   Eg: 56
	# total height of the creative image
	height = null,
	# backgroundSize: String = ""   Eg: backgroundSize_example
	# the size of the background
	backgroundSize = "",
	# template: String = ""   Eg: template_example
	# the template to use
	template = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/asset/morph"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["offerId"] = offerId
	bzz_query["creativeId"] = creativeId
	bzz_query["adSize"] = adSize
	bzz_query["width"] = width
	bzz_query["height"] = height
	bzz_query["backgroundSize"] = backgroundSize
	bzz_query["template"] = template

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AssetShortResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func asset_morph_threaded(
	# offerId: float   Eg: 789
	# offer id used for inserting offer text/flavor
	offerId: float,
	# adSize: String = ""   Eg: adSize_example
	# the ad size used for selecting a format for the creative image
	adSize: String,
	# creativeId: float   Eg: 789
	# used for inserting the newly created image into
	creativeId = null,
	# width: int   Eg: 56
	# total width of the creative image
	width = null,
	# height: int   Eg: 56
	# total height of the creative image
	height = null,
	# backgroundSize: String = ""   Eg: backgroundSize_example
	# the size of the background
	backgroundSize = "",
	# template: String = ""   Eg: template_example
	# the template to use
	template = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "asset_morph")
	bzz_callable.bind(
		offerId,
		adSize,
		creativeId,
		width,
		height,
		backgroundSize,
		template,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createAsset → POST /asset/create
# Create Asset
#
# Uploads an asset to server and returns an asset id which can be used to assign to various objects.
func create_asset(
	# returnNulls: bool   Eg: true
	# to return nulls
	returnNulls = null,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# albumId: float   Eg: 789
	# the album the asset will be added to (optional)
	albumId = null,
	# collectionId: float   Eg: 789
	# Deprecated: use collections via the collection endpoints.
	collectionId = null,
	# addToDefaultAlbum: String = ""   Eg: addToDefaultAlbum_example
	# Whether to add to a default album
	addToDefaultAlbum = "",
	# addToMediaLibrary: bool   Eg: true
	# Whether to add to the media library
	addToMediaLibrary = null,
	# versionCode: int   Eg: 56
	# the version code
	versionCode = null,
	# versionName: String = ""   Eg: versionName_example
	# the version name
	versionName = "",
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# caption: String = ""   Eg: caption_example
	# the caption (optional)
	caption = "",
	# assetType: String = ""   Eg: assetType_example
	# the asset type
	assetType = "",
	# approvalStatus: String = ""   Eg: approvalStatus_example
	# approval status for the asset
	approvalStatus = "",
	# assignedAccountId: float   Eg: 789
	# account id assigned to the asset
	assignedAccountId = null,
	# media: String   Eg: BINARY_DATA_HERE
	# a MultipartFile containing the mimetype, etc
	media = null,
	# mediaUrl: String = ""   Eg: mediaUrl_example
	# this can be used if the \"media\" is a link (optional)
	mediaUrl = "",
	# mediaString: String = ""   Eg: mediaString_example
	# the media content as a string (optional)
	mediaString = "",
	# mediaStringFileName: String = ""   Eg: mediaStringFileName_example
	# file name for mediaString (optional)
	mediaStringFileName = "",
	# mediaStringContentType: String = ""   Eg: mediaStringContentType_example
	# content type for mediaString (optional)
	mediaStringContentType = "",
	# mediaHeight: int   Eg: 56
	# the media height (optional)
	mediaHeight = null,
	# mediaWidth: int   Eg: 56
	# the media width (optional)
	mediaWidth = null,
	# attachedMedia: String   Eg: BINARY_DATA_HERE
	# a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.
	attachedMedia = null,
	# attachedMediaUrl: String = ""   Eg: attachedMediaUrl_example
	# this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)
	attachedMediaUrl = "",
	# attachedMediaString: String = ""   Eg: attachedMediaString_example
	# attached media content as a string (optional)
	attachedMediaString = "",
	# attachedMediaStringFileName: String = ""   Eg: attachedMediaStringFileName_example
	# file name for attachedMediaString (optional)
	attachedMediaStringFileName = "",
	# attachedMediaStringContentType: String = ""   Eg: attachedMediaStringContentType_example
	# content type for attachedMediaString (optional)
	attachedMediaStringContentType = "",
	# attachedMediaHeight: int   Eg: 56
	# the attached media height (optional)
	attachedMediaHeight = null,
	# attachedMediaWidth: int   Eg: 56
	# the attached media width (optional)
	attachedMediaWidth = null,
	# locationDescription: String = ""   Eg: locationDescription_example
	# the location description (optional)
	locationDescription = "",
	# app: String = ""   Eg: app_example
	# Deprecated: app parameter
	app = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# searchTags: String = ""   Eg: searchTags_example
	# the search tags
	searchTags = "",
	# latitude: int   Eg: 1.2
	# the latitude (optional)
	latitude = null,
	# longitude: int   Eg: 1.2
	# the longitude (optional)
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/asset/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["returnNulls"] = returnNulls
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["albumId"] = albumId
	bzz_query["collectionId"] = collectionId
	bzz_query["addToDefaultAlbum"] = addToDefaultAlbum
	bzz_query["addToMediaLibrary"] = addToMediaLibrary
	bzz_query["versionCode"] = versionCode
	bzz_query["versionName"] = versionName
	bzz_query["metaData"] = metaData
	bzz_query["caption"] = caption
	bzz_query["assetType"] = assetType
	bzz_query["approvalStatus"] = approvalStatus
	bzz_query["assignedAccountId"] = assignedAccountId
	bzz_query["media"] = media
	bzz_query["mediaUrl"] = mediaUrl
	bzz_query["mediaString"] = mediaString
	bzz_query["mediaStringFileName"] = mediaStringFileName
	bzz_query["mediaStringContentType"] = mediaStringContentType
	bzz_query["mediaHeight"] = mediaHeight
	bzz_query["mediaWidth"] = mediaWidth
	bzz_query["attachedMedia"] = attachedMedia
	bzz_query["attachedMediaUrl"] = attachedMediaUrl
	bzz_query["attachedMediaString"] = attachedMediaString
	bzz_query["attachedMediaStringFileName"] = attachedMediaStringFileName
	bzz_query["attachedMediaStringContentType"] = attachedMediaStringContentType
	bzz_query["attachedMediaHeight"] = attachedMediaHeight
	bzz_query["attachedMediaWidth"] = attachedMediaWidth
	bzz_query["locationDescription"] = locationDescription
	bzz_query["app"] = app
	bzz_query["appKey"] = appKey
	bzz_query["searchTags"] = searchTags
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AssetResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_asset_threaded(
	# returnNulls: bool   Eg: true
	# to return nulls
	returnNulls = null,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# albumId: float   Eg: 789
	# the album the asset will be added to (optional)
	albumId = null,
	# collectionId: float   Eg: 789
	# Deprecated: use collections via the collection endpoints.
	collectionId = null,
	# addToDefaultAlbum: String = ""   Eg: addToDefaultAlbum_example
	# Whether to add to a default album
	addToDefaultAlbum = "",
	# addToMediaLibrary: bool   Eg: true
	# Whether to add to the media library
	addToMediaLibrary = null,
	# versionCode: int   Eg: 56
	# the version code
	versionCode = null,
	# versionName: String = ""   Eg: versionName_example
	# the version name
	versionName = "",
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# caption: String = ""   Eg: caption_example
	# the caption (optional)
	caption = "",
	# assetType: String = ""   Eg: assetType_example
	# the asset type
	assetType = "",
	# approvalStatus: String = ""   Eg: approvalStatus_example
	# approval status for the asset
	approvalStatus = "",
	# assignedAccountId: float   Eg: 789
	# account id assigned to the asset
	assignedAccountId = null,
	# media: String   Eg: BINARY_DATA_HERE
	# a MultipartFile containing the mimetype, etc
	media = null,
	# mediaUrl: String = ""   Eg: mediaUrl_example
	# this can be used if the \"media\" is a link (optional)
	mediaUrl = "",
	# mediaString: String = ""   Eg: mediaString_example
	# the media content as a string (optional)
	mediaString = "",
	# mediaStringFileName: String = ""   Eg: mediaStringFileName_example
	# file name for mediaString (optional)
	mediaStringFileName = "",
	# mediaStringContentType: String = ""   Eg: mediaStringContentType_example
	# content type for mediaString (optional)
	mediaStringContentType = "",
	# mediaHeight: int   Eg: 56
	# the media height (optional)
	mediaHeight = null,
	# mediaWidth: int   Eg: 56
	# the media width (optional)
	mediaWidth = null,
	# attachedMedia: String   Eg: BINARY_DATA_HERE
	# a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.
	attachedMedia = null,
	# attachedMediaUrl: String = ""   Eg: attachedMediaUrl_example
	# this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)
	attachedMediaUrl = "",
	# attachedMediaString: String = ""   Eg: attachedMediaString_example
	# attached media content as a string (optional)
	attachedMediaString = "",
	# attachedMediaStringFileName: String = ""   Eg: attachedMediaStringFileName_example
	# file name for attachedMediaString (optional)
	attachedMediaStringFileName = "",
	# attachedMediaStringContentType: String = ""   Eg: attachedMediaStringContentType_example
	# content type for attachedMediaString (optional)
	attachedMediaStringContentType = "",
	# attachedMediaHeight: int   Eg: 56
	# the attached media height (optional)
	attachedMediaHeight = null,
	# attachedMediaWidth: int   Eg: 56
	# the attached media width (optional)
	attachedMediaWidth = null,
	# locationDescription: String = ""   Eg: locationDescription_example
	# the location description (optional)
	locationDescription = "",
	# app: String = ""   Eg: app_example
	# Deprecated: app parameter
	app = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# searchTags: String = ""   Eg: searchTags_example
	# the search tags
	searchTags = "",
	# latitude: int   Eg: 1.2
	# the latitude (optional)
	latitude = null,
	# longitude: int   Eg: 1.2
	# the longitude (optional)
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_asset")
	bzz_callable.bind(
		returnNulls,
		deviceId,
		accountId,
		albumId,
		collectionId,
		addToDefaultAlbum,
		addToMediaLibrary,
		versionCode,
		versionName,
		metaData,
		caption,
		assetType,
		approvalStatus,
		assignedAccountId,
		media,
		mediaUrl,
		mediaString,
		mediaStringFileName,
		mediaStringContentType,
		mediaHeight,
		mediaWidth,
		attachedMedia,
		attachedMediaUrl,
		attachedMediaString,
		attachedMediaStringFileName,
		attachedMediaStringContentType,
		attachedMediaHeight,
		attachedMediaWidth,
		locationDescription,
		app,
		appKey,
		searchTags,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteAsset → POST /asset/delete
# Delete Asset
#
# Delete an asset.
func delete_asset(
	# assetId: String = ""   Eg: assetId_example
	# the id of the asset to delete
	assetId: String,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# latitude: int   Eg: 1.2
	# latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/asset/delete"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["assetId"] = assetId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_asset_threaded(
	# assetId: String = ""   Eg: assetId_example
	# the id of the asset to delete
	assetId: String,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# latitude: int   Eg: 1.2
	# latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_asset")
	bzz_callable.bind(
		assetId,
		deviceId,
		accountId,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getAsset → GET /asset/get
# Get Asset
#
# Gets the full asset response including attached likes and notes.
func get_asset(
	# assetId: float   Eg: 789
	# the asset ID
	assetId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# noteDescending: bool = false   Eg: true
	# determines whether the notes on the asset are in descending order
	noteDescending = false,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/asset/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["assetId"] = assetId
	bzz_query["noteDescending"] = noteDescending

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AssetFullResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_asset_threaded(
	# assetId: float   Eg: 789
	# the asset ID
	assetId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# noteDescending: bool = false   Eg: true
	# determines whether the notes on the asset are in descending order
	noteDescending = false,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_asset")
	bzz_callable.bind(
		assetId,
		deviceId,
		accountId,
		noteDescending,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation removeAsset → POST /asset/remove
# Remove Asset from Collection
#
# Remove assets from collections
func remove_asset(
	# assetId: String = ""   Eg: assetId_example
	# the id of the asset to remove
	assetId: String,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# albumId: float   Eg: 789
	# the album id to remove the asset from
	albumId = null,
	# collectionId: float   Eg: 789
	# the collection id to remove the asset from
	collectionId = null,
	# removeFromDefaultAlbums: bool   Eg: true
	# remove from the user's profile album
	removeFromDefaultAlbums = null,
	# latitude: int   Eg: 1.2
	# latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/asset/remove"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["albumId"] = albumId
	bzz_query["collectionId"] = collectionId
	bzz_query["assetId"] = assetId
	bzz_query["removeFromDefaultAlbums"] = removeFromDefaultAlbums
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func remove_asset_threaded(
	# assetId: String = ""   Eg: assetId_example
	# the id of the asset to remove
	assetId: String,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# albumId: float   Eg: 789
	# the album id to remove the asset from
	albumId = null,
	# collectionId: float   Eg: 789
	# the collection id to remove the asset from
	collectionId = null,
	# removeFromDefaultAlbums: bool   Eg: true
	# remove from the user's profile album
	removeFromDefaultAlbums = null,
	# latitude: int   Eg: 1.2
	# latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "remove_asset")
	bzz_callable.bind(
		assetId,
		deviceId,
		accountId,
		albumId,
		collectionId,
		removeFromDefaultAlbums,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchAssets → GET /asset/search
# Search Assets
#
# Searches for assets
func search_assets(
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# albumIds: String = ""   Eg: albumIds_example
	# comma separated list of album ids to search on
	albumIds = "",
	# assetIds: String = ""   Eg: assetIds_example
	# comma separated list of asset ids to search on
	assetIds = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key to filter results by application.
	appKey = "",
	# mediaType: String = ""   Eg: mediaType_example
	# filter results by media type. Possible values include: APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, TEXT
	mediaType = "",
	# mimeType: String = ""   Eg: mimeType_example
	# filter results by mime type
	mimeType = "",
	# keyword: String = ""   Eg: keyword_example
	# keyword search string
	keyword = "",
	# versionCode: int   Eg: 56
	# filter results by version code
	versionCode = null,
	# versionName: String = ""   Eg: versionName_example
	# filter results by version name
	versionName = "",
	# updatedSince: float   Eg: 789
	# return items that have been updated since this date (time-stamp in milliseconds)
	updatedSince = null,
	# updatedBefore: float   Eg: 789
	# return items that have been updated before this date (time-stamp in milliseconds)
	updatedBefore = null,
	# sortField: String = ""   Eg: sortField_example
	# the field to sort by. See AssetApiMap
	sortField = "",
	# descending: bool   Eg: true
	# determines whether the sorted list is in descending or ascending order
	descending = null,
	# searchMediaLibrary: bool   Eg: true
	# determines whether to search on the media library album
	searchMediaLibrary = null,
	# filterByBillable: bool   Eg: true
	# filter results by billable entity
	filterByBillable = null,
	# activeOnly: bool   Eg: true
	# if only searching for active assets
	activeOnly = null,
	# returnApp: bool   Eg: true
	# determines whether to include the application response as part of the asset response
	returnApp = null,
	# start: int   Eg: 56
	# the start index for pagination
	start = null,
	# limit: int   Eg: 56
	# the limit for pagination (there is a hard limit of 200)
	limit = null,
	# searchMode: String = ""   Eg: searchMode_example
	# search mode for index (SearchIndexMode)
	searchMode = "",
	# assetType: String = ""   Eg: assetType_example
	# filter by asset type
	assetType = "",
	# approvalStatus: String = ""   Eg: approvalStatus_example
	# filter by approval status
	approvalStatus = "",
	# assignedAccountId: float   Eg: 789
	# filter results by an assigned account id
	assignedAccountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/asset/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["albumIds"] = albumIds
	bzz_query["assetIds"] = assetIds
	bzz_query["appKey"] = appKey
	bzz_query["mediaType"] = mediaType
	bzz_query["mimeType"] = mimeType
	bzz_query["keyword"] = keyword
	bzz_query["versionCode"] = versionCode
	bzz_query["versionName"] = versionName
	bzz_query["updatedSince"] = updatedSince
	bzz_query["updatedBefore"] = updatedBefore
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["searchMediaLibrary"] = searchMediaLibrary
	bzz_query["filterByBillable"] = filterByBillable
	bzz_query["activeOnly"] = activeOnly
	bzz_query["returnApp"] = returnApp
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["searchMode"] = searchMode
	bzz_query["assetType"] = assetType
	bzz_query["approvalStatus"] = approvalStatus
	bzz_query["assignedAccountId"] = assignedAccountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AssetResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_assets_threaded(
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# albumIds: String = ""   Eg: albumIds_example
	# comma separated list of album ids to search on
	albumIds = "",
	# assetIds: String = ""   Eg: assetIds_example
	# comma separated list of asset ids to search on
	assetIds = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key to filter results by application.
	appKey = "",
	# mediaType: String = ""   Eg: mediaType_example
	# filter results by media type. Possible values include: APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, TEXT
	mediaType = "",
	# mimeType: String = ""   Eg: mimeType_example
	# filter results by mime type
	mimeType = "",
	# keyword: String = ""   Eg: keyword_example
	# keyword search string
	keyword = "",
	# versionCode: int   Eg: 56
	# filter results by version code
	versionCode = null,
	# versionName: String = ""   Eg: versionName_example
	# filter results by version name
	versionName = "",
	# updatedSince: float   Eg: 789
	# return items that have been updated since this date (time-stamp in milliseconds)
	updatedSince = null,
	# updatedBefore: float   Eg: 789
	# return items that have been updated before this date (time-stamp in milliseconds)
	updatedBefore = null,
	# sortField: String = ""   Eg: sortField_example
	# the field to sort by. See AssetApiMap
	sortField = "",
	# descending: bool   Eg: true
	# determines whether the sorted list is in descending or ascending order
	descending = null,
	# searchMediaLibrary: bool   Eg: true
	# determines whether to search on the media library album
	searchMediaLibrary = null,
	# filterByBillable: bool   Eg: true
	# filter results by billable entity
	filterByBillable = null,
	# activeOnly: bool   Eg: true
	# if only searching for active assets
	activeOnly = null,
	# returnApp: bool   Eg: true
	# determines whether to include the application response as part of the asset response
	returnApp = null,
	# start: int   Eg: 56
	# the start index for pagination
	start = null,
	# limit: int   Eg: 56
	# the limit for pagination (there is a hard limit of 200)
	limit = null,
	# searchMode: String = ""   Eg: searchMode_example
	# search mode for index (SearchIndexMode)
	searchMode = "",
	# assetType: String = ""   Eg: assetType_example
	# filter by asset type
	assetType = "",
	# approvalStatus: String = ""   Eg: approvalStatus_example
	# filter by approval status
	approvalStatus = "",
	# assignedAccountId: float   Eg: 789
	# filter results by an assigned account id
	assignedAccountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_assets")
	bzz_callable.bind(
		deviceId,
		accountId,
		albumIds,
		assetIds,
		appKey,
		mediaType,
		mimeType,
		keyword,
		versionCode,
		versionName,
		updatedSince,
		updatedBefore,
		sortField,
		descending,
		searchMediaLibrary,
		filterByBillable,
		activeOnly,
		returnApp,
		start,
		limit,
		searchMode,
		assetType,
		approvalStatus,
		assignedAccountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateAsset → POST /asset/update
# Update Asset
#
# Updates an asset's meta data. If an album reference is passed in, the participants with write permissions are allowed to edit the asset. Otherwise, only the asset up-loader has permission to edit the data.
func update_asset(
	# assetId: float   Eg: 789
	# the ID of the asset to update
	assetId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# albumId: float   Eg: 789
	# the ID of the album to check user permissions
	albumId = null,
	# attachedAssetId: float   Eg: 789
	# the ID of the attached asset
	attachedAssetId = null,
	# versionCode: int   Eg: 56
	# the version code
	versionCode = null,
	# versionName: String = ""   Eg: versionName_example
	# the version name
	versionName = "",
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# caption: String = ""   Eg: caption_example
	# the caption
	caption = "",
	# assetType: String = ""   Eg: assetType_example
	# the asset type
	assetType = "",
	# approvalStatus: String = ""   Eg: approvalStatus_example
	# approval status for the asset
	approvalStatus = "",
	# assignedAccountId: float   Eg: 789
	# account id assigned to the asset
	assignedAccountId = null,
	# media: String   Eg: BINARY_DATA_HERE
	# a MultipartFile containing the mimetype, etc
	media = null,
	# mediaUrl: String = ""   Eg: mediaUrl_example
	# this can be used if the \"media\" is a link (optional)
	mediaUrl = "",
	# mediaString: String = ""   Eg: mediaString_example
	# the media content as a string (optional)
	mediaString = "",
	# mediaStringFileName: String = ""   Eg: mediaStringFileName_example
	# file name for mediaString (optional)
	mediaStringFileName = "",
	# mediaStringContentType: String = ""   Eg: mediaStringContentType_example
	# content type for mediaString (optional)
	mediaStringContentType = "",
	# mediaHeight: int   Eg: 56
	# the media height (optional)
	mediaHeight = null,
	# mediaWidth: int   Eg: 56
	# the media width (optional)
	mediaWidth = null,
	# attachedMedia: String   Eg: BINARY_DATA_HERE
	# a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.
	attachedMedia = null,
	# attachedMediaUrl: String = ""   Eg: attachedMediaUrl_example
	# this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)
	attachedMediaUrl = "",
	# attachedMediaString: String = ""   Eg: attachedMediaString_example
	# attached media content as a string (optional)
	attachedMediaString = "",
	# attachedMediaStringFileName: String = ""   Eg: attachedMediaStringFileName_example
	# file name for attachedMediaString (optional)
	attachedMediaStringFileName = "",
	# attachedMediaStringContentType: String = ""   Eg: attachedMediaStringContentType_example
	# content type for attachedMediaString (optional)
	attachedMediaStringContentType = "",
	# attachedMediaHeight: int   Eg: 56
	# the attached media height (optional)
	attachedMediaHeight = null,
	# attachedMediaWidth: int   Eg: 56
	# the attached media width (optional)
	attachedMediaWidth = null,
	# locationDescription: String = ""   Eg: locationDescription_example
	# the location description
	locationDescription = "",
	# searchTags: String = ""   Eg: searchTags_example
	# search tags
	searchTags = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# latitude: int   Eg: 1.2
	# latitude used to update the asset's location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the asset's location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/asset/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["assetId"] = assetId
	bzz_query["albumId"] = albumId
	bzz_query["attachedAssetId"] = attachedAssetId
	bzz_query["versionCode"] = versionCode
	bzz_query["versionName"] = versionName
	bzz_query["metaData"] = metaData
	bzz_query["caption"] = caption
	bzz_query["assetType"] = assetType
	bzz_query["approvalStatus"] = approvalStatus
	bzz_query["assignedAccountId"] = assignedAccountId
	bzz_query["media"] = media
	bzz_query["mediaUrl"] = mediaUrl
	bzz_query["mediaString"] = mediaString
	bzz_query["mediaStringFileName"] = mediaStringFileName
	bzz_query["mediaStringContentType"] = mediaStringContentType
	bzz_query["mediaHeight"] = mediaHeight
	bzz_query["mediaWidth"] = mediaWidth
	bzz_query["attachedMedia"] = attachedMedia
	bzz_query["attachedMediaUrl"] = attachedMediaUrl
	bzz_query["attachedMediaString"] = attachedMediaString
	bzz_query["attachedMediaStringFileName"] = attachedMediaStringFileName
	bzz_query["attachedMediaStringContentType"] = attachedMediaStringContentType
	bzz_query["attachedMediaHeight"] = attachedMediaHeight
	bzz_query["attachedMediaWidth"] = attachedMediaWidth
	bzz_query["locationDescription"] = locationDescription
	bzz_query["searchTags"] = searchTags
	bzz_query["appKey"] = appKey
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_asset_threaded(
	# assetId: float   Eg: 789
	# the ID of the asset to update
	assetId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# a unique ID given by the device (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account ID of the user (deviceId or accountId required)
	accountId = null,
	# albumId: float   Eg: 789
	# the ID of the album to check user permissions
	albumId = null,
	# attachedAssetId: float   Eg: 789
	# the ID of the attached asset
	attachedAssetId = null,
	# versionCode: int   Eg: 56
	# the version code
	versionCode = null,
	# versionName: String = ""   Eg: versionName_example
	# the version name
	versionName = "",
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# caption: String = ""   Eg: caption_example
	# the caption
	caption = "",
	# assetType: String = ""   Eg: assetType_example
	# the asset type
	assetType = "",
	# approvalStatus: String = ""   Eg: approvalStatus_example
	# approval status for the asset
	approvalStatus = "",
	# assignedAccountId: float   Eg: 789
	# account id assigned to the asset
	assignedAccountId = null,
	# media: String   Eg: BINARY_DATA_HERE
	# a MultipartFile containing the mimetype, etc
	media = null,
	# mediaUrl: String = ""   Eg: mediaUrl_example
	# this can be used if the \"media\" is a link (optional)
	mediaUrl = "",
	# mediaString: String = ""   Eg: mediaString_example
	# the media content as a string (optional)
	mediaString = "",
	# mediaStringFileName: String = ""   Eg: mediaStringFileName_example
	# file name for mediaString (optional)
	mediaStringFileName = "",
	# mediaStringContentType: String = ""   Eg: mediaStringContentType_example
	# content type for mediaString (optional)
	mediaStringContentType = "",
	# mediaHeight: int   Eg: 56
	# the media height (optional)
	mediaHeight = null,
	# mediaWidth: int   Eg: 56
	# the media width (optional)
	mediaWidth = null,
	# attachedMedia: String   Eg: BINARY_DATA_HERE
	# a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.
	attachedMedia = null,
	# attachedMediaUrl: String = ""   Eg: attachedMediaUrl_example
	# this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)
	attachedMediaUrl = "",
	# attachedMediaString: String = ""   Eg: attachedMediaString_example
	# attached media content as a string (optional)
	attachedMediaString = "",
	# attachedMediaStringFileName: String = ""   Eg: attachedMediaStringFileName_example
	# file name for attachedMediaString (optional)
	attachedMediaStringFileName = "",
	# attachedMediaStringContentType: String = ""   Eg: attachedMediaStringContentType_example
	# content type for attachedMediaString (optional)
	attachedMediaStringContentType = "",
	# attachedMediaHeight: int   Eg: 56
	# the attached media height (optional)
	attachedMediaHeight = null,
	# attachedMediaWidth: int   Eg: 56
	# the attached media width (optional)
	attachedMediaWidth = null,
	# locationDescription: String = ""   Eg: locationDescription_example
	# the location description
	locationDescription = "",
	# searchTags: String = ""   Eg: searchTags_example
	# search tags
	searchTags = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# latitude: int   Eg: 1.2
	# latitude used to update the asset's location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the asset's location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_asset")
	bzz_callable.bind(
		assetId,
		deviceId,
		accountId,
		albumId,
		attachedAssetId,
		versionCode,
		versionName,
		metaData,
		caption,
		assetType,
		approvalStatus,
		assignedAccountId,
		media,
		mediaUrl,
		mediaString,
		mediaStringFileName,
		mediaStringContentType,
		mediaHeight,
		mediaWidth,
		attachedMedia,
		attachedMediaUrl,
		attachedMediaString,
		attachedMediaStringFileName,
		attachedMediaStringContentType,
		attachedMediaHeight,
		attachedMediaWidth,
		locationDescription,
		searchTags,
		appKey,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


