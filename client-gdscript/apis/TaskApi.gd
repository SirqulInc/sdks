extends ApiBee
class_name TaskApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API TaskApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "TaskApi"


# Operation createTask → POST /api/{version}/task/create
# Create Task
#
# Create a Task
func create_task(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the task
	name: String,
	# appKey: String = ""   Eg: appKey_example
	# The application to target
	appKey = "",
	# groupingId: String = ""   Eg: groupingId_example
	# Client defined identifier for grouping tasks
	groupingId = "",
	# endpointURL: String = ""   Eg: endpointURL_example
	# The URL for making an HTTP call
	endpointURL = "",
	# payload: String = ""   Eg: payload_example
	# The parameters for making an HTTP call
	payload = "",
	# scheduledDate: float   Eg: 789
	# The date and time of the task
	scheduledDate = null,
	# startDate: float   Eg: 789
	# The starting date of the task
	startDate = null,
	# endDate: float   Eg: 789
	# The ending date of the task
	endDate = null,
	# cronExpression: String = ""   Eg: cronExpression_example
	# The cron expression that represents the task's schedule
	cronExpression = "",
	# visibility: String = ""   Eg: visibility_example
	# The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
	visibility = "",
	# active: bool = true   Eg: true
	# Sets whether the Task is active or not (inactive Tasks are not processed)
	active = true,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/task/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["name"] = name
	bzz_query["appKey"] = appKey
	bzz_query["groupingId"] = groupingId
	bzz_query["endpointURL"] = endpointURL
	bzz_query["payload"] = payload
	bzz_query["scheduledDate"] = scheduledDate
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["cronExpression"] = cronExpression
	bzz_query["visibility"] = visibility
	bzz_query["active"] = active

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = TaskResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_task_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the task
	name: String,
	# appKey: String = ""   Eg: appKey_example
	# The application to target
	appKey = "",
	# groupingId: String = ""   Eg: groupingId_example
	# Client defined identifier for grouping tasks
	groupingId = "",
	# endpointURL: String = ""   Eg: endpointURL_example
	# The URL for making an HTTP call
	endpointURL = "",
	# payload: String = ""   Eg: payload_example
	# The parameters for making an HTTP call
	payload = "",
	# scheduledDate: float   Eg: 789
	# The date and time of the task
	scheduledDate = null,
	# startDate: float   Eg: 789
	# The starting date of the task
	startDate = null,
	# endDate: float   Eg: 789
	# The ending date of the task
	endDate = null,
	# cronExpression: String = ""   Eg: cronExpression_example
	# The cron expression that represents the task's schedule
	cronExpression = "",
	# visibility: String = ""   Eg: visibility_example
	# The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
	visibility = "",
	# active: bool = true   Eg: true
	# Sets whether the Task is active or not (inactive Tasks are not processed)
	active = true,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_task")
	bzz_callable.bind(
		version,
		accountId,
		name,
		appKey,
		groupingId,
		endpointURL,
		payload,
		scheduledDate,
		startDate,
		endDate,
		cronExpression,
		visibility,
		active,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteTask → POST /api/{version}/task/delete
# Delete Task
#
# Delete a Task
func delete_task(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# taskId: float   Eg: 789
	# The id of the Task to delete.
	taskId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/task/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["taskId"] = taskId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_task_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# taskId: float   Eg: 789
	# The id of the Task to delete.
	taskId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_task")
	bzz_callable.bind(
		version,
		accountId,
		taskId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getTask → GET /api/{version}/task/get
# Get Task
#
# Get a Task
func get_task(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# taskId: float   Eg: 789
	# The id of the Task to return.
	taskId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/task/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["taskId"] = taskId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = TaskResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_task_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# taskId: float   Eg: 789
	# The id of the Task to return.
	taskId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_task")
	bzz_callable.bind(
		version,
		accountId,
		taskId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchTasks → GET /api/{version}/task/search
# Search Tasks
#
# Search on Tasks
func search_tasks(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# groupingId: String = ""   Eg: groupingId_example
	# Filter results by a grouping identifier defined by the client
	groupingId = "",
	# filter: String = "MINE"   Eg: filter_example
	# A comma separated list of filters:  * MINE - Return tasks that the user has created * SHARED - Return tasks that have been shared to the user * FOLLOWER - Return tasks that have been created by the user''s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return tasks that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC tasks that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC tasks regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all tasks that the user has liked * FEATURED - Return all tasks that have been featured * PENDING - Return all pending tasks 
	filter = "MINE",
	# statuses: String = "NEW,ERROR,COMPLETE,PROCESSING"   Eg: statuses_example
	# Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE
	statuses = "NEW,ERROR,COMPLETE,PROCESSING",
	# templateTypes: String = ""   Eg: templateTypes_example
	# Template Types
	templateTypes = "",
	# appKey: String = ""   Eg: appKey_example
	# Filter the list by a specific application
	appKey = "",
	# keyword: String = ""   Eg: keyword_example
	# Keyword search on the task names.
	keyword = "",
	# sortField: String = "CREATED"   Eg: sortField_example
	# The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE
	sortField = "CREATED",
	# descending: bool = true   Eg: true
	# Determines whether the sorted list is in descending or ascending order
	descending = true,
	# start: int = 0   Eg: 56
	# Start the result set at some index.
	start = 0,
	# limit: int = 20   Eg: 56
	# Limit the result to some number.
	limit = 20,
	# activeOnly: bool = true   Eg: true
	# Determines whether to return only active results
	activeOnly = true,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/task/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["groupingId"] = groupingId
	bzz_query["filter"] = filter
	bzz_query["statuses"] = statuses
	bzz_query["templateTypes"] = templateTypes
	bzz_query["appKey"] = appKey
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["activeOnly"] = activeOnly

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = TaskResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_tasks_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# groupingId: String = ""   Eg: groupingId_example
	# Filter results by a grouping identifier defined by the client
	groupingId = "",
	# filter: String = "MINE"   Eg: filter_example
	# A comma separated list of filters:  * MINE - Return tasks that the user has created * SHARED - Return tasks that have been shared to the user * FOLLOWER - Return tasks that have been created by the user''s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return tasks that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC tasks that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC tasks regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all tasks that the user has liked * FEATURED - Return all tasks that have been featured * PENDING - Return all pending tasks 
	filter = "MINE",
	# statuses: String = "NEW,ERROR,COMPLETE,PROCESSING"   Eg: statuses_example
	# Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE
	statuses = "NEW,ERROR,COMPLETE,PROCESSING",
	# templateTypes: String = ""   Eg: templateTypes_example
	# Template Types
	templateTypes = "",
	# appKey: String = ""   Eg: appKey_example
	# Filter the list by a specific application
	appKey = "",
	# keyword: String = ""   Eg: keyword_example
	# Keyword search on the task names.
	keyword = "",
	# sortField: String = "CREATED"   Eg: sortField_example
	# The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE
	sortField = "CREATED",
	# descending: bool = true   Eg: true
	# Determines whether the sorted list is in descending or ascending order
	descending = true,
	# start: int = 0   Eg: 56
	# Start the result set at some index.
	start = 0,
	# limit: int = 20   Eg: 56
	# Limit the result to some number.
	limit = 20,
	# activeOnly: bool = true   Eg: true
	# Determines whether to return only active results
	activeOnly = true,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_tasks")
	bzz_callable.bind(
		version,
		accountId,
		groupingId,
		filter,
		statuses,
		templateTypes,
		appKey,
		keyword,
		sortField,
		descending,
		start,
		limit,
		activeOnly,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateTask → POST /api/{version}/task/update
# Update Task
#
# Update a Task
func update_task(
	# version: float   Eg: 3.16
	version: float,
	# taskId: float   Eg: 789
	# Task Id
	taskId: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the task
	name = "",
	# appKey: String = ""   Eg: appKey_example
	# The application to target
	appKey = "",
	# groupingId: String = ""   Eg: groupingId_example
	# Client defined identifier for grouping tasks
	groupingId = "",
	# endpointURL: String = ""   Eg: endpointURL_example
	# The URL for making an HTTP call
	endpointURL = "",
	# payload: String = ""   Eg: payload_example
	# The parameters for making an HTTP call
	payload = "",
	# scheduledDate: float   Eg: 789
	# The date and time of the task
	scheduledDate = null,
	# startDate: float   Eg: 789
	# The starting date of the task
	startDate = null,
	# endDate: float   Eg: 789
	# The ending date of the task
	endDate = null,
	# cronExpression: String = ""   Eg: cronExpression_example
	# The cron expression that represents the task's schedule
	cronExpression = "",
	# visibility: String = ""   Eg: visibility_example
	# The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
	visibility = "",
	# active: bool   Eg: true
	# Sets whether the Task is active or not (inactive Tasks are not processed)
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/task/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["taskId"] = taskId
	bzz_query["accountId"] = accountId
	bzz_query["name"] = name
	bzz_query["appKey"] = appKey
	bzz_query["groupingId"] = groupingId
	bzz_query["endpointURL"] = endpointURL
	bzz_query["payload"] = payload
	bzz_query["scheduledDate"] = scheduledDate
	bzz_query["startDate"] = startDate
	bzz_query["endDate"] = endDate
	bzz_query["cronExpression"] = cronExpression
	bzz_query["visibility"] = visibility
	bzz_query["active"] = active

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = TaskResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_task_threaded(
	# version: float   Eg: 3.16
	version: float,
	# taskId: float   Eg: 789
	# Task Id
	taskId: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the task
	name = "",
	# appKey: String = ""   Eg: appKey_example
	# The application to target
	appKey = "",
	# groupingId: String = ""   Eg: groupingId_example
	# Client defined identifier for grouping tasks
	groupingId = "",
	# endpointURL: String = ""   Eg: endpointURL_example
	# The URL for making an HTTP call
	endpointURL = "",
	# payload: String = ""   Eg: payload_example
	# The parameters for making an HTTP call
	payload = "",
	# scheduledDate: float   Eg: 789
	# The date and time of the task
	scheduledDate = null,
	# startDate: float   Eg: 789
	# The starting date of the task
	startDate = null,
	# endDate: float   Eg: 789
	# The ending date of the task
	endDate = null,
	# cronExpression: String = ""   Eg: cronExpression_example
	# The cron expression that represents the task's schedule
	cronExpression = "",
	# visibility: String = ""   Eg: visibility_example
	# The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
	visibility = "",
	# active: bool   Eg: true
	# Sets whether the Task is active or not (inactive Tasks are not processed)
	active = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_task")
	bzz_callable.bind(
		version,
		taskId,
		accountId,
		name,
		appKey,
		groupingId,
		endpointURL,
		payload,
		scheduledDate,
		startDate,
		endDate,
		cronExpression,
		visibility,
		active,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


