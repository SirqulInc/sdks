extends ApiBee
class_name NotificationApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API NotificationApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "NotificationApi"


# Operation createNotificationTemplate → POST /api/{version}/notification/template/create
# Create Notification Template
#
# Create a notification template. Developers will only be able to create notification templates for their own applications.
func create_notification_template(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account ID of the user.
	accountId: float,
	# conduit: String = ""   Eg: conduit_example
	# Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
	conduit: String,
	# title: String = ""   Eg: title_example
	# title of the notification template
	title: String,
	# body: String = ""   Eg: body_example
	# body of the notification template
	body: String,
	# appKey: String = ""   Eg: appKey_example
	# Filter results by application.
	appKey = "",
	# event: String = ""   Eg: event_example
	# Filter results by event.
	event = "",
	# tags: String = ""   Eg: tags_example
	# tags associated with the note template
	tags = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/template/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["event"] = event
	bzz_query["conduit"] = conduit
	bzz_query["title"] = title
	bzz_query["body"] = body
	bzz_query["tags"] = tags

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = NotificationTemplateResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_notification_template_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account ID of the user.
	accountId: float,
	# conduit: String = ""   Eg: conduit_example
	# Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
	conduit: String,
	# title: String = ""   Eg: title_example
	# title of the notification template
	title: String,
	# body: String = ""   Eg: body_example
	# body of the notification template
	body: String,
	# appKey: String = ""   Eg: appKey_example
	# Filter results by application.
	appKey = "",
	# event: String = ""   Eg: event_example
	# Filter results by event.
	event = "",
	# tags: String = ""   Eg: tags_example
	# tags associated with the note template
	tags = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_notification_template")
	bzz_callable.bind(
		version,
		accountId,
		conduit,
		title,
		body,
		appKey,
		event,
		tags,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createOrUpdateBlockedNotifications → POST /api/{version}/notification/blocked/batch
# Create or update blocked notification settings
#
# Create or update blocked notification settings
func create_or_update_blocked_notifications(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key
	appKey: String,
	# data: String = ""   Eg: data_example
	# batch data payload (application specific)
	data: String,
	# accountId: float   Eg: 789
	# the account id of the user
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/blocked/batch".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["data"] = data

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = BlockedNotificationResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_or_update_blocked_notifications_threaded(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key
	appKey: String,
	# data: String = ""   Eg: data_example
	# batch data payload (application specific)
	data: String,
	# accountId: float   Eg: 789
	# the account id of the user
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_or_update_blocked_notifications")
	bzz_callable.bind(
		version,
		appKey,
		data,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteNotificationTemplate → POST /api/{version}/notification/template/delete
# Delete Notification Template
#
# Deletes a notification template. Developers will only be able to delete notification templates for their own applications.
func delete_notification_template(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the account id of the user
	accountId: float,
	# notificationTemplateId: float   Eg: 789
	# the id of the notification template to delete
	notificationTemplateId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/template/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["notificationTemplateId"] = notificationTemplateId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = NotificationTemplateResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_notification_template_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the account id of the user
	accountId: float,
	# notificationTemplateId: float   Eg: 789
	# the id of the notification template to delete
	notificationTemplateId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_notification_template")
	bzz_callable.bind(
		version,
		accountId,
		notificationTemplateId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getNotificationTemplate → GET /api/{version}/notification/template/get
# Get Notification Template
#
# Get the details of a notification template. Developers will only be able to see notification templates for their own applications.
func get_notification_template(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the id of the account
	accountId: float,
	# notificationTemplateId: float   Eg: 789
	# the id of the notification template to get
	notificationTemplateId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/template/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["notificationTemplateId"] = notificationTemplateId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = NotificationTemplateResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_notification_template_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# the id of the account
	accountId: float,
	# notificationTemplateId: float   Eg: 789
	# the id of the notification template to get
	notificationTemplateId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_notification_template")
	bzz_callable.bind(
		version,
		accountId,
		notificationTemplateId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getNotifications → GET /api/{version}/notification/search
# Get Notifications
#
# Get a list of notifications for a user. If the \"markAsRead\" parameter is set to true, the returned notifications will be marked as \"read\" after the response has been sent. By default, read messages will not be returned, so to see read messages, set \"returnReadMessages\" to true.
func get_notifications(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# connectionAccountId: float   Eg: 789
	# the account id used to view another person's notifications
	connectionAccountId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key to filter messages by application
	appKey = "",
	# eventType: String = ""   Eg: eventType_example
	# comma separated list of EVENTS. Filters search results to only include these events. Don't include this parameter or pass in an empty string to return all event types.
	eventType = "",
	# contentIds: String = ""   Eg: contentIds_example
	# comma separated list of content ids to search notifications on
	contentIds = "",
	# contentTypes: String = ""   Eg: contentTypes_example
	# comma separated list of content types to search notifications on
	contentTypes = "",
	# parentIds: String = ""   Eg: parentIds_example
	# comma separated list of parent ids to search notifications on
	parentIds = "",
	# parentTypes: String = ""   Eg: parentTypes_example
	# comma separated list of parent types to search notifications on
	parentTypes = "",
	# actionCategory: String = ""   Eg: actionCategory_example
	# Action category used to filter notifications
	actionCategory = "",
	# conduits: String = ""   Eg: conduits_example
	# comma separated list of conduits to search notifications on
	conduits = "",
	# keyword: String = ""   Eg: keyword_example
	# search notifications via keyword
	keyword = "",
	# returnReadMessages: bool   Eg: true
	# if set to true, will return notifications that have been marked as read
	returnReadMessages = null,
	# markAsRead: bool   Eg: true
	# if set to true, the returned notifications will be marked as \\\"read\\\" after the response has been sent
	markAsRead = null,
	# fromDate: float   Eg: 789
	# filter notifications from this date
	fromDate = null,
	# latitude: int   Eg: 1.2
	# latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the user's current location
	longitude = null,
	# returnSent: bool   Eg: true
	# whether to include notifications sent by the requester in the response
	returnSent = null,
	# ignoreFlagged: bool   Eg: true
	# whether to ignore flagged notifications
	ignoreFlagged = null,
	# start: int   Eg: 56
	# start of the pagination
	start = null,
	# limit: int   Eg: 56
	# limit of the pagination
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["connectionAccountId"] = connectionAccountId
	bzz_query["appKey"] = appKey
	bzz_query["eventType"] = eventType
	bzz_query["contentIds"] = contentIds
	bzz_query["contentTypes"] = contentTypes
	bzz_query["parentIds"] = parentIds
	bzz_query["parentTypes"] = parentTypes
	bzz_query["actionCategory"] = actionCategory
	bzz_query["conduits"] = conduits
	bzz_query["keyword"] = keyword
	bzz_query["returnReadMessages"] = returnReadMessages
	bzz_query["markAsRead"] = markAsRead
	bzz_query["fromDate"] = fromDate
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["returnSent"] = returnSent
	bzz_query["ignoreFlagged"] = ignoreFlagged
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = NotificationMessageListResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_notifications_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# connectionAccountId: float   Eg: 789
	# the account id used to view another person's notifications
	connectionAccountId = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key to filter messages by application
	appKey = "",
	# eventType: String = ""   Eg: eventType_example
	# comma separated list of EVENTS. Filters search results to only include these events. Don't include this parameter or pass in an empty string to return all event types.
	eventType = "",
	# contentIds: String = ""   Eg: contentIds_example
	# comma separated list of content ids to search notifications on
	contentIds = "",
	# contentTypes: String = ""   Eg: contentTypes_example
	# comma separated list of content types to search notifications on
	contentTypes = "",
	# parentIds: String = ""   Eg: parentIds_example
	# comma separated list of parent ids to search notifications on
	parentIds = "",
	# parentTypes: String = ""   Eg: parentTypes_example
	# comma separated list of parent types to search notifications on
	parentTypes = "",
	# actionCategory: String = ""   Eg: actionCategory_example
	# Action category used to filter notifications
	actionCategory = "",
	# conduits: String = ""   Eg: conduits_example
	# comma separated list of conduits to search notifications on
	conduits = "",
	# keyword: String = ""   Eg: keyword_example
	# search notifications via keyword
	keyword = "",
	# returnReadMessages: bool   Eg: true
	# if set to true, will return notifications that have been marked as read
	returnReadMessages = null,
	# markAsRead: bool   Eg: true
	# if set to true, the returned notifications will be marked as \\\"read\\\" after the response has been sent
	markAsRead = null,
	# fromDate: float   Eg: 789
	# filter notifications from this date
	fromDate = null,
	# latitude: int   Eg: 1.2
	# latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the user's current location
	longitude = null,
	# returnSent: bool   Eg: true
	# whether to include notifications sent by the requester in the response
	returnSent = null,
	# ignoreFlagged: bool   Eg: true
	# whether to ignore flagged notifications
	ignoreFlagged = null,
	# start: int   Eg: 56
	# start of the pagination
	start = null,
	# limit: int   Eg: 56
	# limit of the pagination
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_notifications")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		connectionAccountId,
		appKey,
		eventType,
		contentIds,
		contentTypes,
		parentIds,
		parentTypes,
		actionCategory,
		conduits,
		keyword,
		returnReadMessages,
		markAsRead,
		fromDate,
		latitude,
		longitude,
		returnSent,
		ignoreFlagged,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation registerNotificationToken → POST /api/{version}/notification/token
# Register Notification Token
#
# Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.
func register_notification_token(
	# version: float   Eg: 3.16
	version: float,
	# token: String = ""   Eg: token_example
	# A token that is generated by the device to sign requests for the notification service providers
	token: String,
	# pushType: String = ""   Eg: pushType_example
	# The type of push notification. Possible values include: APNS, GCM
	pushType: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# some_environment: String = ""   Eg: some_environment_example
	# Determines if the token is a DEVELOPMENT or PRODUCTION token
	some_environment = "",
	# appKey: String = ""   Eg: appKey_example
	# The application key
	appKey = "",
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated (use appKey instead)
	gameType = "",
	# active: bool   Eg: true
	# Sets whether the token is active or not (non-active tokens are not used)
	active = null,
	# latitude: int   Eg: 1.2
	# Latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# Longitude used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/token".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["token"] = token
	bzz_query["pushType"] = pushType
	bzz_query["environment"] = some_environment
	bzz_query["appKey"] = appKey
	bzz_query["gameType"] = gameType
	bzz_query["active"] = active
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func register_notification_token_threaded(
	# version: float   Eg: 3.16
	version: float,
	# token: String = ""   Eg: token_example
	# A token that is generated by the device to sign requests for the notification service providers
	token: String,
	# pushType: String = ""   Eg: pushType_example
	# The type of push notification. Possible values include: APNS, GCM
	pushType: String,
	# deviceId: String = ""   Eg: deviceId_example
	# The unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# The account id of the user (deviceId or accountId required)
	accountId = null,
	# some_environment: String = ""   Eg: some_environment_example
	# Determines if the token is a DEVELOPMENT or PRODUCTION token
	some_environment = "",
	# appKey: String = ""   Eg: appKey_example
	# The application key
	appKey = "",
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated (use appKey instead)
	gameType = "",
	# active: bool   Eg: true
	# Sets whether the token is active or not (non-active tokens are not used)
	active = null,
	# latitude: int   Eg: 1.2
	# Latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# Longitude used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "register_notification_token")
	bzz_callable.bind(
		version,
		token,
		pushType,
		deviceId,
		accountId,
		some_environment,
		appKey,
		gameType,
		active,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchBlockedNotifications → GET /api/{version}/notification/blocked/search
# Search on the user's blocked notification settings
#
# Search on the user's blocked notification settings
func search_blocked_notifications(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key
	appKey: String,
	# accountId: float   Eg: 789
	# the account id of the user
	accountId = null,
	# searchTags: String = ""   Eg: searchTags_example
	# search tags to filter results
	searchTags = "",
	# events: String = ""   Eg: events_example
	# events to filter by (comma separated)
	events = "",
	# conduits: String = ""   Eg: conduits_example
	# conduits to filter by (comma separated)
	conduits = "",
	# customTypes: String = ""   Eg: customTypes_example
	# custom types to filter by (comma separated)
	customTypes = "",
	# contentTypes: String = ""   Eg: contentTypes_example
	# content types to filter by (comma separated)
	contentTypes = "",
	# contentIds: String = ""   Eg: contentIds_example
	# content ids to filter by (comma separated)
	contentIds = "",
	# sortField: String = ""   Eg: sortField_example
	# sort field for results
	sortField = "",
	# descending: bool   Eg: true
	# whether to sort descending
	descending = null,
	# start: int   Eg: 56
	# start of the pagination
	start = null,
	# limit: int   Eg: 56
	# limit of the pagination
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/blocked/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["searchTags"] = searchTags
	bzz_query["events"] = events
	bzz_query["conduits"] = conduits
	bzz_query["customTypes"] = customTypes
	bzz_query["contentTypes"] = contentTypes
	bzz_query["contentIds"] = contentIds
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = BlockedNotificationResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_blocked_notifications_threaded(
	# version: float   Eg: 3.16
	version: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key
	appKey: String,
	# accountId: float   Eg: 789
	# the account id of the user
	accountId = null,
	# searchTags: String = ""   Eg: searchTags_example
	# search tags to filter results
	searchTags = "",
	# events: String = ""   Eg: events_example
	# events to filter by (comma separated)
	events = "",
	# conduits: String = ""   Eg: conduits_example
	# conduits to filter by (comma separated)
	conduits = "",
	# customTypes: String = ""   Eg: customTypes_example
	# custom types to filter by (comma separated)
	customTypes = "",
	# contentTypes: String = ""   Eg: contentTypes_example
	# content types to filter by (comma separated)
	contentTypes = "",
	# contentIds: String = ""   Eg: contentIds_example
	# content ids to filter by (comma separated)
	contentIds = "",
	# sortField: String = ""   Eg: sortField_example
	# sort field for results
	sortField = "",
	# descending: bool   Eg: true
	# whether to sort descending
	descending = null,
	# start: int   Eg: 56
	# start of the pagination
	start = null,
	# limit: int   Eg: 56
	# limit of the pagination
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_blocked_notifications")
	bzz_callable.bind(
		version,
		appKey,
		accountId,
		searchTags,
		events,
		conduits,
		customTypes,
		contentTypes,
		contentIds,
		sortField,
		descending,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchNotificationTemplate → GET /api/{version}/notification/template/search
# Search Notification Templates
#
# Search for notification templates on owned applications.
func search_notification_template(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account ID of the user.
	accountId: float,
	# sortField: String = ""   Eg: sortField_example
	# Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name ('global' templates will not have an application and will be returned last if 'descending' is set to false.
	sortField: String,
	# descending: bool   Eg: true
	# Specified whether the results are returned in descending or ascending order.
	descending: bool,
	# start: int   Eg: 56
	# The start of the pagination.
	start: int,
	# limit: int   Eg: 56
	# The limit of the pagination.
	limit: int,
	# appKey: String = ""   Eg: appKey_example
	# Filter results by application.
	appKey = "",
	# event: String = ""   Eg: event_example
	# Filter results by event.
	event = "",
	# conduit: String = ""   Eg: conduit_example
	# Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
	conduit = "",
	# globalOnly: bool   Eg: true
	# Returns only templates that have been reserved for system use on all applications (only for admin accounts).
	globalOnly = null,
	# reservedOnly: bool   Eg: true
	# Returns only templates that use reserved events.
	reservedOnly = null,
	# keyword: String = ""   Eg: keyword_example
	# Filter results by keyword on the title, tags.
	keyword = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/template/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["event"] = event
	bzz_query["conduit"] = conduit
	bzz_query["globalOnly"] = globalOnly
	bzz_query["reservedOnly"] = reservedOnly
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = NotificationTemplateResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_notification_template_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account ID of the user.
	accountId: float,
	# sortField: String = ""   Eg: sortField_example
	# Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name ('global' templates will not have an application and will be returned last if 'descending' is set to false.
	sortField: String,
	# descending: bool   Eg: true
	# Specified whether the results are returned in descending or ascending order.
	descending: bool,
	# start: int   Eg: 56
	# The start of the pagination.
	start: int,
	# limit: int   Eg: 56
	# The limit of the pagination.
	limit: int,
	# appKey: String = ""   Eg: appKey_example
	# Filter results by application.
	appKey = "",
	# event: String = ""   Eg: event_example
	# Filter results by event.
	event = "",
	# conduit: String = ""   Eg: conduit_example
	# Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
	conduit = "",
	# globalOnly: bool   Eg: true
	# Returns only templates that have been reserved for system use on all applications (only for admin accounts).
	globalOnly = null,
	# reservedOnly: bool   Eg: true
	# Returns only templates that use reserved events.
	reservedOnly = null,
	# keyword: String = ""   Eg: keyword_example
	# Filter results by keyword on the title, tags.
	keyword = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_notification_template")
	bzz_callable.bind(
		version,
		accountId,
		sortField,
		descending,
		start,
		limit,
		appKey,
		event,
		conduit,
		globalOnly,
		reservedOnly,
		keyword,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchRecipients → GET /api/{version}/notification/recipient/search
# Search for Recipients
#
# Search for application users to send notifications.
func search_recipients(
	# version: float   Eg: 3.16
	version: float,
	# sortField: String = ""   Eg: sortField_example
	# The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}
	sortField: String,
	# deviceId: String = ""   Eg: deviceId_example
	# the unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
	appKey = "",
	# conduit: String = ""   Eg: conduit_example
	# the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
	conduit = "",
	# keyword: String = ""   Eg: keyword_example
	# search by keyword on user's display name and email
	keyword = "",
	# audienceId: float   Eg: 789
	# This parameter is deprecated. filter results by audience
	audienceId = null,
	# audienceIds: String = ""   Eg: audienceIds_example
	# filter results by audiences (comma separated list of audience ids)
	audienceIds = "",
	# connectionGroupIds: String = ""   Eg: connectionGroupIds_example
	# filter results by connection groups (comma separated list of connection group ids)
	connectionGroupIds = "",
	# recipientAccountIds: String = ""   Eg: recipientAccountIds_example
	# filter results by accounts (comma separated list of account ids)
	recipientAccountIds = "",
	# descending: bool   Eg: true
	# Determines whether the sorted list is in descending or ascending order
	descending = null,
	# start: int   Eg: 56
	# start of the pagination
	start = null,
	# limit: int   Eg: 56
	# limit of the pagination (hard limit of 1000)
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/recipient/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["conduit"] = conduit
	bzz_query["keyword"] = keyword
	bzz_query["audienceId"] = audienceId
	bzz_query["audienceIds"] = audienceIds
	bzz_query["connectionGroupIds"] = connectionGroupIds
	bzz_query["recipientAccountIds"] = recipientAccountIds
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = NotificationRecipientResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_recipients_threaded(
	# version: float   Eg: 3.16
	version: float,
	# sortField: String = ""   Eg: sortField_example
	# The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}
	sortField: String,
	# deviceId: String = ""   Eg: deviceId_example
	# the unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
	appKey = "",
	# conduit: String = ""   Eg: conduit_example
	# the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
	conduit = "",
	# keyword: String = ""   Eg: keyword_example
	# search by keyword on user's display name and email
	keyword = "",
	# audienceId: float   Eg: 789
	# This parameter is deprecated. filter results by audience
	audienceId = null,
	# audienceIds: String = ""   Eg: audienceIds_example
	# filter results by audiences (comma separated list of audience ids)
	audienceIds = "",
	# connectionGroupIds: String = ""   Eg: connectionGroupIds_example
	# filter results by connection groups (comma separated list of connection group ids)
	connectionGroupIds = "",
	# recipientAccountIds: String = ""   Eg: recipientAccountIds_example
	# filter results by accounts (comma separated list of account ids)
	recipientAccountIds = "",
	# descending: bool   Eg: true
	# Determines whether the sorted list is in descending or ascending order
	descending = null,
	# start: int   Eg: 56
	# start of the pagination
	start = null,
	# limit: int   Eg: 56
	# limit of the pagination (hard limit of 1000)
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_recipients")
	bzz_callable.bind(
		version,
		sortField,
		deviceId,
		accountId,
		appKey,
		conduit,
		keyword,
		audienceId,
		audienceIds,
		connectionGroupIds,
		recipientAccountIds,
		descending,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchRecipientsCount → GET /api/{version}/notification/recipient/search/count
# Search for Recipients (Counts/Grouped)
#
# Search for application users to send notifications (count/grouped variant).
func search_recipients_count(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
	appKey = "",
	# conduit: String = ""   Eg: conduit_example
	# the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
	conduit = "",
	# keyword: String = ""   Eg: keyword_example
	# search by keyword on user's display name and email
	keyword = "",
	# audienceId: float   Eg: 789
	# This parameter is deprecated. filter results by audience
	audienceId = null,
	# audienceIds: String = ""   Eg: audienceIds_example
	# filter results by audiences (comma separated list of audience ids)
	audienceIds = "",
	# connectionGroupIds: String = ""   Eg: connectionGroupIds_example
	# filter results by connection groups (comma separated list of connection group ids)
	connectionGroupIds = "",
	# sortField: String = ""   Eg: sortField_example
	# The field to sort by (see API docs for allowed values).
	sortField = "",
	# descending: bool   Eg: true
	# Determines whether the sorted list is in descending or ascending order
	descending = null,
	# start: int   Eg: 56
	# start of the pagination
	start = null,
	# limit: int   Eg: 56
	# limit of the pagination
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/recipient/search/count".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["conduit"] = conduit
	bzz_query["keyword"] = keyword
	bzz_query["audienceId"] = audienceId
	bzz_query["audienceIds"] = audienceIds
	bzz_query["connectionGroupIds"] = connectionGroupIds
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = NotificationRecipientResponseListResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_recipients_count_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# appKey: String = ""   Eg: appKey_example
	# filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
	appKey = "",
	# conduit: String = ""   Eg: conduit_example
	# the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
	conduit = "",
	# keyword: String = ""   Eg: keyword_example
	# search by keyword on user's display name and email
	keyword = "",
	# audienceId: float   Eg: 789
	# This parameter is deprecated. filter results by audience
	audienceId = null,
	# audienceIds: String = ""   Eg: audienceIds_example
	# filter results by audiences (comma separated list of audience ids)
	audienceIds = "",
	# connectionGroupIds: String = ""   Eg: connectionGroupIds_example
	# filter results by connection groups (comma separated list of connection group ids)
	connectionGroupIds = "",
	# sortField: String = ""   Eg: sortField_example
	# The field to sort by (see API docs for allowed values).
	sortField = "",
	# descending: bool   Eg: true
	# Determines whether the sorted list is in descending or ascending order
	descending = null,
	# start: int   Eg: 56
	# start of the pagination
	start = null,
	# limit: int   Eg: 56
	# limit of the pagination
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_recipients_count")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		appKey,
		conduit,
		keyword,
		audienceId,
		audienceIds,
		connectionGroupIds,
		sortField,
		descending,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation sendBatchNotifications → POST /api/{version}/notification/batch
# Send Batch Notifications
#
# Send notifications to all users of an application. Only someone with permissions to the application can do this.
func send_batch_notifications(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the application owner/manager
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key for updating an existing application
	appKey: String,
	# customMessage: String = ""   Eg: customMessage_example
	# Message string that will be displayed in on the notification
	customMessage: String,
	# conduit: String = ""   Eg: conduit_example
	# The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
	conduit = "",
	# contentId: float   Eg: 789
	# Default notification pay-load field (usage is dependent on the app and the type of event)
	contentId = null,
	# contentName: String = ""   Eg: contentName_example
	# Default notification pay-load field (usage is dependent on the app and the type of event)
	contentName = "",
	# contentType: String = ""   Eg: contentType_example
	# Default notification pay-load field (usage is dependent on the app and the type of event)
	contentType = "",
	# parentId: float   Eg: 789
	# Default notification pay-load field (usage is dependent on the app and the type of event)
	parentId = null,
	# parentType: String = ""   Eg: parentType_example
	# Default notification pay-load field (usage is dependent on the app and the type of event)
	parentType = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/batch".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["conduit"] = conduit
	bzz_query["customMessage"] = customMessage
	bzz_query["contentId"] = contentId
	bzz_query["contentName"] = contentName
	bzz_query["contentType"] = contentType
	bzz_query["parentId"] = parentId
	bzz_query["parentType"] = parentType

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func send_batch_notifications_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the application owner/manager
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key for updating an existing application
	appKey: String,
	# customMessage: String = ""   Eg: customMessage_example
	# Message string that will be displayed in on the notification
	customMessage: String,
	# conduit: String = ""   Eg: conduit_example
	# The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
	conduit = "",
	# contentId: float   Eg: 789
	# Default notification pay-load field (usage is dependent on the app and the type of event)
	contentId = null,
	# contentName: String = ""   Eg: contentName_example
	# Default notification pay-load field (usage is dependent on the app and the type of event)
	contentName = "",
	# contentType: String = ""   Eg: contentType_example
	# Default notification pay-load field (usage is dependent on the app and the type of event)
	contentType = "",
	# parentId: float   Eg: 789
	# Default notification pay-load field (usage is dependent on the app and the type of event)
	parentId = null,
	# parentType: String = ""   Eg: parentType_example
	# Default notification pay-load field (usage is dependent on the app and the type of event)
	parentType = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "send_batch_notifications")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		customMessage,
		conduit,
		contentId,
		contentName,
		contentType,
		parentId,
		parentType,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation sendCustomNotifications → POST /api/{version}/notification/custom
# Send Custom Notifications
#
# Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.
func send_custom_notifications(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# receiverAccountIds: String = ""   Eg: receiverAccountIds_example
	# comma separated list of account IDs that will receive the notification
	receiverAccountIds = "",
	# includeFriendGroup: bool   Eg: true
	# determines whether to send to all of the user's friends, this flag must be true or receiverAccountIds must not be empty
	includeFriendGroup = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# conduit: String = ""   Eg: conduit_example
	# the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
	conduit = "",
	# contentId: float   Eg: 789
	# default notification pay-load field (usage is dependent on the app and the type of event)
	contentId = null,
	# contentName: String = ""   Eg: contentName_example
	# default notification pay-load field (usage is dependent on the app and the type of event)
	contentName = "",
	# contentType: String = ""   Eg: contentType_example
	# default notification pay-load field (usage is dependent on the app and the type of event)
	contentType = "",
	# parentId: float   Eg: 789
	# default notification pay-load field (usage is dependent on the app and the type of event)
	parentId = null,
	# parentType: String = ""   Eg: parentType_example
	# default notification pay-load field (usage is dependent on the app and the type of event)
	parentType = "",
	# actionCategory: String = ""   Eg: actionCategory_example
	actionCategory = "",
	# subject: String = ""   Eg: subject_example
	# the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)
	subject = "",
	# customMessage: String = ""   Eg: customMessage_example
	# message string that will be displayed in on the notification
	customMessage = "",
	# friendOnlyAPNS: bool   Eg: true
	# only sends APNS to people who are friends of the user (still saves the notification message for feed polling)
	friendOnlyAPNS = null,
	# latitude: int   Eg: 1.2
	# latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/custom".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["receiverAccountIds"] = receiverAccountIds
	bzz_query["includeFriendGroup"] = includeFriendGroup
	bzz_query["appKey"] = appKey
	bzz_query["gameType"] = gameType
	bzz_query["conduit"] = conduit
	bzz_query["contentId"] = contentId
	bzz_query["contentName"] = contentName
	bzz_query["contentType"] = contentType
	bzz_query["parentId"] = parentId
	bzz_query["parentType"] = parentType
	bzz_query["actionCategory"] = actionCategory
	bzz_query["subject"] = subject
	bzz_query["customMessage"] = customMessage
	bzz_query["friendOnlyAPNS"] = friendOnlyAPNS
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func send_custom_notifications_threaded(
	# version: float   Eg: 3.16
	version: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the unique id of the device making the request (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# receiverAccountIds: String = ""   Eg: receiverAccountIds_example
	# comma separated list of account IDs that will receive the notification
	receiverAccountIds = "",
	# includeFriendGroup: bool   Eg: true
	# determines whether to send to all of the user's friends, this flag must be true or receiverAccountIds must not be empty
	includeFriendGroup = null,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# conduit: String = ""   Eg: conduit_example
	# the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
	conduit = "",
	# contentId: float   Eg: 789
	# default notification pay-load field (usage is dependent on the app and the type of event)
	contentId = null,
	# contentName: String = ""   Eg: contentName_example
	# default notification pay-load field (usage is dependent on the app and the type of event)
	contentName = "",
	# contentType: String = ""   Eg: contentType_example
	# default notification pay-load field (usage is dependent on the app and the type of event)
	contentType = "",
	# parentId: float   Eg: 789
	# default notification pay-load field (usage is dependent on the app and the type of event)
	parentId = null,
	# parentType: String = ""   Eg: parentType_example
	# default notification pay-load field (usage is dependent on the app and the type of event)
	parentType = "",
	# actionCategory: String = ""   Eg: actionCategory_example
	actionCategory = "",
	# subject: String = ""   Eg: subject_example
	# the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)
	subject = "",
	# customMessage: String = ""   Eg: customMessage_example
	# message string that will be displayed in on the notification
	customMessage = "",
	# friendOnlyAPNS: bool   Eg: true
	# only sends APNS to people who are friends of the user (still saves the notification message for feed polling)
	friendOnlyAPNS = null,
	# latitude: int   Eg: 1.2
	# latitude used to update the user's current location
	latitude = null,
	# longitude: int   Eg: 1.2
	# longitude used to update the user's current location
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "send_custom_notifications")
	bzz_callable.bind(
		version,
		deviceId,
		accountId,
		receiverAccountIds,
		includeFriendGroup,
		appKey,
		gameType,
		conduit,
		contentId,
		contentName,
		contentType,
		parentId,
		parentType,
		actionCategory,
		subject,
		customMessage,
		friendOnlyAPNS,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateNotificationTemplate → POST /api/{version}/notification/template/update
# Update Notification Template
#
# Update a notification template. Developers will only be able to update notification templates for their own applications.
func update_notification_template(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account ID of the user.
	accountId: float,
	# notificationTemplateId: float   Eg: 789
	# The notification template ID to update.
	notificationTemplateId: float,
	# title: String = ""   Eg: title_example
	# The title of the message (this would become the subject title for emails). There is a 191 character limit.
	title = "",
	# body: String = ""   Eg: body_example
	# The body of the message.
	body = "",
	# tags: String = ""   Eg: tags_example
	# The search tags on the template used during search queries.
	tags = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/notification/template/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["notificationTemplateId"] = notificationTemplateId
	bzz_query["title"] = title
	bzz_query["body"] = body
	bzz_query["tags"] = tags

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = NotificationTemplateResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_notification_template_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account ID of the user.
	accountId: float,
	# notificationTemplateId: float   Eg: 789
	# The notification template ID to update.
	notificationTemplateId: float,
	# title: String = ""   Eg: title_example
	# The title of the message (this would become the subject title for emails). There is a 191 character limit.
	title = "",
	# body: String = ""   Eg: body_example
	# The body of the message.
	body = "",
	# tags: String = ""   Eg: tags_example
	# The search tags on the template used during search queries.
	tags = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_notification_template")
	bzz_callable.bind(
		version,
		accountId,
		notificationTemplateId,
		title,
		body,
		tags,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


