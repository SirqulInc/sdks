extends ApiBee
class_name AudienceApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API AudienceApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "AudienceApi"


# Operation createAudience → POST /audience/create
# Create Audience
#
# Create a user defined audience.
func create_audience(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the audience
	name: String,
	# description: String = ""   Eg: description_example
	# The description of the audience
	description = "",
	# searchTags: String = ""   Eg: searchTags_example
	# The search tags
	searchTags = "",
	# gender: String = ""   Eg: gender_example
	# The gender; possible values are: MALE, FEMALE, ANY
	gender = "",
	# ageGroups: String = ""   Eg: ageGroups_example
	# The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
	ageGroups = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
	categoryIds = "",
	# applicationIds: String = ""   Eg: applicationIds_example
	# The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
	applicationIds = "",
	# gameExperienceLevel: String = ""   Eg: gameExperienceLevel_example
	# The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
	gameExperienceLevel = "",
	# devices: String = ""   Eg: devices_example
	# (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
	devices = "",
	# deviceIds: String = ""   Eg: deviceIds_example
	# The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
	deviceIds = "",
	# deviceVersions: String = ""   Eg: deviceVersions_example
	# The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
	deviceVersions = "",
	# locations: String = ""   Eg: locations_example
	# The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
	locations = "",
	# radius: String = ""   Eg: radius_example
	# The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
	radius = "",
	# startTimeOffset: int   Eg: 56
	# Seconds from the start time of an event
	startTimeOffset = null,
	# endTimeOffset: int   Eg: 56
	# Seconds from the end time of an event
	endTimeOffset = null,
	# sendSuggestion: bool = true   Eg: true
	# If true, then notify matching users when they are inside the radius
	sendSuggestion = true,
	# associateDescription: String = ""   Eg: associateDescription_example
	# The description of the associated object
	associateDescription = "",
	# associateType: String = ""   Eg: associateType_example
	# The type of the object to center the audience geofence
	associateType = "",
	# associateId: float   Eg: 789
	# The ID of the object to center the audience geofence
	associateId = null,
	# groupingId: String = ""   Eg: groupingId_example
	# Optional grouping id for the audience
	groupingId = "",
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# visibility: String = ""   Eg: visibility_example
	# Visibility of the audience
	visibility = "",
	# audienceType: String = ""   Eg: audienceType_example
	# Type of audience
	audienceType = "",
	# useOrder: bool   Eg: true
	# Use order for cohort
	useOrder = null,
	# cohortRegionsData: String = ""   Eg: cohortRegionsData_example
	# Cohort data for \"cohort\" audience type
	cohortRegionsData = "",
	# appKey: String = ""   Eg: appKey_example
	# Filter results by application key
	appKey = "",
	# trilaterationTypes: String = ""   Eg: trilaterationTypes_example
	# Trilateration types
	trilaterationTypes = "",
	# uniqueName: bool   Eg: true
	# If true, makes sure the audience name is unique
	uniqueName = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/audience/create"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["name"] = name
	bzz_query["description"] = description
	bzz_query["searchTags"] = searchTags
	bzz_query["gender"] = gender
	bzz_query["ageGroups"] = ageGroups
	bzz_query["categoryIds"] = categoryIds
	bzz_query["applicationIds"] = applicationIds
	bzz_query["gameExperienceLevel"] = gameExperienceLevel
	bzz_query["devices"] = devices
	bzz_query["deviceIds"] = deviceIds
	bzz_query["deviceVersions"] = deviceVersions
	bzz_query["locations"] = locations
	bzz_query["radius"] = radius
	bzz_query["startTimeOffset"] = startTimeOffset
	bzz_query["endTimeOffset"] = endTimeOffset
	bzz_query["sendSuggestion"] = sendSuggestion
	bzz_query["associateDescription"] = associateDescription
	bzz_query["associateType"] = associateType
	bzz_query["associateId"] = associateId
	bzz_query["groupingId"] = groupingId
	bzz_query["metaData"] = metaData
	bzz_query["visibility"] = visibility
	bzz_query["audienceType"] = audienceType
	bzz_query["useOrder"] = useOrder
	bzz_query["cohortRegionsData"] = cohortRegionsData
	bzz_query["appKey"] = appKey
	bzz_query["trilaterationTypes"] = trilaterationTypes
	bzz_query["uniqueName"] = uniqueName

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AudienceResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_audience_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the audience
	name: String,
	# description: String = ""   Eg: description_example
	# The description of the audience
	description = "",
	# searchTags: String = ""   Eg: searchTags_example
	# The search tags
	searchTags = "",
	# gender: String = ""   Eg: gender_example
	# The gender; possible values are: MALE, FEMALE, ANY
	gender = "",
	# ageGroups: String = ""   Eg: ageGroups_example
	# The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
	ageGroups = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
	categoryIds = "",
	# applicationIds: String = ""   Eg: applicationIds_example
	# The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
	applicationIds = "",
	# gameExperienceLevel: String = ""   Eg: gameExperienceLevel_example
	# The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
	gameExperienceLevel = "",
	# devices: String = ""   Eg: devices_example
	# (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
	devices = "",
	# deviceIds: String = ""   Eg: deviceIds_example
	# The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
	deviceIds = "",
	# deviceVersions: String = ""   Eg: deviceVersions_example
	# The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
	deviceVersions = "",
	# locations: String = ""   Eg: locations_example
	# The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
	locations = "",
	# radius: String = ""   Eg: radius_example
	# The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
	radius = "",
	# startTimeOffset: int   Eg: 56
	# Seconds from the start time of an event
	startTimeOffset = null,
	# endTimeOffset: int   Eg: 56
	# Seconds from the end time of an event
	endTimeOffset = null,
	# sendSuggestion: bool = true   Eg: true
	# If true, then notify matching users when they are inside the radius
	sendSuggestion = true,
	# associateDescription: String = ""   Eg: associateDescription_example
	# The description of the associated object
	associateDescription = "",
	# associateType: String = ""   Eg: associateType_example
	# The type of the object to center the audience geofence
	associateType = "",
	# associateId: float   Eg: 789
	# The ID of the object to center the audience geofence
	associateId = null,
	# groupingId: String = ""   Eg: groupingId_example
	# Optional grouping id for the audience
	groupingId = "",
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# visibility: String = ""   Eg: visibility_example
	# Visibility of the audience
	visibility = "",
	# audienceType: String = ""   Eg: audienceType_example
	# Type of audience
	audienceType = "",
	# useOrder: bool   Eg: true
	# Use order for cohort
	useOrder = null,
	# cohortRegionsData: String = ""   Eg: cohortRegionsData_example
	# Cohort data for \"cohort\" audience type
	cohortRegionsData = "",
	# appKey: String = ""   Eg: appKey_example
	# Filter results by application key
	appKey = "",
	# trilaterationTypes: String = ""   Eg: trilaterationTypes_example
	# Trilateration types
	trilaterationTypes = "",
	# uniqueName: bool   Eg: true
	# If true, makes sure the audience name is unique
	uniqueName = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_audience")
	bzz_callable.bind(
		accountId,
		name,
		description,
		searchTags,
		gender,
		ageGroups,
		categoryIds,
		applicationIds,
		gameExperienceLevel,
		devices,
		deviceIds,
		deviceVersions,
		locations,
		radius,
		startTimeOffset,
		endTimeOffset,
		sendSuggestion,
		associateDescription,
		associateType,
		associateId,
		groupingId,
		metaData,
		visibility,
		audienceType,
		useOrder,
		cohortRegionsData,
		appKey,
		trilaterationTypes,
		uniqueName,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteAudience → POST /audience/delete
# Delete Audience
#
# Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.
func delete_audience(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# audienceId: float   Eg: 789
	# The id of the audience to delete.
	audienceId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/audience/delete"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["audienceId"] = audienceId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_audience_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# audienceId: float   Eg: 789
	# The id of the audience to delete.
	audienceId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_audience")
	bzz_callable.bind(
		accountId,
		audienceId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getAgeGroups → GET /audience/ageGroups
# Get Age Groups
#
# Gets the list of available age groups that can be selected by consumers and retailers targeting offers.
func get_age_groups(
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/audience/ageGroups"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AgeGroupResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_age_groups_threaded(
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_age_groups")
	bzz_callable.bind(
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getAudience → GET /audience/get
# Get Audience
#
# Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.
func get_audience(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# audienceId: float   Eg: 789
	# The id of the audience to return.
	audienceId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key (optional). If provided, results may be scoped to this application.
	appKey = "",
	# returnAccountCount: bool = false   Eg: true
	# (boolean) set to true to include the accountCount associated with current audience of the current app
	returnAccountCount = false,
	# returnAlbumCount: bool = false   Eg: true
	# (boolean) set to true to include the albumCount associated with current audience of the current app
	returnAlbumCount = false,
	# albumTypesForCount: String = ""   Eg: albumTypesForCount_example
	# (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.
	albumTypesForCount = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/audience/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["audienceId"] = audienceId
	bzz_query["appKey"] = appKey
	bzz_query["returnAccountCount"] = returnAccountCount
	bzz_query["returnAlbumCount"] = returnAlbumCount
	bzz_query["albumTypesForCount"] = albumTypesForCount

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AudienceResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_audience_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# audienceId: float   Eg: 789
	# The id of the audience to return.
	audienceId: float,
	# appKey: String = ""   Eg: appKey_example
	# The application key (optional). If provided, results may be scoped to this application.
	appKey = "",
	# returnAccountCount: bool = false   Eg: true
	# (boolean) set to true to include the accountCount associated with current audience of the current app
	returnAccountCount = false,
	# returnAlbumCount: bool = false   Eg: true
	# (boolean) set to true to include the albumCount associated with current audience of the current app
	returnAlbumCount = false,
	# albumTypesForCount: String = ""   Eg: albumTypesForCount_example
	# (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.
	albumTypesForCount = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_audience")
	bzz_callable.bind(
		accountId,
		audienceId,
		appKey,
		returnAccountCount,
		returnAlbumCount,
		albumTypesForCount,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getAudienceList → GET /audience/search
# Search Audiences
#
# Get the list audiences owned by the account
func get_audience_list(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId = null,
	# albumIds: String = ""   Eg: albumIds_example
	# Comma separated list of album IDs to filter results with
	albumIds = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search
	keyword = "",
	# keywordFields: String = "SEARCH_TAGS,NAME,DESCRIPTION"   Eg: keywordFields_example
	# Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY
	keywordFields = "SEARCH_TAGS,NAME,DESCRIPTION",
	# sortField: String = "NAME"   Eg: sortField_example
	# The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}
	sortField = "NAME",
	# descending: bool = false   Eg: true
	# The order to return the results. Default is false, which will return the results in ascending order.
	descending = false,
	# start: int = 0   Eg: 56
	# The index into the record set to start with.
	start = 0,
	# limit: int = 20   Eg: 56
	# The total number of record to return (there is a hard limit of 100).
	limit = 20,
	# sendSuggestion: bool   Eg: true
	# Filter results based on whether or not the audience is set to send suggestions
	sendSuggestion = null,
	# activeOnly: bool   Eg: true
	# Determines whether to return only active results. Default is false.
	activeOnly = null,
	# groupByGroupingId: bool   Eg: true
	# Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)
	groupByGroupingId = null,
	# appKey: String = ""   Eg: appKey_example
	# Filter results by application key
	appKey = "",
	# returnGlobal: bool   Eg: true
	# If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well
	returnGlobal = null,
	# exactKeyword: bool   Eg: true
	# If true, match keyword exactly
	exactKeyword = null,
	# audienceType: String = ""   Eg: audienceType_example
	# (Deprecated) Filter results by audience type
	audienceType = "",
	# audienceTypes: String = ""   Eg: audienceTypes_example
	# comma separated string with the different audience types you want to filter for
	audienceTypes = "",
	# returnAccountCount: bool = false   Eg: true
	# (boolean) set to true to include the accountCount associated with current audience of the current app
	returnAccountCount = false,
	# returnAlbumCount: bool = false   Eg: true
	# (boolean) set to true to include the albumCount associated with current audience of the current app
	returnAlbumCount = false,
	# albumTypesForCount: String = ""   Eg: albumTypesForCount_example
	# (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.
	albumTypesForCount = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/audience/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["albumIds"] = albumIds
	bzz_query["keyword"] = keyword
	bzz_query["keywordFields"] = keywordFields
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["sendSuggestion"] = sendSuggestion
	bzz_query["activeOnly"] = activeOnly
	bzz_query["groupByGroupingId"] = groupByGroupingId
	bzz_query["appKey"] = appKey
	bzz_query["returnGlobal"] = returnGlobal
	bzz_query["exactKeyword"] = exactKeyword
	bzz_query["audienceType"] = audienceType
	bzz_query["audienceTypes"] = audienceTypes
	bzz_query["returnAccountCount"] = returnAccountCount
	bzz_query["returnAlbumCount"] = returnAlbumCount
	bzz_query["albumTypesForCount"] = albumTypesForCount

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SearchResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_audience_list_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId = null,
	# albumIds: String = ""   Eg: albumIds_example
	# Comma separated list of album IDs to filter results with
	albumIds = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search
	keyword = "",
	# keywordFields: String = "SEARCH_TAGS,NAME,DESCRIPTION"   Eg: keywordFields_example
	# Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY
	keywordFields = "SEARCH_TAGS,NAME,DESCRIPTION",
	# sortField: String = "NAME"   Eg: sortField_example
	# The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}
	sortField = "NAME",
	# descending: bool = false   Eg: true
	# The order to return the results. Default is false, which will return the results in ascending order.
	descending = false,
	# start: int = 0   Eg: 56
	# The index into the record set to start with.
	start = 0,
	# limit: int = 20   Eg: 56
	# The total number of record to return (there is a hard limit of 100).
	limit = 20,
	# sendSuggestion: bool   Eg: true
	# Filter results based on whether or not the audience is set to send suggestions
	sendSuggestion = null,
	# activeOnly: bool   Eg: true
	# Determines whether to return only active results. Default is false.
	activeOnly = null,
	# groupByGroupingId: bool   Eg: true
	# Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)
	groupByGroupingId = null,
	# appKey: String = ""   Eg: appKey_example
	# Filter results by application key
	appKey = "",
	# returnGlobal: bool   Eg: true
	# If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well
	returnGlobal = null,
	# exactKeyword: bool   Eg: true
	# If true, match keyword exactly
	exactKeyword = null,
	# audienceType: String = ""   Eg: audienceType_example
	# (Deprecated) Filter results by audience type
	audienceType = "",
	# audienceTypes: String = ""   Eg: audienceTypes_example
	# comma separated string with the different audience types you want to filter for
	audienceTypes = "",
	# returnAccountCount: bool = false   Eg: true
	# (boolean) set to true to include the accountCount associated with current audience of the current app
	returnAccountCount = false,
	# returnAlbumCount: bool = false   Eg: true
	# (boolean) set to true to include the albumCount associated with current audience of the current app
	returnAlbumCount = false,
	# albumTypesForCount: String = ""   Eg: albumTypesForCount_example
	# (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.
	albumTypesForCount = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_audience_list")
	bzz_callable.bind(
		accountId,
		albumIds,
		keyword,
		keywordFields,
		sortField,
		descending,
		start,
		limit,
		sendSuggestion,
		activeOnly,
		groupByGroupingId,
		appKey,
		returnGlobal,
		exactKeyword,
		audienceType,
		audienceTypes,
		returnAccountCount,
		returnAlbumCount,
		albumTypesForCount,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getDevices → GET /audience/devices
# Get Devices
#
# Gets the list of available devices that can be selected by consumers and retailers.
func get_devices(
	# includeInactive: bool   Eg: true
	# If true return inactive record as well. default is false.
	includeInactive: bool,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/audience/devices"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["includeInactive"] = includeInactive

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AudienceDeviceResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_devices_threaded(
	# includeInactive: bool   Eg: true
	# If true return inactive record as well. default is false.
	includeInactive: bool,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_devices")
	bzz_callable.bind(
		includeInactive,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getExperiences → GET /audience/experiences
# Get Experiences
#
# Gets the list of available experiences that can be selected by consumers and retailers.
func get_experiences(
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/audience/experiences"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_experiences_threaded(
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_experiences")
	bzz_callable.bind(
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getGroupedAudiences → GET /audience/grouped/get
# Get GroupedAudiences
#
# Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.
func get_grouped_audiences(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# audienceGroupingId: String = ""   Eg: audienceGroupingId_example
	# The audience grouping id to return.
	audienceGroupingId: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/audience/grouped/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["audienceGroupingId"] = audienceGroupingId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AudienceResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_grouped_audiences_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# audienceGroupingId: String = ""   Eg: audienceGroupingId_example
	# The audience grouping id to return.
	audienceGroupingId: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_grouped_audiences")
	bzz_callable.bind(
		accountId,
		audienceGroupingId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation listByAccount → POST /audience/suggestion/list
# List Suggestions by Audience
#
# List either Missions or Offers that the user matches the assigned audience.
func list_by_account(
	# accountId: float   Eg: 789
	# The account to match offers for.
	accountId: float,
	# limit: int   Eg: 56
	# the limit of the index
	limit: int,
	# suggestionType: String = ""   Eg: suggestionType_example
	# the type of suggestion
	suggestionType: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/audience/suggestion/list"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["limit"] = limit
	bzz_query["suggestionType"] = suggestionType

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OfferListResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func list_by_account_threaded(
	# accountId: float   Eg: 789
	# The account to match offers for.
	accountId: float,
	# limit: int   Eg: 56
	# the limit of the index
	limit: int,
	# suggestionType: String = ""   Eg: suggestionType_example
	# the type of suggestion
	suggestionType: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "list_by_account")
	bzz_callable.bind(
		accountId,
		limit,
		suggestionType,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation listByAudience → GET /audience/suggestion/offersByAudience
# List Offers by Audience
#
# Get a list of offer locations based on audience information provided.
func list_by_audience(
	# limit: int   Eg: 56
	# this is the limit of the index
	limit: int,
	# gender: String = ""   Eg: gender_example
	# this is the gender to list offers by
	gender = "",
	# age: int   Eg: 56
	# this is the age to list offers by
	age = null,
	# categoryIds: String = ""   Eg: categoryIds_example
	# this is the category IDs to list offers by
	categoryIds = "",
	# latitude: int   Eg: 1.2
	# this is the latitude to list offers by
	latitude = null,
	# longitude: int   Eg: 1.2
	# this is the longitude to list offers by
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/audience/suggestion/offersByAudience"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["gender"] = gender
	bzz_query["age"] = age
	bzz_query["categoryIds"] = categoryIds
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OfferListResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func list_by_audience_threaded(
	# limit: int   Eg: 56
	# this is the limit of the index
	limit: int,
	# gender: String = ""   Eg: gender_example
	# this is the gender to list offers by
	gender = "",
	# age: int   Eg: 56
	# this is the age to list offers by
	age = null,
	# categoryIds: String = ""   Eg: categoryIds_example
	# this is the category IDs to list offers by
	categoryIds = "",
	# latitude: int   Eg: 1.2
	# this is the latitude to list offers by
	latitude = null,
	# longitude: int   Eg: 1.2
	# this is the longitude to list offers by
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "list_by_audience")
	bzz_callable.bind(
		limit,
		gender,
		age,
		categoryIds,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation listLastestByAccount → GET /audience/suggestion/latest
# List Sent Suggestions 
#
# Return list of recent trigger suggestions that have been sent to the user.
func list_lastest_by_account(
	# accountId: float   Eg: 789
	# The account to match offers for.
	accountId: float,
	# timeframe: int   Eg: 56
	# The timeframe in seconds of the latest suggestions
	timeframe: int,
	# suggestionType: String = ""   Eg: suggestionType_example
	# The type of trigger suggestions to return
	suggestionType: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/audience/suggestion/latest"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["timeframe"] = timeframe
	bzz_query["suggestionType"] = suggestionType

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = OfferListResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func list_lastest_by_account_threaded(
	# accountId: float   Eg: 789
	# The account to match offers for.
	accountId: float,
	# timeframe: int   Eg: 56
	# The timeframe in seconds of the latest suggestions
	timeframe: int,
	# suggestionType: String = ""   Eg: suggestionType_example
	# The type of trigger suggestions to return
	suggestionType: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "list_lastest_by_account")
	bzz_callable.bind(
		accountId,
		timeframe,
		suggestionType,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation sendByAccount → POST /audience/suggestion/send
# Send Suggestions
#
# Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.
func send_by_account(
	# accountId: float   Eg: 789
	# The account to match offers for.
	accountId: float,
	# latitude: int   Eg: 1.2
	# the latitude
	latitude: int,
	# longitude: int   Eg: 1.2
	# the longitude
	longitude: int,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/audience/suggestion/send"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func send_by_account_threaded(
	# accountId: float   Eg: 789
	# The account to match offers for.
	accountId: float,
	# latitude: int   Eg: 1.2
	# the latitude
	latitude: int,
	# longitude: int   Eg: 1.2
	# the longitude
	longitude: int,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "send_by_account")
	bzz_callable.bind(
		accountId,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateAudience → POST /audience/update
# Update Audience
#
# Update a user defined audience.
func update_audience(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# audienceId: float   Eg: 789
	# The id of the audience to update.
	audienceId: float,
	# name: String = ""   Eg: name_example
	# The name of the audience
	name = "",
	# description: String = ""   Eg: description_example
	# The description of the audience
	description = "",
	# searchTags: String = ""   Eg: searchTags_example
	# The search tags
	searchTags = "",
	# gender: String = ""   Eg: gender_example
	# The gender; possible values are: MALE, FEMALE, ANY
	gender = "",
	# ageGroups: String = ""   Eg: ageGroups_example
	# The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
	ageGroups = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
	categoryIds = "",
	# applicationIds: String = ""   Eg: applicationIds_example
	# The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
	applicationIds = "",
	# gameExperienceLevel: String = ""   Eg: gameExperienceLevel_example
	# The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
	gameExperienceLevel = "",
	# devices: String = ""   Eg: devices_example
	# (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
	devices = "",
	# deviceIds: String = ""   Eg: deviceIds_example
	# The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
	deviceIds = "",
	# deviceVersions: String = ""   Eg: deviceVersions_example
	# The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
	deviceVersions = "",
	# locations: String = ""   Eg: locations_example
	# The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
	locations = "",
	# radius: String = ""   Eg: radius_example
	# The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
	radius = "",
	# active: bool   Eg: true
	# if audience is active
	active = null,
	# sendSuggestion: bool   Eg: true
	# If true, then notify matching users when they are inside the radius
	sendSuggestion = null,
	# startTimeOffset: int   Eg: 56
	# Seconds from the start time of an event
	startTimeOffset = null,
	# endTimeOffset: int   Eg: 56
	# Seconds from the end time of an event
	endTimeOffset = null,
	# associateDescription: String = ""   Eg: associateDescription_example
	# the associate description
	associateDescription = "",
	# associateType: String = ""   Eg: associateType_example
	# The type of the object to center the audience geofence
	associateType = "",
	# associateId: float   Eg: 789
	# The ID of the object to center the audience geofence
	associateId = null,
	# groupingId: String = ""   Eg: groupingId_example
	# Optional grouping id for the audience
	groupingId = "",
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# visibility: String = ""   Eg: visibility_example
	# Visibility of the audience
	visibility = "",
	# audienceType: String = ""   Eg: audienceType_example
	# Type of audience
	audienceType = "",
	# useOrder: bool   Eg: true
	# Use order for cohort
	useOrder = null,
	# cohortRegionsData: String = ""   Eg: cohortRegionsData_example
	# Cohort data for \"cohort\" audience type
	cohortRegionsData = "",
	# appKey: String = ""   Eg: appKey_example
	# Filter results by application key
	appKey = "",
	# trilaterationTypes: String = ""   Eg: trilaterationTypes_example
	# Trilateration types
	trilaterationTypes = "",
	# uniqueName: bool   Eg: true
	# If true, makes sure the audience name is unique
	uniqueName = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/audience/update"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["audienceId"] = audienceId
	bzz_query["name"] = name
	bzz_query["description"] = description
	bzz_query["searchTags"] = searchTags
	bzz_query["gender"] = gender
	bzz_query["ageGroups"] = ageGroups
	bzz_query["categoryIds"] = categoryIds
	bzz_query["applicationIds"] = applicationIds
	bzz_query["gameExperienceLevel"] = gameExperienceLevel
	bzz_query["devices"] = devices
	bzz_query["deviceIds"] = deviceIds
	bzz_query["deviceVersions"] = deviceVersions
	bzz_query["locations"] = locations
	bzz_query["radius"] = radius
	bzz_query["active"] = active
	bzz_query["sendSuggestion"] = sendSuggestion
	bzz_query["startTimeOffset"] = startTimeOffset
	bzz_query["endTimeOffset"] = endTimeOffset
	bzz_query["associateDescription"] = associateDescription
	bzz_query["associateType"] = associateType
	bzz_query["associateId"] = associateId
	bzz_query["groupingId"] = groupingId
	bzz_query["metaData"] = metaData
	bzz_query["visibility"] = visibility
	bzz_query["audienceType"] = audienceType
	bzz_query["useOrder"] = useOrder
	bzz_query["cohortRegionsData"] = cohortRegionsData
	bzz_query["appKey"] = appKey
	bzz_query["trilaterationTypes"] = trilaterationTypes
	bzz_query["uniqueName"] = uniqueName

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = AudienceResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_audience_threaded(
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# audienceId: float   Eg: 789
	# The id of the audience to update.
	audienceId: float,
	# name: String = ""   Eg: name_example
	# The name of the audience
	name = "",
	# description: String = ""   Eg: description_example
	# The description of the audience
	description = "",
	# searchTags: String = ""   Eg: searchTags_example
	# The search tags
	searchTags = "",
	# gender: String = ""   Eg: gender_example
	# The gender; possible values are: MALE, FEMALE, ANY
	gender = "",
	# ageGroups: String = ""   Eg: ageGroups_example
	# The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
	ageGroups = "",
	# categoryIds: String = ""   Eg: categoryIds_example
	# The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
	categoryIds = "",
	# applicationIds: String = ""   Eg: applicationIds_example
	# The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
	applicationIds = "",
	# gameExperienceLevel: String = ""   Eg: gameExperienceLevel_example
	# The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
	gameExperienceLevel = "",
	# devices: String = ""   Eg: devices_example
	# (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
	devices = "",
	# deviceIds: String = ""   Eg: deviceIds_example
	# The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
	deviceIds = "",
	# deviceVersions: String = ""   Eg: deviceVersions_example
	# The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
	deviceVersions = "",
	# locations: String = ""   Eg: locations_example
	# The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
	locations = "",
	# radius: String = ""   Eg: radius_example
	# The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
	radius = "",
	# active: bool   Eg: true
	# if audience is active
	active = null,
	# sendSuggestion: bool   Eg: true
	# If true, then notify matching users when they are inside the radius
	sendSuggestion = null,
	# startTimeOffset: int   Eg: 56
	# Seconds from the start time of an event
	startTimeOffset = null,
	# endTimeOffset: int   Eg: 56
	# Seconds from the end time of an event
	endTimeOffset = null,
	# associateDescription: String = ""   Eg: associateDescription_example
	# the associate description
	associateDescription = "",
	# associateType: String = ""   Eg: associateType_example
	# The type of the object to center the audience geofence
	associateType = "",
	# associateId: float   Eg: 789
	# The ID of the object to center the audience geofence
	associateId = null,
	# groupingId: String = ""   Eg: groupingId_example
	# Optional grouping id for the audience
	groupingId = "",
	# metaData: String = ""   Eg: metaData_example
	# External custom client defined data
	metaData = "",
	# visibility: String = ""   Eg: visibility_example
	# Visibility of the audience
	visibility = "",
	# audienceType: String = ""   Eg: audienceType_example
	# Type of audience
	audienceType = "",
	# useOrder: bool   Eg: true
	# Use order for cohort
	useOrder = null,
	# cohortRegionsData: String = ""   Eg: cohortRegionsData_example
	# Cohort data for \"cohort\" audience type
	cohortRegionsData = "",
	# appKey: String = ""   Eg: appKey_example
	# Filter results by application key
	appKey = "",
	# trilaterationTypes: String = ""   Eg: trilaterationTypes_example
	# Trilateration types
	trilaterationTypes = "",
	# uniqueName: bool   Eg: true
	# If true, makes sure the audience name is unique
	uniqueName = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_audience")
	bzz_callable.bind(
		accountId,
		audienceId,
		name,
		description,
		searchTags,
		gender,
		ageGroups,
		categoryIds,
		applicationIds,
		gameExperienceLevel,
		devices,
		deviceIds,
		deviceVersions,
		locations,
		radius,
		active,
		sendSuggestion,
		startTimeOffset,
		endTimeOffset,
		associateDescription,
		associateType,
		associateId,
		groupingId,
		metaData,
		visibility,
		audienceType,
		useOrder,
		cohortRegionsData,
		appKey,
		trilaterationTypes,
		uniqueName,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


