extends ApiBee
class_name GameLevelApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API GameLevelApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "GameLevelApi"


# Operation createGameLevel → POST /api/{version}/level/create
# Create Game Level
#
# Create a game level. Currently does NOT support game objects.
func create_game_level(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the level.
	name: String,
	# gameData: String = ""   Eg: gameData_example
	# The game level data: xml, json, or other text based format.
	gameData: String,
	# gameDataSuffix: String = ""   Eg: gameDataSuffix_example
	# The game level data format type.
	gameDataSuffix: String,
	# appKey: String = ""   Eg: appKey_example
	# The game application key to save the level for.
	appKey = "",
	# description: String = ""   Eg: description_example
	# The description of the level.
	description = "",
	# difficulty: String = ""   Eg: difficulty_example
	# The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD.
	difficulty = "",
	# appVersion: String = ""   Eg: appVersion_example
	# The version number of the application required to correctly load/play the level.
	appVersion = "",
	# assetImageId: float   Eg: 789
	# The asset Id of the level image.
	assetImageId = null,
	# assetIconId: float   Eg: 789
	# The asset Id of the level icon.
	assetIconId = null,
	# visibility: String = ""   Eg: visibility_example
	# Is the level visible to others, possible values are: PUBLIC, PRIVATE.
	visibility = "",
	# friendGroup: bool   Eg: true
	# Make the level be readable by all friends.
	friendGroup = null,
	# connectionIds: String = ""   Eg: connectionIds_example
	# Make the level be readable by connections in this list.
	connectionIds = "",
	# connectionGroupIds: String = ""   Eg: connectionGroupIds_example
	# Make the level be readable by connection groups in this list.
	connectionGroupIds = "",
	# balance: int   Eg: 1.2
	# Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.
	balance = null,
	# active: bool   Eg: true
	# If true set the game level as active. Default is false.
	active = null,
	# allocateTickets: bool   Eg: true
	# If true then scoring will give tickets. Default is false.
	allocateTickets = null,
	# ticketCount: float   Eg: 789
	# The number of tickets to reward
	ticketCount = null,
	# ticketType: String = ""   Eg: ticketType_example
	# The type of ticket to reward, null means default type
	ticketType = "",
	# points: float   Eg: 789
	# The number of points to award for completing a level
	points = null,
	# tutorialTitle: String = ""   Eg: tutorialTitle_example
	# Title of the tutorial.
	tutorialTitle = "",
	# tutorialMessage: String = ""   Eg: tutorialMessage_example
	# Message of the tutotrial.
	tutorialMessage = "",
	# tutorialAlignment: String = ""   Eg: tutorialAlignment_example
	# Alignment of the tutorial image. Default to NONE. Possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY
	tutorialAlignment = "",
	# tutorialImageAssetId: float   Eg: 789
	# Asset id of the tutorial image.
	tutorialImageAssetId = null,
	# offerId: float   Eg: 789
	# id of the offer
	offerId = null,
	# metaData: String = ""   Eg: metaData_example
	# external custom client defined data
	metaData = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/level/create".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["name"] = name
	bzz_query["description"] = description
	bzz_query["difficulty"] = difficulty
	bzz_query["appVersion"] = appVersion
	bzz_query["assetImageId"] = assetImageId
	bzz_query["assetIconId"] = assetIconId
	bzz_query["gameData"] = gameData
	bzz_query["gameDataSuffix"] = gameDataSuffix
	bzz_query["visibility"] = visibility
	bzz_query["friendGroup"] = friendGroup
	bzz_query["connectionIds"] = connectionIds
	bzz_query["connectionGroupIds"] = connectionGroupIds
	bzz_query["balance"] = balance
	bzz_query["active"] = active
	bzz_query["allocateTickets"] = allocateTickets
	bzz_query["ticketCount"] = ticketCount
	bzz_query["ticketType"] = ticketType
	bzz_query["points"] = points
	bzz_query["tutorialTitle"] = tutorialTitle
	bzz_query["tutorialMessage"] = tutorialMessage
	bzz_query["tutorialAlignment"] = tutorialAlignment
	bzz_query["tutorialImageAssetId"] = tutorialImageAssetId
	bzz_query["offerId"] = offerId
	bzz_query["metaData"] = metaData

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = GameLevelResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_game_level_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# name: String = ""   Eg: name_example
	# The name of the level.
	name: String,
	# gameData: String = ""   Eg: gameData_example
	# The game level data: xml, json, or other text based format.
	gameData: String,
	# gameDataSuffix: String = ""   Eg: gameDataSuffix_example
	# The game level data format type.
	gameDataSuffix: String,
	# appKey: String = ""   Eg: appKey_example
	# The game application key to save the level for.
	appKey = "",
	# description: String = ""   Eg: description_example
	# The description of the level.
	description = "",
	# difficulty: String = ""   Eg: difficulty_example
	# The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD.
	difficulty = "",
	# appVersion: String = ""   Eg: appVersion_example
	# The version number of the application required to correctly load/play the level.
	appVersion = "",
	# assetImageId: float   Eg: 789
	# The asset Id of the level image.
	assetImageId = null,
	# assetIconId: float   Eg: 789
	# The asset Id of the level icon.
	assetIconId = null,
	# visibility: String = ""   Eg: visibility_example
	# Is the level visible to others, possible values are: PUBLIC, PRIVATE.
	visibility = "",
	# friendGroup: bool   Eg: true
	# Make the level be readable by all friends.
	friendGroup = null,
	# connectionIds: String = ""   Eg: connectionIds_example
	# Make the level be readable by connections in this list.
	connectionIds = "",
	# connectionGroupIds: String = ""   Eg: connectionGroupIds_example
	# Make the level be readable by connection groups in this list.
	connectionGroupIds = "",
	# balance: int   Eg: 1.2
	# Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.
	balance = null,
	# active: bool   Eg: true
	# If true set the game level as active. Default is false.
	active = null,
	# allocateTickets: bool   Eg: true
	# If true then scoring will give tickets. Default is false.
	allocateTickets = null,
	# ticketCount: float   Eg: 789
	# The number of tickets to reward
	ticketCount = null,
	# ticketType: String = ""   Eg: ticketType_example
	# The type of ticket to reward, null means default type
	ticketType = "",
	# points: float   Eg: 789
	# The number of points to award for completing a level
	points = null,
	# tutorialTitle: String = ""   Eg: tutorialTitle_example
	# Title of the tutorial.
	tutorialTitle = "",
	# tutorialMessage: String = ""   Eg: tutorialMessage_example
	# Message of the tutotrial.
	tutorialMessage = "",
	# tutorialAlignment: String = ""   Eg: tutorialAlignment_example
	# Alignment of the tutorial image. Default to NONE. Possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY
	tutorialAlignment = "",
	# tutorialImageAssetId: float   Eg: 789
	# Asset id of the tutorial image.
	tutorialImageAssetId = null,
	# offerId: float   Eg: 789
	# id of the offer
	offerId = null,
	# metaData: String = ""   Eg: metaData_example
	# external custom client defined data
	metaData = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_game_level")
	bzz_callable.bind(
		version,
		accountId,
		name,
		gameData,
		gameDataSuffix,
		appKey,
		description,
		difficulty,
		appVersion,
		assetImageId,
		assetIconId,
		visibility,
		friendGroup,
		connectionIds,
		connectionGroupIds,
		balance,
		active,
		allocateTickets,
		ticketCount,
		ticketType,
		points,
		tutorialTitle,
		tutorialMessage,
		tutorialAlignment,
		tutorialImageAssetId,
		offerId,
		metaData,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation deleteGameLevel → POST /api/{version}/level/delete
# Delete Game Level
#
# Delete a game level. The level and account must be valid and have the appropirate permissions to view the content.
func delete_game_level(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# levelId: float   Eg: 789
	# The id of the level to return.
	levelId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/level/delete".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["levelId"] = levelId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func delete_game_level_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# levelId: float   Eg: 789
	# The id of the level to return.
	levelId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "delete_game_level")
	bzz_callable.bind(
		version,
		accountId,
		levelId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getGameLevel → GET /api/{version}/level/get
# Get Game Level
#
# Get a game level. The level and account must be valid and have the appropirate permissions to view the content.
func get_game_level(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# levelId: float   Eg: 789
	# The id of the level to return.
	levelId: float,
	# includeGameData: bool   Eg: true
	# If true include the game level data, otherwise don't. default is false.
	includeGameData = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/level/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["levelId"] = levelId
	bzz_query["includeGameData"] = includeGameData

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = GameLevelResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_game_level_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# levelId: float   Eg: 789
	# The id of the level to return.
	levelId: float,
	# includeGameData: bool   Eg: true
	# If true include the game level data, otherwise don't. default is false.
	includeGameData = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_game_level")
	bzz_callable.bind(
		version,
		accountId,
		levelId,
		includeGameData,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getGameLevelsByApplication → GET /api/{version}/level/search
# Search Game Levels
#
# Get a list of levels for an application, just those the account has permissions to view.
func get_game_levels_by_application(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# keyword: String = ""   Eg: keyword_example
	# Match the keyword to the owner name or level name.
	keyword = "",
	# sortField: String = ""   Eg: sortField_example
	# what field to sort on
	sortField = "",
	# descending: bool   Eg: true
	# whether to return levels in ascending or descending order
	descending = null,
	# start: int   Eg: 56
	# Start the result set at some index.
	start = null,
	# limit: int   Eg: 56
	# Limit the result to some number.
	limit = null,
	# appVersion: String = ""   Eg: appVersion_example
	# The maximum version of the level to return.
	appVersion = "",
	# includeGameData: bool   Eg: true
	# If true include the game level data, otherwise don't. default is false.
	includeGameData = null,
	# filters: String = ""   Eg: filters_example
	filters = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/level/search".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["start"] = start
	bzz_query["limit"] = limit
	bzz_query["appVersion"] = appVersion
	bzz_query["includeGameData"] = includeGameData
	bzz_query["filters"] = filters

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = GameLevelListResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_game_levels_by_application_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey: String,
	# keyword: String = ""   Eg: keyword_example
	# Match the keyword to the owner name or level name.
	keyword = "",
	# sortField: String = ""   Eg: sortField_example
	# what field to sort on
	sortField = "",
	# descending: bool   Eg: true
	# whether to return levels in ascending or descending order
	descending = null,
	# start: int   Eg: 56
	# Start the result set at some index.
	start = null,
	# limit: int   Eg: 56
	# Limit the result to some number.
	limit = null,
	# appVersion: String = ""   Eg: appVersion_example
	# The maximum version of the level to return.
	appVersion = "",
	# includeGameData: bool   Eg: true
	# If true include the game level data, otherwise don't. default is false.
	includeGameData = null,
	# filters: String = ""   Eg: filters_example
	filters = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_game_levels_by_application")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		keyword,
		sortField,
		descending,
		start,
		limit,
		appVersion,
		includeGameData,
		filters,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getGameLevelsByBillableEntity → GET /api/{version}/level/searchByBillableEntity
# Search Game Level by Billable Entity
#
# Searches on game levels that the logged in user has access to. A user would have access if the creator of the game level is managed under the same BillableEntity.
func get_game_levels_by_billable_entity(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search
	keyword = "",
	# sortField: String = ""   Eg: sortField_example
	# The column to sort the search on
	sortField = "",
	# descending: bool   Eg: true
	# The order to return the search results
	descending = null,
	# activeOnly: bool   Eg: true
	# Return only active results
	activeOnly = null,
	# start: float   Eg: 789
	# The record to begin the return set on
	start = null,
	# limit: float   Eg: 789
	# The number of records to return
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/level/searchByBillableEntity".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["activeOnly"] = activeOnly
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = GameLevelResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_game_levels_by_billable_entity_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The account id of the user
	accountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# keyword: String = ""   Eg: keyword_example
	# The keyword used to search
	keyword = "",
	# sortField: String = ""   Eg: sortField_example
	# The column to sort the search on
	sortField = "",
	# descending: bool   Eg: true
	# The order to return the search results
	descending = null,
	# activeOnly: bool   Eg: true
	# Return only active results
	activeOnly = null,
	# start: float   Eg: 789
	# The record to begin the return set on
	start = null,
	# limit: float   Eg: 789
	# The number of records to return
	limit = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_game_levels_by_billable_entity")
	bzz_callable.bind(
		version,
		accountId,
		appKey,
		keyword,
		sortField,
		descending,
		activeOnly,
		start,
		limit,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getQuestionsInLevel → GET /api/{version}/level/questions/get
# Get Level Questions
#
# Get questions within a level.
func get_questions_in_level(
	# version: float   Eg: 3.16
	version: float,
	# levelId: float   Eg: 789
	# the id of the level to get questions from
	levelId: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/level/questions/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["levelId"] = levelId
	bzz_query["accountId"] = accountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = QuestionResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_questions_in_level_threaded(
	# version: float   Eg: 3.16
	version: float,
	# levelId: float   Eg: 789
	# the id of the level to get questions from
	levelId: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_questions_in_level")
	bzz_callable.bind(
		version,
		levelId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getWordsInLevel → GET /api/{version}/level/words/get
# Get Level Words
#
# Get words within a level.
func get_words_in_level(
	# version: float   Eg: 3.16
	version: float,
	# levelId: float   Eg: 789
	# the id of the level to get words for
	levelId: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/level/words/get".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["levelId"] = levelId
	bzz_query["accountId"] = accountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = WordzWordResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_words_in_level_threaded(
	# version: float   Eg: 3.16
	version: float,
	# levelId: float   Eg: 789
	# the id of the level to get words for
	levelId: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_words_in_level")
	bzz_callable.bind(
		version,
		levelId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateGameLevel → POST /api/{version}/level/update
# Update Game Level
#
# Update a game level. Currently does NOT support game objects.
func update_game_level(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# levelId: float   Eg: 789
	# If update then include the level Id.
	levelId: float,
	# appKey: String = ""   Eg: appKey_example
	# The game application key to save the level for.
	appKey = "",
	# name: String = ""   Eg: name_example
	# The name of the level.
	name = "",
	# description: String = ""   Eg: description_example
	# The description of the level.
	description = "",
	# difficulty: String = ""   Eg: difficulty_example
	# The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD.
	difficulty = "",
	# appVersion: String = ""   Eg: appVersion_example
	# The version number of the applicatuion required to correctly load/play the level.
	appVersion = "",
	# assetImageId: float   Eg: 789
	# The asset Id of the level image.
	assetImageId = null,
	# assetIconId: float   Eg: 789
	# The asset Id of the level icon.
	assetIconId = null,
	# gameData: String = ""   Eg: gameData_example
	# The game level data: xml, json, or other texted based format.
	gameData = "",
	# gameDataSuffix: String = ""   Eg: gameDataSuffix_example
	# The game level data format type.
	gameDataSuffix = "",
	# visibility: String = ""   Eg: visibility_example
	# Is the level visible to others, possible values are: PUBLIC, PRIVATE.
	visibility = "",
	# friendGroup: bool   Eg: true
	# Make the level be readable by all friends.
	friendGroup = null,
	# connectionIds: String = ""   Eg: connectionIds_example
	# Make the level be readable by connections in this list.
	connectionIds = "",
	# connectionGroupIds: String = ""   Eg: connectionGroupIds_example
	# Make the level be readable by connection groups in this list.
	connectionGroupIds = "",
	# balance: int   Eg: 1.2
	# Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.
	balance = null,
	# active: bool   Eg: true
	# If true set the game level as active.
	active = null,
	# allocateTickets: bool   Eg: true
	# If true then scoring will give tickets.
	allocateTickets = null,
	# ticketCount: float   Eg: 789
	# The number of tickets to reward
	ticketCount = null,
	# ticketType: String = ""   Eg: ticketType_example
	# The type of ticket to reward, null means default type
	ticketType = "",
	# points: float   Eg: 789
	# The number of points to award for completing a level
	points = null,
	# tutorialTitle: String = ""   Eg: tutorialTitle_example
	# Title of the tutorial.
	tutorialTitle = "",
	# tutorialMessage: String = ""   Eg: tutorialMessage_example
	# Message of the tutorial.
	tutorialMessage = "",
	# tutorialAlignment: String = ""   Eg: tutorialAlignment_example
	# Alignment of the tutorial image, possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY
	tutorialAlignment = "",
	# tutorialImageAssetId: float   Eg: 789
	# Asset id of the tutorial image.
	tutorialImageAssetId = null,
	# offerId: float   Eg: 789
	offerId = null,
	# metaData: String = ""   Eg: metaData_example
	# external custom client defined data
	metaData = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/level/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["appKey"] = appKey
	bzz_query["levelId"] = levelId
	bzz_query["name"] = name
	bzz_query["description"] = description
	bzz_query["difficulty"] = difficulty
	bzz_query["appVersion"] = appVersion
	bzz_query["assetImageId"] = assetImageId
	bzz_query["assetIconId"] = assetIconId
	bzz_query["gameData"] = gameData
	bzz_query["gameDataSuffix"] = gameDataSuffix
	bzz_query["visibility"] = visibility
	bzz_query["friendGroup"] = friendGroup
	bzz_query["connectionIds"] = connectionIds
	bzz_query["connectionGroupIds"] = connectionGroupIds
	bzz_query["balance"] = balance
	bzz_query["active"] = active
	bzz_query["allocateTickets"] = allocateTickets
	bzz_query["ticketCount"] = ticketCount
	bzz_query["ticketType"] = ticketType
	bzz_query["points"] = points
	bzz_query["tutorialTitle"] = tutorialTitle
	bzz_query["tutorialMessage"] = tutorialMessage
	bzz_query["tutorialAlignment"] = tutorialAlignment
	bzz_query["tutorialImageAssetId"] = tutorialImageAssetId
	bzz_query["offerId"] = offerId
	bzz_query["metaData"] = metaData

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = GameLevelResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_game_level_threaded(
	# version: float   Eg: 3.16
	version: float,
	# accountId: float   Eg: 789
	# The logged in user.
	accountId: float,
	# levelId: float   Eg: 789
	# If update then include the level Id.
	levelId: float,
	# appKey: String = ""   Eg: appKey_example
	# The game application key to save the level for.
	appKey = "",
	# name: String = ""   Eg: name_example
	# The name of the level.
	name = "",
	# description: String = ""   Eg: description_example
	# The description of the level.
	description = "",
	# difficulty: String = ""   Eg: difficulty_example
	# The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD.
	difficulty = "",
	# appVersion: String = ""   Eg: appVersion_example
	# The version number of the applicatuion required to correctly load/play the level.
	appVersion = "",
	# assetImageId: float   Eg: 789
	# The asset Id of the level image.
	assetImageId = null,
	# assetIconId: float   Eg: 789
	# The asset Id of the level icon.
	assetIconId = null,
	# gameData: String = ""   Eg: gameData_example
	# The game level data: xml, json, or other texted based format.
	gameData = "",
	# gameDataSuffix: String = ""   Eg: gameDataSuffix_example
	# The game level data format type.
	gameDataSuffix = "",
	# visibility: String = ""   Eg: visibility_example
	# Is the level visible to others, possible values are: PUBLIC, PRIVATE.
	visibility = "",
	# friendGroup: bool   Eg: true
	# Make the level be readable by all friends.
	friendGroup = null,
	# connectionIds: String = ""   Eg: connectionIds_example
	# Make the level be readable by connections in this list.
	connectionIds = "",
	# connectionGroupIds: String = ""   Eg: connectionGroupIds_example
	# Make the level be readable by connection groups in this list.
	connectionGroupIds = "",
	# balance: int   Eg: 1.2
	# Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.
	balance = null,
	# active: bool   Eg: true
	# If true set the game level as active.
	active = null,
	# allocateTickets: bool   Eg: true
	# If true then scoring will give tickets.
	allocateTickets = null,
	# ticketCount: float   Eg: 789
	# The number of tickets to reward
	ticketCount = null,
	# ticketType: String = ""   Eg: ticketType_example
	# The type of ticket to reward, null means default type
	ticketType = "",
	# points: float   Eg: 789
	# The number of points to award for completing a level
	points = null,
	# tutorialTitle: String = ""   Eg: tutorialTitle_example
	# Title of the tutorial.
	tutorialTitle = "",
	# tutorialMessage: String = ""   Eg: tutorialMessage_example
	# Message of the tutorial.
	tutorialMessage = "",
	# tutorialAlignment: String = ""   Eg: tutorialAlignment_example
	# Alignment of the tutorial image, possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY
	tutorialAlignment = "",
	# tutorialImageAssetId: float   Eg: 789
	# Asset id of the tutorial image.
	tutorialImageAssetId = null,
	# offerId: float   Eg: 789
	offerId = null,
	# metaData: String = ""   Eg: metaData_example
	# external custom client defined data
	metaData = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_game_level")
	bzz_callable.bind(
		version,
		accountId,
		levelId,
		appKey,
		name,
		description,
		difficulty,
		appVersion,
		assetImageId,
		assetIconId,
		gameData,
		gameDataSuffix,
		visibility,
		friendGroup,
		connectionIds,
		connectionGroupIds,
		balance,
		active,
		allocateTickets,
		ticketCount,
		ticketType,
		points,
		tutorialTitle,
		tutorialMessage,
		tutorialAlignment,
		tutorialImageAssetId,
		offerId,
		metaData,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateQuestionsInLevel → POST /api/{version}/level/questions/update
# Update Level Questions
#
# Updates a level with question game objects.
func update_questions_in_level(
	# version: float   Eg: 3.16
	version: float,
	# levelId: float   Eg: 789
	# the id of the level to update questions on
	levelId: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# questionIds: String = ""   Eg: questionIds_example
	# the IDs of the questions to update
	questionIds: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/level/questions/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["levelId"] = levelId
	bzz_query["accountId"] = accountId
	bzz_query["questionIds"] = questionIds

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_questions_in_level_threaded(
	# version: float   Eg: 3.16
	version: float,
	# levelId: float   Eg: 789
	# the id of the level to update questions on
	levelId: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# questionIds: String = ""   Eg: questionIds_example
	# the IDs of the questions to update
	questionIds: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_questions_in_level")
	bzz_callable.bind(
		version,
		levelId,
		accountId,
		questionIds,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation updateWordsInLevel → POST /api/{version}/level/words/update
# Update Level Words
#
# Updates a level with word game objects.
func update_words_in_level(
	# version: float   Eg: 3.16
	version: float,
	# levelId: float   Eg: 789
	# the id of the level to update words for
	levelId: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# wordIds: String = ""   Eg: wordIds_example
	# the ids of the words to update for the level
	wordIds: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/{version}/level/words/update".replace("{" + "version" + "}", _bzz_urlize_path_param(version))

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["levelId"] = levelId
	bzz_query["accountId"] = accountId
	bzz_query["wordIds"] = wordIds

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func update_words_in_level_threaded(
	# version: float   Eg: 3.16
	version: float,
	# levelId: float   Eg: 789
	# the id of the level to update words for
	levelId: float,
	# accountId: float   Eg: 789
	# the id of the logged in user
	accountId: float,
	# wordIds: String = ""   Eg: wordIds_example
	# the ids of the words to update for the level
	wordIds: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "update_words_in_level")
	bzz_callable.bind(
		version,
		levelId,
		accountId,
		wordIds,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


