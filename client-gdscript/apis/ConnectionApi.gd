extends ApiBee
class_name ConnectionApi

# THIS FILE WAS AUTOMATICALLY GENERATED by the OpenAPI Generator project.
# For more information on how to customize templates, see:
# https://openapi-generator.tech
# https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/gdscript
# The OpenAPI Generator Community, © Public Domain, 2022

# API ConnectionApi
# Instantiate this object and use it to make requests to the API.

func _bzz_get_api_name() -> String:
	return "ConnectionApi"


# Operation addConnectionToGroup → POST /consumer/connection/group/addConnection
# Add Connection
#
# Adds a connection to a group.
func add_connection_to_group(
	# returnNulls: bool   Eg: true
	# whether to return nulls or not
	returnNulls: bool,
	# groupId: float   Eg: 789
	# the group id
	groupId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# connectionId: float   Eg: 789
	# the connection id
	connectionId = null,
	# connectionAccountId: float   Eg: 789
	# the connection account id
	connectionAccountId = null,
	# pendingId: float   Eg: 789
	# the pending id
	pendingId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/connection/group/addConnection"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["returnNulls"] = returnNulls
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["connectionId"] = connectionId
	bzz_query["connectionAccountId"] = connectionAccountId
	bzz_query["pendingId"] = pendingId
	bzz_query["groupId"] = groupId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func add_connection_to_group_threaded(
	# returnNulls: bool   Eg: true
	# whether to return nulls or not
	returnNulls: bool,
	# groupId: float   Eg: 789
	# the group id
	groupId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# connectionId: float   Eg: 789
	# the connection id
	connectionId = null,
	# connectionAccountId: float   Eg: 789
	# the connection account id
	connectionAccountId = null,
	# pendingId: float   Eg: 789
	# the pending id
	pendingId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "add_connection_to_group")
	bzz_callable.bind(
		returnNulls,
		groupId,
		deviceId,
		accountId,
		connectionId,
		connectionAccountId,
		pendingId,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation addConnectionsToGroup → POST /connection/group/addConnections
# Add Connections
#
# Adds a list of connections to a group.
func add_connections_to_group(
	# connectionGroupId: float   Eg: 789
	# the connection group ID
	connectionGroupId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# connectionIds: String = ""   Eg: connectionIds_example
	# comma separated list of connection ids
	connectionIds = "",
	# connectionAccountIds: String = ""   Eg: connectionAccountIds_example
	# comma separated list of connection account ids
	connectionAccountIds = "",
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/connection/group/addConnections"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["connectionIds"] = connectionIds
	bzz_query["connectionAccountIds"] = connectionAccountIds
	bzz_query["connectionGroupId"] = connectionGroupId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func add_connections_to_group_threaded(
	# connectionGroupId: float   Eg: 789
	# the connection group ID
	connectionGroupId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# connectionIds: String = ""   Eg: connectionIds_example
	# comma separated list of connection ids
	connectionIds = "",
	# connectionAccountIds: String = ""   Eg: connectionAccountIds_example
	# comma separated list of connection account ids
	connectionAccountIds = "",
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "add_connections_to_group")
	bzz_callable.bind(
		connectionGroupId,
		deviceId,
		accountId,
		connectionIds,
		connectionAccountIds,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation addSubGroups → POST /consumer/connection/group/addSubGroup
# Add Connection Groups
#
# Add sub groups to a group.
func add_sub_groups(
	# returnNulls: bool   Eg: true
	# whether to return nulls or not
	returnNulls: bool,
	# groupId: float   Eg: 789
	# the parent group id
	groupId: float,
	# subGroupIds: String = ""   Eg: subGroupIds_example
	# comma separated list of group IDs to add to the parent group
	subGroupIds: String,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/connection/group/addSubGroup"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["returnNulls"] = returnNulls
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["groupId"] = groupId
	bzz_query["subGroupIds"] = subGroupIds
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ConnectionGroupResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func add_sub_groups_threaded(
	# returnNulls: bool   Eg: true
	# whether to return nulls or not
	returnNulls: bool,
	# groupId: float   Eg: 789
	# the parent group id
	groupId: float,
	# subGroupIds: String = ""   Eg: subGroupIds_example
	# comma separated list of group IDs to add to the parent group
	subGroupIds: String,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "add_sub_groups")
	bzz_callable.bind(
		returnNulls,
		groupId,
		subGroupIds,
		deviceId,
		accountId,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createOrUpdateConnection → POST /consumer/connection/add
# Create or Update Connection
#
# Creates or updates the connection of the user and another account. Allows a user to follow, block, mark as trusted, and/or add someone to a group.
func create_or_update_connection(
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# connectionId: float   Eg: 789
	# the connection id for editing
	connectionId = null,
	# connectionAccountId: float   Eg: 789
	# the connection account id (i.e. the account id of another user)
	connectionAccountId = null,
	# pendingId: float   Eg: 789
	# the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps)
	pendingId = null,
	# groupId: float   Eg: 789
	# optional group id if the user wants to add this person into a group
	groupId = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# isTrusted: bool   Eg: true
	# determines whether the user is trusting this account
	isTrusted = null,
	# ignoreFriendRequest: bool   Eg: true
	# determines whether the user has set to ignore the user's friend request
	ignoreFriendRequest = null,
	# isContact: bool   Eg: true
	# determines whether the user is a contact of this account
	isContact = null,
	# isBlocked: bool   Eg: true
	# determines whether the user is blocking this account
	isBlocked = null,
	# isFollowing: bool   Eg: true
	# determines whether the user is following this account
	isFollowing = null,
	# connectionResponse: bool   Eg: true
	# whether to return the connection response or not
	connectionResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/connection/add"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["connectionId"] = connectionId
	bzz_query["connectionAccountId"] = connectionAccountId
	bzz_query["pendingId"] = pendingId
	bzz_query["groupId"] = groupId
	bzz_query["gameType"] = gameType
	bzz_query["appKey"] = appKey
	bzz_query["isTrusted"] = isTrusted
	bzz_query["ignoreFriendRequest"] = ignoreFriendRequest
	bzz_query["isContact"] = isContact
	bzz_query["isBlocked"] = isBlocked
	bzz_query["isFollowing"] = isFollowing
	bzz_query["connectionResponse"] = connectionResponse

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ConnectionResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_or_update_connection_threaded(
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# connectionId: float   Eg: 789
	# the connection id for editing
	connectionId = null,
	# connectionAccountId: float   Eg: 789
	# the connection account id (i.e. the account id of another user)
	connectionAccountId = null,
	# pendingId: float   Eg: 789
	# the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps)
	pendingId = null,
	# groupId: float   Eg: 789
	# optional group id if the user wants to add this person into a group
	groupId = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# isTrusted: bool   Eg: true
	# determines whether the user is trusting this account
	isTrusted = null,
	# ignoreFriendRequest: bool   Eg: true
	# determines whether the user has set to ignore the user's friend request
	ignoreFriendRequest = null,
	# isContact: bool   Eg: true
	# determines whether the user is a contact of this account
	isContact = null,
	# isBlocked: bool   Eg: true
	# determines whether the user is blocking this account
	isBlocked = null,
	# isFollowing: bool   Eg: true
	# determines whether the user is following this account
	isFollowing = null,
	# connectionResponse: bool   Eg: true
	# whether to return the connection response or not
	connectionResponse = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_or_update_connection")
	bzz_callable.bind(
		deviceId,
		accountId,
		connectionId,
		connectionAccountId,
		pendingId,
		groupId,
		gameType,
		appKey,
		isTrusted,
		ignoreFriendRequest,
		isContact,
		isBlocked,
		isFollowing,
		connectionResponse,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation createOrUpdateGroup → POST /consumer/connection/group
# Create or Update Connection Group
#
# Creates a new private group.
func create_or_update_group(
	# returnNulls: bool   Eg: true
	# whether to return nulls or not
	returnNulls: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# name: String = ""   Eg: name_example
	# the name of the group
	name = "",
	# groupId: float   Eg: 789
	# the group id to update a group (don't pass anything in if you want to create a new group)
	groupId = null,
	# assetId: float   Eg: 789
	# the asset to attach to the group
	assetId = null,
	# connections: String = ""   Eg: connections_example
	# comma separated list of connection IDs
	connections = "",
	# description: String = ""   Eg: description_example
	# the description of the group
	description = "",
	# canViewProfileInfo: bool   Eg: true
	# determines whether the connections in the group can see the user's profile info
	canViewProfileInfo = null,
	# canViewGameInfo: bool   Eg: true
	# determines whether the connections in the group can see the user's game info
	canViewGameInfo = null,
	# canViewFriendInfo: bool   Eg: true
	# determines whether the connections in the group can see the user's friends/connections
	canViewFriendInfo = null,
	# active: bool   Eg: true
	# Sets whether the connection group is active or inactive
	active = null,
	# latitude: int   Eg: 1.2
	# the latitude of the group
	latitude = null,
	# longitude: int   Eg: 1.2
	# the longitude of the group
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/connection/group"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["returnNulls"] = returnNulls
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["name"] = name
	bzz_query["groupId"] = groupId
	bzz_query["assetId"] = assetId
	bzz_query["connections"] = connections
	bzz_query["description"] = description
	bzz_query["canViewProfileInfo"] = canViewProfileInfo
	bzz_query["canViewGameInfo"] = canViewGameInfo
	bzz_query["canViewFriendInfo"] = canViewFriendInfo
	bzz_query["active"] = active
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func create_or_update_group_threaded(
	# returnNulls: bool   Eg: true
	# whether to return nulls or not
	returnNulls: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# name: String = ""   Eg: name_example
	# the name of the group
	name = "",
	# groupId: float   Eg: 789
	# the group id to update a group (don't pass anything in if you want to create a new group)
	groupId = null,
	# assetId: float   Eg: 789
	# the asset to attach to the group
	assetId = null,
	# connections: String = ""   Eg: connections_example
	# comma separated list of connection IDs
	connections = "",
	# description: String = ""   Eg: description_example
	# the description of the group
	description = "",
	# canViewProfileInfo: bool   Eg: true
	# determines whether the connections in the group can see the user's profile info
	canViewProfileInfo = null,
	# canViewGameInfo: bool   Eg: true
	# determines whether the connections in the group can see the user's game info
	canViewGameInfo = null,
	# canViewFriendInfo: bool   Eg: true
	# determines whether the connections in the group can see the user's friends/connections
	canViewFriendInfo = null,
	# active: bool   Eg: true
	# Sets whether the connection group is active or inactive
	active = null,
	# latitude: int   Eg: 1.2
	# the latitude of the group
	latitude = null,
	# longitude: int   Eg: 1.2
	# the longitude of the group
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "create_or_update_group")
	bzz_callable.bind(
		returnNulls,
		deviceId,
		accountId,
		name,
		groupId,
		assetId,
		connections,
		description,
		canViewProfileInfo,
		canViewGameInfo,
		canViewFriendInfo,
		active,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation followAccept → POST /consumer/follow/accept
# Accept Follow Request
#
# Accept someone's follow request.
func follow_accept(
	# accountId: float   Eg: 789
	# the account id of the user
	accountId: float,
	# connectionAccountId: float   Eg: 789
	# the account ID of the user who initiated the follow
	connectionAccountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key for sending notifications
	appKey: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/follow/accept"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["connectionAccountId"] = connectionAccountId
	bzz_query["appKey"] = appKey

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func follow_accept_threaded(
	# accountId: float   Eg: 789
	# the account id of the user
	accountId: float,
	# connectionAccountId: float   Eg: 789
	# the account ID of the user who initiated the follow
	connectionAccountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key for sending notifications
	appKey: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "follow_accept")
	bzz_callable.bind(
		accountId,
		connectionAccountId,
		appKey,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation followReject → POST /consumer/follow/reject
# Reject Follow Request
#
# Reject someone's follow request or remove them as a follower.
func follow_reject(
	# accountId: float   Eg: 789
	# the account id of the user
	accountId: float,
	# connectionAccountId: float   Eg: 789
	# the account ID of the user who initiated the follow
	connectionAccountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key for sending notifications
	appKey: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/follow/reject"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["connectionAccountId"] = connectionAccountId
	bzz_query["appKey"] = appKey

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func follow_reject_threaded(
	# accountId: float   Eg: 789
	# the account id of the user
	accountId: float,
	# connectionAccountId: float   Eg: 789
	# the account ID of the user who initiated the follow
	connectionAccountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key for sending notifications
	appKey: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "follow_reject")
	bzz_callable.bind(
		accountId,
		connectionAccountId,
		appKey,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation followRemove → POST /consumer/follow/remove
# Remove Follower / Unfollow
#
# Unfollow someone you are following or remove them as a follower.
func follow_remove(
	# accountId: float   Eg: 789
	# the account id of the user
	accountId: float,
	# connectionAccountId: float   Eg: 789
	# the account ID of the user who you want to unfollow
	connectionAccountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key for sending notifications
	appKey: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/follow/remove"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["connectionAccountId"] = connectionAccountId
	bzz_query["appKey"] = appKey

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func follow_remove_threaded(
	# accountId: float   Eg: 789
	# the account id of the user
	accountId: float,
	# connectionAccountId: float   Eg: 789
	# the account ID of the user who you want to unfollow
	connectionAccountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key for sending notifications
	appKey: String,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "follow_remove")
	bzz_callable.bind(
		accountId,
		connectionAccountId,
		appKey,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation followRequest → POST /consumer/follow/request
# Send Follow Request
#
# Send a request to follow someone.
func follow_request(
	# accountId: float   Eg: 789
	# the account id of the user
	accountId: float,
	# connectionAccountId: float   Eg: 789
	# the account ID of the user who you want to follow
	connectionAccountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key for sending notifications
	appKey: String,
	# approvalNeeded: bool = true   Eg: true
	# determines if the other user needs to confirm the follow request
	approvalNeeded = true,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/follow/request"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["accountId"] = accountId
	bzz_query["connectionAccountId"] = connectionAccountId
	bzz_query["appKey"] = appKey
	bzz_query["approvalNeeded"] = approvalNeeded

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func follow_request_threaded(
	# accountId: float   Eg: 789
	# the account id of the user
	accountId: float,
	# connectionAccountId: float   Eg: 789
	# the account ID of the user who you want to follow
	connectionAccountId: float,
	# appKey: String = ""   Eg: appKey_example
	# the application key for sending notifications
	appKey: String,
	# approvalNeeded: bool = true   Eg: true
	# determines if the other user needs to confirm the follow request
	approvalNeeded = true,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "follow_request")
	bzz_callable.bind(
		accountId,
		connectionAccountId,
		appKey,
		approvalNeeded,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation friendAccept → POST /consumer/friend/accept
# Accept Friend
#
# Accept a friend request and optionally sends a notification.
func friend_accept(
	# friendAccountId: float   Eg: 789
	# the friend's account id
	friendAccountId: float,
	# notifyFriend: bool   Eg: true
	# determines whether to send a notification to the afflicting party
	notifyFriend: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# notificationMessage: String = ""   Eg: notificationMessage_example
	# optional message to send in a notification
	notificationMessage = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/friend/accept"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["friendAccountId"] = friendAccountId
	bzz_query["gameType"] = gameType
	bzz_query["appKey"] = appKey
	bzz_query["notifyFriend"] = notifyFriend
	bzz_query["notificationMessage"] = notificationMessage

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func friend_accept_threaded(
	# friendAccountId: float   Eg: 789
	# the friend's account id
	friendAccountId: float,
	# notifyFriend: bool   Eg: true
	# determines whether to send a notification to the afflicting party
	notifyFriend: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# notificationMessage: String = ""   Eg: notificationMessage_example
	# optional message to send in a notification
	notificationMessage = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "friend_accept")
	bzz_callable.bind(
		friendAccountId,
		notifyFriend,
		deviceId,
		accountId,
		gameType,
		appKey,
		notificationMessage,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation friendReject → POST /consumer/friend/reject
# Decline Friend
#
# Request a friend request and optionally sends a notification.
func friend_reject(
	# friendAccountId: float   Eg: 789
	# the friend's account id
	friendAccountId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# notifyFriend: bool   Eg: true
	# determines whether to send a notification to the afflicting party
	notifyFriend = null,
	# notificationMessage: String = ""   Eg: notificationMessage_example
	# optional message to send in a notification
	notificationMessage = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/friend/reject"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["friendAccountId"] = friendAccountId
	bzz_query["gameType"] = gameType
	bzz_query["appKey"] = appKey
	bzz_query["notifyFriend"] = notifyFriend
	bzz_query["notificationMessage"] = notificationMessage

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func friend_reject_threaded(
	# friendAccountId: float   Eg: 789
	# the friend's account id
	friendAccountId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# notifyFriend: bool   Eg: true
	# determines whether to send a notification to the afflicting party
	notifyFriend = null,
	# notificationMessage: String = ""   Eg: notificationMessage_example
	# optional message to send in a notification
	notificationMessage = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "friend_reject")
	bzz_callable.bind(
		friendAccountId,
		deviceId,
		accountId,
		gameType,
		appKey,
		notifyFriend,
		notificationMessage,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation friendRemove → POST /consumer/friend/remove
# Delete Friend
#
# Removes a friend from the user's friends list.
func friend_remove(
	# friendAccountId: float   Eg: 789
	# the account ID of the friend to remove
	friendAccountId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# notifyFriend: bool   Eg: true
	# optionally notifies the connection that they have been removed as a friend
	notifyFriend = null,
	# removeFromGroups: bool   Eg: true
	# optionally removes the connection from the user's groups
	removeFromGroups = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/friend/remove"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["friendAccountId"] = friendAccountId
	bzz_query["notifyFriend"] = notifyFriend
	bzz_query["removeFromGroups"] = removeFromGroups

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func friend_remove_threaded(
	# friendAccountId: float   Eg: 789
	# the account ID of the friend to remove
	friendAccountId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# notifyFriend: bool   Eg: true
	# optionally notifies the connection that they have been removed as a friend
	notifyFriend = null,
	# removeFromGroups: bool   Eg: true
	# optionally removes the connection from the user's groups
	removeFromGroups = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "friend_remove")
	bzz_callable.bind(
		friendAccountId,
		deviceId,
		accountId,
		notifyFriend,
		removeFromGroups,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation friendRequest → POST /consumer/friend/request
# Request Friend
#
# Sends a friend request notification to another user.
func friend_request(
	# friendAccountId: float   Eg: 789
	# the friend's account id
	friendAccountId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# notificationMessage: String = ""   Eg: notificationMessage_example
	# optional message to send in a notification
	notificationMessage = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/friend/request"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["friendAccountId"] = friendAccountId
	bzz_query["gameType"] = gameType
	bzz_query["appKey"] = appKey
	bzz_query["notificationMessage"] = notificationMessage

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func friend_request_threaded(
	# friendAccountId: float   Eg: 789
	# the friend's account id
	friendAccountId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the application key
	appKey = "",
	# notificationMessage: String = ""   Eg: notificationMessage_example
	# optional message to send in a notification
	notificationMessage = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "friend_request")
	bzz_callable.bind(
		friendAccountId,
		deviceId,
		accountId,
		gameType,
		appKey,
		notificationMessage,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getConnectionSentFriendRequests → GET /consumer/connection/getRequested
# Get Sent Friend Requests
#
# Gets the connection sent friend requests.
func get_connection_sent_friend_requests(
	# deviceId: String = ""   Eg: deviceId_example
	# the ID of the device
	deviceId = "",
	# accountId: float   Eg: 789
	# the id of the account
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/connection/getRequested"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ConnectionListResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_connection_sent_friend_requests_threaded(
	# deviceId: String = ""   Eg: deviceId_example
	# the ID of the device
	deviceId = "",
	# accountId: float   Eg: 789
	# the id of the account
	accountId = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_connection_sent_friend_requests")
	bzz_callable.bind(
		deviceId,
		accountId,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getConnections → GET /consumer/connection/get
# Search Connections
#
# Gets the connections.
func get_connections(
	# returnNulls: bool   Eg: true
	# whether to return nulls or not
	returnNulls: bool,
	# filter: String = ""   Eg: filter_example
	# a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)
	filter: String,
	# sortField: String = ""   Eg: sortField_example
	# sorts the response list by ConnectionApiMap
	sortField: String,
	# descending: bool   Eg: true
	# sorts the response list by descending order if true
	descending: bool,
	# start: int   Eg: 56
	# start index of the pagination
	start: int,
	# limit: int   Eg: 56
	# limit of the pagination
	limit: int,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id (deviceId or accountId required)
	accountId = null,
	# connectionAccountId: float   Eg: 789
	# optional parameter to search on other account's connections
	connectionAccountId = null,
	# q: String = ""   Eg: q_example
	# This parameter is deprecated.
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# an optional keyword to search on, this parameter is ignored if empty
	keyword = "",
	# i: int   Eg: 56
	# This parameter is deprecated.
	i = null,
	# l: int   Eg: 56
	# This parameter is deprecated.
	l = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/connection/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["returnNulls"] = returnNulls
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["connectionAccountId"] = connectionAccountId
	bzz_query["filter"] = filter
	bzz_query["q"] = q
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["_i"] = i
	bzz_query["start"] = start
	bzz_query["_l"] = l
	bzz_query["limit"] = limit
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ConnectionListResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_connections_threaded(
	# returnNulls: bool   Eg: true
	# whether to return nulls or not
	returnNulls: bool,
	# filter: String = ""   Eg: filter_example
	# a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)
	filter: String,
	# sortField: String = ""   Eg: sortField_example
	# sorts the response list by ConnectionApiMap
	sortField: String,
	# descending: bool   Eg: true
	# sorts the response list by descending order if true
	descending: bool,
	# start: int   Eg: 56
	# start index of the pagination
	start: int,
	# limit: int   Eg: 56
	# limit of the pagination
	limit: int,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id (deviceId or accountId required)
	accountId = null,
	# connectionAccountId: float   Eg: 789
	# optional parameter to search on other account's connections
	connectionAccountId = null,
	# q: String = ""   Eg: q_example
	# This parameter is deprecated.
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# an optional keyword to search on, this parameter is ignored if empty
	keyword = "",
	# i: int   Eg: 56
	# This parameter is deprecated.
	i = null,
	# l: int   Eg: 56
	# This parameter is deprecated.
	l = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_connections")
	bzz_callable.bind(
		returnNulls,
		filter,
		sortField,
		descending,
		start,
		limit,
		deviceId,
		accountId,
		connectionAccountId,
		q,
		keyword,
		i,
		l,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation getGroupDetails → GET /consumer/connection/group/details/get
# Get Connection Group
func get_group_details(
	# combineConnections: bool   Eg: true
	# whether to combine connections or not
	combineConnections: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# groupId: float   Eg: 789
	# the group id
	groupId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/connection/group/details/get"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["groupId"] = groupId
	bzz_query["combineConnections"] = combineConnections
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ConnectionGroupResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func get_group_details_threaded(
	# combineConnections: bool   Eg: true
	# whether to combine connections or not
	combineConnections: bool,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# groupId: float   Eg: 789
	# the group id
	groupId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "get_group_details")
	bzz_callable.bind(
		combineConnections,
		deviceId,
		accountId,
		groupId,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation groupSearch → GET /connection/group/search
# Search Connection Groups
#
# Gets a user's private groups and default groups.
func group_search(
	# sortField: String = ""   Eg: sortField_example
	# the field to sort by
	sortField: String,
	# descending: bool   Eg: true
	# whether to return results in descending or ascending order
	descending: bool,
	# activeOnly: bool   Eg: true
	# to search on active only or not
	activeOnly: bool,
	# start: int   Eg: 56
	# The start of the pagination
	start: int,
	# limit: int   Eg: 56
	# the limit of the pagination
	limit: int,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	# keyword: String = ""   Eg: keyword_example
	# keyword search string
	keyword = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/connection/group/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["keyword"] = keyword
	bzz_query["sortField"] = sortField
	bzz_query["descending"] = descending
	bzz_query["activeOnly"] = activeOnly
	bzz_query["start"] = start
	bzz_query["limit"] = limit

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ConnectionInfoResponse.bzz_denormalize_multiple(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func group_search_threaded(
	# sortField: String = ""   Eg: sortField_example
	# the field to sort by
	sortField: String,
	# descending: bool   Eg: true
	# whether to return results in descending or ascending order
	descending: bool,
	# activeOnly: bool   Eg: true
	# to search on active only or not
	activeOnly: bool,
	# start: int   Eg: 56
	# The start of the pagination
	start: int,
	# limit: int   Eg: 56
	# the limit of the pagination
	limit: int,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	# keyword: String = ""   Eg: keyword_example
	# keyword search string
	keyword = "",
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "group_search")
	bzz_callable.bind(
		sortField,
		descending,
		activeOnly,
		start,
		limit,
		deviceId,
		accountId,
		latitude,
		longitude,
		keyword,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation removeConnectionFromGroup → POST /consumer/connection/group/removeConnection
# Delete Connection
#
# Removes the connection from group.
func remove_connection_from_group(
	# returnNulls: bool   Eg: true
	# whether to return nulls or not
	returnNulls: bool,
	# groupId: float   Eg: 789
	# the group id
	groupId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# connectionId: float   Eg: 789
	# the connection id
	connectionId = null,
	# connectionAccountId: float   Eg: 789
	# the connection account id
	connectionAccountId = null,
	# pendingId: float   Eg: 789
	# the pending id
	pendingId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/connection/group/removeConnection"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["returnNulls"] = returnNulls
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["connectionId"] = connectionId
	bzz_query["connectionAccountId"] = connectionAccountId
	bzz_query["pendingId"] = pendingId
	bzz_query["groupId"] = groupId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func remove_connection_from_group_threaded(
	# returnNulls: bool   Eg: true
	# whether to return nulls or not
	returnNulls: bool,
	# groupId: float   Eg: 789
	# the group id
	groupId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# connectionId: float   Eg: 789
	# the connection id
	connectionId = null,
	# connectionAccountId: float   Eg: 789
	# the connection account id
	connectionAccountId = null,
	# pendingId: float   Eg: 789
	# the pending id
	pendingId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "remove_connection_from_group")
	bzz_callable.bind(
		returnNulls,
		groupId,
		deviceId,
		accountId,
		connectionId,
		connectionAccountId,
		pendingId,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation removeConnectionsFromGroup → POST /connection/group/removeConnections
# Remove Connections
#
# Remove a list of connections from a group.
func remove_connections_from_group(
	# connectionGroupId: float   Eg: 789
	# connection group id
	connectionGroupId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# connectionIds: String = ""   Eg: connectionIds_example
	# comma separated list of connection ids
	connectionIds = "",
	# connectionAccountIds: String = ""   Eg: connectionAccountIds_example
	# comma separated list of connection account ids
	connectionAccountIds = "",
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/connection/group/removeConnections"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["connectionIds"] = connectionIds
	bzz_query["connectionAccountIds"] = connectionAccountIds
	bzz_query["connectionGroupId"] = connectionGroupId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func remove_connections_from_group_threaded(
	# connectionGroupId: float   Eg: 789
	# connection group id
	connectionGroupId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# connectionIds: String = ""   Eg: connectionIds_example
	# comma separated list of connection ids
	connectionIds = "",
	# connectionAccountIds: String = ""   Eg: connectionAccountIds_example
	# comma separated list of connection account ids
	connectionAccountIds = "",
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "remove_connections_from_group")
	bzz_callable.bind(
		connectionGroupId,
		deviceId,
		accountId,
		connectionIds,
		connectionAccountIds,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation removeGroup → POST /consumer/connection/group/remove
# Delete Connection Group
#
# Remove a user's group.
func remove_group(
	# returnNulls: bool   Eg: true
	# whether to return nulls or not
	returnNulls: bool,
	# groupId: float   Eg: 789
	# the group id
	groupId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/connection/group/remove"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["returnNulls"] = returnNulls
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["groupId"] = groupId
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func remove_group_threaded(
	# returnNulls: bool   Eg: true
	# whether to return nulls or not
	returnNulls: bool,
	# groupId: float   Eg: 789
	# the group id
	groupId: float,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "remove_group")
	bzz_callable.bind(
		returnNulls,
		groupId,
		deviceId,
		accountId,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation removeSubGroups → POST /consumer/connection/group/removeSubGroup
# Remove Connection Groups
#
# Remove sub groups from a group
func remove_sub_groups(
	# returnNulls: bool   Eg: true
	# whether to return nulls or not
	returnNulls: bool,
	# groupId: float   Eg: 789
	# the parent group id
	groupId: float,
	# subGroupIds: String = ""   Eg: subGroupIds_example
	# comma separated list of group IDs to remove from the parent group
	subGroupIds: String,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("POST")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/consumer/connection/group/removeSubGroup"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["returnNulls"] = returnNulls
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["groupId"] = groupId
	bzz_query["subGroupIds"] = subGroupIds
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = SirqulResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func remove_sub_groups_threaded(
	# returnNulls: bool   Eg: true
	# whether to return nulls or not
	returnNulls: bool,
	# groupId: float   Eg: 789
	# the parent group id
	groupId: float,
	# subGroupIds: String = ""   Eg: subGroupIds_example
	# comma separated list of group IDs to remove from the parent group
	subGroupIds: String,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id of the user (deviceId or accountId required)
	accountId = null,
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "remove_sub_groups")
	bzz_callable.bind(
		returnNulls,
		groupId,
		subGroupIds,
		deviceId,
		accountId,
		latitude,
		longitude,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


# Operation searchConnections → GET /connection/search
# Search Possible Connections
#
# Search for accounts that the user may not have a connection with.
func search_connections(
	# returnNulls: bool   Eg: true
	# return all json attributes if true. defualt is true.
	returnNulls: bool,
	# start: int   Eg: 56
	# start index of the pagination
	start: int,
	# limit: int   Eg: 56
	# limit of the pagination
	limit: int,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id (deviceId or accountId required)
	accountId = null,
	# q: String = ""   Eg: q_example
	# This parameter is deprecated.
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# keyword to search on, optional and this parameter is ignored if empt
	keyword = "",
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the public application key, if provided only looks for users of that application
	appKey = "",
	# i: int   Eg: 56
	# This parameter is deprecated.
	i = null,
	# l: int   Eg: 56
	# This parameter is deprecated.
	l = null,
	# sortField: String = ""   Eg: sortField_example
	# the field to sort on
	sortField = "",
	# hasLocation: bool   Eg: true
	# whether the search has location or not
	hasLocation = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
):

	# Convert the String HTTP method to a Constant Godot understands
	var bzz_method := self._bzz_convert_http_method("GET")

	# Compute the URL path to the API resource
	var bzz_path := "/api/3.18/connection/search"

	# Collect the headers
	var bzz_headers := Dictionary()
	var bzz_mimes_produced_by_server := ['*/*']
	for bzz_mime in BZZ_CONSUMABLE_CONTENT_TYPES:
		if bzz_mime in bzz_mimes_produced_by_server:
			bzz_headers["Accept"] = bzz_mime
			break

	# Collect the query parameters
	# Note: we do not support multiple values for a single param (for now), nor arrays
	var bzz_query := Dictionary()
	bzz_query["returnNulls"] = returnNulls
	bzz_query["deviceId"] = deviceId
	bzz_query["accountId"] = accountId
	bzz_query["q"] = q
	bzz_query["keyword"] = keyword
	bzz_query["latitude"] = latitude
	bzz_query["longitude"] = longitude
	bzz_query["gameType"] = gameType
	bzz_query["appKey"] = appKey
	bzz_query["_i"] = i
	bzz_query["start"] = start
	bzz_query["_l"] = l
	bzz_query["limit"] = limit
	bzz_query["sortField"] = sortField
	bzz_query["hasLocation"] = hasLocation

	var bzz_body = null

	self._bzz_request(
		bzz_method, bzz_path, bzz_headers, bzz_query, bzz_body,
		func(bzz_response):
			bzz_response.data = ConnectionListResponse.bzz_denormalize_single(bzz_response.data)
			on_success.call(bzz_response)
			,
		func(bzz_error):
			on_failure.call(bzz_error)
			,  # ざわ‥
	)


func search_connections_threaded(
	# returnNulls: bool   Eg: true
	# return all json attributes if true. defualt is true.
	returnNulls: bool,
	# start: int   Eg: 56
	# start index of the pagination
	start: int,
	# limit: int   Eg: 56
	# limit of the pagination
	limit: int,
	# deviceId: String = ""   Eg: deviceId_example
	# the device id (deviceId or accountId required)
	deviceId = "",
	# accountId: float   Eg: 789
	# the account id (deviceId or accountId required)
	accountId = null,
	# q: String = ""   Eg: q_example
	# This parameter is deprecated.
	q = "",
	# keyword: String = ""   Eg: keyword_example
	# keyword to search on, optional and this parameter is ignored if empt
	keyword = "",
	# latitude: int   Eg: 1.2
	# the current latitude of the user
	latitude = null,
	# longitude: int   Eg: 1.2
	# the current longitude of the user
	longitude = null,
	# gameType: String = ""   Eg: gameType_example
	# This parameter is deprecated.
	gameType = "",
	# appKey: String = ""   Eg: appKey_example
	# the public application key, if provided only looks for users of that application
	appKey = "",
	# i: int   Eg: 56
	# This parameter is deprecated.
	i = null,
	# l: int   Eg: 56
	# This parameter is deprecated.
	l = null,
	# sortField: String = ""   Eg: sortField_example
	# the field to sort on
	sortField = "",
	# hasLocation: bool   Eg: true
	# whether the search has location or not
	hasLocation = null,
	on_success: Callable = Callable(),  # func(response: ApiResponse)
	on_failure: Callable = Callable(),  # func(error: ApiError)
) -> Thread:
	var bzz_thread := Thread.new()
	var bzz_callable := Callable(self, "search_connections")
	bzz_callable.bind(
		returnNulls,
		start,
		limit,
		deviceId,
		accountId,
		q,
		keyword,
		latitude,
		longitude,
		gameType,
		appKey,
		i,
		l,
		sortField,
		hasLocation,
		on_success,
		on_failure,
	)
	bzz_thread.start(bzz_callable)
	return bzz_thread


