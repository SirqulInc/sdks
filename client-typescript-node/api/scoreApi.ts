/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET[\'appKey\']);$b = htmlspecialchars($_GET[\'appRestKey\']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { ScoreResponse } from '../model/scoreResponse';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'http://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum ScoreApiApiKeys {
    appKey,
    restKey,
}

export class ScoreApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'appKey': new ApiKeyAuth('header', 'Application-Key'),
        'restKey': new ApiKeyAuth('header', 'Application-Rest-Key'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: ScoreApiApiKeys, value: string) {
        (this.authentications as any)[ScoreApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Create a score.  The response object will contain a series of   coded messages detailing what items were completed, the score registered,   and any tickets allocated.  Scoring a  level could complete the pack it   is in, completing that pack could complete the game, which  in turn could   complete the mission.  This completion chain is indicated to the client   via  a list of {@link MessageResponse}.
     * @summary Create Score
     * @param version 
     * @param accountId The logged in user.
     * @param appKey The game application key to save the score for.
     * @param points The score
     * @param missionId The missionId to score for, ignore if not playing mission.
     * @param gameId The gameId to score for, ignore if not playing mission.
     * @param packId The packId to score for, send -2 if playing community levels.
     * @param gameLevelId The gameLevelId to score for.
     * @param gameObjectId The gameObjectId to score for, ignore if level based scoring.
     * @param timeTaken The time taken to complete task
     * @param highest 
     */
    public async createScore (version: number, accountId: number, appKey: string, points: number, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, timeTaken?: number, highest?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ScoreResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/score/create'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling createScore.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createScore.');
        }

        // verify required parameter 'appKey' is not null or undefined
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling createScore.');
        }

        // verify required parameter 'points' is not null or undefined
        if (points === null || points === undefined) {
            throw new Error('Required parameter points was null or undefined when calling createScore.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (missionId !== undefined) {
            localVarQueryParameters['missionId'] = ObjectSerializer.serialize(missionId, "number");
        }

        if (gameId !== undefined) {
            localVarQueryParameters['gameId'] = ObjectSerializer.serialize(gameId, "number");
        }

        if (packId !== undefined) {
            localVarQueryParameters['packId'] = ObjectSerializer.serialize(packId, "number");
        }

        if (gameLevelId !== undefined) {
            localVarQueryParameters['gameLevelId'] = ObjectSerializer.serialize(gameLevelId, "number");
        }

        if (gameObjectId !== undefined) {
            localVarQueryParameters['gameObjectId'] = ObjectSerializer.serialize(gameObjectId, "number");
        }

        if (points !== undefined) {
            localVarQueryParameters['points'] = ObjectSerializer.serialize(points, "number");
        }

        if (timeTaken !== undefined) {
            localVarQueryParameters['timeTaken'] = ObjectSerializer.serialize(timeTaken, "number");
        }

        if (highest !== undefined) {
            localVarQueryParameters['highest'] = ObjectSerializer.serialize(highest, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ScoreResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ScoreResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get the high score for an item.  Pass in the full path IDs for the score.
     * @summary Get Score
     * @param version 
     * @param accountId The logged in user.
     * @param appKey The game application key to get the level for.
     * @param missionId The missionId to score for, null if not playing mission.
     * @param gameId The gameId to score for, null if not playing mission.
     * @param packId The packId to score for, null if playing community levels.
     * @param gameLevelId The gameLevelId to score for.
     * @param gameObjectId The gameObjectId to score for, null if level based scoring.
     * @param scoreObjectType The object type to filter scores by (TicketObjectType)
     * @param scoreStatus The status of the score to filter (ScoreStatus)
     */
    public async getScore (version: number, accountId: number, appKey: string, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, scoreObjectType?: string, scoreStatus?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ScoreResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/score/get'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getScore.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getScore.');
        }

        // verify required parameter 'appKey' is not null or undefined
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling getScore.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (missionId !== undefined) {
            localVarQueryParameters['missionId'] = ObjectSerializer.serialize(missionId, "number");
        }

        if (gameId !== undefined) {
            localVarQueryParameters['gameId'] = ObjectSerializer.serialize(gameId, "number");
        }

        if (packId !== undefined) {
            localVarQueryParameters['packId'] = ObjectSerializer.serialize(packId, "number");
        }

        if (gameLevelId !== undefined) {
            localVarQueryParameters['gameLevelId'] = ObjectSerializer.serialize(gameLevelId, "number");
        }

        if (gameObjectId !== undefined) {
            localVarQueryParameters['gameObjectId'] = ObjectSerializer.serialize(gameObjectId, "number");
        }

        if (scoreObjectType !== undefined) {
            localVarQueryParameters['scoreObjectType'] = ObjectSerializer.serialize(scoreObjectType, "string");
        }

        if (scoreStatus !== undefined) {
            localVarQueryParameters['scoreStatus'] = ObjectSerializer.serialize(scoreStatus, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ScoreResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ScoreResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Search the scores for an item.  Pass in the full path IDs for the scores.
     * @summary Search Score
     * @param version 
     * @param accountId The logged in user.
     * @param appKey The game application key to get the level for.
     * @param missionId The missionId to score for, null if not playing mission.
     * @param gameId The gameId to score for, null if not playing mission.
     * @param packId The packId to score for, null if playing community levels.
     * @param gameLevelId The gameLevelId to score for.
     * @param gameObjectId The gameObjectId to score for, null if level based scoring.
     */
    public async searchScores (version: number, accountId: number, appKey: string, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<ScoreResponse>;  }> {
        const localVarPath = this.basePath + '/api/{version}/score/search'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling searchScores.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling searchScores.');
        }

        // verify required parameter 'appKey' is not null or undefined
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling searchScores.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (missionId !== undefined) {
            localVarQueryParameters['missionId'] = ObjectSerializer.serialize(missionId, "number");
        }

        if (gameId !== undefined) {
            localVarQueryParameters['gameId'] = ObjectSerializer.serialize(gameId, "number");
        }

        if (packId !== undefined) {
            localVarQueryParameters['packId'] = ObjectSerializer.serialize(packId, "number");
        }

        if (gameLevelId !== undefined) {
            localVarQueryParameters['gameLevelId'] = ObjectSerializer.serialize(gameLevelId, "number");
        }

        if (gameObjectId !== undefined) {
            localVarQueryParameters['gameObjectId'] = ObjectSerializer.serialize(gameObjectId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<ScoreResponse>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<ScoreResponse>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
