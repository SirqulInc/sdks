/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET[\'appKey\']);$b = htmlspecialchars($_GET[\'appRestKey\']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { CountResponse } from '../model/countResponse';
import { ProfileResponse } from '../model/profileResponse';
import { SirqulResponse } from '../model/sirqulResponse';
import { TicketListResponse } from '../model/ticketListResponse';
import { TicketOfferResponse } from '../model/ticketOfferResponse';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'http://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum TicketApiApiKeys {
    appKey,
    restKey,
}

export class TicketApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'appKey': new ApiKeyAuth('header', 'Application-Key'),
        'restKey': new ApiKeyAuth('header', 'Application-Rest-Key'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: TicketApiApiKeys, value: string) {
        (this.authentications as any)[TicketApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Gets the ticket count.
     * @summary Get Ticket Count
     * @param version 
     * @param deviceId the id of the device that owns the tickets
     * @param accountId the id of the account that owns the tickets
     * @param gameType this is deprecated.
     * @param appKey the applicationkey
     * @param ticketType the type of ticket
     */
    public async getTicketCount (version: number, deviceId?: string, accountId?: number, gameType?: string, appKey?: string, ticketType?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CountResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/ticket/count'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getTicketCount.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (gameType !== undefined) {
            localVarQueryParameters['gameType'] = ObjectSerializer.serialize(gameType, "string");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (ticketType !== undefined) {
            localVarQueryParameters['ticketType'] = ObjectSerializer.serialize(ticketType, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CountResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CountResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Gets the list of tickets.
     * @summary Get Ticket List
     * @param version 
     * @param deviceId the id of the device that owns the tickets
     * @param accountId the id of the account that owns the tickets
     * @param ticketObjectType comma separated list of TicketObjectType
     * @param actionType comma separated list of TicketActionType
     * @param ticketIds the ids of the tickets to get
     * @param objectIds the ids of the objects to get
     * @param receiptTokens 
     * @param gameType 
     * @param appKey the application key
     */
    public async getTicketList (version: number, deviceId?: string, accountId?: number, ticketObjectType?: string, actionType?: string, ticketIds?: string, objectIds?: string, receiptTokens?: string, gameType?: string, appKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TicketListResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/ticket/getList'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getTicketList.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (ticketObjectType !== undefined) {
            localVarQueryParameters['ticketObjectType'] = ObjectSerializer.serialize(ticketObjectType, "string");
        }

        if (actionType !== undefined) {
            localVarQueryParameters['actionType'] = ObjectSerializer.serialize(actionType, "string");
        }

        if (ticketIds !== undefined) {
            localVarQueryParameters['ticketIds'] = ObjectSerializer.serialize(ticketIds, "string");
        }

        if (objectIds !== undefined) {
            localVarQueryParameters['objectIds'] = ObjectSerializer.serialize(objectIds, "string");
        }

        if (receiptTokens !== undefined) {
            localVarQueryParameters['receiptTokens'] = ObjectSerializer.serialize(receiptTokens, "string");
        }

        if (gameType !== undefined) {
            localVarQueryParameters['gameType'] = ObjectSerializer.serialize(gameType, "string");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TicketListResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TicketListResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Gift tickets to another user.
     * @summary Gift Tickets
     * @param version 
     * @param receiverAccountId the id of the account receiving the tickets
     * @param ticketId the id of the tickets
     * @param deviceId the id of the device
     * @param accountId the id of the gift owner
     * @param assetId the id of the asset
     * @param customMessage a message that can be written to go along with the gift
     * @param gameType the type of game associated with the tickets
     * @param appKey the application key
     */
    public async giftPurchase (version: number, receiverAccountId: number, ticketId: number, deviceId?: string, accountId?: number, assetId?: number, customMessage?: string, gameType?: string, appKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/purchase/gift'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling giftPurchase.');
        }

        // verify required parameter 'receiverAccountId' is not null or undefined
        if (receiverAccountId === null || receiverAccountId === undefined) {
            throw new Error('Required parameter receiverAccountId was null or undefined when calling giftPurchase.');
        }

        // verify required parameter 'ticketId' is not null or undefined
        if (ticketId === null || ticketId === undefined) {
            throw new Error('Required parameter ticketId was null or undefined when calling giftPurchase.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (receiverAccountId !== undefined) {
            localVarQueryParameters['receiverAccountId'] = ObjectSerializer.serialize(receiverAccountId, "number");
        }

        if (ticketId !== undefined) {
            localVarQueryParameters['ticketId'] = ObjectSerializer.serialize(ticketId, "number");
        }

        if (assetId !== undefined) {
            localVarQueryParameters['assetId'] = ObjectSerializer.serialize(assetId, "number");
        }

        if (customMessage !== undefined) {
            localVarQueryParameters['customMessage'] = ObjectSerializer.serialize(customMessage, "string");
        }

        if (gameType !== undefined) {
            localVarQueryParameters['gameType'] = ObjectSerializer.serialize(gameType, "string");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Allow user to acquire a purchase item and generate a ticket record. Used to redeem tickets or add tickets to the system.
     * @summary Save Ticket
     * @param version 
     * @param actionType the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER
     * @param ticketObjectType the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM
     * @param returnNulls whether to return nulls or not
     * @param deviceId the device id that owns the tickets
     * @param accountId the account id that owns the tickets
     * @param gameType This parameter is deprecated. deprecated, use the appKey
     * @param appKey the application key
     * @param objectId the ID of the item being purchased
     * @param purchaseCode a unique string identifier defined by the application owner or Executive
     * @param receiptToken a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)
     * @param receiptData the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format.
     * @param count the count of tickets
     * @param ticketType the ticket type
     * @param purchaseProvider the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}
     * @param purchaseType a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }
     * @param returnProfileResponse returns a ProfileResponse if true, otherwise will return an AppResponse
     * @param includeProfileResponse if returnProfileResponse is false, will return an AppResponse with profile data if true
     * @param appVersion the application version
     */
    public async saveTicket (version: number, actionType: string, ticketObjectType: string, returnNulls?: boolean, deviceId?: string, accountId?: number, gameType?: string, appKey?: string, objectId?: number, purchaseCode?: string, receiptToken?: string, receiptData?: string, count?: number, ticketType?: string, purchaseProvider?: string, purchaseType?: string, returnProfileResponse?: boolean, includeProfileResponse?: boolean, appVersion?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ProfileResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/ticket/save'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling saveTicket.');
        }

        // verify required parameter 'actionType' is not null or undefined
        if (actionType === null || actionType === undefined) {
            throw new Error('Required parameter actionType was null or undefined when calling saveTicket.');
        }

        // verify required parameter 'ticketObjectType' is not null or undefined
        if (ticketObjectType === null || ticketObjectType === undefined) {
            throw new Error('Required parameter ticketObjectType was null or undefined when calling saveTicket.');
        }

        if (returnNulls !== undefined) {
            localVarQueryParameters['returnNulls'] = ObjectSerializer.serialize(returnNulls, "boolean");
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (gameType !== undefined) {
            localVarQueryParameters['gameType'] = ObjectSerializer.serialize(gameType, "string");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (actionType !== undefined) {
            localVarQueryParameters['actionType'] = ObjectSerializer.serialize(actionType, "string");
        }

        if (ticketObjectType !== undefined) {
            localVarQueryParameters['ticketObjectType'] = ObjectSerializer.serialize(ticketObjectType, "string");
        }

        if (objectId !== undefined) {
            localVarQueryParameters['objectId'] = ObjectSerializer.serialize(objectId, "number");
        }

        if (purchaseCode !== undefined) {
            localVarQueryParameters['purchaseCode'] = ObjectSerializer.serialize(purchaseCode, "string");
        }

        if (receiptToken !== undefined) {
            localVarQueryParameters['receiptToken'] = ObjectSerializer.serialize(receiptToken, "string");
        }

        if (receiptData !== undefined) {
            localVarQueryParameters['receiptData'] = ObjectSerializer.serialize(receiptData, "string");
        }

        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "number");
        }

        if (ticketType !== undefined) {
            localVarQueryParameters['ticketType'] = ObjectSerializer.serialize(ticketType, "string");
        }

        if (purchaseProvider !== undefined) {
            localVarQueryParameters['purchaseProvider'] = ObjectSerializer.serialize(purchaseProvider, "string");
        }

        if (purchaseType !== undefined) {
            localVarQueryParameters['purchaseType'] = ObjectSerializer.serialize(purchaseType, "string");
        }

        if (returnProfileResponse !== undefined) {
            localVarQueryParameters['returnProfileResponse'] = ObjectSerializer.serialize(returnProfileResponse, "boolean");
        }

        if (includeProfileResponse !== undefined) {
            localVarQueryParameters['includeProfileResponse'] = ObjectSerializer.serialize(includeProfileResponse, "boolean");
        }

        if (appVersion !== undefined) {
            localVarQueryParameters['appVersion'] = ObjectSerializer.serialize(appVersion, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ProfileResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ProfileResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Similar to the Save Ticket endpoint but allows the receiptData to be in binary format. This must be a multi-part post
     * @summary Save Ticket with Reciept
     * @param version 
     * @param actionType the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER }
     * @param ticketObjectType the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM}
     * @param receiptData the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format.
     * @param returnNulls whether to return nulls or not
     * @param deviceId the device id
     * @param accountId the account id
     * @param gameType This parameter is deprecated. deprecated, use the appKey
     * @param appKey the application key
     * @param objectId the ID of the item being purchased
     * @param purchaseCode a unique string identifier defined by the application owner or Executive
     * @param receiptToken a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)
     * @param count the count of tickets
     * @param ticketType the ticket type
     * @param purchaseProvider the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}
     * @param purchaseType a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }
     * @param returnProfileResponse returns a ProfileResponse if true, otherwise will return an AppResponse
     * @param includeProfileResponse if returnProfileResponse is false, will return an AppResponse with profile data if true
     * @param appVersion the application version
     */
    public async saveTicketViaFileUpload (version: number, actionType: string, ticketObjectType: string, receiptData: RequestFile, returnNulls?: boolean, deviceId?: string, accountId?: number, gameType?: string, appKey?: string, objectId?: number, purchaseCode?: string, receiptToken?: string, count?: number, ticketType?: string, purchaseProvider?: string, purchaseType?: string, returnProfileResponse?: boolean, includeProfileResponse?: boolean, appVersion?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ProfileResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/ticket/save/fileUpload'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling saveTicketViaFileUpload.');
        }

        // verify required parameter 'actionType' is not null or undefined
        if (actionType === null || actionType === undefined) {
            throw new Error('Required parameter actionType was null or undefined when calling saveTicketViaFileUpload.');
        }

        // verify required parameter 'ticketObjectType' is not null or undefined
        if (ticketObjectType === null || ticketObjectType === undefined) {
            throw new Error('Required parameter ticketObjectType was null or undefined when calling saveTicketViaFileUpload.');
        }

        // verify required parameter 'receiptData' is not null or undefined
        if (receiptData === null || receiptData === undefined) {
            throw new Error('Required parameter receiptData was null or undefined when calling saveTicketViaFileUpload.');
        }

        if (returnNulls !== undefined) {
            localVarQueryParameters['returnNulls'] = ObjectSerializer.serialize(returnNulls, "boolean");
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (gameType !== undefined) {
            localVarQueryParameters['gameType'] = ObjectSerializer.serialize(gameType, "string");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (actionType !== undefined) {
            localVarQueryParameters['actionType'] = ObjectSerializer.serialize(actionType, "string");
        }

        if (ticketObjectType !== undefined) {
            localVarQueryParameters['ticketObjectType'] = ObjectSerializer.serialize(ticketObjectType, "string");
        }

        if (objectId !== undefined) {
            localVarQueryParameters['objectId'] = ObjectSerializer.serialize(objectId, "number");
        }

        if (purchaseCode !== undefined) {
            localVarQueryParameters['purchaseCode'] = ObjectSerializer.serialize(purchaseCode, "string");
        }

        if (receiptToken !== undefined) {
            localVarQueryParameters['receiptToken'] = ObjectSerializer.serialize(receiptToken, "string");
        }

        if (receiptData !== undefined) {
            localVarQueryParameters['receiptData'] = ObjectSerializer.serialize(receiptData, "RequestFile");
        }

        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "number");
        }

        if (ticketType !== undefined) {
            localVarQueryParameters['ticketType'] = ObjectSerializer.serialize(ticketType, "string");
        }

        if (purchaseProvider !== undefined) {
            localVarQueryParameters['purchaseProvider'] = ObjectSerializer.serialize(purchaseProvider, "string");
        }

        if (purchaseType !== undefined) {
            localVarQueryParameters['purchaseType'] = ObjectSerializer.serialize(purchaseType, "string");
        }

        if (returnProfileResponse !== undefined) {
            localVarQueryParameters['returnProfileResponse'] = ObjectSerializer.serialize(returnProfileResponse, "boolean");
        }

        if (includeProfileResponse !== undefined) {
            localVarQueryParameters['includeProfileResponse'] = ObjectSerializer.serialize(includeProfileResponse, "boolean");
        }

        if (appVersion !== undefined) {
            localVarQueryParameters['appVersion'] = ObjectSerializer.serialize(appVersion, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ProfileResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ProfileResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a list offers for tickets owned by sirqul.  Purchasing these will add the number of tickets to the account specified by the offer.
     * @summary Get Ticket Offers
     * @param version 
     */
    public async ticketOffers (version: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TicketOfferResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/ticket/ticketoffers'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling ticketOffers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TicketOfferResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TicketOfferResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
