/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET[\'appKey\']);$b = htmlspecialchars($_GET[\'appRestKey\']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { NoteResponse } from '../model/noteResponse';
import { SirqulResponse } from '../model/sirqulResponse';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'http://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum NoteApiApiKeys {
    appKey,
    restKey,
}

export class NoteApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'appKey': new ApiKeyAuth('header', 'Application-Key'),
        'restKey': new ApiKeyAuth('header', 'Application-Rest-Key'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: NoteApiApiKeys, value: string) {
        (this.authentications as any)[NoteApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Perform a batch operation on notes for a notable object (for example: DELETE_ALL_NOTES_IN_NOTABLE). 
     * @summary Batch Note Operation
     * @param version 
     * @param notableId The id of the notable object the batch operation will affect
     * @param notableType The notable object type (for example ALBUM, ASSET, OFFER, etc.)
     * @param deviceId The device id (deviceId or accountId required)
     * @param accountId The account id of the user (deviceId or accountId required)
     * @param batchOperation The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional.
     */
    public async batchOperation (version: number, notableId: number, notableType: string, deviceId?: string, accountId?: number, batchOperation?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/note/batch'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling batchOperation.');
        }

        // verify required parameter 'notableId' is not null or undefined
        if (notableId === null || notableId === undefined) {
            throw new Error('Required parameter notableId was null or undefined when calling batchOperation.');
        }

        // verify required parameter 'notableType' is not null or undefined
        if (notableType === null || notableType === undefined) {
            throw new Error('Required parameter notableType was null or undefined when calling batchOperation.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (notableId !== undefined) {
            localVarQueryParameters['notableId'] = ObjectSerializer.serialize(notableId, "number");
        }

        if (notableType !== undefined) {
            localVarQueryParameters['notableType'] = ObjectSerializer.serialize(notableType, "string");
        }

        if (batchOperation !== undefined) {
            localVarQueryParameters['batchOperation'] = ObjectSerializer.serialize(batchOperation, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * This is used to leave a comment (note) on a notable object (i.e. albums, album contests, assets, game levels, offers, offer locations, retailers, retailer locations, and theme descriptors). Leaving a comment on a notable object will be visiable to everyone who has access to view the object.
     * @summary Create Note
     * @param version 
     * @param comment The message the user wishes to leave a comment on
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used)
     * @param notableType The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}
     * @param notableId The id of the notable object
     * @param noteType The custom string defined by the client (used for differentiating various note types)
     * @param assetIds A comma separated list of asset IDs to add with the note
     * @param tags search tags
     * @param permissionableType This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
     * @param permissionableId The id of the permissionable object (for sending group notifications)
     * @param appKey The application key used to identify the application
     * @param locationDescription The description of the location
     * @param latitude The current location of the user
     * @param longitude The current location of the user
     * @param metaData External custom client defined data
     * @param receiverAccountIds Comma separated list of additional account IDs that will receive the note notifications
     * @param returnFullResponse whether to return the full response or not
     * @param initializeAsset Check true if need to initialize an asset and assign to current note
     * @param assetReturnNulls Return null fields for asset response when creating an asset
     * @param assetAlbumId the album the asset will be added to (optional)
     * @param assetCollectionId the collection ID that the asset is associated with
     * @param assetAddToDefaultAlbum the default album to add the asset to
     * @param assetAddToMediaLibrary the media library to add the asset to
     * @param assetVersionCode the version code of the asset
     * @param assetVersionName the version name of the asset
     * @param assetMetaData the meta data of the asset
     * @param assetCaption the caption of the asset
     * @param assetMedia the media of the asset
     * @param assetMediaUrl the media URL of the asset
     * @param assetMediaString the media string of the asset
     * @param assetMediaStringFileName the media string file name of the asset
     * @param assetMediaStringContentType the media string content type of the asset
     * @param assetAttachedMedia the attached media of the asset
     * @param assetAttachedMediaUrl the attached media URL of the asset
     * @param assetAttachedMediaString the attached media string of the asset
     * @param assetAttachedMediaStringFileName the attached media string file name of the asset
     * @param assetAttachedMediaStringContentType the attached media string content type of the asset
     * @param assetLocationDescription the location description for the asset
     * @param assetApp the application for the asset
     * @param assetSearchTags the search tags used for the asset
     * @param assetLatitude the latitude of the asset
     * @param assetLongitude the longitude of the asset
     */
    public async createNote (version: number, comment: string, deviceId?: string, accountId?: number, notableType?: string, notableId?: number, noteType?: string, assetIds?: string, tags?: string, permissionableType?: string, permissionableId?: number, appKey?: string, locationDescription?: string, latitude?: number, longitude?: number, metaData?: string, receiverAccountIds?: string, returnFullResponse?: boolean, initializeAsset?: boolean, assetReturnNulls?: boolean, assetAlbumId?: number, assetCollectionId?: number, assetAddToDefaultAlbum?: string, assetAddToMediaLibrary?: boolean, assetVersionCode?: number, assetVersionName?: string, assetMetaData?: string, assetCaption?: string, assetMedia?: RequestFile, assetMediaUrl?: string, assetMediaString?: string, assetMediaStringFileName?: string, assetMediaStringContentType?: string, assetAttachedMedia?: RequestFile, assetAttachedMediaUrl?: string, assetAttachedMediaString?: string, assetAttachedMediaStringFileName?: string, assetAttachedMediaStringContentType?: string, assetLocationDescription?: string, assetApp?: string, assetSearchTags?: string, assetLatitude?: number, assetLongitude?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: NoteResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/note/create'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling createNote.');
        }

        // verify required parameter 'comment' is not null or undefined
        if (comment === null || comment === undefined) {
            throw new Error('Required parameter comment was null or undefined when calling createNote.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (notableType !== undefined) {
            localVarQueryParameters['notableType'] = ObjectSerializer.serialize(notableType, "string");
        }

        if (notableId !== undefined) {
            localVarQueryParameters['notableId'] = ObjectSerializer.serialize(notableId, "number");
        }

        if (comment !== undefined) {
            localVarQueryParameters['comment'] = ObjectSerializer.serialize(comment, "string");
        }

        if (noteType !== undefined) {
            localVarQueryParameters['noteType'] = ObjectSerializer.serialize(noteType, "string");
        }

        if (assetIds !== undefined) {
            localVarQueryParameters['assetIds'] = ObjectSerializer.serialize(assetIds, "string");
        }

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "string");
        }

        if (permissionableType !== undefined) {
            localVarQueryParameters['permissionableType'] = ObjectSerializer.serialize(permissionableType, "string");
        }

        if (permissionableId !== undefined) {
            localVarQueryParameters['permissionableId'] = ObjectSerializer.serialize(permissionableId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (locationDescription !== undefined) {
            localVarQueryParameters['locationDescription'] = ObjectSerializer.serialize(locationDescription, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        if (metaData !== undefined) {
            localVarQueryParameters['metaData'] = ObjectSerializer.serialize(metaData, "string");
        }

        if (receiverAccountIds !== undefined) {
            localVarQueryParameters['receiverAccountIds'] = ObjectSerializer.serialize(receiverAccountIds, "string");
        }

        if (returnFullResponse !== undefined) {
            localVarQueryParameters['returnFullResponse'] = ObjectSerializer.serialize(returnFullResponse, "boolean");
        }

        if (initializeAsset !== undefined) {
            localVarQueryParameters['initializeAsset'] = ObjectSerializer.serialize(initializeAsset, "boolean");
        }

        if (assetReturnNulls !== undefined) {
            localVarQueryParameters['assetReturnNulls'] = ObjectSerializer.serialize(assetReturnNulls, "boolean");
        }

        if (assetAlbumId !== undefined) {
            localVarQueryParameters['assetAlbumId'] = ObjectSerializer.serialize(assetAlbumId, "number");
        }

        if (assetCollectionId !== undefined) {
            localVarQueryParameters['assetCollectionId'] = ObjectSerializer.serialize(assetCollectionId, "number");
        }

        if (assetAddToDefaultAlbum !== undefined) {
            localVarQueryParameters['assetAddToDefaultAlbum'] = ObjectSerializer.serialize(assetAddToDefaultAlbum, "string");
        }

        if (assetAddToMediaLibrary !== undefined) {
            localVarQueryParameters['assetAddToMediaLibrary'] = ObjectSerializer.serialize(assetAddToMediaLibrary, "boolean");
        }

        if (assetVersionCode !== undefined) {
            localVarQueryParameters['assetVersionCode'] = ObjectSerializer.serialize(assetVersionCode, "number");
        }

        if (assetVersionName !== undefined) {
            localVarQueryParameters['assetVersionName'] = ObjectSerializer.serialize(assetVersionName, "string");
        }

        if (assetMetaData !== undefined) {
            localVarQueryParameters['assetMetaData'] = ObjectSerializer.serialize(assetMetaData, "string");
        }

        if (assetCaption !== undefined) {
            localVarQueryParameters['assetCaption'] = ObjectSerializer.serialize(assetCaption, "string");
        }

        if (assetMedia !== undefined) {
            localVarQueryParameters['assetMedia'] = ObjectSerializer.serialize(assetMedia, "RequestFile");
        }

        if (assetMediaUrl !== undefined) {
            localVarQueryParameters['assetMediaUrl'] = ObjectSerializer.serialize(assetMediaUrl, "string");
        }

        if (assetMediaString !== undefined) {
            localVarQueryParameters['assetMediaString'] = ObjectSerializer.serialize(assetMediaString, "string");
        }

        if (assetMediaStringFileName !== undefined) {
            localVarQueryParameters['assetMediaStringFileName'] = ObjectSerializer.serialize(assetMediaStringFileName, "string");
        }

        if (assetMediaStringContentType !== undefined) {
            localVarQueryParameters['assetMediaStringContentType'] = ObjectSerializer.serialize(assetMediaStringContentType, "string");
        }

        if (assetAttachedMedia !== undefined) {
            localVarQueryParameters['assetAttachedMedia'] = ObjectSerializer.serialize(assetAttachedMedia, "RequestFile");
        }

        if (assetAttachedMediaUrl !== undefined) {
            localVarQueryParameters['assetAttachedMediaUrl'] = ObjectSerializer.serialize(assetAttachedMediaUrl, "string");
        }

        if (assetAttachedMediaString !== undefined) {
            localVarQueryParameters['assetAttachedMediaString'] = ObjectSerializer.serialize(assetAttachedMediaString, "string");
        }

        if (assetAttachedMediaStringFileName !== undefined) {
            localVarQueryParameters['assetAttachedMediaStringFileName'] = ObjectSerializer.serialize(assetAttachedMediaStringFileName, "string");
        }

        if (assetAttachedMediaStringContentType !== undefined) {
            localVarQueryParameters['assetAttachedMediaStringContentType'] = ObjectSerializer.serialize(assetAttachedMediaStringContentType, "string");
        }

        if (assetLocationDescription !== undefined) {
            localVarQueryParameters['assetLocationDescription'] = ObjectSerializer.serialize(assetLocationDescription, "string");
        }

        if (assetApp !== undefined) {
            localVarQueryParameters['assetApp'] = ObjectSerializer.serialize(assetApp, "string");
        }

        if (assetSearchTags !== undefined) {
            localVarQueryParameters['assetSearchTags'] = ObjectSerializer.serialize(assetSearchTags, "string");
        }

        if (assetLatitude !== undefined) {
            localVarQueryParameters['assetLatitude'] = ObjectSerializer.serialize(assetLatitude, "number");
        }

        if (assetLongitude !== undefined) {
            localVarQueryParameters['assetLongitude'] = ObjectSerializer.serialize(assetLongitude, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: NoteResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "NoteResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Sets a comment (note) as deleted.
     * @summary Delete Note
     * @param version 
     * @param noteId The ID of the note to delete
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used)
     * @param latitude The current location of the user
     * @param longitude The current location of the user
     * @param appKey The application key used to identify the application
     */
    public async deleteNote (version: number, noteId: number, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, appKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/note/delete'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling deleteNote.');
        }

        // verify required parameter 'noteId' is not null or undefined
        if (noteId === null || noteId === undefined) {
            throw new Error('Required parameter noteId was null or undefined when calling deleteNote.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (noteId !== undefined) {
            localVarQueryParameters['noteId'] = ObjectSerializer.serialize(noteId, "number");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get for a note based on its Id.
     * @summary Get Note
     * @param version 
     * @param noteId the id of the note to get
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used)
     * @param returnFullResponse Determines whether to return the NoteFullResponse for the item
     */
    public async getNote (version: number, noteId: number, deviceId?: string, accountId?: number, returnFullResponse?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/note/get'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getNote.');
        }

        // verify required parameter 'noteId' is not null or undefined
        if (noteId === null || noteId === undefined) {
            throw new Error('Required parameter noteId was null or undefined when calling getNote.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (returnFullResponse !== undefined) {
            localVarQueryParameters['returnFullResponse'] = ObjectSerializer.serialize(returnFullResponse, "boolean");
        }

        if (noteId !== undefined) {
            localVarQueryParameters['noteId'] = ObjectSerializer.serialize(noteId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Search for notes on a notable object.
     * @summary Search Notes
     * @param version 
     * @param deviceId The device id (deviceId or accountId required)
     * @param accountId The account id of the user (deviceId or accountId required)
     * @param notableType The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}
     * @param notableId The id of the notable object
     * @param noteTypes Comma separated list of noteType strings to filter results with
     * @param appKey The application key used to identify the application
     * @param keyword The keyword used to search
     * @param flagCountMinimum return items that has flagCount &gt;&#x3D; flagCountMinimum if this is set, return all items, even ones with flagCount &gt;&#x3D; flagThreshold
     * @param flagsExceedThreshold return items that has flagCount &gt;&#x3D; flagThreshold, which are hidden by default
     * @param includeInactive include inactive in the result
     * @param sortField The column to sort the search on
     * @param descending The order to return the search results
     * @param returnFullResponse Determines whether to return the NoteFullResponse for each search item
     * @param updatedSince return items that have been updated since this date (time-stamp in milliseconds)
     * @param updatedBefore return items that have been updated before this date (time-stamp in milliseconds)
     * @param start The record to begin the return set on
     * @param limit The number of records to return
     */
    public async searchNotes (version: number, deviceId?: string, accountId?: number, notableType?: string, notableId?: number, noteTypes?: string, appKey?: string, keyword?: string, flagCountMinimum?: number, flagsExceedThreshold?: boolean, includeInactive?: boolean, sortField?: 'ID' | 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'OWNER_DISPLAY' | 'NOTABLE_TYPE' | 'NOTE_TAG' | 'NOTE_COUNT' | 'LIKES' | 'DISLIKES', descending?: boolean, returnFullResponse?: boolean, updatedSince?: number, updatedBefore?: number, start?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<NoteResponse>;  }> {
        const localVarPath = this.basePath + '/api/{version}/note/search'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling searchNotes.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (notableType !== undefined) {
            localVarQueryParameters['notableType'] = ObjectSerializer.serialize(notableType, "string");
        }

        if (notableId !== undefined) {
            localVarQueryParameters['notableId'] = ObjectSerializer.serialize(notableId, "number");
        }

        if (noteTypes !== undefined) {
            localVarQueryParameters['noteTypes'] = ObjectSerializer.serialize(noteTypes, "string");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (keyword !== undefined) {
            localVarQueryParameters['keyword'] = ObjectSerializer.serialize(keyword, "string");
        }

        if (flagCountMinimum !== undefined) {
            localVarQueryParameters['flagCountMinimum'] = ObjectSerializer.serialize(flagCountMinimum, "number");
        }

        if (flagsExceedThreshold !== undefined) {
            localVarQueryParameters['flagsExceedThreshold'] = ObjectSerializer.serialize(flagsExceedThreshold, "boolean");
        }

        if (includeInactive !== undefined) {
            localVarQueryParameters['includeInactive'] = ObjectSerializer.serialize(includeInactive, "boolean");
        }

        if (sortField !== undefined) {
            localVarQueryParameters['sortField'] = ObjectSerializer.serialize(sortField, "'ID' | 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'OWNER_DISPLAY' | 'NOTABLE_TYPE' | 'NOTE_TAG' | 'NOTE_COUNT' | 'LIKES' | 'DISLIKES'");
        }

        if (descending !== undefined) {
            localVarQueryParameters['descending'] = ObjectSerializer.serialize(descending, "boolean");
        }

        if (returnFullResponse !== undefined) {
            localVarQueryParameters['returnFullResponse'] = ObjectSerializer.serialize(returnFullResponse, "boolean");
        }

        if (updatedSince !== undefined) {
            localVarQueryParameters['updatedSince'] = ObjectSerializer.serialize(updatedSince, "number");
        }

        if (updatedBefore !== undefined) {
            localVarQueryParameters['updatedBefore'] = ObjectSerializer.serialize(updatedBefore, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<NoteResponse>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<NoteResponse>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update an existing comment (note). Only the creator of the note have permission to update.
     * @summary Update Note
     * @param version 
     * @param noteId The id of the note, used when editing a comment
     * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used)
     * @param accountId The unique accountId that made the request (either deviceId or accountId must be used)
     * @param comment The message the user wishes to leave a comment on
     * @param noteType The custom string defined by the client (used for differentiating on various note types)
     * @param assetIds A comma separated list of asset IDs to add with the note
     * @param tags search tags
     * @param permissionableType This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
     * @param permissionableId The id of the permissionable object (for sending group notifications)
     * @param appKey The application key used to identify the application
     * @param locationDescription The description of the location
     * @param latitude The current location of the user
     * @param longitude The current location of the user
     * @param metaData meta data to update with the note
     * @param returnFullResponse whether to return the full response or not
     * @param active Sets the active flag for the note
     * @param updateAsset main flag for updating asset in note, must set to true if you want to update the note\&#39;s asset
     * @param assetReturnNulls Return null fields for asset response when updating an asset
     * @param assetAlbumId the album the asset will be added to (optional)
     * @param assetCollectionId the collection ID that the asset is associated with
     * @param assetAddToDefaultAlbum the default album to add the asset to
     * @param assetAddToMediaLibrary the media library to add the asset to
     * @param assetVersionCode the version code of the asset
     * @param assetVersionName the version name of the asset
     * @param assetMetaData the meta data of the asset
     * @param assetCaption the caption of the asset
     * @param assetMedia the media of the asset
     * @param assetMediaUrl the media URL of the asset
     * @param assetMediaString the media string of the asset
     * @param assetMediaStringFileName the media string file name of the asset
     * @param assetMediaStringContentType the media string content type of the asset
     * @param assetAttachedMedia the attached media of the asset
     * @param assetAttachedMediaUrl the attached media URL of the asset
     * @param assetAttachedMediaString the attached media string of the asset
     * @param assetAttachedMediaStringFileName the attached media string file name of the asset
     * @param assetAttachedMediaStringContentType the attached media string content type of the asset
     * @param assetLocationDescription the location description for the asset
     * @param assetApp the application for the asset
     * @param assetSearchTags the search tags used for the asset
     * @param assetLatitude the latitude of the asset
     * @param assetLongitude the longitude of the asset
     */
    public async updateNote (version: number, noteId: number, deviceId?: string, accountId?: number, comment?: string, noteType?: string, assetIds?: string, tags?: string, permissionableType?: string, permissionableId?: number, appKey?: string, locationDescription?: string, latitude?: number, longitude?: number, metaData?: string, returnFullResponse?: boolean, active?: boolean, updateAsset?: boolean, assetReturnNulls?: boolean, assetAlbumId?: number, assetCollectionId?: number, assetAddToDefaultAlbum?: string, assetAddToMediaLibrary?: boolean, assetVersionCode?: number, assetVersionName?: string, assetMetaData?: string, assetCaption?: string, assetMedia?: RequestFile, assetMediaUrl?: string, assetMediaString?: string, assetMediaStringFileName?: string, assetMediaStringContentType?: string, assetAttachedMedia?: RequestFile, assetAttachedMediaUrl?: string, assetAttachedMediaString?: string, assetAttachedMediaStringFileName?: string, assetAttachedMediaStringContentType?: string, assetLocationDescription?: string, assetApp?: string, assetSearchTags?: string, assetLatitude?: number, assetLongitude?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: NoteResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/note/update'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling updateNote.');
        }

        // verify required parameter 'noteId' is not null or undefined
        if (noteId === null || noteId === undefined) {
            throw new Error('Required parameter noteId was null or undefined when calling updateNote.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (noteId !== undefined) {
            localVarQueryParameters['noteId'] = ObjectSerializer.serialize(noteId, "number");
        }

        if (comment !== undefined) {
            localVarQueryParameters['comment'] = ObjectSerializer.serialize(comment, "string");
        }

        if (noteType !== undefined) {
            localVarQueryParameters['noteType'] = ObjectSerializer.serialize(noteType, "string");
        }

        if (assetIds !== undefined) {
            localVarQueryParameters['assetIds'] = ObjectSerializer.serialize(assetIds, "string");
        }

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "string");
        }

        if (permissionableType !== undefined) {
            localVarQueryParameters['permissionableType'] = ObjectSerializer.serialize(permissionableType, "string");
        }

        if (permissionableId !== undefined) {
            localVarQueryParameters['permissionableId'] = ObjectSerializer.serialize(permissionableId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (locationDescription !== undefined) {
            localVarQueryParameters['locationDescription'] = ObjectSerializer.serialize(locationDescription, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        if (metaData !== undefined) {
            localVarQueryParameters['metaData'] = ObjectSerializer.serialize(metaData, "string");
        }

        if (returnFullResponse !== undefined) {
            localVarQueryParameters['returnFullResponse'] = ObjectSerializer.serialize(returnFullResponse, "boolean");
        }

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (updateAsset !== undefined) {
            localVarQueryParameters['updateAsset'] = ObjectSerializer.serialize(updateAsset, "boolean");
        }

        if (assetReturnNulls !== undefined) {
            localVarQueryParameters['assetReturnNulls'] = ObjectSerializer.serialize(assetReturnNulls, "boolean");
        }

        if (assetAlbumId !== undefined) {
            localVarQueryParameters['assetAlbumId'] = ObjectSerializer.serialize(assetAlbumId, "number");
        }

        if (assetCollectionId !== undefined) {
            localVarQueryParameters['assetCollectionId'] = ObjectSerializer.serialize(assetCollectionId, "number");
        }

        if (assetAddToDefaultAlbum !== undefined) {
            localVarQueryParameters['assetAddToDefaultAlbum'] = ObjectSerializer.serialize(assetAddToDefaultAlbum, "string");
        }

        if (assetAddToMediaLibrary !== undefined) {
            localVarQueryParameters['assetAddToMediaLibrary'] = ObjectSerializer.serialize(assetAddToMediaLibrary, "boolean");
        }

        if (assetVersionCode !== undefined) {
            localVarQueryParameters['assetVersionCode'] = ObjectSerializer.serialize(assetVersionCode, "number");
        }

        if (assetVersionName !== undefined) {
            localVarQueryParameters['assetVersionName'] = ObjectSerializer.serialize(assetVersionName, "string");
        }

        if (assetMetaData !== undefined) {
            localVarQueryParameters['assetMetaData'] = ObjectSerializer.serialize(assetMetaData, "string");
        }

        if (assetCaption !== undefined) {
            localVarQueryParameters['assetCaption'] = ObjectSerializer.serialize(assetCaption, "string");
        }

        if (assetMedia !== undefined) {
            localVarQueryParameters['assetMedia'] = ObjectSerializer.serialize(assetMedia, "RequestFile");
        }

        if (assetMediaUrl !== undefined) {
            localVarQueryParameters['assetMediaUrl'] = ObjectSerializer.serialize(assetMediaUrl, "string");
        }

        if (assetMediaString !== undefined) {
            localVarQueryParameters['assetMediaString'] = ObjectSerializer.serialize(assetMediaString, "string");
        }

        if (assetMediaStringFileName !== undefined) {
            localVarQueryParameters['assetMediaStringFileName'] = ObjectSerializer.serialize(assetMediaStringFileName, "string");
        }

        if (assetMediaStringContentType !== undefined) {
            localVarQueryParameters['assetMediaStringContentType'] = ObjectSerializer.serialize(assetMediaStringContentType, "string");
        }

        if (assetAttachedMedia !== undefined) {
            localVarQueryParameters['assetAttachedMedia'] = ObjectSerializer.serialize(assetAttachedMedia, "RequestFile");
        }

        if (assetAttachedMediaUrl !== undefined) {
            localVarQueryParameters['assetAttachedMediaUrl'] = ObjectSerializer.serialize(assetAttachedMediaUrl, "string");
        }

        if (assetAttachedMediaString !== undefined) {
            localVarQueryParameters['assetAttachedMediaString'] = ObjectSerializer.serialize(assetAttachedMediaString, "string");
        }

        if (assetAttachedMediaStringFileName !== undefined) {
            localVarQueryParameters['assetAttachedMediaStringFileName'] = ObjectSerializer.serialize(assetAttachedMediaStringFileName, "string");
        }

        if (assetAttachedMediaStringContentType !== undefined) {
            localVarQueryParameters['assetAttachedMediaStringContentType'] = ObjectSerializer.serialize(assetAttachedMediaStringContentType, "string");
        }

        if (assetLocationDescription !== undefined) {
            localVarQueryParameters['assetLocationDescription'] = ObjectSerializer.serialize(assetLocationDescription, "string");
        }

        if (assetApp !== undefined) {
            localVarQueryParameters['assetApp'] = ObjectSerializer.serialize(assetApp, "string");
        }

        if (assetSearchTags !== undefined) {
            localVarQueryParameters['assetSearchTags'] = ObjectSerializer.serialize(assetSearchTags, "string");
        }

        if (assetLatitude !== undefined) {
            localVarQueryParameters['assetLatitude'] = ObjectSerializer.serialize(assetLatitude, "number");
        }

        if (assetLongitude !== undefined) {
            localVarQueryParameters['assetLongitude'] = ObjectSerializer.serialize(assetLongitude, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: NoteResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "NoteResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
