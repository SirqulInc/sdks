/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET[\'appKey\']);$b = htmlspecialchars($_GET[\'appRestKey\']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { AccountLoginResponse } from '../model/accountLoginResponse';
import { AssetListResponse } from '../model/assetListResponse';
import { ProfileInfoResponse } from '../model/profileInfoResponse';
import { ProfileResponse } from '../model/profileResponse';
import { SirqulResponse } from '../model/sirqulResponse';
import { UserLocationSearchResponse } from '../model/userLocationSearchResponse';
import { UserSettingsResponse } from '../model/userSettingsResponse';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://dev.sirqul.com/api/3.18';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum AccountApiApiKeys {
    appKey,
    restKey,
}

export class AccountApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'appKey': new ApiKeyAuth('header', 'Application-Key'),
        'restKey': new ApiKeyAuth('header', 'Application-Rest-Key'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: AccountApiApiKeys, value: string) {
        (this.authentications as any)[AccountApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Search accounts by their location. This only searches on users that have location data. Use ConnectionApi to perform a regular search on accounts.
     * @summary Search Accounts by Location
     * @param deviceId The device id (deviceId or accountId required)
     * @param accountId The account id of the user (deviceId or accountId required)
     * @param q Deprecated - legacy query parameter
     * @param keyword An optional keyword to search on, will be ignore if empty (NOT implemented yet)
     * @param postalCode The postal code to search on, either postalCode or the user\&#39;s exact location is required
     * @param latitude The latitude of the user, either postalCode or the user\&#39;s exact location is required
     * @param longitude The longitude of the user, either postalCode or the user\&#39;s exact location is required
     * @param appKey The application key
     * @param range The range to search on
     * @param locationLastUpdated Searches for user\&#39;s that has updated their location since this date
     * @param gender The preferred gender
     * @param minAge The preferred min age
     * @param maxAge The preferred max age
     * @param companionshipIndex The preferred companionship index
     * @param i this is the start index of a query
     * @param start Start of the pagination
     * @param l this is the limit index of a query
     * @param limit Limit of the pagination
     * @param searchMode Search mode to use for index searches (e.g. CLOUDINDEX, OPENSEARCH)
     * @param sortField Sorting field for results (default: DISTANCE)
     * @param descending Whether to sort descending (default: false)
     * @param roles Roles to filter on
     * @param tags Tags to filter on
     * @param experience The experience to filter on
     * @param categoryIds The category ids to filter on (comma separated)
     * @param audienceIds The audience ids to filter on (comma separated)
     * @param audienceOperator Operator used to combine audience filters (default: AND)
     * @param updateCurrentLocation Whether to use the given lat &amp; long to update the user\&#39;s current location
     * @param updatePreferredSettings Whether to use the given parameters to update the user\&#39;s preferred settings
     * @param showExactLocations Determines whether to always display user exact locations
     * @param showConnectionToSearcher Return connection of the accounts in the result to the passed in account if there exists any
     * @param flagCountMinimum Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)
     * @param verifiedUserOnly Returns only verified users
     * @param contentAdminOnly Returns only content admin users
     */
    public async accountLocationSearch (deviceId?: string, accountId?: number, q?: string, keyword?: string, postalCode?: string, latitude?: number, longitude?: number, appKey?: string, range?: number, locationLastUpdated?: number, gender?: string, minAge?: number, maxAge?: number, companionshipIndex?: number, i?: number, start?: number, l?: number, limit?: number, searchMode?: string, sortField?: string, descending?: boolean, roles?: string, tags?: string, experience?: string, categoryIds?: string, audienceIds?: string, audienceOperator?: string, updateCurrentLocation?: boolean, updatePreferredSettings?: boolean, showExactLocations?: boolean, showConnectionToSearcher?: boolean, flagCountMinimum?: number, verifiedUserOnly?: boolean, contentAdminOnly?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: UserLocationSearchResponse;  }> {
        const localVarPath = this.basePath + '/account/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (keyword !== undefined) {
            localVarQueryParameters['keyword'] = ObjectSerializer.serialize(keyword, "string");
        }

        if (postalCode !== undefined) {
            localVarQueryParameters['postalCode'] = ObjectSerializer.serialize(postalCode, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (range !== undefined) {
            localVarQueryParameters['range'] = ObjectSerializer.serialize(range, "number");
        }

        if (locationLastUpdated !== undefined) {
            localVarQueryParameters['locationLastUpdated'] = ObjectSerializer.serialize(locationLastUpdated, "number");
        }

        if (gender !== undefined) {
            localVarQueryParameters['gender'] = ObjectSerializer.serialize(gender, "string");
        }

        if (minAge !== undefined) {
            localVarQueryParameters['minAge'] = ObjectSerializer.serialize(minAge, "number");
        }

        if (maxAge !== undefined) {
            localVarQueryParameters['maxAge'] = ObjectSerializer.serialize(maxAge, "number");
        }

        if (companionshipIndex !== undefined) {
            localVarQueryParameters['companionshipIndex'] = ObjectSerializer.serialize(companionshipIndex, "number");
        }

        if (i !== undefined) {
            localVarQueryParameters['_i'] = ObjectSerializer.serialize(i, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (l !== undefined) {
            localVarQueryParameters['_l'] = ObjectSerializer.serialize(l, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (searchMode !== undefined) {
            localVarQueryParameters['searchMode'] = ObjectSerializer.serialize(searchMode, "string");
        }

        if (sortField !== undefined) {
            localVarQueryParameters['sortField'] = ObjectSerializer.serialize(sortField, "string");
        }

        if (descending !== undefined) {
            localVarQueryParameters['descending'] = ObjectSerializer.serialize(descending, "boolean");
        }

        if (roles !== undefined) {
            localVarQueryParameters['roles'] = ObjectSerializer.serialize(roles, "string");
        }

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "string");
        }

        if (experience !== undefined) {
            localVarQueryParameters['experience'] = ObjectSerializer.serialize(experience, "string");
        }

        if (categoryIds !== undefined) {
            localVarQueryParameters['categoryIds'] = ObjectSerializer.serialize(categoryIds, "string");
        }

        if (audienceIds !== undefined) {
            localVarQueryParameters['audienceIds'] = ObjectSerializer.serialize(audienceIds, "string");
        }

        if (audienceOperator !== undefined) {
            localVarQueryParameters['audienceOperator'] = ObjectSerializer.serialize(audienceOperator, "string");
        }

        if (updateCurrentLocation !== undefined) {
            localVarQueryParameters['updateCurrentLocation'] = ObjectSerializer.serialize(updateCurrentLocation, "boolean");
        }

        if (updatePreferredSettings !== undefined) {
            localVarQueryParameters['updatePreferredSettings'] = ObjectSerializer.serialize(updatePreferredSettings, "boolean");
        }

        if (showExactLocations !== undefined) {
            localVarQueryParameters['showExactLocations'] = ObjectSerializer.serialize(showExactLocations, "boolean");
        }

        if (showConnectionToSearcher !== undefined) {
            localVarQueryParameters['showConnectionToSearcher'] = ObjectSerializer.serialize(showConnectionToSearcher, "boolean");
        }

        if (flagCountMinimum !== undefined) {
            localVarQueryParameters['flagCountMinimum'] = ObjectSerializer.serialize(flagCountMinimum, "number");
        }

        if (verifiedUserOnly !== undefined) {
            localVarQueryParameters['verifiedUserOnly'] = ObjectSerializer.serialize(verifiedUserOnly, "boolean");
        }

        if (contentAdminOnly !== undefined) {
            localVarQueryParameters['contentAdminOnly'] = ObjectSerializer.serialize(contentAdminOnly, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: UserLocationSearchResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "UserLocationSearchResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Moves or removes an account into the user\'s blocked group.
     * @summary Block Account
     * @param accountIdBeingBlocked The id of the account to be blocked/unblocked
     * @param deviceId The device id (deviceId or accountId required)
     * @param accountId The account id of the user (deviceId or accountId required)
     * @param blockFlagValue Determines whether the account is blocked or unblocked
     * @param removeFromGroupsIfBlocked Determines whether the account is removed from all other groups if blocked
     * @param latitude The current latitude of the user
     * @param longitude The current longitude of the user
     */
    public async blockAccount (accountIdBeingBlocked: number, deviceId?: string, accountId?: number, blockFlagValue?: boolean, removeFromGroupsIfBlocked?: boolean, latitude?: number, longitude?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/account/block';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountIdBeingBlocked' is not null or undefined
        if (accountIdBeingBlocked === null || accountIdBeingBlocked === undefined) {
            throw new Error('Required parameter accountIdBeingBlocked was null or undefined when calling blockAccount.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (accountIdBeingBlocked !== undefined) {
            localVarQueryParameters['accountIdBeingBlocked'] = ObjectSerializer.serialize(accountIdBeingBlocked, "number");
        }

        if (blockFlagValue !== undefined) {
            localVarQueryParameters['blockFlagValue'] = ObjectSerializer.serialize(blockFlagValue, "boolean");
        }

        if (removeFromGroupsIfBlocked !== undefined) {
            localVarQueryParameters['removeFromGroupsIfBlocked'] = ObjectSerializer.serialize(removeFromGroupsIfBlocked, "boolean");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a new account by role.
     * @summary Create Account
     * @param username The access token to authenticate with (ex: username)
     * @param password The secret to authenticate with (ex: password)
     * @param name The full name of the user. If this parameter is NOT empty, the following parameters will be ignored: prefixName, firstName, middleName, lastName, and suffixName
     * @param prefixName If the parameter \&#39;name\&#39; is empty or not present, this field will be used to set the prefix of the user\&#39;s name
     * @param firstName If the parameter \&#39;name\&#39; is empty or not present, this field will be used to set the user\&#39;s first name
     * @param middleName If the parameter \&#39;name\&#39; is empty or not present, this field will be used to set the user\&#39;s middle name
     * @param lastName If the parameter \&#39;name\&#39; is empty or not present, this field will be used to set the user\&#39;s last name
     * @param suffixName If the parameter \&#39;name\&#39; is empty or not present, this field will be used to set the suffix of the user\&#39;s name
     * @param title This field will be used to set the user\&#39;s job title
     * @param deviceId The unique id of the device making the request
     * @param deviceIdType The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc
     * @param emailAddress The user\&#39;s contact email address (NOT the username)
     * @param assetId The asset id to set the user\&#39;s profile image
     * @param streetAddress The street address of the user\&#39;s contact location
     * @param zipcode The zipcode of the user\&#39;s contact location
     * @param gender The gender of the user (AudienceGender)
     * @param birthday The birthday date of the user in UTC milliseconds
     * @param homePhone The home phone number
     * @param cellPhone The cellular phone number
     * @param cellPhoneCarrier The cellular service provider
     * @param businessPhone The business phone number
     * @param role The account role (default: MEMBER)
     * @param platforms Comma separated list of development platforms
     * @param tags Search tags
     * @param aboutUs About us information
     * @param gameExperience Game experience of the user
     * @param categoryIds A list of category ids that represent interests and associations
     * @param hometown The user\&#39;s hometown
     * @param height The user\&#39;s height
     * @param heightIndex The user\&#39;s height in a numerical value that can be used for ordering/searching
     * @param ethnicity The user\&#39;s ethnicity
     * @param bodyType The user\&#39;s body type
     * @param maritalStatus The user\&#39;s marital status
     * @param children The user\&#39;s children status
     * @param religion The user\&#39;s religion
     * @param education The user\&#39;s education
     * @param educationIndex The user\&#39;s education in a numerical value that can be used for ordering/searching
     * @param smoke The user\&#39;s smoke status
     * @param drink The user\&#39;s drink status
     * @param companionship The user\&#39;s companionship status
     * @param companionshipIndex The user\&#39;s companionship index
     * @param preferredMinAge The preferred minimum age in the account location search
     * @param preferredMaxAge The preferred maximum age in the account location search
     * @param preferredMinHeight The preferred minimum height in the account location search
     * @param preferredMaxHeight The preferred maximum height in the account location search
     * @param preferredGender The preferred gender in the account location search
     * @param preferredEducation The preferred education in the account location search
     * @param preferredEducationIndex The preferred education in a numerical value that can be used for ordering/searching
     * @param preferredBodyType The preferred body type in the account location search
     * @param preferredEthnicity The preferred ethnicity in the account location search
     * @param preferredLocation The preferred location in the account location search
     * @param preferredLocationRange The preferred location range in the account location search
     * @param latitude The current latitude of the user
     * @param longitude The current longitude of the user
     * @param acceptedTerms Accepted Terms
     * @param inviteToken The inviteToken that the referrer used for this account to sign up
     * @param referralAccountId The accountId of the referrer (used if there is no inviteToken)
     * @param sendValidation Whether to send validation email
     * @param gameType Deprecated: use appKey
     * @param appKey The application key
     * @param appVersion The application version
     * @param responseType Returns an AccountLoginResponse if \&quot;AccountLoginResponse\&quot; is passed in
     * @param audienceIdsToAdd Comma separated list of audience ids to assign to the user
     * @param appBlob Application blob data
     * @param appEnablePush Enable push for the app
     * @param appEnableSMS Enable SMS for the app
     * @param appEnableEmail Enable email for the app
     * @param locationVisibility Location visibility setting
     * @param homeLatitude Home latitude
     * @param homeLongitude Home longitude
     * @param appNickname The nickname used in the application for this account
     * @param personalAudienceId Personal audience id to associate with this account
     */
    public async createAccount (username: string, password: string, name?: string, prefixName?: string, firstName?: string, middleName?: string, lastName?: string, suffixName?: string, title?: string, deviceId?: string, deviceIdType?: string, emailAddress?: string, assetId?: number, streetAddress?: string, zipcode?: string, gender?: string, birthday?: number, homePhone?: string, cellPhone?: string, cellPhoneCarrier?: string, businessPhone?: string, role?: string, platforms?: string, tags?: string, aboutUs?: string, gameExperience?: string, categoryIds?: string, hometown?: string, height?: string, heightIndex?: number, ethnicity?: string, bodyType?: string, maritalStatus?: string, children?: string, religion?: string, education?: string, educationIndex?: number, smoke?: string, drink?: string, companionship?: string, companionshipIndex?: number, preferredMinAge?: number, preferredMaxAge?: number, preferredMinHeight?: number, preferredMaxHeight?: number, preferredGender?: string, preferredEducation?: string, preferredEducationIndex?: number, preferredBodyType?: string, preferredEthnicity?: string, preferredLocation?: string, preferredLocationRange?: number, latitude?: number, longitude?: number, acceptedTerms?: boolean, inviteToken?: string, referralAccountId?: number, sendValidation?: boolean, gameType?: string, appKey?: string, appVersion?: string, responseType?: string, audienceIdsToAdd?: string, appBlob?: string, appEnablePush?: boolean, appEnableSMS?: boolean, appEnableEmail?: boolean, locationVisibility?: string, homeLatitude?: number, homeLongitude?: number, appNickname?: string, personalAudienceId?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AccountLoginResponse;  }> {
        const localVarPath = this.basePath + '/account/create';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling createAccount.');
        }

        // verify required parameter 'password' is not null or undefined
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling createAccount.');
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (prefixName !== undefined) {
            localVarQueryParameters['prefixName'] = ObjectSerializer.serialize(prefixName, "string");
        }

        if (firstName !== undefined) {
            localVarQueryParameters['firstName'] = ObjectSerializer.serialize(firstName, "string");
        }

        if (middleName !== undefined) {
            localVarQueryParameters['middleName'] = ObjectSerializer.serialize(middleName, "string");
        }

        if (lastName !== undefined) {
            localVarQueryParameters['lastName'] = ObjectSerializer.serialize(lastName, "string");
        }

        if (suffixName !== undefined) {
            localVarQueryParameters['suffixName'] = ObjectSerializer.serialize(suffixName, "string");
        }

        if (title !== undefined) {
            localVarQueryParameters['title'] = ObjectSerializer.serialize(title, "string");
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (deviceIdType !== undefined) {
            localVarQueryParameters['deviceIdType'] = ObjectSerializer.serialize(deviceIdType, "string");
        }

        if (username !== undefined) {
            localVarQueryParameters['username'] = ObjectSerializer.serialize(username, "string");
        }

        if (password !== undefined) {
            localVarQueryParameters['password'] = ObjectSerializer.serialize(password, "string");
        }

        if (emailAddress !== undefined) {
            localVarQueryParameters['emailAddress'] = ObjectSerializer.serialize(emailAddress, "string");
        }

        if (assetId !== undefined) {
            localVarQueryParameters['assetId'] = ObjectSerializer.serialize(assetId, "number");
        }

        if (streetAddress !== undefined) {
            localVarQueryParameters['streetAddress'] = ObjectSerializer.serialize(streetAddress, "string");
        }

        if (zipcode !== undefined) {
            localVarQueryParameters['zipcode'] = ObjectSerializer.serialize(zipcode, "string");
        }

        if (gender !== undefined) {
            localVarQueryParameters['gender'] = ObjectSerializer.serialize(gender, "string");
        }

        if (birthday !== undefined) {
            localVarQueryParameters['birthday'] = ObjectSerializer.serialize(birthday, "number");
        }

        if (homePhone !== undefined) {
            localVarQueryParameters['homePhone'] = ObjectSerializer.serialize(homePhone, "string");
        }

        if (cellPhone !== undefined) {
            localVarQueryParameters['cellPhone'] = ObjectSerializer.serialize(cellPhone, "string");
        }

        if (cellPhoneCarrier !== undefined) {
            localVarQueryParameters['cellPhoneCarrier'] = ObjectSerializer.serialize(cellPhoneCarrier, "string");
        }

        if (businessPhone !== undefined) {
            localVarQueryParameters['businessPhone'] = ObjectSerializer.serialize(businessPhone, "string");
        }

        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "string");
        }

        if (platforms !== undefined) {
            localVarQueryParameters['platforms'] = ObjectSerializer.serialize(platforms, "string");
        }

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "string");
        }

        if (aboutUs !== undefined) {
            localVarQueryParameters['aboutUs'] = ObjectSerializer.serialize(aboutUs, "string");
        }

        if (gameExperience !== undefined) {
            localVarQueryParameters['gameExperience'] = ObjectSerializer.serialize(gameExperience, "string");
        }

        if (categoryIds !== undefined) {
            localVarQueryParameters['categoryIds'] = ObjectSerializer.serialize(categoryIds, "string");
        }

        if (hometown !== undefined) {
            localVarQueryParameters['hometown'] = ObjectSerializer.serialize(hometown, "string");
        }

        if (height !== undefined) {
            localVarQueryParameters['height'] = ObjectSerializer.serialize(height, "string");
        }

        if (heightIndex !== undefined) {
            localVarQueryParameters['heightIndex'] = ObjectSerializer.serialize(heightIndex, "number");
        }

        if (ethnicity !== undefined) {
            localVarQueryParameters['ethnicity'] = ObjectSerializer.serialize(ethnicity, "string");
        }

        if (bodyType !== undefined) {
            localVarQueryParameters['bodyType'] = ObjectSerializer.serialize(bodyType, "string");
        }

        if (maritalStatus !== undefined) {
            localVarQueryParameters['maritalStatus'] = ObjectSerializer.serialize(maritalStatus, "string");
        }

        if (children !== undefined) {
            localVarQueryParameters['children'] = ObjectSerializer.serialize(children, "string");
        }

        if (religion !== undefined) {
            localVarQueryParameters['religion'] = ObjectSerializer.serialize(religion, "string");
        }

        if (education !== undefined) {
            localVarQueryParameters['education'] = ObjectSerializer.serialize(education, "string");
        }

        if (educationIndex !== undefined) {
            localVarQueryParameters['educationIndex'] = ObjectSerializer.serialize(educationIndex, "number");
        }

        if (smoke !== undefined) {
            localVarQueryParameters['smoke'] = ObjectSerializer.serialize(smoke, "string");
        }

        if (drink !== undefined) {
            localVarQueryParameters['drink'] = ObjectSerializer.serialize(drink, "string");
        }

        if (companionship !== undefined) {
            localVarQueryParameters['companionship'] = ObjectSerializer.serialize(companionship, "string");
        }

        if (companionshipIndex !== undefined) {
            localVarQueryParameters['companionshipIndex'] = ObjectSerializer.serialize(companionshipIndex, "number");
        }

        if (preferredMinAge !== undefined) {
            localVarQueryParameters['preferredMinAge'] = ObjectSerializer.serialize(preferredMinAge, "number");
        }

        if (preferredMaxAge !== undefined) {
            localVarQueryParameters['preferredMaxAge'] = ObjectSerializer.serialize(preferredMaxAge, "number");
        }

        if (preferredMinHeight !== undefined) {
            localVarQueryParameters['preferredMinHeight'] = ObjectSerializer.serialize(preferredMinHeight, "number");
        }

        if (preferredMaxHeight !== undefined) {
            localVarQueryParameters['preferredMaxHeight'] = ObjectSerializer.serialize(preferredMaxHeight, "number");
        }

        if (preferredGender !== undefined) {
            localVarQueryParameters['preferredGender'] = ObjectSerializer.serialize(preferredGender, "string");
        }

        if (preferredEducation !== undefined) {
            localVarQueryParameters['preferredEducation'] = ObjectSerializer.serialize(preferredEducation, "string");
        }

        if (preferredEducationIndex !== undefined) {
            localVarQueryParameters['preferredEducationIndex'] = ObjectSerializer.serialize(preferredEducationIndex, "number");
        }

        if (preferredBodyType !== undefined) {
            localVarQueryParameters['preferredBodyType'] = ObjectSerializer.serialize(preferredBodyType, "string");
        }

        if (preferredEthnicity !== undefined) {
            localVarQueryParameters['preferredEthnicity'] = ObjectSerializer.serialize(preferredEthnicity, "string");
        }

        if (preferredLocation !== undefined) {
            localVarQueryParameters['preferredLocation'] = ObjectSerializer.serialize(preferredLocation, "string");
        }

        if (preferredLocationRange !== undefined) {
            localVarQueryParameters['preferredLocationRange'] = ObjectSerializer.serialize(preferredLocationRange, "number");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        if (acceptedTerms !== undefined) {
            localVarQueryParameters['acceptedTerms'] = ObjectSerializer.serialize(acceptedTerms, "boolean");
        }

        if (inviteToken !== undefined) {
            localVarQueryParameters['inviteToken'] = ObjectSerializer.serialize(inviteToken, "string");
        }

        if (referralAccountId !== undefined) {
            localVarQueryParameters['referralAccountId'] = ObjectSerializer.serialize(referralAccountId, "number");
        }

        if (sendValidation !== undefined) {
            localVarQueryParameters['sendValidation'] = ObjectSerializer.serialize(sendValidation, "boolean");
        }

        if (gameType !== undefined) {
            localVarQueryParameters['gameType'] = ObjectSerializer.serialize(gameType, "string");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (appVersion !== undefined) {
            localVarQueryParameters['appVersion'] = ObjectSerializer.serialize(appVersion, "string");
        }

        if (responseType !== undefined) {
            localVarQueryParameters['responseType'] = ObjectSerializer.serialize(responseType, "string");
        }

        if (audienceIdsToAdd !== undefined) {
            localVarQueryParameters['audienceIdsToAdd'] = ObjectSerializer.serialize(audienceIdsToAdd, "string");
        }

        if (appBlob !== undefined) {
            localVarQueryParameters['appBlob'] = ObjectSerializer.serialize(appBlob, "string");
        }

        if (appEnablePush !== undefined) {
            localVarQueryParameters['appEnablePush'] = ObjectSerializer.serialize(appEnablePush, "boolean");
        }

        if (appEnableSMS !== undefined) {
            localVarQueryParameters['appEnableSMS'] = ObjectSerializer.serialize(appEnableSMS, "boolean");
        }

        if (appEnableEmail !== undefined) {
            localVarQueryParameters['appEnableEmail'] = ObjectSerializer.serialize(appEnableEmail, "boolean");
        }

        if (locationVisibility !== undefined) {
            localVarQueryParameters['locationVisibility'] = ObjectSerializer.serialize(locationVisibility, "string");
        }

        if (homeLatitude !== undefined) {
            localVarQueryParameters['homeLatitude'] = ObjectSerializer.serialize(homeLatitude, "number");
        }

        if (homeLongitude !== undefined) {
            localVarQueryParameters['homeLongitude'] = ObjectSerializer.serialize(homeLongitude, "number");
        }

        if (appNickname !== undefined) {
            localVarQueryParameters['appNickname'] = ObjectSerializer.serialize(appNickname, "string");
        }

        if (personalAudienceId !== undefined) {
            localVarQueryParameters['personalAudienceId'] = ObjectSerializer.serialize(personalAudienceId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AccountLoginResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AccountLoginResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Edit the user\'s profile information
     * @summary Update Account
     * @param deviceId The device id (deviceId or accountId required)
     * @param accountId The account id of the user (deviceId or accountId required)
     * @param connectionAccountId The account id used to edit another person\&#39;s account
     * @param role The account role to change to
     * @param assetId The asset id to set the user\&#39;s profile image
     * @param name The full name of the user. If this parameter is NOT empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName 
     * @param prefixName If the parameter \&#39;name\&#39; is empty or not present, this field will be used to set the prefix of the user\&#39;s name
     * @param firstName If the parameter \&#39;name\&#39; is empty or not present, this field will be used to set the user\&#39;s first name
     * @param middleName If the parameter \&#39;name\&#39; is empty or not present, this field will be used to set the user\&#39;s middle name
     * @param lastName If the parameter \&#39;name\&#39; is empty or not present, this field will be used to set the user\&#39;s last name
     * @param suffixName If the parameter \&#39;name\&#39; is empty or not present, this field will be used to set the suffix of the user\&#39;s name
     * @param title This field will be used to set the user\&#39;s job title
     * @param gender The gender of the user AudienceGender
     * @param age This is deperecated, use the birthday parameter
     * @param birthday The birthday date of the user in UTC milliseconds
     * @param homePhone The home phone number
     * @param cellPhone The cellular phone number
     * @param cellPhoneCarrier The cellular service provider
     * @param businessPhone The business phone number
     * @param emailAddress The user\&#39;s contact email address (NOT the username)
     * @param streetAddress The street address of the user\&#39;s contact location
     * @param streetAddress2 Additional address information (such as a suite number, floor number, building name, or PO Box)
     * @param city The city of the user\&#39;s contact location
     * @param state The state of the user\&#39;s contact location
     * @param zipcode The zipcode of the user\&#39;s contact location
     * @param country The country of the user\&#39;s contact location
     * @param makeProfileInfoPublic Allow anyone to view the user\&#39;s personal profile
     * @param makeGameInfoPublic Allow anyone to view the user\&#39;s game/app info
     * @param makeFriendsInfoPublic Allow anyone to view the user\&#39;s friends list
     * @param hometown The user\&#39;s hometown
     * @param height The user\&#39;s height
     * @param heightIndex The user\&#39;s height in a numerical value that can be used for ordering/searching
     * @param ethnicity The user\&#39;s ethnicity
     * @param bodyType The user\&#39;s body type
     * @param maritalStatus The user\&#39;s marital status
     * @param children The user\&#39;s children status
     * @param religion The user\&#39;s religion
     * @param education The user\&#39;s education
     * @param educationIndex The user\&#39;s education in a numerical value that can be used for ordering/searching
     * @param smoke The user\&#39;s smoke status
     * @param drink The user\&#39;s drink status
     * @param companionship The user\&#39;s companionship status
     * @param companionshipIndex The user\&#39;s companionship index
     * @param preferredMinAge The preferred minimum age in the account location search
     * @param preferredMaxAge The preferred maximum age in the account location search
     * @param preferredMinHeight The preferred minimum height in the account location search
     * @param preferredMaxHeight The preferred maximum height in the account location search
     * @param preferredGender The preferred gender in the account location search
     * @param preferredEducation The preferred education in the account location search
     * @param preferredEducationIndex The preferred education in a numerical value that can be used for ordering/searching
     * @param preferredBodyType The preferred body type in the account location search
     * @param preferredEthnicity The preferred ethnicity in the account location search
     * @param preferredLocation The preferred education in the account location search
     * @param preferredLocationRange The preferred location range in the account location search
     * @param platforms Platforms
     * @param tags Tags
     * @param aboutUs About Us
     * @param matchToken Match Token
     * @param gameExperience Game Experience
     * @param categories Deprecated use categoryIds
     * @param categoryIds A list of category ids that represent interests and associations
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data
     * @param showAsZipcode The user\&#39;s preference if they want to be shown by zipcode on a map
     * @param showExactLocation The user\&#39;s preference if they want to be shown by their exact location on a map
     * @param showOthersExactLocation The user\&#39;s preference if they want to see others exact location on a map
     * @param acceptedTerms Accepted Terms
     * @param locationVisibility Location Visibility
     * @param appBlob App Blob
     * @param appEnablePush App Enable Push
     * @param appEnableSMS App Enable SMS
     * @param appEnableEmail App Enable Email
     * @param gameType Game Type
     * @param appKey The application key
     * @param latitude The current latitude of the user
     * @param longitude The current longitude of the user
     * @param returnProfile Return Profile
     * @param audienceIdsToAdd Audience Ids to add
     * @param audienceIdsToRemove Audience Ids to remove
     * @param referralAccountId The account id of the referrer
     * @param appNickname App nickname
     * @param personalAudienceId Personal Audience
     * @param nonGuestUsername The user\&#39;s username to update with if they currently have a guest username
     */
    public async editAccount (deviceId?: string, accountId?: number, connectionAccountId?: number, role?: string, assetId?: number, name?: string, prefixName?: string, firstName?: string, middleName?: string, lastName?: string, suffixName?: string, title?: string, gender?: string, age?: number, birthday?: number, homePhone?: string, cellPhone?: string, cellPhoneCarrier?: string, businessPhone?: string, emailAddress?: string, streetAddress?: string, streetAddress2?: string, city?: string, state?: string, zipcode?: string, country?: string, makeProfileInfoPublic?: boolean, makeGameInfoPublic?: boolean, makeFriendsInfoPublic?: boolean, hometown?: string, height?: string, heightIndex?: number, ethnicity?: string, bodyType?: string, maritalStatus?: string, children?: string, religion?: string, education?: string, educationIndex?: number, smoke?: string, drink?: string, companionship?: string, companionshipIndex?: number, preferredMinAge?: number, preferredMaxAge?: number, preferredMinHeight?: number, preferredMaxHeight?: number, preferredGender?: string, preferredEducation?: string, preferredEducationIndex?: number, preferredBodyType?: string, preferredEthnicity?: string, preferredLocation?: string, preferredLocationRange?: number, platforms?: string, tags?: string, aboutUs?: string, matchToken?: string, gameExperience?: string, categories?: string, categoryIds?: string, responseFilters?: string, showAsZipcode?: boolean, showExactLocation?: boolean, showOthersExactLocation?: boolean, acceptedTerms?: boolean, locationVisibility?: string, appBlob?: string, appEnablePush?: boolean, appEnableSMS?: boolean, appEnableEmail?: boolean, gameType?: string, appKey?: string, latitude?: number, longitude?: number, returnProfile?: boolean, audienceIdsToAdd?: string, audienceIdsToRemove?: string, referralAccountId?: number, appNickname?: string, personalAudienceId?: number, nonGuestUsername?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ProfileInfoResponse;  }> {
        const localVarPath = this.basePath + '/account/profile/update';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (connectionAccountId !== undefined) {
            localVarQueryParameters['connectionAccountId'] = ObjectSerializer.serialize(connectionAccountId, "number");
        }

        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "string");
        }

        if (assetId !== undefined) {
            localVarQueryParameters['assetId'] = ObjectSerializer.serialize(assetId, "number");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (prefixName !== undefined) {
            localVarQueryParameters['prefixName'] = ObjectSerializer.serialize(prefixName, "string");
        }

        if (firstName !== undefined) {
            localVarQueryParameters['firstName'] = ObjectSerializer.serialize(firstName, "string");
        }

        if (middleName !== undefined) {
            localVarQueryParameters['middleName'] = ObjectSerializer.serialize(middleName, "string");
        }

        if (lastName !== undefined) {
            localVarQueryParameters['lastName'] = ObjectSerializer.serialize(lastName, "string");
        }

        if (suffixName !== undefined) {
            localVarQueryParameters['suffixName'] = ObjectSerializer.serialize(suffixName, "string");
        }

        if (title !== undefined) {
            localVarQueryParameters['title'] = ObjectSerializer.serialize(title, "string");
        }

        if (gender !== undefined) {
            localVarQueryParameters['gender'] = ObjectSerializer.serialize(gender, "string");
        }

        if (age !== undefined) {
            localVarQueryParameters['age'] = ObjectSerializer.serialize(age, "number");
        }

        if (birthday !== undefined) {
            localVarQueryParameters['birthday'] = ObjectSerializer.serialize(birthday, "number");
        }

        if (homePhone !== undefined) {
            localVarQueryParameters['homePhone'] = ObjectSerializer.serialize(homePhone, "string");
        }

        if (cellPhone !== undefined) {
            localVarQueryParameters['cellPhone'] = ObjectSerializer.serialize(cellPhone, "string");
        }

        if (cellPhoneCarrier !== undefined) {
            localVarQueryParameters['cellPhoneCarrier'] = ObjectSerializer.serialize(cellPhoneCarrier, "string");
        }

        if (businessPhone !== undefined) {
            localVarQueryParameters['businessPhone'] = ObjectSerializer.serialize(businessPhone, "string");
        }

        if (emailAddress !== undefined) {
            localVarQueryParameters['emailAddress'] = ObjectSerializer.serialize(emailAddress, "string");
        }

        if (streetAddress !== undefined) {
            localVarQueryParameters['streetAddress'] = ObjectSerializer.serialize(streetAddress, "string");
        }

        if (streetAddress2 !== undefined) {
            localVarQueryParameters['streetAddress2'] = ObjectSerializer.serialize(streetAddress2, "string");
        }

        if (city !== undefined) {
            localVarQueryParameters['city'] = ObjectSerializer.serialize(city, "string");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "string");
        }

        if (zipcode !== undefined) {
            localVarQueryParameters['zipcode'] = ObjectSerializer.serialize(zipcode, "string");
        }

        if (country !== undefined) {
            localVarQueryParameters['country'] = ObjectSerializer.serialize(country, "string");
        }

        if (makeProfileInfoPublic !== undefined) {
            localVarQueryParameters['makeProfileInfoPublic'] = ObjectSerializer.serialize(makeProfileInfoPublic, "boolean");
        }

        if (makeGameInfoPublic !== undefined) {
            localVarQueryParameters['makeGameInfoPublic'] = ObjectSerializer.serialize(makeGameInfoPublic, "boolean");
        }

        if (makeFriendsInfoPublic !== undefined) {
            localVarQueryParameters['makeFriendsInfoPublic'] = ObjectSerializer.serialize(makeFriendsInfoPublic, "boolean");
        }

        if (hometown !== undefined) {
            localVarQueryParameters['hometown'] = ObjectSerializer.serialize(hometown, "string");
        }

        if (height !== undefined) {
            localVarQueryParameters['height'] = ObjectSerializer.serialize(height, "string");
        }

        if (heightIndex !== undefined) {
            localVarQueryParameters['heightIndex'] = ObjectSerializer.serialize(heightIndex, "number");
        }

        if (ethnicity !== undefined) {
            localVarQueryParameters['ethnicity'] = ObjectSerializer.serialize(ethnicity, "string");
        }

        if (bodyType !== undefined) {
            localVarQueryParameters['bodyType'] = ObjectSerializer.serialize(bodyType, "string");
        }

        if (maritalStatus !== undefined) {
            localVarQueryParameters['maritalStatus'] = ObjectSerializer.serialize(maritalStatus, "string");
        }

        if (children !== undefined) {
            localVarQueryParameters['children'] = ObjectSerializer.serialize(children, "string");
        }

        if (religion !== undefined) {
            localVarQueryParameters['religion'] = ObjectSerializer.serialize(religion, "string");
        }

        if (education !== undefined) {
            localVarQueryParameters['education'] = ObjectSerializer.serialize(education, "string");
        }

        if (educationIndex !== undefined) {
            localVarQueryParameters['educationIndex'] = ObjectSerializer.serialize(educationIndex, "number");
        }

        if (smoke !== undefined) {
            localVarQueryParameters['smoke'] = ObjectSerializer.serialize(smoke, "string");
        }

        if (drink !== undefined) {
            localVarQueryParameters['drink'] = ObjectSerializer.serialize(drink, "string");
        }

        if (companionship !== undefined) {
            localVarQueryParameters['companionship'] = ObjectSerializer.serialize(companionship, "string");
        }

        if (companionshipIndex !== undefined) {
            localVarQueryParameters['companionshipIndex'] = ObjectSerializer.serialize(companionshipIndex, "number");
        }

        if (preferredMinAge !== undefined) {
            localVarQueryParameters['preferredMinAge'] = ObjectSerializer.serialize(preferredMinAge, "number");
        }

        if (preferredMaxAge !== undefined) {
            localVarQueryParameters['preferredMaxAge'] = ObjectSerializer.serialize(preferredMaxAge, "number");
        }

        if (preferredMinHeight !== undefined) {
            localVarQueryParameters['preferredMinHeight'] = ObjectSerializer.serialize(preferredMinHeight, "number");
        }

        if (preferredMaxHeight !== undefined) {
            localVarQueryParameters['preferredMaxHeight'] = ObjectSerializer.serialize(preferredMaxHeight, "number");
        }

        if (preferredGender !== undefined) {
            localVarQueryParameters['preferredGender'] = ObjectSerializer.serialize(preferredGender, "string");
        }

        if (preferredEducation !== undefined) {
            localVarQueryParameters['preferredEducation'] = ObjectSerializer.serialize(preferredEducation, "string");
        }

        if (preferredEducationIndex !== undefined) {
            localVarQueryParameters['preferredEducationIndex'] = ObjectSerializer.serialize(preferredEducationIndex, "number");
        }

        if (preferredBodyType !== undefined) {
            localVarQueryParameters['preferredBodyType'] = ObjectSerializer.serialize(preferredBodyType, "string");
        }

        if (preferredEthnicity !== undefined) {
            localVarQueryParameters['preferredEthnicity'] = ObjectSerializer.serialize(preferredEthnicity, "string");
        }

        if (preferredLocation !== undefined) {
            localVarQueryParameters['preferredLocation'] = ObjectSerializer.serialize(preferredLocation, "string");
        }

        if (preferredLocationRange !== undefined) {
            localVarQueryParameters['preferredLocationRange'] = ObjectSerializer.serialize(preferredLocationRange, "number");
        }

        if (platforms !== undefined) {
            localVarQueryParameters['platforms'] = ObjectSerializer.serialize(platforms, "string");
        }

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "string");
        }

        if (aboutUs !== undefined) {
            localVarQueryParameters['aboutUs'] = ObjectSerializer.serialize(aboutUs, "string");
        }

        if (matchToken !== undefined) {
            localVarQueryParameters['matchToken'] = ObjectSerializer.serialize(matchToken, "string");
        }

        if (gameExperience !== undefined) {
            localVarQueryParameters['gameExperience'] = ObjectSerializer.serialize(gameExperience, "string");
        }

        if (categories !== undefined) {
            localVarQueryParameters['categories'] = ObjectSerializer.serialize(categories, "string");
        }

        if (categoryIds !== undefined) {
            localVarQueryParameters['categoryIds'] = ObjectSerializer.serialize(categoryIds, "string");
        }

        if (responseFilters !== undefined) {
            localVarQueryParameters['responseFilters'] = ObjectSerializer.serialize(responseFilters, "string");
        }

        if (showAsZipcode !== undefined) {
            localVarQueryParameters['showAsZipcode'] = ObjectSerializer.serialize(showAsZipcode, "boolean");
        }

        if (showExactLocation !== undefined) {
            localVarQueryParameters['showExactLocation'] = ObjectSerializer.serialize(showExactLocation, "boolean");
        }

        if (showOthersExactLocation !== undefined) {
            localVarQueryParameters['showOthersExactLocation'] = ObjectSerializer.serialize(showOthersExactLocation, "boolean");
        }

        if (acceptedTerms !== undefined) {
            localVarQueryParameters['acceptedTerms'] = ObjectSerializer.serialize(acceptedTerms, "boolean");
        }

        if (locationVisibility !== undefined) {
            localVarQueryParameters['locationVisibility'] = ObjectSerializer.serialize(locationVisibility, "string");
        }

        if (appBlob !== undefined) {
            localVarQueryParameters['appBlob'] = ObjectSerializer.serialize(appBlob, "string");
        }

        if (appEnablePush !== undefined) {
            localVarQueryParameters['appEnablePush'] = ObjectSerializer.serialize(appEnablePush, "boolean");
        }

        if (appEnableSMS !== undefined) {
            localVarQueryParameters['appEnableSMS'] = ObjectSerializer.serialize(appEnableSMS, "boolean");
        }

        if (appEnableEmail !== undefined) {
            localVarQueryParameters['appEnableEmail'] = ObjectSerializer.serialize(appEnableEmail, "boolean");
        }

        if (gameType !== undefined) {
            localVarQueryParameters['gameType'] = ObjectSerializer.serialize(gameType, "string");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        if (returnProfile !== undefined) {
            localVarQueryParameters['returnProfile'] = ObjectSerializer.serialize(returnProfile, "boolean");
        }

        if (audienceIdsToAdd !== undefined) {
            localVarQueryParameters['audienceIdsToAdd'] = ObjectSerializer.serialize(audienceIdsToAdd, "string");
        }

        if (audienceIdsToRemove !== undefined) {
            localVarQueryParameters['audienceIdsToRemove'] = ObjectSerializer.serialize(audienceIdsToRemove, "string");
        }

        if (referralAccountId !== undefined) {
            localVarQueryParameters['referralAccountId'] = ObjectSerializer.serialize(referralAccountId, "number");
        }

        if (appNickname !== undefined) {
            localVarQueryParameters['appNickname'] = ObjectSerializer.serialize(appNickname, "string");
        }

        if (personalAudienceId !== undefined) {
            localVarQueryParameters['personalAudienceId'] = ObjectSerializer.serialize(personalAudienceId, "number");
        }

        if (nonGuestUsername !== undefined) {
            localVarQueryParameters['nonGuestUsername'] = ObjectSerializer.serialize(nonGuestUsername, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ProfileInfoResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ProfileInfoResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update account\'s own username and/or emailAddress
     * @summary Update Username and Email
     * @param deviceId The device id
     * @param accountId The account id of the user (deviceId or accountId required)
     * @param emailAddress the user\&#39;s contact email address (NOT the username) which is also used for email validation
     * @param username the user\&#39;s username to update with if they currently have a guest username
     */
    public async editUsername (deviceId?: string, accountId?: number, emailAddress?: string, username?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/account/username/update';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (emailAddress !== undefined) {
            localVarQueryParameters['emailAddress'] = ObjectSerializer.serialize(emailAddress, "string");
        }

        if (username !== undefined) {
            localVarQueryParameters['username'] = ObjectSerializer.serialize(username, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Gets a user\'s account profile. Application settings and account settings will also be returned for the owner of the account.
     * @summary Get Account
     * @param returnNulls Return Nulls
     * @param deviceId The device id (deviceId or accountId required)
     * @param accountId The account id of the user (deviceId or accountId required)
     * @param connectionAccountEmail Connection Account Email
     * @param connectionAccountId The account id used to view another person\&#39;s account
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data
     * @param gameType Game Type
     * @param appKey The application key
     * @param purchaseType Purchase Type
     * @param updateViewedDate Determines whether to track if a person has viewed someone\&#39;s profile
     * @param latitude Latitude used to update the user\&#39;s current location
     * @param longitude Longitude used to update the user\&#39;s current location
     */
    public async getAccount (returnNulls?: boolean, deviceId?: string, accountId?: number, connectionAccountEmail?: string, connectionAccountId?: number, responseFilters?: string, gameType?: string, appKey?: string, purchaseType?: string, updateViewedDate?: boolean, latitude?: number, longitude?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ProfileResponse;  }> {
        const localVarPath = this.basePath + '/account/profile/get';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (returnNulls !== undefined) {
            localVarQueryParameters['returnNulls'] = ObjectSerializer.serialize(returnNulls, "boolean");
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (connectionAccountEmail !== undefined) {
            localVarQueryParameters['connectionAccountEmail'] = ObjectSerializer.serialize(connectionAccountEmail, "string");
        }

        if (connectionAccountId !== undefined) {
            localVarQueryParameters['connectionAccountId'] = ObjectSerializer.serialize(connectionAccountId, "number");
        }

        if (responseFilters !== undefined) {
            localVarQueryParameters['responseFilters'] = ObjectSerializer.serialize(responseFilters, "string");
        }

        if (gameType !== undefined) {
            localVarQueryParameters['gameType'] = ObjectSerializer.serialize(gameType, "string");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (purchaseType !== undefined) {
            localVarQueryParameters['purchaseType'] = ObjectSerializer.serialize(purchaseType, "string");
        }

        if (updateViewedDate !== undefined) {
            localVarQueryParameters['updateViewedDate'] = ObjectSerializer.serialize(updateViewedDate, "boolean");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ProfileResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ProfileResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a list of assets a person has ever uploaded. Filters the list based on parameters.
     * @summary Get Profile Assets
     * @param returnNulls Determines whether to return null fields in the response
     * @param deviceId The device id (deviceId or accountId required)
     * @param accountId The account id of the user (deviceId or accountId required)
     * @param ownerId The account id of the person the user wants to view
     * @param mediaTypes Comma separated list of MediaType
     * @param mimeTypes Comma separated list of mime types
     * @param sortField Determines what the returning list will be sorted by (see AssetApiMap)
     * @param descending Determines whether to return the resulting list in descending or ascending order
     * @param latitude Latitude used to update the user\&#39;s current location
     * @param longitude Longitude used to update the user\&#39;s current location
     * @param i _i
     * @param start Start of the pagination
     * @param l _l
     * @param limit Limit of the pagination
     */
    public async getProfileAssets (returnNulls?: boolean, deviceId?: string, accountId?: number, ownerId?: number, mediaTypes?: string, mimeTypes?: string, sortField?: string, descending?: boolean, latitude?: number, longitude?: number, i?: number, start?: number, l?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AssetListResponse;  }> {
        const localVarPath = this.basePath + '/account/profile/assets';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (returnNulls !== undefined) {
            localVarQueryParameters['returnNulls'] = ObjectSerializer.serialize(returnNulls, "boolean");
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (ownerId !== undefined) {
            localVarQueryParameters['ownerId'] = ObjectSerializer.serialize(ownerId, "number");
        }

        if (mediaTypes !== undefined) {
            localVarQueryParameters['mediaTypes'] = ObjectSerializer.serialize(mediaTypes, "string");
        }

        if (mimeTypes !== undefined) {
            localVarQueryParameters['mimeTypes'] = ObjectSerializer.serialize(mimeTypes, "string");
        }

        if (sortField !== undefined) {
            localVarQueryParameters['sortField'] = ObjectSerializer.serialize(sortField, "string");
        }

        if (descending !== undefined) {
            localVarQueryParameters['descending'] = ObjectSerializer.serialize(descending, "boolean");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        if (i !== undefined) {
            localVarQueryParameters['_i'] = ObjectSerializer.serialize(i, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (l !== undefined) {
            localVarQueryParameters['_l'] = ObjectSerializer.serialize(l, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AssetListResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AssetListResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Gets a user\'s account profile and their referral List.
     * @summary Search Accounts
     * @param accountId The account id of the user (deviceId or accountId required)
     * @param appKey The application key
     * @param retrieveType one of these option - GET_CHILDREN will get all accounts that had signed up using the current account invite link - GET_ANCESTOR will get all accounts that referred the current account and it\&#39;s parents, recursively - GET_ALL will get all of the above
     * @param levelLimit level limit for children and ancestors of current account, starts from current account
     * @param ancestorLevelLimit level limit for ancestors, will override levelLimit if this is set
     * @param childrenLevelLimit level limit for children, will override levelLimit if this is set
     * @param ancestorListStart pagination start for children list
     * @param ancestorListLimit pagination limit for children list
     * @param childrenListStart pagination start for children list
     * @param childrenListLimit pagination limit for children list
     * @param childrenChildren if true, on each item in ancestor and children list, return the childrenTotalNumber and ancestorTotalNumber for that item
     */
    public async getReferralList (accountId?: number, appKey?: string, retrieveType?: string, levelLimit?: number, ancestorLevelLimit?: number, childrenLevelLimit?: number, ancestorListStart?: number, ancestorListLimit?: number, childrenListStart?: number, childrenListLimit?: number, childrenChildren?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/account/referral/list';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (retrieveType !== undefined) {
            localVarQueryParameters['retrieveType'] = ObjectSerializer.serialize(retrieveType, "string");
        }

        if (levelLimit !== undefined) {
            localVarQueryParameters['levelLimit'] = ObjectSerializer.serialize(levelLimit, "number");
        }

        if (ancestorLevelLimit !== undefined) {
            localVarQueryParameters['ancestorLevelLimit'] = ObjectSerializer.serialize(ancestorLevelLimit, "number");
        }

        if (childrenLevelLimit !== undefined) {
            localVarQueryParameters['childrenLevelLimit'] = ObjectSerializer.serialize(childrenLevelLimit, "number");
        }

        if (ancestorListStart !== undefined) {
            localVarQueryParameters['ancestorListStart'] = ObjectSerializer.serialize(ancestorListStart, "number");
        }

        if (ancestorListLimit !== undefined) {
            localVarQueryParameters['ancestorListLimit'] = ObjectSerializer.serialize(ancestorListLimit, "number");
        }

        if (childrenListStart !== undefined) {
            localVarQueryParameters['childrenListStart'] = ObjectSerializer.serialize(childrenListStart, "number");
        }

        if (childrenListLimit !== undefined) {
            localVarQueryParameters['childrenListLimit'] = ObjectSerializer.serialize(childrenListLimit, "number");
        }

        if (childrenChildren !== undefined) {
            localVarQueryParameters['childrenChildren'] = ObjectSerializer.serialize(childrenChildren, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get the account settings for a user
     * @summary Get Account Settings
     * @param deviceId The device id (deviceId or accountId required)
     * @param accountId The account id of the user (deviceId or accountId required)
     * @param latitude The current latitude of the user
     * @param longitude The current longitude of the user
     */
    public async getSettings (deviceId?: string, accountId?: number, latitude?: number, longitude?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: UserSettingsResponse;  }> {
        const localVarPath = this.basePath + '/account/settings/get';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: UserSettingsResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "UserSettingsResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * A login service that supports logging in as someone else (accounts that the user manages). Intended for internal use for now.
     * @summary Login as Account
     * @param accessToken 
     * @param appKey 
     * @param deviceId 
     * @param accessTokenSecret 
     * @param delegatedAccountId 
     * @param delegatedUsername 
     * @param networkUID The access provider to authenticate against (default: USERNAME). Supported values: FACEBOOK, TWITTER, USERNAME, PHONE
     * @param ageRestriction Checks user\&#39;s birthday to see if they meet an age requirement. If the user is under age, an error message is returned.
     * @param responseFilters This determines how much of the profile should be returned, see ProfileFilters
     * @param latitude 
     * @param longitude 
     */
    public async loginDelegate (accessToken: string, appKey: string, deviceId?: string, accessTokenSecret?: string, delegatedAccountId?: number, delegatedUsername?: string, networkUID?: string, ageRestriction?: number, responseFilters?: string, latitude?: number, longitude?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ProfileResponse;  }> {
        const localVarPath = this.basePath + '/account/login/delegate';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling loginDelegate.');
        }

        // verify required parameter 'appKey' is not null or undefined
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling loginDelegate.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accessToken !== undefined) {
            localVarQueryParameters['accessToken'] = ObjectSerializer.serialize(accessToken, "string");
        }

        if (accessTokenSecret !== undefined) {
            localVarQueryParameters['accessTokenSecret'] = ObjectSerializer.serialize(accessTokenSecret, "string");
        }

        if (delegatedAccountId !== undefined) {
            localVarQueryParameters['delegatedAccountId'] = ObjectSerializer.serialize(delegatedAccountId, "number");
        }

        if (delegatedUsername !== undefined) {
            localVarQueryParameters['delegatedUsername'] = ObjectSerializer.serialize(delegatedUsername, "string");
        }

        if (networkUID !== undefined) {
            localVarQueryParameters['networkUID'] = ObjectSerializer.serialize(networkUID, "string");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (ageRestriction !== undefined) {
            localVarQueryParameters['ageRestriction'] = ObjectSerializer.serialize(ageRestriction, "number");
        }

        if (responseFilters !== undefined) {
            localVarQueryParameters['responseFilters'] = ObjectSerializer.serialize(responseFilters, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ProfileResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ProfileResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * General login service that supports various authentication methods. Currently supports Facebook, Twitter, Sirqul Username, and Sirqul Phone by default. Can also support custom networks created using the {@link ThirdPartyApi}
     * @summary Login Account
     * @param accessToken The access token to authenticate with (ex: username or fb token)
     * @param networkUID The access provider to authenticate against. This can be custom  networks created using the ThirdPartyApi as well. Supported values by default  include: FACEBOOK, TWITTER, USERNAME, PHONE 
     * @param appKey The application key
     * @param deviceId The unique id of the device making the request
     * @param deviceIdType The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc
     * @param accessTokenSecret The secret to authenticate with (ex: password)
     * @param ageRestriction Checks user\&#39;s birthday to see if they meet an age requirement. If the user is under age, an error message is returned.
     * @param responseFilters This determines how much of the profile should be returned, see ProfileFilters
     * @param latitude Used to update the user\&#39;s current location
     * @param longitude Used to update the user\&#39;s current location
     * @param emailMatch Option to check for email if username doesn\&#39;t match, also support multiple accounts
     * @param chosenAccountId Chosen account Id sent from the app - pass in the 2nd request to choose an account from multiple accounts matching the email - use one of the account id from the previous request
     * @param thirdPartyCredentialId Third-party credential Id, pass in the 2nd request to choose an account from multiple accounts matching the email - use the id from the previous call ThirdPartyCredential object
     */
    public async loginGeneral (accessToken: string, networkUID: string, appKey: string, deviceId?: string, deviceIdType?: string, accessTokenSecret?: string, ageRestriction?: number, responseFilters?: string, latitude?: number, longitude?: number, emailMatch?: boolean, chosenAccountId?: number, thirdPartyCredentialId?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ProfileResponse;  }> {
        const localVarPath = this.basePath + '/account/login';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling loginGeneral.');
        }

        // verify required parameter 'networkUID' is not null or undefined
        if (networkUID === null || networkUID === undefined) {
            throw new Error('Required parameter networkUID was null or undefined when calling loginGeneral.');
        }

        // verify required parameter 'appKey' is not null or undefined
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling loginGeneral.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (deviceIdType !== undefined) {
            localVarQueryParameters['deviceIdType'] = ObjectSerializer.serialize(deviceIdType, "string");
        }

        if (accessToken !== undefined) {
            localVarQueryParameters['accessToken'] = ObjectSerializer.serialize(accessToken, "string");
        }

        if (accessTokenSecret !== undefined) {
            localVarQueryParameters['accessTokenSecret'] = ObjectSerializer.serialize(accessTokenSecret, "string");
        }

        if (networkUID !== undefined) {
            localVarQueryParameters['networkUID'] = ObjectSerializer.serialize(networkUID, "string");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (ageRestriction !== undefined) {
            localVarQueryParameters['ageRestriction'] = ObjectSerializer.serialize(ageRestriction, "number");
        }

        if (responseFilters !== undefined) {
            localVarQueryParameters['responseFilters'] = ObjectSerializer.serialize(responseFilters, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        if (emailMatch !== undefined) {
            localVarQueryParameters['emailMatch'] = ObjectSerializer.serialize(emailMatch, "boolean");
        }

        if (chosenAccountId !== undefined) {
            localVarQueryParameters['chosenAccountId'] = ObjectSerializer.serialize(chosenAccountId, "number");
        }

        if (thirdPartyCredentialId !== undefined) {
            localVarQueryParameters['thirdPartyCredentialId'] = ObjectSerializer.serialize(thirdPartyCredentialId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ProfileResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ProfileResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Login to system with an account
     * @summary Login Account (Username)
     * @param username the user\&#39;s email address they used to sign-up
     * @param password the password
     * @param deviceId the device id
     * @param latitude the current latitude of the user
     * @param longitude the current longitude of the user
     * @param app the app
     * @param gameType This parameter is deprecated. This is deprecated, use appKey.
     * @param appKey the application key
     * @param returnProfile the profile to return
     * @param responseFilters a comma separated list of ProfileFilters for filtering the returned response data
     */
    public async loginUsername (username: string, password: string, deviceId?: string, latitude?: number, longitude?: number, app?: string, gameType?: string, appKey?: string, returnProfile?: boolean, responseFilters?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ProfileResponse;  }> {
        const localVarPath = this.basePath + '/account/get';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling loginUsername.');
        }

        // verify required parameter 'password' is not null or undefined
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling loginUsername.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (username !== undefined) {
            localVarQueryParameters['username'] = ObjectSerializer.serialize(username, "string");
        }

        if (password !== undefined) {
            localVarQueryParameters['password'] = ObjectSerializer.serialize(password, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        if (app !== undefined) {
            localVarQueryParameters['app'] = ObjectSerializer.serialize(app, "string");
        }

        if (gameType !== undefined) {
            localVarQueryParameters['gameType'] = ObjectSerializer.serialize(gameType, "string");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (returnProfile !== undefined) {
            localVarQueryParameters['returnProfile'] = ObjectSerializer.serialize(returnProfile, "boolean");
        }

        if (responseFilters !== undefined) {
            localVarQueryParameters['responseFilters'] = ObjectSerializer.serialize(responseFilters, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ProfileResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ProfileResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Cleans up the users data for logging out.
     * @summary Logout Account
     * @param deviceId The device id (deviceId or accountId required)
     * @param deviceIdType Device Id Type
     * @param accountId The account id of the user (deviceId or accountId required)
     * @param latitude The current latitude of the user
     * @param longitude The current longitude of the user
     */
    public async logout (deviceId?: string, deviceIdType?: string, accountId?: number, latitude?: number, longitude?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/account/logout';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (deviceIdType !== undefined) {
            localVarQueryParameters['deviceIdType'] = ObjectSerializer.serialize(deviceIdType, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Merges the analytics, achievements, leaderboards of two accounts.
     * @summary Merge Account
     * @param mergeAccountId The id of the account to being merged
     * @param appKey The application key
     * @param deviceId The device id (deviceId or accountId required)
     * @param accountId The account id of the user (deviceId or accountId required)
     */
    public async mergeAccount (mergeAccountId: number, appKey: string, deviceId?: string, accountId?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/account/merge';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'mergeAccountId' is not null or undefined
        if (mergeAccountId === null || mergeAccountId === undefined) {
            throw new Error('Required parameter mergeAccountId was null or undefined when calling mergeAccount.');
        }

        // verify required parameter 'appKey' is not null or undefined
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling mergeAccount.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (mergeAccountId !== undefined) {
            localVarQueryParameters['mergeAccountId'] = ObjectSerializer.serialize(mergeAccountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update the account password.
     * @summary Update Password
     * @param accountId The account to update
     * @param oldPassword The current password, used to validate access
     * @param newPassword The new password to set, cannot be empty
     * @param confirmPassword The new password to confirm, must match newPassword
     */
    public async passwordChange (accountId: number, oldPassword: string, newPassword: string, confirmPassword: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/account/passwordchange';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling passwordChange.');
        }

        // verify required parameter 'oldPassword' is not null or undefined
        if (oldPassword === null || oldPassword === undefined) {
            throw new Error('Required parameter oldPassword was null or undefined when calling passwordChange.');
        }

        // verify required parameter 'newPassword' is not null or undefined
        if (newPassword === null || newPassword === undefined) {
            throw new Error('Required parameter newPassword was null or undefined when calling passwordChange.');
        }

        // verify required parameter 'confirmPassword' is not null or undefined
        if (confirmPassword === null || confirmPassword === undefined) {
            throw new Error('Required parameter confirmPassword was null or undefined when calling passwordChange.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (oldPassword !== undefined) {
            localVarQueryParameters['oldPassword'] = ObjectSerializer.serialize(oldPassword, "string");
        }

        if (newPassword !== undefined) {
            localVarQueryParameters['newPassword'] = ObjectSerializer.serialize(newPassword, "string");
        }

        if (confirmPassword !== undefined) {
            localVarQueryParameters['confirmPassword'] = ObjectSerializer.serialize(confirmPassword, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Reset the account password. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token.
     * @summary Reset Password
     * @param token The token associated with the account to update, good for 24 hours
     * @param password The new password to set, cannot be empty
     * @param confirm The new password to confirm, must match newPassword
     */
    public async passwordReset (token: string, password: string, confirm: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/account/passwordreset';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'token' is not null or undefined
        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling passwordReset.');
        }

        // verify required parameter 'password' is not null or undefined
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling passwordReset.');
        }

        // verify required parameter 'confirm' is not null or undefined
        if (confirm === null || confirm === undefined) {
            throw new Error('Required parameter confirm was null or undefined when calling passwordReset.');
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (password !== undefined) {
            localVarQueryParameters['password'] = ObjectSerializer.serialize(password, "string");
        }

        if (confirm !== undefined) {
            localVarQueryParameters['confirm'] = ObjectSerializer.serialize(confirm, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Request that an account password be reset. The account is looked up by email address and then a link is sent via email to that account with a reset token. The token is valid for 24 hours.
     * @summary Request Password Reset
     * @param email The email/username of the account
     * @param from this is the sender email
     * @param domain this is the domain (like dev.sirqul.com) used to generate the password reset link
     * @param subUrl this is the the subUrl (like resetpassword) used to generate a password reset link
     * @param referer this is used to generate a password reset link
     */
    public async requestPasswordReset (email: string, from?: string, domain?: string, subUrl?: string, referer?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/account/requestpasswordreset';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling requestPasswordReset.');
        }

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "string");
        }

        if (domain !== undefined) {
            localVarQueryParameters['domain'] = ObjectSerializer.serialize(domain, "string");
        }

        if (subUrl !== undefined) {
            localVarQueryParameters['subUrl'] = ObjectSerializer.serialize(subUrl, "string");
        }

        if (referer !== undefined) {
            localVarQueryParameters['referer'] = ObjectSerializer.serialize(referer, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Send an email to validate a user\'s account.
     * @summary Send Validation Request
     * @param accountId The account id of the user
     */
    public async requestValidateAccount (accountId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/account/requestValidateAccount';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling requestValidateAccount.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Search for account profiles.
     * @summary Search Accounts
     * @param accountId The id of the account requesting
     * @param appKey The application key
     * @param keyword The keyword for for querying the account
     * @param latitude the latitude
     * @param longitude the longitude
     * @param radius the radius
     * @param gender the user\&#39;s gender
     * @param gameExperience the user\&#39;s Game Experience
     * @param age the user\&#39;s age
     * @param categoryIds the user\&#39;s Category Ids
     * @param returnNulls Return Nulls
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data
     * @param purchaseType A comma separated list of PurchaseType
     * @param sortField The field to sort by
     * @param descending The order to return the results. Default is false, which will return the results in ascending order.
     * @param start The index into the record set to start with.
     * @param limit The total number of record to return.
     * @param activeOnly Determines whether to return only active results. Default is false.
     */
    public async searchAccounts (accountId: number, appKey: string, keyword?: string, latitude?: number, longitude?: number, radius?: number, gender?: 'MALE' | 'FEMALE' | 'ANY', gameExperience?: 'ANY' | 'NEW' | 'BEGINNER' | 'INTERMEDIATE' | 'EXPERT', age?: number, categoryIds?: string, returnNulls?: boolean, responseFilters?: string, purchaseType?: string, sortField?: string, descending?: boolean, start?: number, limit?: number, activeOnly?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<ProfileResponse>;  }> {
        const localVarPath = this.basePath + '/account/profile/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling searchAccounts.');
        }

        // verify required parameter 'appKey' is not null or undefined
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling searchAccounts.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (keyword !== undefined) {
            localVarQueryParameters['keyword'] = ObjectSerializer.serialize(keyword, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        if (radius !== undefined) {
            localVarQueryParameters['radius'] = ObjectSerializer.serialize(radius, "number");
        }

        if (gender !== undefined) {
            localVarQueryParameters['gender'] = ObjectSerializer.serialize(gender, "'MALE' | 'FEMALE' | 'ANY'");
        }

        if (gameExperience !== undefined) {
            localVarQueryParameters['gameExperience'] = ObjectSerializer.serialize(gameExperience, "'ANY' | 'NEW' | 'BEGINNER' | 'INTERMEDIATE' | 'EXPERT'");
        }

        if (age !== undefined) {
            localVarQueryParameters['age'] = ObjectSerializer.serialize(age, "number");
        }

        if (categoryIds !== undefined) {
            localVarQueryParameters['categoryIds'] = ObjectSerializer.serialize(categoryIds, "string");
        }

        if (returnNulls !== undefined) {
            localVarQueryParameters['returnNulls'] = ObjectSerializer.serialize(returnNulls, "boolean");
        }

        if (responseFilters !== undefined) {
            localVarQueryParameters['responseFilters'] = ObjectSerializer.serialize(responseFilters, "string");
        }

        if (purchaseType !== undefined) {
            localVarQueryParameters['purchaseType'] = ObjectSerializer.serialize(purchaseType, "string");
        }

        if (sortField !== undefined) {
            localVarQueryParameters['sortField'] = ObjectSerializer.serialize(sortField, "string");
        }

        if (descending !== undefined) {
            localVarQueryParameters['descending'] = ObjectSerializer.serialize(descending, "boolean");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (activeOnly !== undefined) {
            localVarQueryParameters['activeOnly'] = ObjectSerializer.serialize(activeOnly, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<ProfileResponse>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<ProfileResponse>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * ogin with encrypted user-name and password.
     * @summary Login Account (Encrypted Username)
     * @param username The user\&#39;s encrypted email address they used to sign-up
     * @param password The encrypted password
     * @param gameType The application key
     * @param deviceId The device id
     * @param charsetName Charset Name
     * @param latitude The current latitude of the user
     * @param longitude The current longitude of the user
     * @param returnProfile Return Profile
     * @param responseFilters A comma separated list of ProfileFilters for filtering the returned response data
     */
    public async secureLogin (username: string, password: string, gameType: string, deviceId?: string, charsetName?: string, latitude?: number, longitude?: number, returnProfile?: boolean, responseFilters?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ProfileResponse;  }> {
        const localVarPath = this.basePath + '/account/login/validate';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling secureLogin.');
        }

        // verify required parameter 'password' is not null or undefined
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling secureLogin.');
        }

        // verify required parameter 'gameType' is not null or undefined
        if (gameType === null || gameType === undefined) {
            throw new Error('Required parameter gameType was null or undefined when calling secureLogin.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (username !== undefined) {
            localVarQueryParameters['username'] = ObjectSerializer.serialize(username, "string");
        }

        if (password !== undefined) {
            localVarQueryParameters['password'] = ObjectSerializer.serialize(password, "string");
        }

        if (gameType !== undefined) {
            localVarQueryParameters['gameType'] = ObjectSerializer.serialize(gameType, "string");
        }

        if (charsetName !== undefined) {
            localVarQueryParameters['charsetName'] = ObjectSerializer.serialize(charsetName, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        if (returnProfile !== undefined) {
            localVarQueryParameters['returnProfile'] = ObjectSerializer.serialize(returnProfile, "boolean");
        }

        if (responseFilters !== undefined) {
            localVarQueryParameters['responseFilters'] = ObjectSerializer.serialize(responseFilters, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ProfileResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ProfileResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a new account by role (with encrypted user-name and password)
     * @summary Create Account (Encrypted Username)
     * @param deviceId The device id
     * @param username The encrypted email of the user, this is what will be used when they login
     * @param password The encrypted password of the user
     * @param name The full name of the user. If this parameter is not empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName 
     * @param inviteToken the inviteToken that the referrer use for this account to sign up
     * @param prefixName If the parameter \&#39;name\&#39; is empty or not present, this field will be used to set the prefix of the user\&#39;s name
     * @param firstName If the parameter \&#39;name\&#39; is empty or not present, this field will be used to set the user\&#39;s first name
     * @param middleName If the parameter \&#39;name\&#39; is empty or not present, this field will be used to set the user\&#39;s middle name
     * @param lastName If the parameter \&#39;name\&#39; is empty or not present, this field will be used to set the user\&#39;s last name
     * @param suffixName If the parameter \&#39;name\&#39; is empty or not present, this field will be used to set the suffix of the user\&#39;s name
     * @param title Title
     * @param deviceIdType Device Id Type
     * @param emailAddress The user\&#39;s contact email address (NOT the username) which is also used for email validation
     * @param assetId The asset id to set the user\&#39;s profile image
     * @param address the user\&#39;s address
     * @param zipcode The street zipcode of the user\&#39;s contact location
     * @param gender The gender of the user AudienceGender
     * @param birthday The birthday date of the user in milliseconds
     * @param homePhone the user\&#39;s home phone number
     * @param cellPhone the user\&#39;s cell phone number
     * @param cellPhoneCarrier the user\&#39;s Cell Phone Carrier
     * @param businessPhone the user\&#39;s Business Phone Number
     * @param role The type of account being created {RETAILER, MEMBER, DEVELOPER, GUEST
     * @param platforms Comma separated list of development platforms: MAC, WINDOWS, IOS, ANDROID, WINDOWSPHONE, KINDLE, UNITY3D, COCOS2D, HTML5, FACEBOOK
     * @param tags Search tags
     * @param aboutUs About Us information
     * @param gameExperience Game experience level of the user {ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
     * @param categoryIds A list of category ids that represent interests and associations
     * @param hometown The user\&#39;s hometown
     * @param height The user\&#39;s height
     * @param heightIndex The user\&#39;s height in a numerical value that can be used for ordering/searching
     * @param ethnicity The user\&#39;s ethnicity
     * @param bodyType The user\&#39;s body type
     * @param maritalStatus The user\&#39;s maritial status
     * @param children The user\&#39;s children status
     * @param religion The user\&#39;s religion
     * @param education The user\&#39;s education
     * @param educationIndex The user\&#39;s education in a numerical value that can be used for ordering/searching
     * @param smoke The user\&#39;s smoke status
     * @param drink The user\&#39;s drink status
     * @param companionship The user\&#39;s companionship status
     * @param companionshipIndex The user\&#39;s companionship index
     * @param preferredMinAge The preferred minimum age in the account location search
     * @param preferredMaxAge The preferred maximum age in the account location search
     * @param preferredMinHeight The preferred minimum height in the account location search
     * @param preferredMaxHeight The preferred maximum height in the account location search
     * @param preferredGender The preferred gender in the account location search
     * @param preferredEducation The preferred education in the account location search
     * @param preferredEducationIndex The preferred education in a numerical value that can be used for ordering/searching
     * @param preferredBodyType The preferred body type in the account location search
     * @param preferredEthnicity The preferred ethnicity in the account location search
     * @param preferredLocation The preferred education in the account location search
     * @param preferredLocationRange The preferred location range in the account location search
     * @param latitude The current latitude of the user
     * @param longitude The current longitude of the user
     * @param acceptedTerms Accepted Terms
     * @param charsetName Charset Name
     * @param gameType Game Type
     * @param appKey The application key
     * @param appVersion App Version
     * @param responseType Response Type
     */
    public async secureSignup (deviceId: string, username: string, password: string, name?: string, inviteToken?: string, prefixName?: string, firstName?: string, middleName?: string, lastName?: string, suffixName?: string, title?: string, deviceIdType?: string, emailAddress?: string, assetId?: number, address?: string, zipcode?: string, gender?: string, birthday?: number, homePhone?: string, cellPhone?: string, cellPhoneCarrier?: string, businessPhone?: string, role?: string, platforms?: string, tags?: string, aboutUs?: string, gameExperience?: string, categoryIds?: string, hometown?: string, height?: string, heightIndex?: number, ethnicity?: string, bodyType?: string, maritalStatus?: string, children?: string, religion?: string, education?: string, educationIndex?: number, smoke?: string, drink?: string, companionship?: string, companionshipIndex?: number, preferredMinAge?: number, preferredMaxAge?: number, preferredMinHeight?: number, preferredMaxHeight?: number, preferredGender?: string, preferredEducation?: string, preferredEducationIndex?: number, preferredBodyType?: string, preferredEthnicity?: string, preferredLocation?: string, preferredLocationRange?: number, latitude?: number, longitude?: number, acceptedTerms?: boolean, charsetName?: string, gameType?: string, appKey?: string, appVersion?: string, responseType?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ProfileInfoResponse;  }> {
        const localVarPath = this.basePath + '/account/create/validate';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling secureSignup.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling secureSignup.');
        }

        // verify required parameter 'password' is not null or undefined
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling secureSignup.');
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (inviteToken !== undefined) {
            localVarQueryParameters['inviteToken'] = ObjectSerializer.serialize(inviteToken, "string");
        }

        if (prefixName !== undefined) {
            localVarQueryParameters['prefixName'] = ObjectSerializer.serialize(prefixName, "string");
        }

        if (firstName !== undefined) {
            localVarQueryParameters['firstName'] = ObjectSerializer.serialize(firstName, "string");
        }

        if (middleName !== undefined) {
            localVarQueryParameters['middleName'] = ObjectSerializer.serialize(middleName, "string");
        }

        if (lastName !== undefined) {
            localVarQueryParameters['lastName'] = ObjectSerializer.serialize(lastName, "string");
        }

        if (suffixName !== undefined) {
            localVarQueryParameters['suffixName'] = ObjectSerializer.serialize(suffixName, "string");
        }

        if (title !== undefined) {
            localVarQueryParameters['title'] = ObjectSerializer.serialize(title, "string");
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (deviceIdType !== undefined) {
            localVarQueryParameters['deviceIdType'] = ObjectSerializer.serialize(deviceIdType, "string");
        }

        if (username !== undefined) {
            localVarQueryParameters['username'] = ObjectSerializer.serialize(username, "string");
        }

        if (password !== undefined) {
            localVarQueryParameters['password'] = ObjectSerializer.serialize(password, "string");
        }

        if (emailAddress !== undefined) {
            localVarQueryParameters['emailAddress'] = ObjectSerializer.serialize(emailAddress, "string");
        }

        if (assetId !== undefined) {
            localVarQueryParameters['assetId'] = ObjectSerializer.serialize(assetId, "number");
        }

        if (address !== undefined) {
            localVarQueryParameters['address'] = ObjectSerializer.serialize(address, "string");
        }

        if (zipcode !== undefined) {
            localVarQueryParameters['zipcode'] = ObjectSerializer.serialize(zipcode, "string");
        }

        if (gender !== undefined) {
            localVarQueryParameters['gender'] = ObjectSerializer.serialize(gender, "string");
        }

        if (birthday !== undefined) {
            localVarQueryParameters['birthday'] = ObjectSerializer.serialize(birthday, "number");
        }

        if (homePhone !== undefined) {
            localVarQueryParameters['homePhone'] = ObjectSerializer.serialize(homePhone, "string");
        }

        if (cellPhone !== undefined) {
            localVarQueryParameters['cellPhone'] = ObjectSerializer.serialize(cellPhone, "string");
        }

        if (cellPhoneCarrier !== undefined) {
            localVarQueryParameters['cellPhoneCarrier'] = ObjectSerializer.serialize(cellPhoneCarrier, "string");
        }

        if (businessPhone !== undefined) {
            localVarQueryParameters['businessPhone'] = ObjectSerializer.serialize(businessPhone, "string");
        }

        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "string");
        }

        if (platforms !== undefined) {
            localVarQueryParameters['platforms'] = ObjectSerializer.serialize(platforms, "string");
        }

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "string");
        }

        if (aboutUs !== undefined) {
            localVarQueryParameters['aboutUs'] = ObjectSerializer.serialize(aboutUs, "string");
        }

        if (gameExperience !== undefined) {
            localVarQueryParameters['gameExperience'] = ObjectSerializer.serialize(gameExperience, "string");
        }

        if (categoryIds !== undefined) {
            localVarQueryParameters['categoryIds'] = ObjectSerializer.serialize(categoryIds, "string");
        }

        if (hometown !== undefined) {
            localVarQueryParameters['hometown'] = ObjectSerializer.serialize(hometown, "string");
        }

        if (height !== undefined) {
            localVarQueryParameters['height'] = ObjectSerializer.serialize(height, "string");
        }

        if (heightIndex !== undefined) {
            localVarQueryParameters['heightIndex'] = ObjectSerializer.serialize(heightIndex, "number");
        }

        if (ethnicity !== undefined) {
            localVarQueryParameters['ethnicity'] = ObjectSerializer.serialize(ethnicity, "string");
        }

        if (bodyType !== undefined) {
            localVarQueryParameters['bodyType'] = ObjectSerializer.serialize(bodyType, "string");
        }

        if (maritalStatus !== undefined) {
            localVarQueryParameters['maritalStatus'] = ObjectSerializer.serialize(maritalStatus, "string");
        }

        if (children !== undefined) {
            localVarQueryParameters['children'] = ObjectSerializer.serialize(children, "string");
        }

        if (religion !== undefined) {
            localVarQueryParameters['religion'] = ObjectSerializer.serialize(religion, "string");
        }

        if (education !== undefined) {
            localVarQueryParameters['education'] = ObjectSerializer.serialize(education, "string");
        }

        if (educationIndex !== undefined) {
            localVarQueryParameters['educationIndex'] = ObjectSerializer.serialize(educationIndex, "number");
        }

        if (smoke !== undefined) {
            localVarQueryParameters['smoke'] = ObjectSerializer.serialize(smoke, "string");
        }

        if (drink !== undefined) {
            localVarQueryParameters['drink'] = ObjectSerializer.serialize(drink, "string");
        }

        if (companionship !== undefined) {
            localVarQueryParameters['companionship'] = ObjectSerializer.serialize(companionship, "string");
        }

        if (companionshipIndex !== undefined) {
            localVarQueryParameters['companionshipIndex'] = ObjectSerializer.serialize(companionshipIndex, "number");
        }

        if (preferredMinAge !== undefined) {
            localVarQueryParameters['preferredMinAge'] = ObjectSerializer.serialize(preferredMinAge, "number");
        }

        if (preferredMaxAge !== undefined) {
            localVarQueryParameters['preferredMaxAge'] = ObjectSerializer.serialize(preferredMaxAge, "number");
        }

        if (preferredMinHeight !== undefined) {
            localVarQueryParameters['preferredMinHeight'] = ObjectSerializer.serialize(preferredMinHeight, "number");
        }

        if (preferredMaxHeight !== undefined) {
            localVarQueryParameters['preferredMaxHeight'] = ObjectSerializer.serialize(preferredMaxHeight, "number");
        }

        if (preferredGender !== undefined) {
            localVarQueryParameters['preferredGender'] = ObjectSerializer.serialize(preferredGender, "string");
        }

        if (preferredEducation !== undefined) {
            localVarQueryParameters['preferredEducation'] = ObjectSerializer.serialize(preferredEducation, "string");
        }

        if (preferredEducationIndex !== undefined) {
            localVarQueryParameters['preferredEducationIndex'] = ObjectSerializer.serialize(preferredEducationIndex, "number");
        }

        if (preferredBodyType !== undefined) {
            localVarQueryParameters['preferredBodyType'] = ObjectSerializer.serialize(preferredBodyType, "string");
        }

        if (preferredEthnicity !== undefined) {
            localVarQueryParameters['preferredEthnicity'] = ObjectSerializer.serialize(preferredEthnicity, "string");
        }

        if (preferredLocation !== undefined) {
            localVarQueryParameters['preferredLocation'] = ObjectSerializer.serialize(preferredLocation, "string");
        }

        if (preferredLocationRange !== undefined) {
            localVarQueryParameters['preferredLocationRange'] = ObjectSerializer.serialize(preferredLocationRange, "number");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        if (acceptedTerms !== undefined) {
            localVarQueryParameters['acceptedTerms'] = ObjectSerializer.serialize(acceptedTerms, "boolean");
        }

        if (charsetName !== undefined) {
            localVarQueryParameters['charsetName'] = ObjectSerializer.serialize(charsetName, "string");
        }

        if (gameType !== undefined) {
            localVarQueryParameters['gameType'] = ObjectSerializer.serialize(gameType, "string");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (appVersion !== undefined) {
            localVarQueryParameters['appVersion'] = ObjectSerializer.serialize(appVersion, "string");
        }

        if (responseType !== undefined) {
            localVarQueryParameters['responseType'] = ObjectSerializer.serialize(responseType, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ProfileInfoResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ProfileInfoResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Save user\'s match token to be used for profile match making
     * @summary Save Match Token
     * @param deviceId The device id (deviceId or accountId required)
     * @param accountId The account id of the user (deviceId or accountId required)
     * @param matchToken A string of numbers
     * @param gameType Game Type (deprecated)
     * @param appKey The application key
     * @param latitude The current latitude of the user
     * @param longitude The current longitude of the user
     */
    public async setMatchToken (deviceId?: string, accountId?: number, matchToken?: string, gameType?: string, appKey?: string, latitude?: number, longitude?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/consumer/profile/matchToken';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (matchToken !== undefined) {
            localVarQueryParameters['matchToken'] = ObjectSerializer.serialize(matchToken, "string");
        }

        if (gameType !== undefined) {
            localVarQueryParameters['gameType'] = ObjectSerializer.serialize(gameType, "string");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Activate or deactivate an account (requires appropriate permissions).
     * @summary Update Account Active Status
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param connectionAccountId The account id of the user you want to modify (if this is not set, then the accountId parameter will be used instead)
     * @param active true will activate the user and false will deactivate
     * @param deviceId the device id (deviceId or accountId required)
     * @param appKey the application key that the user belongs to
     */
    public async updateActveStatus (accountId: number, connectionAccountId: number, active: boolean, deviceId?: string, appKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/account/active/update';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateActveStatus.');
        }

        // verify required parameter 'connectionAccountId' is not null or undefined
        if (connectionAccountId === null || connectionAccountId === undefined) {
            throw new Error('Required parameter connectionAccountId was null or undefined when calling updateActveStatus.');
        }

        // verify required parameter 'active' is not null or undefined
        if (active === null || active === undefined) {
            throw new Error('Required parameter active was null or undefined when calling updateActveStatus.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (connectionAccountId !== undefined) {
            localVarQueryParameters['connectionAccountId'] = ObjectSerializer.serialize(connectionAccountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update the account location
     * @summary Update Location
     * @param deviceId The device id (deviceId or accountId required)
     * @param accountId The account id of the user (deviceId or accountId required)
     * @param latitude The current latitude of the user
     * @param longitude The current longitude of the user
     * @param clientTime The time of the update
     */
    public async updateLocation (deviceId?: string, accountId?: number, latitude?: number, longitude?: number, clientTime?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/account/location/update';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        if (clientTime !== undefined) {
            localVarQueryParameters['clientTime'] = ObjectSerializer.serialize(clientTime, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update the account settings for a user
     * @summary Update Account Settings
     * @param deviceId The device id (deviceId or accountId required)
     * @param accountId The account id of the user (deviceId or accountId required)
     * @param blockedNotifications The notifications to be blocked
     * @param suggestionMethod How suggestions are to be sent (APNS, MOBILE_NOTIFICATION, SMS)
     * @param suggestionCount How many suggestions to receive per time frame
     * @param suggestionTimeFrame The time frame in seconds, 3600 would be a 1 hour time frame
     * @param showOthersExactLocation Show Others Exact Location
     * @param showAsZipcode Show As Zipcode
     * @param showExactLocation Show Exact Location
     * @param favoriteVisibility Show favorites
     * @param latitude The current latitude of the user
     * @param longitude The current longitude of the user
     */
    public async updateSettings (deviceId?: string, accountId?: number, blockedNotifications?: string, suggestionMethod?: string, suggestionCount?: number, suggestionTimeFrame?: number, showOthersExactLocation?: boolean, showAsZipcode?: boolean, showExactLocation?: boolean, favoriteVisibility?: string, latitude?: number, longitude?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: UserSettingsResponse;  }> {
        const localVarPath = this.basePath + '/account/settings/update';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (blockedNotifications !== undefined) {
            localVarQueryParameters['blockedNotifications'] = ObjectSerializer.serialize(blockedNotifications, "string");
        }

        if (suggestionMethod !== undefined) {
            localVarQueryParameters['suggestionMethod'] = ObjectSerializer.serialize(suggestionMethod, "string");
        }

        if (suggestionCount !== undefined) {
            localVarQueryParameters['suggestionCount'] = ObjectSerializer.serialize(suggestionCount, "number");
        }

        if (suggestionTimeFrame !== undefined) {
            localVarQueryParameters['suggestionTimeFrame'] = ObjectSerializer.serialize(suggestionTimeFrame, "number");
        }

        if (showOthersExactLocation !== undefined) {
            localVarQueryParameters['showOthersExactLocation'] = ObjectSerializer.serialize(showOthersExactLocation, "boolean");
        }

        if (showAsZipcode !== undefined) {
            localVarQueryParameters['showAsZipcode'] = ObjectSerializer.serialize(showAsZipcode, "boolean");
        }

        if (showExactLocation !== undefined) {
            localVarQueryParameters['showExactLocation'] = ObjectSerializer.serialize(showExactLocation, "boolean");
        }

        if (favoriteVisibility !== undefined) {
            localVarQueryParameters['favoriteVisibility'] = ObjectSerializer.serialize(favoriteVisibility, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: UserSettingsResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "UserSettingsResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Validate the account\'s email address. The token must be valid and not expired. Use the RequestValidateAccount end point to request a new token.
     * @summary Save Validation Status
     * @param token The token associated with the account to update, good for 24 hours
     */
    public async validateAccountSignup (token: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AccountLoginResponse;  }> {
        const localVarPath = this.basePath + '/account/validateAccountSignup';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'token' is not null or undefined
        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling validateAccountSignup.');
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AccountLoginResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AccountLoginResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Validate the password reset token. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token. The user receives and email with the reset page, therefore it should be validated before bwing used to reset the password.
     * @summary Validate Password Reset Token
     * @param token The token associated with the account to update, good for 24 hours
     */
    public async validatePasswordReset (token: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/account/validatepasswordreset';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'token' is not null or undefined
        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling validatePasswordReset.');
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
