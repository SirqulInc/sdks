/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET[\'appKey\']);$b = htmlspecialchars($_GET[\'appRestKey\']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { RegionResponse } from '../model/regionResponse';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://dev.sirqul.com/api/3.18';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum RegionApiApiKeys {
    appKey,
    restKey,
}

export class RegionApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'appKey': new ApiKeyAuth('header', 'Application-Key'),
        'restKey': new ApiKeyAuth('header', 'Application-Rest-Key'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: RegionApiApiKeys, value: string) {
        (this.authentications as any)[RegionApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Create a region.
     * @summary Create Region
     * @param accountId The id of the account sending the request
     * @param regionClass RegionClass of this region
     * @param shortName Short name of the region. This is optimized for search
     * @param fullName Full name of the region
     * @param parentIds Comma separated region ids that are parents of this region
     * @param childrenIds Comma separated region ids that are children of this region
     * @param postalCodeIds Comma separated postal code ids the region will include
     * @param locations Sets of name,lat,long used to create new postal codes assigned to the region
     * @param retailerLocationId the id of the retailer location that the region is being created for
     * @param visibility The Visibility of the region
     * @param categoryIds the categories that the region is assigned to
     * @param filterIds the filters that the region is assigned to
     * @param start 
     * @param end 
     * @param polygon the polygon generated for the region
     * @param metaData the meta data associated with the region
     * @param latitude the latitude of the region
     * @param longitude the longitude of the region
     * @param versionCode the version code
     * @param root If this is a root region or not. If true means this region has no parent regions
     * @param active Active or inactive status of the region
     */
    public async createRegion (accountId: number, regionClass: string, shortName: string, fullName?: string, parentIds?: string, childrenIds?: string, postalCodeIds?: string, locations?: string, retailerLocationId?: number, visibility?: 'PUBLIC' | 'PRIVATE' | 'FRIENDS', categoryIds?: string, filterIds?: string, start?: number, end?: number, polygon?: string, metaData?: string, latitude?: number, longitude?: number, versionCode?: number, root?: boolean, active?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RegionResponse;  }> {
        const localVarPath = this.basePath + '/region/create';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createRegion.');
        }

        // verify required parameter 'regionClass' is not null or undefined
        if (regionClass === null || regionClass === undefined) {
            throw new Error('Required parameter regionClass was null or undefined when calling createRegion.');
        }

        // verify required parameter 'shortName' is not null or undefined
        if (shortName === null || shortName === undefined) {
            throw new Error('Required parameter shortName was null or undefined when calling createRegion.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (regionClass !== undefined) {
            localVarQueryParameters['regionClass'] = ObjectSerializer.serialize(regionClass, "string");
        }

        if (shortName !== undefined) {
            localVarQueryParameters['shortName'] = ObjectSerializer.serialize(shortName, "string");
        }

        if (fullName !== undefined) {
            localVarQueryParameters['fullName'] = ObjectSerializer.serialize(fullName, "string");
        }

        if (parentIds !== undefined) {
            localVarQueryParameters['parentIds'] = ObjectSerializer.serialize(parentIds, "string");
        }

        if (childrenIds !== undefined) {
            localVarQueryParameters['childrenIds'] = ObjectSerializer.serialize(childrenIds, "string");
        }

        if (postalCodeIds !== undefined) {
            localVarQueryParameters['postalCodeIds'] = ObjectSerializer.serialize(postalCodeIds, "string");
        }

        if (locations !== undefined) {
            localVarQueryParameters['locations'] = ObjectSerializer.serialize(locations, "string");
        }

        if (retailerLocationId !== undefined) {
            localVarQueryParameters['retailerLocationId'] = ObjectSerializer.serialize(retailerLocationId, "number");
        }

        if (visibility !== undefined) {
            localVarQueryParameters['visibility'] = ObjectSerializer.serialize(visibility, "'PUBLIC' | 'PRIVATE' | 'FRIENDS'");
        }

        if (categoryIds !== undefined) {
            localVarQueryParameters['categoryIds'] = ObjectSerializer.serialize(categoryIds, "string");
        }

        if (filterIds !== undefined) {
            localVarQueryParameters['filterIds'] = ObjectSerializer.serialize(filterIds, "string");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "number");
        }

        if (polygon !== undefined) {
            localVarQueryParameters['polygon'] = ObjectSerializer.serialize(polygon, "string");
        }

        if (metaData !== undefined) {
            localVarQueryParameters['metaData'] = ObjectSerializer.serialize(metaData, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        if (versionCode !== undefined) {
            localVarQueryParameters['versionCode'] = ObjectSerializer.serialize(versionCode, "number");
        }

        if (root !== undefined) {
            localVarQueryParameters['root'] = ObjectSerializer.serialize(root, "boolean");
        }

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RegionResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RegionResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Delete a region.
     * @summary Delete Region
     * @param accountId the id of the account logged in
     * @param regionId the id of the region
     */
    public async deleteRegion (accountId: number, regionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RegionResponse;  }> {
        const localVarPath = this.basePath + '/region/delete';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteRegion.');
        }

        // verify required parameter 'regionId' is not null or undefined
        if (regionId === null || regionId === undefined) {
            throw new Error('Required parameter regionId was null or undefined when calling deleteRegion.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (regionId !== undefined) {
            localVarQueryParameters['regionId'] = ObjectSerializer.serialize(regionId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RegionResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RegionResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a region.
     * @summary Get Region
     * @param regionId the id of the region to get
     * @param accountId the id of the logged in user
     */
    public async getRegion (regionId: number, accountId?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RegionResponse;  }> {
        const localVarPath = this.basePath + '/region/get';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'regionId' is not null or undefined
        if (regionId === null || regionId === undefined) {
            throw new Error('Required parameter regionId was null or undefined when calling getRegion.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (regionId !== undefined) {
            localVarQueryParameters['regionId'] = ObjectSerializer.serialize(regionId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RegionResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RegionResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get the list of regions.
     * @summary Search Regions
     * @param accountId the owner account id of the region to be created
     * @param query This parameter is deprecated. deprecated - use \&quot;keyword\&quot;
     * @param keyword the keyword to filter results on
     * @param latitude the latitude of the user
     * @param longitude the longitude of the user
     * @param range the search radius
     * @param regionClass 
     * @param visibility 
     * @param searchMode the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server
     * @param sortField the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided.
     * @param descending determines if the results get ordered in descending order
     * @param includeParent include the parent region or not
     * @param includeChildren include the chidren regions or not
     * @param includePostalCodes include the postal codes associated with the region or not
     * @param categoryIds search on the categories associated with the region
     * @param filterIds search on the filters associated with the region
     * @param versionCode filter by a specific version code
     * @param activeOnly filter to show only active results
     * @param showDeleted If showDeleted is true and activeOnly is false, will return regions that have been deleted
     * @param lastUpdatedSince only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\)
     * @param start the start index for pagination
     * @param limit the limit for pagination
     */
    public async searchRegions (accountId?: number, query?: string, keyword?: string, latitude?: number, longitude?: number, range?: number, regionClass?: 'NATIONAL' | 'STATE' | 'COUNTY' | 'METRO_AREA' | 'CITY' | 'NEIGHBORHOOD' | 'TERRITORY' | 'CUSTOM' | 'ZONE', visibility?: 'PUBLIC' | 'PRIVATE' | 'FRIENDS', searchMode?: 'RDS' | 'LUCENE' | 'CLOUDINDEX', sortField?: 'ID' | 'UPDATED' | 'NAME' | 'DISTANCE', descending?: boolean, includeParent?: boolean, includeChildren?: boolean, includePostalCodes?: boolean, categoryIds?: string, filterIds?: string, versionCode?: number, activeOnly?: boolean, showDeleted?: boolean, lastUpdatedSince?: number, start?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<RegionResponse>;  }> {
        const localVarPath = this.basePath + '/region/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (keyword !== undefined) {
            localVarQueryParameters['keyword'] = ObjectSerializer.serialize(keyword, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        if (range !== undefined) {
            localVarQueryParameters['range'] = ObjectSerializer.serialize(range, "number");
        }

        if (regionClass !== undefined) {
            localVarQueryParameters['regionClass'] = ObjectSerializer.serialize(regionClass, "'NATIONAL' | 'STATE' | 'COUNTY' | 'METRO_AREA' | 'CITY' | 'NEIGHBORHOOD' | 'TERRITORY' | 'CUSTOM' | 'ZONE'");
        }

        if (visibility !== undefined) {
            localVarQueryParameters['visibility'] = ObjectSerializer.serialize(visibility, "'PUBLIC' | 'PRIVATE' | 'FRIENDS'");
        }

        if (searchMode !== undefined) {
            localVarQueryParameters['searchMode'] = ObjectSerializer.serialize(searchMode, "'RDS' | 'LUCENE' | 'CLOUDINDEX'");
        }

        if (sortField !== undefined) {
            localVarQueryParameters['sortField'] = ObjectSerializer.serialize(sortField, "'ID' | 'UPDATED' | 'NAME' | 'DISTANCE'");
        }

        if (descending !== undefined) {
            localVarQueryParameters['descending'] = ObjectSerializer.serialize(descending, "boolean");
        }

        if (includeParent !== undefined) {
            localVarQueryParameters['includeParent'] = ObjectSerializer.serialize(includeParent, "boolean");
        }

        if (includeChildren !== undefined) {
            localVarQueryParameters['includeChildren'] = ObjectSerializer.serialize(includeChildren, "boolean");
        }

        if (includePostalCodes !== undefined) {
            localVarQueryParameters['includePostalCodes'] = ObjectSerializer.serialize(includePostalCodes, "boolean");
        }

        if (categoryIds !== undefined) {
            localVarQueryParameters['categoryIds'] = ObjectSerializer.serialize(categoryIds, "string");
        }

        if (filterIds !== undefined) {
            localVarQueryParameters['filterIds'] = ObjectSerializer.serialize(filterIds, "string");
        }

        if (versionCode !== undefined) {
            localVarQueryParameters['versionCode'] = ObjectSerializer.serialize(versionCode, "number");
        }

        if (activeOnly !== undefined) {
            localVarQueryParameters['activeOnly'] = ObjectSerializer.serialize(activeOnly, "boolean");
        }

        if (showDeleted !== undefined) {
            localVarQueryParameters['showDeleted'] = ObjectSerializer.serialize(showDeleted, "boolean");
        }

        if (lastUpdatedSince !== undefined) {
            localVarQueryParameters['lastUpdatedSince'] = ObjectSerializer.serialize(lastUpdatedSince, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<RegionResponse>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<RegionResponse>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update a region.
     * @summary Update Region
     * @param accountId The id of the account sending the request
     * @param regionId The id of the region to be updated
     * @param regionClass RegionClass of this region
     * @param shortName Short name of the region. This is optimized for search
     * @param fullName Full name of the region
     * @param parentIds Comma separated region ids that are parents of this region
     * @param childrenIds Comma separated region ids that are children of this region
     * @param postalCodeIds Comma separated postal code ids the region will include
     * @param locations Sets of name,lat,long used to create new postal codes assigned to the region
     * @param retailerLocationId the retailer location ID that the region is associated with
     * @param visibility The Visibility of the region
     * @param categoryIds the categories that the region is assigned to
     * @param filterIds the filters that the region is assigned to
     * @param start 
     * @param end 
     * @param polygon the polygon of the region
     * @param metaData the meta data of the region
     * @param latitude the latitude of the region
     * @param longitude the longitude of the region
     * @param versionCode the version code
     * @param root If this is a root region or not. If true means this region has no parent regions
     * @param active Active or inactive status of the region
     * @param clearLists If true clear the children and postal code lists before add new ones, otherwise just append.
     */
    public async updateRegion (accountId: number, regionId: number, regionClass?: string, shortName?: string, fullName?: string, parentIds?: string, childrenIds?: string, postalCodeIds?: string, locations?: string, retailerLocationId?: number, visibility?: 'PUBLIC' | 'PRIVATE' | 'FRIENDS', categoryIds?: string, filterIds?: string, start?: number, end?: number, polygon?: string, metaData?: string, latitude?: number, longitude?: number, versionCode?: number, root?: boolean, active?: boolean, clearLists?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RegionResponse;  }> {
        const localVarPath = this.basePath + '/region/update';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateRegion.');
        }

        // verify required parameter 'regionId' is not null or undefined
        if (regionId === null || regionId === undefined) {
            throw new Error('Required parameter regionId was null or undefined when calling updateRegion.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (regionId !== undefined) {
            localVarQueryParameters['regionId'] = ObjectSerializer.serialize(regionId, "number");
        }

        if (regionClass !== undefined) {
            localVarQueryParameters['regionClass'] = ObjectSerializer.serialize(regionClass, "string");
        }

        if (shortName !== undefined) {
            localVarQueryParameters['shortName'] = ObjectSerializer.serialize(shortName, "string");
        }

        if (fullName !== undefined) {
            localVarQueryParameters['fullName'] = ObjectSerializer.serialize(fullName, "string");
        }

        if (parentIds !== undefined) {
            localVarQueryParameters['parentIds'] = ObjectSerializer.serialize(parentIds, "string");
        }

        if (childrenIds !== undefined) {
            localVarQueryParameters['childrenIds'] = ObjectSerializer.serialize(childrenIds, "string");
        }

        if (postalCodeIds !== undefined) {
            localVarQueryParameters['postalCodeIds'] = ObjectSerializer.serialize(postalCodeIds, "string");
        }

        if (locations !== undefined) {
            localVarQueryParameters['locations'] = ObjectSerializer.serialize(locations, "string");
        }

        if (retailerLocationId !== undefined) {
            localVarQueryParameters['retailerLocationId'] = ObjectSerializer.serialize(retailerLocationId, "number");
        }

        if (visibility !== undefined) {
            localVarQueryParameters['visibility'] = ObjectSerializer.serialize(visibility, "'PUBLIC' | 'PRIVATE' | 'FRIENDS'");
        }

        if (categoryIds !== undefined) {
            localVarQueryParameters['categoryIds'] = ObjectSerializer.serialize(categoryIds, "string");
        }

        if (filterIds !== undefined) {
            localVarQueryParameters['filterIds'] = ObjectSerializer.serialize(filterIds, "string");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "number");
        }

        if (polygon !== undefined) {
            localVarQueryParameters['polygon'] = ObjectSerializer.serialize(polygon, "string");
        }

        if (metaData !== undefined) {
            localVarQueryParameters['metaData'] = ObjectSerializer.serialize(metaData, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        if (versionCode !== undefined) {
            localVarQueryParameters['versionCode'] = ObjectSerializer.serialize(versionCode, "number");
        }

        if (root !== undefined) {
            localVarQueryParameters['root'] = ObjectSerializer.serialize(root, "boolean");
        }

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (clearLists !== undefined) {
            localVarQueryParameters['clearLists'] = ObjectSerializer.serialize(clearLists, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RegionResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RegionResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
