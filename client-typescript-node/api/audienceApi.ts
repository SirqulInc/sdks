/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET[\'appKey\']);$b = htmlspecialchars($_GET[\'appRestKey\']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { AgeGroupResponse } from '../model/ageGroupResponse';
import { AudienceDeviceResponse } from '../model/audienceDeviceResponse';
import { AudienceResponse } from '../model/audienceResponse';
import { OfferListResponse } from '../model/offerListResponse';
import { SearchResponse } from '../model/searchResponse';
import { SirqulResponse } from '../model/sirqulResponse';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'http://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum AudienceApiApiKeys {
    appKey,
    restKey,
}

export class AudienceApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'appKey': new ApiKeyAuth('header', 'Application-Key'),
        'restKey': new ApiKeyAuth('header', 'Application-Rest-Key'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: AudienceApiApiKeys, value: string) {
        (this.authentications as any)[AudienceApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Create a user defined audience.
     * @summary Create Audience
     * @param version 
     * @param accountId The logged in user.
     * @param name The name of the audience
     * @param description The description of the audience
     * @param searchTags The search tags
     * @param gender The gender; possible values are: MALE, FEMALE, ANY
     * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
     * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
     * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
     * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
     * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
     * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
     * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
     * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
     * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
     * @param startTimeOffset Seconds from the start time of an event
     * @param endTimeOffset Seconds from the end time of an event
     * @param sendSuggestion If true, then notify matching users when they are inside the radius
     * @param associateDescription The description of the associated object
     * @param associateType The type of the object to center the audience geofence
     * @param associateId The ID of the object to center the audience geofence
     * @param groupingId Optional grouping id for the audience
     * @param metaData External custom client defined data
     * @param visibility Visibility of the audience
     * @param audienceType Type of audience
     * @param useOrder Use order for cohort
     * @param cohortRegionsData Cohort data for \&quot;cohort\&quot; audience type
     * @param appKey Filter results by application key
     * @param trilaterationTypes Trilateration types
     * @param uniqueName If true, makes sure the audience name is unique
     */
    public async createAudience (version: number, accountId: number, name: string, description?: string, searchTags?: string, gender?: string, ageGroups?: string, categoryIds?: string, applicationIds?: string, gameExperienceLevel?: string, devices?: string, deviceIds?: string, deviceVersions?: string, locations?: string, radius?: string, startTimeOffset?: number, endTimeOffset?: number, sendSuggestion?: boolean, associateDescription?: string, associateType?: string, associateId?: number, groupingId?: string, metaData?: string, visibility?: string, audienceType?: string, useOrder?: boolean, cohortRegionsData?: string, appKey?: string, trilaterationTypes?: string, uniqueName?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AudienceResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/audience/create'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling createAudience.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAudience.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createAudience.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (searchTags !== undefined) {
            localVarQueryParameters['searchTags'] = ObjectSerializer.serialize(searchTags, "string");
        }

        if (gender !== undefined) {
            localVarQueryParameters['gender'] = ObjectSerializer.serialize(gender, "string");
        }

        if (ageGroups !== undefined) {
            localVarQueryParameters['ageGroups'] = ObjectSerializer.serialize(ageGroups, "string");
        }

        if (categoryIds !== undefined) {
            localVarQueryParameters['categoryIds'] = ObjectSerializer.serialize(categoryIds, "string");
        }

        if (applicationIds !== undefined) {
            localVarQueryParameters['applicationIds'] = ObjectSerializer.serialize(applicationIds, "string");
        }

        if (gameExperienceLevel !== undefined) {
            localVarQueryParameters['gameExperienceLevel'] = ObjectSerializer.serialize(gameExperienceLevel, "string");
        }

        if (devices !== undefined) {
            localVarQueryParameters['devices'] = ObjectSerializer.serialize(devices, "string");
        }

        if (deviceIds !== undefined) {
            localVarQueryParameters['deviceIds'] = ObjectSerializer.serialize(deviceIds, "string");
        }

        if (deviceVersions !== undefined) {
            localVarQueryParameters['deviceVersions'] = ObjectSerializer.serialize(deviceVersions, "string");
        }

        if (locations !== undefined) {
            localVarQueryParameters['locations'] = ObjectSerializer.serialize(locations, "string");
        }

        if (radius !== undefined) {
            localVarQueryParameters['radius'] = ObjectSerializer.serialize(radius, "string");
        }

        if (startTimeOffset !== undefined) {
            localVarQueryParameters['startTimeOffset'] = ObjectSerializer.serialize(startTimeOffset, "number");
        }

        if (endTimeOffset !== undefined) {
            localVarQueryParameters['endTimeOffset'] = ObjectSerializer.serialize(endTimeOffset, "number");
        }

        if (sendSuggestion !== undefined) {
            localVarQueryParameters['sendSuggestion'] = ObjectSerializer.serialize(sendSuggestion, "boolean");
        }

        if (associateDescription !== undefined) {
            localVarQueryParameters['associateDescription'] = ObjectSerializer.serialize(associateDescription, "string");
        }

        if (associateType !== undefined) {
            localVarQueryParameters['associateType'] = ObjectSerializer.serialize(associateType, "string");
        }

        if (associateId !== undefined) {
            localVarQueryParameters['associateId'] = ObjectSerializer.serialize(associateId, "number");
        }

        if (groupingId !== undefined) {
            localVarQueryParameters['groupingId'] = ObjectSerializer.serialize(groupingId, "string");
        }

        if (metaData !== undefined) {
            localVarQueryParameters['metaData'] = ObjectSerializer.serialize(metaData, "string");
        }

        if (visibility !== undefined) {
            localVarQueryParameters['visibility'] = ObjectSerializer.serialize(visibility, "string");
        }

        if (audienceType !== undefined) {
            localVarQueryParameters['audienceType'] = ObjectSerializer.serialize(audienceType, "string");
        }

        if (useOrder !== undefined) {
            localVarQueryParameters['useOrder'] = ObjectSerializer.serialize(useOrder, "boolean");
        }

        if (cohortRegionsData !== undefined) {
            localVarQueryParameters['cohortRegionsData'] = ObjectSerializer.serialize(cohortRegionsData, "string");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (trilaterationTypes !== undefined) {
            localVarQueryParameters['trilaterationTypes'] = ObjectSerializer.serialize(trilaterationTypes, "string");
        }

        if (uniqueName !== undefined) {
            localVarQueryParameters['uniqueName'] = ObjectSerializer.serialize(uniqueName, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AudienceResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AudienceResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.
     * @summary Delete Audience
     * @param version 
     * @param accountId The logged in user.
     * @param audienceId The id of the audience to delete.
     */
    public async deleteAudience (version: number, accountId: number, audienceId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/audience/delete'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling deleteAudience.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteAudience.');
        }

        // verify required parameter 'audienceId' is not null or undefined
        if (audienceId === null || audienceId === undefined) {
            throw new Error('Required parameter audienceId was null or undefined when calling deleteAudience.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (audienceId !== undefined) {
            localVarQueryParameters['audienceId'] = ObjectSerializer.serialize(audienceId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Gets the list of available age groups that can be selected by consumers and retailers targeting offers.
     * @summary Get Age Groups
     * @param version 
     */
    public async getAgeGroups (version: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<AgeGroupResponse>;  }> {
        const localVarPath = this.basePath + '/api/{version}/audience/ageGroups'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getAgeGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<AgeGroupResponse>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<AgeGroupResponse>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.
     * @summary Get Audience
     * @param version 
     * @param accountId The logged in user.
     * @param audienceId The id of the audience to return.
     * @param appKey The application key (optional). If provided, results may be scoped to this application.
     * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app
     * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app
     * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned.
     */
    public async getAudience (version: number, accountId: number, audienceId: number, appKey?: string, returnAccountCount?: boolean, returnAlbumCount?: boolean, albumTypesForCount?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AudienceResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/audience/get'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getAudience.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAudience.');
        }

        // verify required parameter 'audienceId' is not null or undefined
        if (audienceId === null || audienceId === undefined) {
            throw new Error('Required parameter audienceId was null or undefined when calling getAudience.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (audienceId !== undefined) {
            localVarQueryParameters['audienceId'] = ObjectSerializer.serialize(audienceId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (returnAccountCount !== undefined) {
            localVarQueryParameters['returnAccountCount'] = ObjectSerializer.serialize(returnAccountCount, "boolean");
        }

        if (returnAlbumCount !== undefined) {
            localVarQueryParameters['returnAlbumCount'] = ObjectSerializer.serialize(returnAlbumCount, "boolean");
        }

        if (albumTypesForCount !== undefined) {
            localVarQueryParameters['albumTypesForCount'] = ObjectSerializer.serialize(albumTypesForCount, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AudienceResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AudienceResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get the list audiences owned by the account
     * @summary Search Audiences
     * @param version 
     * @param accountId The logged in user.
     * @param albumIds Comma separated list of album IDs to filter results with
     * @param keyword The keyword used to search
     * @param keywordFields Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY
     * @param sortField The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}
     * @param descending The order to return the results. Default is false, which will return the results in ascending order.
     * @param start The index into the record set to start with.
     * @param limit The total number of record to return (there is a hard limit of 100).
     * @param sendSuggestion Filter results based on whether or not the audience is set to send suggestions
     * @param activeOnly Determines whether to return only active results. Default is false.
     * @param groupByGroupingId Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)
     * @param appKey Filter results by application key
     * @param returnGlobal If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well
     * @param exactKeyword If true, match keyword exactly
     * @param audienceType (Deprecated) Filter results by audience type
     * @param audienceTypes comma separated string with the different audience types you want to filter for
     * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app
     * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app
     * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned.
     */
    public async getAudienceList (version: number, accountId?: number, albumIds?: string, keyword?: string, keywordFields?: string, sortField?: 'ID' | 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'NAME' | 'DESCRIPTION' | 'SEND_SUGGESTION' | 'OWNER_ID' | 'OWNER_DISPLAY' | 'GENDER', descending?: boolean, start?: number, limit?: number, sendSuggestion?: boolean, activeOnly?: boolean, groupByGroupingId?: boolean, appKey?: string, returnGlobal?: boolean, exactKeyword?: boolean, audienceType?: string, audienceTypes?: string, returnAccountCount?: boolean, returnAlbumCount?: boolean, albumTypesForCount?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<SearchResponse>;  }> {
        const localVarPath = this.basePath + '/api/{version}/audience/search'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getAudienceList.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (albumIds !== undefined) {
            localVarQueryParameters['albumIds'] = ObjectSerializer.serialize(albumIds, "string");
        }

        if (keyword !== undefined) {
            localVarQueryParameters['keyword'] = ObjectSerializer.serialize(keyword, "string");
        }

        if (keywordFields !== undefined) {
            localVarQueryParameters['keywordFields'] = ObjectSerializer.serialize(keywordFields, "string");
        }

        if (sortField !== undefined) {
            localVarQueryParameters['sortField'] = ObjectSerializer.serialize(sortField, "'ID' | 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'NAME' | 'DESCRIPTION' | 'SEND_SUGGESTION' | 'OWNER_ID' | 'OWNER_DISPLAY' | 'GENDER'");
        }

        if (descending !== undefined) {
            localVarQueryParameters['descending'] = ObjectSerializer.serialize(descending, "boolean");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sendSuggestion !== undefined) {
            localVarQueryParameters['sendSuggestion'] = ObjectSerializer.serialize(sendSuggestion, "boolean");
        }

        if (activeOnly !== undefined) {
            localVarQueryParameters['activeOnly'] = ObjectSerializer.serialize(activeOnly, "boolean");
        }

        if (groupByGroupingId !== undefined) {
            localVarQueryParameters['groupByGroupingId'] = ObjectSerializer.serialize(groupByGroupingId, "boolean");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (returnGlobal !== undefined) {
            localVarQueryParameters['returnGlobal'] = ObjectSerializer.serialize(returnGlobal, "boolean");
        }

        if (exactKeyword !== undefined) {
            localVarQueryParameters['exactKeyword'] = ObjectSerializer.serialize(exactKeyword, "boolean");
        }

        if (audienceType !== undefined) {
            localVarQueryParameters['audienceType'] = ObjectSerializer.serialize(audienceType, "string");
        }

        if (audienceTypes !== undefined) {
            localVarQueryParameters['audienceTypes'] = ObjectSerializer.serialize(audienceTypes, "string");
        }

        if (returnAccountCount !== undefined) {
            localVarQueryParameters['returnAccountCount'] = ObjectSerializer.serialize(returnAccountCount, "boolean");
        }

        if (returnAlbumCount !== undefined) {
            localVarQueryParameters['returnAlbumCount'] = ObjectSerializer.serialize(returnAlbumCount, "boolean");
        }

        if (albumTypesForCount !== undefined) {
            localVarQueryParameters['albumTypesForCount'] = ObjectSerializer.serialize(albumTypesForCount, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<SearchResponse>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<SearchResponse>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Gets the list of available devices that can be selected by consumers and retailers.
     * @summary Get Devices
     * @param version 
     * @param includeInactive If true return inactive record as well. default is false.
     */
    public async getDevices (version: number, includeInactive: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<AudienceDeviceResponse>;  }> {
        const localVarPath = this.basePath + '/api/{version}/audience/devices'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getDevices.');
        }

        // verify required parameter 'includeInactive' is not null or undefined
        if (includeInactive === null || includeInactive === undefined) {
            throw new Error('Required parameter includeInactive was null or undefined when calling getDevices.');
        }

        if (includeInactive !== undefined) {
            localVarQueryParameters['includeInactive'] = ObjectSerializer.serialize(includeInactive, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<AudienceDeviceResponse>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<AudienceDeviceResponse>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Gets the list of available experiences that can be selected by consumers and retailers.
     * @summary Get Experiences
     * @param version 
     */
    public async getExperiences (version: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/audience/experiences'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getExperiences.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.
     * @summary Get GroupedAudiences
     * @param version 
     * @param accountId The logged in user.
     * @param audienceGroupingId The audience grouping id to return.
     */
    public async getGroupedAudiences (version: number, accountId: number, audienceGroupingId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AudienceResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/audience/grouped/get'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getGroupedAudiences.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getGroupedAudiences.');
        }

        // verify required parameter 'audienceGroupingId' is not null or undefined
        if (audienceGroupingId === null || audienceGroupingId === undefined) {
            throw new Error('Required parameter audienceGroupingId was null or undefined when calling getGroupedAudiences.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (audienceGroupingId !== undefined) {
            localVarQueryParameters['audienceGroupingId'] = ObjectSerializer.serialize(audienceGroupingId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AudienceResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AudienceResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * List either Missions or Offers that the user matches the assigned audience.
     * @summary List Suggestions by Audience
     * @param version 
     * @param accountId The account to match offers for.
     * @param limit the limit of the index
     * @param suggestionType the type of suggestion
     */
    public async listByAccount (version: number, accountId: number, limit: number, suggestionType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: OfferListResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/audience/suggestion/list'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling listByAccount.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listByAccount.');
        }

        // verify required parameter 'limit' is not null or undefined
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling listByAccount.');
        }

        // verify required parameter 'suggestionType' is not null or undefined
        if (suggestionType === null || suggestionType === undefined) {
            throw new Error('Required parameter suggestionType was null or undefined when calling listByAccount.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (suggestionType !== undefined) {
            localVarQueryParameters['suggestionType'] = ObjectSerializer.serialize(suggestionType, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: OfferListResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "OfferListResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a list of offer locations based on audience information provided.
     * @summary List Offers by Audience
     * @param version 
     * @param limit this is the limit of the index
     * @param gender this is the gender to list offers by
     * @param age this is the age to list offers by
     * @param categoryIds this is the category IDs to list offers by
     * @param latitude this is the latitude to list offers by
     * @param longitude this is the longitude to list offers by
     */
    public async listByAudience (version: number, limit: number, gender?: string, age?: number, categoryIds?: string, latitude?: number, longitude?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: OfferListResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/audience/suggestion/offersByAudience'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling listByAudience.');
        }

        // verify required parameter 'limit' is not null or undefined
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling listByAudience.');
        }

        if (gender !== undefined) {
            localVarQueryParameters['gender'] = ObjectSerializer.serialize(gender, "string");
        }

        if (age !== undefined) {
            localVarQueryParameters['age'] = ObjectSerializer.serialize(age, "number");
        }

        if (categoryIds !== undefined) {
            localVarQueryParameters['categoryIds'] = ObjectSerializer.serialize(categoryIds, "string");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: OfferListResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "OfferListResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Return list of recent trigger suggestions that have been sent to the user.
     * @summary List Sent Suggestions 
     * @param version 
     * @param accountId The account to match offers for.
     * @param timeframe The timeframe in seconds of the latest suggestions
     * @param suggestionType The type of trigger suggestions to return
     */
    public async listLastestByAccount (version: number, accountId: number, timeframe: number, suggestionType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: OfferListResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/audience/suggestion/latest'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling listLastestByAccount.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listLastestByAccount.');
        }

        // verify required parameter 'timeframe' is not null or undefined
        if (timeframe === null || timeframe === undefined) {
            throw new Error('Required parameter timeframe was null or undefined when calling listLastestByAccount.');
        }

        // verify required parameter 'suggestionType' is not null or undefined
        if (suggestionType === null || suggestionType === undefined) {
            throw new Error('Required parameter suggestionType was null or undefined when calling listLastestByAccount.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (timeframe !== undefined) {
            localVarQueryParameters['timeframe'] = ObjectSerializer.serialize(timeframe, "number");
        }

        if (suggestionType !== undefined) {
            localVarQueryParameters['suggestionType'] = ObjectSerializer.serialize(suggestionType, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: OfferListResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "OfferListResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.
     * @summary Send Suggestions
     * @param version 
     * @param accountId The account to match offers for.
     * @param latitude the latitude
     * @param longitude the longitude
     */
    public async sendByAccount (version: number, accountId: number, latitude: number, longitude: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/audience/suggestion/send'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling sendByAccount.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling sendByAccount.');
        }

        // verify required parameter 'latitude' is not null or undefined
        if (latitude === null || latitude === undefined) {
            throw new Error('Required parameter latitude was null or undefined when calling sendByAccount.');
        }

        // verify required parameter 'longitude' is not null or undefined
        if (longitude === null || longitude === undefined) {
            throw new Error('Required parameter longitude was null or undefined when calling sendByAccount.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update a user defined audience.
     * @summary Update Audience
     * @param version 
     * @param accountId The logged in user.
     * @param audienceId The id of the audience to update.
     * @param name The name of the audience
     * @param description The description of the audience
     * @param searchTags The search tags
     * @param gender The gender; possible values are: MALE, FEMALE, ANY
     * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
     * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
     * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
     * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
     * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
     * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
     * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
     * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
     * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
     * @param active if audience is active
     * @param sendSuggestion If true, then notify matching users when they are inside the radius
     * @param startTimeOffset Seconds from the start time of an event
     * @param endTimeOffset Seconds from the end time of an event
     * @param associateDescription the associate description
     * @param associateType The type of the object to center the audience geofence
     * @param associateId The ID of the object to center the audience geofence
     * @param groupingId Optional grouping id for the audience
     * @param metaData External custom client defined data
     * @param visibility Visibility of the audience
     * @param audienceType Type of audience
     * @param useOrder Use order for cohort
     * @param cohortRegionsData Cohort data for \&quot;cohort\&quot; audience type
     * @param appKey Filter results by application key
     * @param trilaterationTypes Trilateration types
     * @param uniqueName If true, makes sure the audience name is unique
     */
    public async updateAudience (version: number, accountId: number, audienceId: number, name?: string, description?: string, searchTags?: string, gender?: string, ageGroups?: string, categoryIds?: string, applicationIds?: string, gameExperienceLevel?: string, devices?: string, deviceIds?: string, deviceVersions?: string, locations?: string, radius?: string, active?: boolean, sendSuggestion?: boolean, startTimeOffset?: number, endTimeOffset?: number, associateDescription?: string, associateType?: string, associateId?: number, groupingId?: string, metaData?: string, visibility?: string, audienceType?: string, useOrder?: boolean, cohortRegionsData?: string, appKey?: string, trilaterationTypes?: string, uniqueName?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AudienceResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/audience/update'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling updateAudience.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateAudience.');
        }

        // verify required parameter 'audienceId' is not null or undefined
        if (audienceId === null || audienceId === undefined) {
            throw new Error('Required parameter audienceId was null or undefined when calling updateAudience.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (audienceId !== undefined) {
            localVarQueryParameters['audienceId'] = ObjectSerializer.serialize(audienceId, "number");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (searchTags !== undefined) {
            localVarQueryParameters['searchTags'] = ObjectSerializer.serialize(searchTags, "string");
        }

        if (gender !== undefined) {
            localVarQueryParameters['gender'] = ObjectSerializer.serialize(gender, "string");
        }

        if (ageGroups !== undefined) {
            localVarQueryParameters['ageGroups'] = ObjectSerializer.serialize(ageGroups, "string");
        }

        if (categoryIds !== undefined) {
            localVarQueryParameters['categoryIds'] = ObjectSerializer.serialize(categoryIds, "string");
        }

        if (applicationIds !== undefined) {
            localVarQueryParameters['applicationIds'] = ObjectSerializer.serialize(applicationIds, "string");
        }

        if (gameExperienceLevel !== undefined) {
            localVarQueryParameters['gameExperienceLevel'] = ObjectSerializer.serialize(gameExperienceLevel, "string");
        }

        if (devices !== undefined) {
            localVarQueryParameters['devices'] = ObjectSerializer.serialize(devices, "string");
        }

        if (deviceIds !== undefined) {
            localVarQueryParameters['deviceIds'] = ObjectSerializer.serialize(deviceIds, "string");
        }

        if (deviceVersions !== undefined) {
            localVarQueryParameters['deviceVersions'] = ObjectSerializer.serialize(deviceVersions, "string");
        }

        if (locations !== undefined) {
            localVarQueryParameters['locations'] = ObjectSerializer.serialize(locations, "string");
        }

        if (radius !== undefined) {
            localVarQueryParameters['radius'] = ObjectSerializer.serialize(radius, "string");
        }

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (sendSuggestion !== undefined) {
            localVarQueryParameters['sendSuggestion'] = ObjectSerializer.serialize(sendSuggestion, "boolean");
        }

        if (startTimeOffset !== undefined) {
            localVarQueryParameters['startTimeOffset'] = ObjectSerializer.serialize(startTimeOffset, "number");
        }

        if (endTimeOffset !== undefined) {
            localVarQueryParameters['endTimeOffset'] = ObjectSerializer.serialize(endTimeOffset, "number");
        }

        if (associateDescription !== undefined) {
            localVarQueryParameters['associateDescription'] = ObjectSerializer.serialize(associateDescription, "string");
        }

        if (associateType !== undefined) {
            localVarQueryParameters['associateType'] = ObjectSerializer.serialize(associateType, "string");
        }

        if (associateId !== undefined) {
            localVarQueryParameters['associateId'] = ObjectSerializer.serialize(associateId, "number");
        }

        if (groupingId !== undefined) {
            localVarQueryParameters['groupingId'] = ObjectSerializer.serialize(groupingId, "string");
        }

        if (metaData !== undefined) {
            localVarQueryParameters['metaData'] = ObjectSerializer.serialize(metaData, "string");
        }

        if (visibility !== undefined) {
            localVarQueryParameters['visibility'] = ObjectSerializer.serialize(visibility, "string");
        }

        if (audienceType !== undefined) {
            localVarQueryParameters['audienceType'] = ObjectSerializer.serialize(audienceType, "string");
        }

        if (useOrder !== undefined) {
            localVarQueryParameters['useOrder'] = ObjectSerializer.serialize(useOrder, "boolean");
        }

        if (cohortRegionsData !== undefined) {
            localVarQueryParameters['cohortRegionsData'] = ObjectSerializer.serialize(cohortRegionsData, "string");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (trilaterationTypes !== undefined) {
            localVarQueryParameters['trilaterationTypes'] = ObjectSerializer.serialize(trilaterationTypes, "string");
        }

        if (uniqueName !== undefined) {
            localVarQueryParameters['uniqueName'] = ObjectSerializer.serialize(uniqueName, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AudienceResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AudienceResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
