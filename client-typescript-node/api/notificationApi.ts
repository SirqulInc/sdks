/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET[\'appKey\']);$b = htmlspecialchars($_GET[\'appRestKey\']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { BlockedNotificationResponse } from '../model/blockedNotificationResponse';
import { NotificationMessageListResponse } from '../model/notificationMessageListResponse';
import { NotificationRecipientResponse } from '../model/notificationRecipientResponse';
import { NotificationRecipientResponseListResponse } from '../model/notificationRecipientResponseListResponse';
import { NotificationTemplateResponse } from '../model/notificationTemplateResponse';
import { SirqulResponse } from '../model/sirqulResponse';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'http://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum NotificationApiApiKeys {
    appKey,
    restKey,
}

export class NotificationApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'appKey': new ApiKeyAuth('header', 'Application-Key'),
        'restKey': new ApiKeyAuth('header', 'Application-Rest-Key'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: NotificationApiApiKeys, value: string) {
        (this.authentications as any)[NotificationApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Create a notification template. Developers will only be able to create notification templates for their own applications.
     * @summary Create Notification Template
     * @param version 
     * @param accountId The account ID of the user.
     * @param conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
     * @param title title of the notification template
     * @param body body of the notification template
     * @param appKey Filter results by application.
     * @param event Filter results by event.
     * @param tags tags associated with the note template
     */
    public async createNotificationTemplate (version: number, accountId: number, conduit: string, title: string, body: string, appKey?: string, event?: string, tags?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: NotificationTemplateResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/notification/template/create'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling createNotificationTemplate.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createNotificationTemplate.');
        }

        // verify required parameter 'conduit' is not null or undefined
        if (conduit === null || conduit === undefined) {
            throw new Error('Required parameter conduit was null or undefined when calling createNotificationTemplate.');
        }

        // verify required parameter 'title' is not null or undefined
        if (title === null || title === undefined) {
            throw new Error('Required parameter title was null or undefined when calling createNotificationTemplate.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createNotificationTemplate.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (event !== undefined) {
            localVarQueryParameters['event'] = ObjectSerializer.serialize(event, "string");
        }

        if (conduit !== undefined) {
            localVarQueryParameters['conduit'] = ObjectSerializer.serialize(conduit, "string");
        }

        if (title !== undefined) {
            localVarQueryParameters['title'] = ObjectSerializer.serialize(title, "string");
        }

        if (body !== undefined) {
            localVarQueryParameters['body'] = ObjectSerializer.serialize(body, "string");
        }

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: NotificationTemplateResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "NotificationTemplateResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create or update blocked notification settings
     * @summary Create or update blocked notification settings
     * @param version 
     * @param appKey The application key
     * @param data batch data payload (application specific)
     * @param accountId the account id of the user
     */
    public async createOrUpdateBlockedNotifications (version: number, appKey: string, data: string, accountId?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: BlockedNotificationResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/notification/blocked/batch'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling createOrUpdateBlockedNotifications.');
        }

        // verify required parameter 'appKey' is not null or undefined
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling createOrUpdateBlockedNotifications.');
        }

        // verify required parameter 'data' is not null or undefined
        if (data === null || data === undefined) {
            throw new Error('Required parameter data was null or undefined when calling createOrUpdateBlockedNotifications.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (data !== undefined) {
            localVarQueryParameters['data'] = ObjectSerializer.serialize(data, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: BlockedNotificationResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "BlockedNotificationResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Deletes a notification template. Developers will only be able to delete notification templates for their own applications.
     * @summary Delete Notification Template
     * @param version 
     * @param accountId the account id of the user
     * @param notificationTemplateId the id of the notification template to delete
     */
    public async deleteNotificationTemplate (version: number, accountId: number, notificationTemplateId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: NotificationTemplateResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/notification/template/delete'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling deleteNotificationTemplate.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteNotificationTemplate.');
        }

        // verify required parameter 'notificationTemplateId' is not null or undefined
        if (notificationTemplateId === null || notificationTemplateId === undefined) {
            throw new Error('Required parameter notificationTemplateId was null or undefined when calling deleteNotificationTemplate.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (notificationTemplateId !== undefined) {
            localVarQueryParameters['notificationTemplateId'] = ObjectSerializer.serialize(notificationTemplateId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: NotificationTemplateResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "NotificationTemplateResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get the details of a notification template. Developers will only be able to see notification templates for their own applications.
     * @summary Get Notification Template
     * @param version 
     * @param accountId the id of the account
     * @param notificationTemplateId the id of the notification template to get
     */
    public async getNotificationTemplate (version: number, accountId: number, notificationTemplateId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: NotificationTemplateResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/notification/template/get'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getNotificationTemplate.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getNotificationTemplate.');
        }

        // verify required parameter 'notificationTemplateId' is not null or undefined
        if (notificationTemplateId === null || notificationTemplateId === undefined) {
            throw new Error('Required parameter notificationTemplateId was null or undefined when calling getNotificationTemplate.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (notificationTemplateId !== undefined) {
            localVarQueryParameters['notificationTemplateId'] = ObjectSerializer.serialize(notificationTemplateId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: NotificationTemplateResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "NotificationTemplateResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a list of notifications for a user. If the \"markAsRead\" parameter is set to true, the returned notifications will be marked as \"read\" after the response has been sent. By default, read messages will not be returned, so to see read messages, set \"returnReadMessages\" to true.
     * @summary Get Notifications
     * @param version 
     * @param deviceId the unique id of the device making the request (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param connectionAccountId the account id used to view another person\&#39;s notifications
     * @param appKey the application key to filter messages by application
     * @param eventType comma separated list of EVENTS. Filters search results to only include these events. Don\&#39;t include this parameter or pass in an empty string to return all event types.
     * @param contentIds comma separated list of content ids to search notifications on
     * @param contentTypes comma separated list of content types to search notifications on
     * @param parentIds comma separated list of parent ids to search notifications on
     * @param parentTypes comma separated list of parent types to search notifications on
     * @param actionCategory Action category used to filter notifications
     * @param conduits comma separated list of conduits to search notifications on
     * @param keyword search notifications via keyword
     * @param returnReadMessages if set to true, will return notifications that have been marked as read
     * @param markAsRead if set to true, the returned notifications will be marked as \\\&quot;read\\\&quot; after the response has been sent
     * @param fromDate filter notifications from this date
     * @param latitude latitude used to update the user\&#39;s current location
     * @param longitude longitude used to update the user\&#39;s current location
     * @param returnSent whether to include notifications sent by the requester in the response
     * @param ignoreFlagged whether to ignore flagged notifications
     * @param start start of the pagination
     * @param limit limit of the pagination
     */
    public async getNotifications (version: number, deviceId?: string, accountId?: number, connectionAccountId?: number, appKey?: string, eventType?: string, contentIds?: string, contentTypes?: string, parentIds?: string, parentTypes?: string, actionCategory?: string, conduits?: string, keyword?: string, returnReadMessages?: boolean, markAsRead?: boolean, fromDate?: number, latitude?: number, longitude?: number, returnSent?: boolean, ignoreFlagged?: boolean, start?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: NotificationMessageListResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/notification/search'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getNotifications.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (connectionAccountId !== undefined) {
            localVarQueryParameters['connectionAccountId'] = ObjectSerializer.serialize(connectionAccountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "string");
        }

        if (contentIds !== undefined) {
            localVarQueryParameters['contentIds'] = ObjectSerializer.serialize(contentIds, "string");
        }

        if (contentTypes !== undefined) {
            localVarQueryParameters['contentTypes'] = ObjectSerializer.serialize(contentTypes, "string");
        }

        if (parentIds !== undefined) {
            localVarQueryParameters['parentIds'] = ObjectSerializer.serialize(parentIds, "string");
        }

        if (parentTypes !== undefined) {
            localVarQueryParameters['parentTypes'] = ObjectSerializer.serialize(parentTypes, "string");
        }

        if (actionCategory !== undefined) {
            localVarQueryParameters['actionCategory'] = ObjectSerializer.serialize(actionCategory, "string");
        }

        if (conduits !== undefined) {
            localVarQueryParameters['conduits'] = ObjectSerializer.serialize(conduits, "string");
        }

        if (keyword !== undefined) {
            localVarQueryParameters['keyword'] = ObjectSerializer.serialize(keyword, "string");
        }

        if (returnReadMessages !== undefined) {
            localVarQueryParameters['returnReadMessages'] = ObjectSerializer.serialize(returnReadMessages, "boolean");
        }

        if (markAsRead !== undefined) {
            localVarQueryParameters['markAsRead'] = ObjectSerializer.serialize(markAsRead, "boolean");
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['fromDate'] = ObjectSerializer.serialize(fromDate, "number");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        if (returnSent !== undefined) {
            localVarQueryParameters['returnSent'] = ObjectSerializer.serialize(returnSent, "boolean");
        }

        if (ignoreFlagged !== undefined) {
            localVarQueryParameters['ignoreFlagged'] = ObjectSerializer.serialize(ignoreFlagged, "boolean");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: NotificationMessageListResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "NotificationMessageListResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.
     * @summary Register Notification Token
     * @param version 
     * @param token A token that is generated by the device to sign requests for the notification service providers
     * @param pushType The type of push notification. Possible values include: APNS, GCM
     * @param deviceId The unique id of the device making the request (deviceId or accountId required)
     * @param accountId The account id of the user (deviceId or accountId required)
     * @param environment Determines if the token is a DEVELOPMENT or PRODUCTION token
     * @param appKey The application key
     * @param gameType This parameter is deprecated (use appKey instead)
     * @param active Sets whether the token is active or not (non-active tokens are not used)
     * @param latitude Latitude used to update the user\&#39;s current location
     * @param longitude Longitude used to update the user\&#39;s current location
     */
    public async registerNotificationToken (version: number, token: string, pushType: 'APNS' | 'GCM' | 'BAIDU' | 'XGPUSH' | 'JPUSH', deviceId?: string, accountId?: number, environment?: string, appKey?: string, gameType?: string, active?: boolean, latitude?: number, longitude?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/notification/token'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling registerNotificationToken.');
        }

        // verify required parameter 'token' is not null or undefined
        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling registerNotificationToken.');
        }

        // verify required parameter 'pushType' is not null or undefined
        if (pushType === null || pushType === undefined) {
            throw new Error('Required parameter pushType was null or undefined when calling registerNotificationToken.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (pushType !== undefined) {
            localVarQueryParameters['pushType'] = ObjectSerializer.serialize(pushType, "'APNS' | 'GCM' | 'BAIDU' | 'XGPUSH' | 'JPUSH'");
        }

        if (environment !== undefined) {
            localVarQueryParameters['environment'] = ObjectSerializer.serialize(environment, "string");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (gameType !== undefined) {
            localVarQueryParameters['gameType'] = ObjectSerializer.serialize(gameType, "string");
        }

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Search on the user\'s blocked notification settings
     * @summary Search on the user\'s blocked notification settings
     * @param version 
     * @param appKey The application key
     * @param accountId the account id of the user
     * @param searchTags search tags to filter results
     * @param events events to filter by (comma separated)
     * @param conduits conduits to filter by (comma separated)
     * @param customTypes custom types to filter by (comma separated)
     * @param contentTypes content types to filter by (comma separated)
     * @param contentIds content ids to filter by (comma separated)
     * @param sortField sort field for results
     * @param descending whether to sort descending
     * @param start start of the pagination
     * @param limit limit of the pagination
     */
    public async searchBlockedNotifications (version: number, appKey: string, accountId?: number, searchTags?: string, events?: string, conduits?: string, customTypes?: string, contentTypes?: string, contentIds?: string, sortField?: string, descending?: boolean, start?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: BlockedNotificationResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/notification/blocked/search'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling searchBlockedNotifications.');
        }

        // verify required parameter 'appKey' is not null or undefined
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling searchBlockedNotifications.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (searchTags !== undefined) {
            localVarQueryParameters['searchTags'] = ObjectSerializer.serialize(searchTags, "string");
        }

        if (events !== undefined) {
            localVarQueryParameters['events'] = ObjectSerializer.serialize(events, "string");
        }

        if (conduits !== undefined) {
            localVarQueryParameters['conduits'] = ObjectSerializer.serialize(conduits, "string");
        }

        if (customTypes !== undefined) {
            localVarQueryParameters['customTypes'] = ObjectSerializer.serialize(customTypes, "string");
        }

        if (contentTypes !== undefined) {
            localVarQueryParameters['contentTypes'] = ObjectSerializer.serialize(contentTypes, "string");
        }

        if (contentIds !== undefined) {
            localVarQueryParameters['contentIds'] = ObjectSerializer.serialize(contentIds, "string");
        }

        if (sortField !== undefined) {
            localVarQueryParameters['sortField'] = ObjectSerializer.serialize(sortField, "string");
        }

        if (descending !== undefined) {
            localVarQueryParameters['descending'] = ObjectSerializer.serialize(descending, "boolean");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: BlockedNotificationResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "BlockedNotificationResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Search for notification templates on owned applications.
     * @summary Search Notification Templates
     * @param version 
     * @param accountId The account ID of the user.
     * @param sortField Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name (\&#39;global\&#39; templates will not have an application and will be returned last if \&#39;descending\&#39; is set to false.
     * @param descending Specified whether the results are returned in descending or ascending order.
     * @param start The start of the pagination.
     * @param limit The limit of the pagination.
     * @param appKey Filter results by application.
     * @param event Filter results by event.
     * @param conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
     * @param globalOnly Returns only templates that have been reserved for system use on all applications (only for admin accounts).
     * @param reservedOnly Returns only templates that use reserved events.
     * @param keyword Filter results by keyword on the title, tags.
     */
    public async searchNotificationTemplate (version: number, accountId: number, sortField: string, descending: boolean, start: number, limit: number, appKey?: string, event?: string, conduit?: string, globalOnly?: boolean, reservedOnly?: boolean, keyword?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: NotificationTemplateResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/notification/template/search'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling searchNotificationTemplate.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling searchNotificationTemplate.');
        }

        // verify required parameter 'sortField' is not null or undefined
        if (sortField === null || sortField === undefined) {
            throw new Error('Required parameter sortField was null or undefined when calling searchNotificationTemplate.');
        }

        // verify required parameter 'descending' is not null or undefined
        if (descending === null || descending === undefined) {
            throw new Error('Required parameter descending was null or undefined when calling searchNotificationTemplate.');
        }

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling searchNotificationTemplate.');
        }

        // verify required parameter 'limit' is not null or undefined
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling searchNotificationTemplate.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (event !== undefined) {
            localVarQueryParameters['event'] = ObjectSerializer.serialize(event, "string");
        }

        if (conduit !== undefined) {
            localVarQueryParameters['conduit'] = ObjectSerializer.serialize(conduit, "string");
        }

        if (globalOnly !== undefined) {
            localVarQueryParameters['globalOnly'] = ObjectSerializer.serialize(globalOnly, "boolean");
        }

        if (reservedOnly !== undefined) {
            localVarQueryParameters['reservedOnly'] = ObjectSerializer.serialize(reservedOnly, "boolean");
        }

        if (keyword !== undefined) {
            localVarQueryParameters['keyword'] = ObjectSerializer.serialize(keyword, "string");
        }

        if (sortField !== undefined) {
            localVarQueryParameters['sortField'] = ObjectSerializer.serialize(sortField, "string");
        }

        if (descending !== undefined) {
            localVarQueryParameters['descending'] = ObjectSerializer.serialize(descending, "boolean");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: NotificationTemplateResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "NotificationTemplateResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Search for application users to send notifications.
     * @summary Search for Recipients
     * @param version 
     * @param sortField The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}
     * @param deviceId the unique id of the device making the request (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param appKey filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
     * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
     * @param keyword search by keyword on user\&#39;s display name and email
     * @param audienceId This parameter is deprecated. filter results by audience
     * @param audienceIds filter results by audiences (comma separated list of audience ids)
     * @param connectionGroupIds filter results by connection groups (comma separated list of connection group ids)
     * @param recipientAccountIds filter results by accounts (comma separated list of account ids)
     * @param descending Determines whether the sorted list is in descending or ascending order
     * @param start start of the pagination
     * @param limit limit of the pagination (hard limit of 1000)
     */
    public async searchRecipients (version: number, sortField: 'ID' | 'HAS_SMS' | 'HAS_EMAIL' | 'HAS_APNS' | 'HAS_GCM' | 'APPLICATION_ID' | 'APPLICATION_NAME' | 'ACCOUNT_ID' | 'ACCOUNT_USERNAME' | 'ACCOUNT_DISPLAY' | 'ACCOUNT_TYPE', deviceId?: string, accountId?: number, appKey?: string, conduit?: string, keyword?: string, audienceId?: number, audienceIds?: string, connectionGroupIds?: string, recipientAccountIds?: string, descending?: boolean, start?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<NotificationRecipientResponse>;  }> {
        const localVarPath = this.basePath + '/api/{version}/notification/recipient/search'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling searchRecipients.');
        }

        // verify required parameter 'sortField' is not null or undefined
        if (sortField === null || sortField === undefined) {
            throw new Error('Required parameter sortField was null or undefined when calling searchRecipients.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (conduit !== undefined) {
            localVarQueryParameters['conduit'] = ObjectSerializer.serialize(conduit, "string");
        }

        if (keyword !== undefined) {
            localVarQueryParameters['keyword'] = ObjectSerializer.serialize(keyword, "string");
        }

        if (audienceId !== undefined) {
            localVarQueryParameters['audienceId'] = ObjectSerializer.serialize(audienceId, "number");
        }

        if (audienceIds !== undefined) {
            localVarQueryParameters['audienceIds'] = ObjectSerializer.serialize(audienceIds, "string");
        }

        if (connectionGroupIds !== undefined) {
            localVarQueryParameters['connectionGroupIds'] = ObjectSerializer.serialize(connectionGroupIds, "string");
        }

        if (recipientAccountIds !== undefined) {
            localVarQueryParameters['recipientAccountIds'] = ObjectSerializer.serialize(recipientAccountIds, "string");
        }

        if (sortField !== undefined) {
            localVarQueryParameters['sortField'] = ObjectSerializer.serialize(sortField, "'ID' | 'HAS_SMS' | 'HAS_EMAIL' | 'HAS_APNS' | 'HAS_GCM' | 'APPLICATION_ID' | 'APPLICATION_NAME' | 'ACCOUNT_ID' | 'ACCOUNT_USERNAME' | 'ACCOUNT_DISPLAY' | 'ACCOUNT_TYPE'");
        }

        if (descending !== undefined) {
            localVarQueryParameters['descending'] = ObjectSerializer.serialize(descending, "boolean");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<NotificationRecipientResponse>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<NotificationRecipientResponse>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Search for application users to send notifications (count/grouped variant).
     * @summary Search for Recipients (Counts/Grouped)
     * @param version 
     * @param deviceId the unique id of the device making the request (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param appKey filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
     * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
     * @param keyword search by keyword on user\&#39;s display name and email
     * @param audienceId This parameter is deprecated. filter results by audience
     * @param audienceIds filter results by audiences (comma separated list of audience ids)
     * @param connectionGroupIds filter results by connection groups (comma separated list of connection group ids)
     * @param sortField The field to sort by (see API docs for allowed values).
     * @param descending Determines whether the sorted list is in descending or ascending order
     * @param start start of the pagination
     * @param limit limit of the pagination
     */
    public async searchRecipientsCount (version: number, deviceId?: string, accountId?: number, appKey?: string, conduit?: string, keyword?: string, audienceId?: number, audienceIds?: string, connectionGroupIds?: string, sortField?: string, descending?: boolean, start?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: NotificationRecipientResponseListResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/notification/recipient/search/count'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling searchRecipientsCount.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (conduit !== undefined) {
            localVarQueryParameters['conduit'] = ObjectSerializer.serialize(conduit, "string");
        }

        if (keyword !== undefined) {
            localVarQueryParameters['keyword'] = ObjectSerializer.serialize(keyword, "string");
        }

        if (audienceId !== undefined) {
            localVarQueryParameters['audienceId'] = ObjectSerializer.serialize(audienceId, "number");
        }

        if (audienceIds !== undefined) {
            localVarQueryParameters['audienceIds'] = ObjectSerializer.serialize(audienceIds, "string");
        }

        if (connectionGroupIds !== undefined) {
            localVarQueryParameters['connectionGroupIds'] = ObjectSerializer.serialize(connectionGroupIds, "string");
        }

        if (sortField !== undefined) {
            localVarQueryParameters['sortField'] = ObjectSerializer.serialize(sortField, "string");
        }

        if (descending !== undefined) {
            localVarQueryParameters['descending'] = ObjectSerializer.serialize(descending, "boolean");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: NotificationRecipientResponseListResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "NotificationRecipientResponseListResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Send notifications to all users of an application. Only someone with permissions to the application can do this.
     * @summary Send Batch Notifications
     * @param version 
     * @param accountId The account id of the application owner/manager
     * @param appKey The application key for updating an existing application
     * @param customMessage Message string that will be displayed in on the notification
     * @param conduit The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
     * @param contentId Default notification pay-load field (usage is dependent on the app and the type of event)
     * @param contentName Default notification pay-load field (usage is dependent on the app and the type of event)
     * @param contentType Default notification pay-load field (usage is dependent on the app and the type of event)
     * @param parentId Default notification pay-load field (usage is dependent on the app and the type of event)
     * @param parentType Default notification pay-load field (usage is dependent on the app and the type of event)
     */
    public async sendBatchNotifications (version: number, accountId: number, appKey: string, customMessage: string, conduit?: string, contentId?: number, contentName?: string, contentType?: string, parentId?: number, parentType?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/notification/batch'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling sendBatchNotifications.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling sendBatchNotifications.');
        }

        // verify required parameter 'appKey' is not null or undefined
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling sendBatchNotifications.');
        }

        // verify required parameter 'customMessage' is not null or undefined
        if (customMessage === null || customMessage === undefined) {
            throw new Error('Required parameter customMessage was null or undefined when calling sendBatchNotifications.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (conduit !== undefined) {
            localVarQueryParameters['conduit'] = ObjectSerializer.serialize(conduit, "string");
        }

        if (customMessage !== undefined) {
            localVarQueryParameters['customMessage'] = ObjectSerializer.serialize(customMessage, "string");
        }

        if (contentId !== undefined) {
            localVarQueryParameters['contentId'] = ObjectSerializer.serialize(contentId, "number");
        }

        if (contentName !== undefined) {
            localVarQueryParameters['contentName'] = ObjectSerializer.serialize(contentName, "string");
        }

        if (contentType !== undefined) {
            localVarQueryParameters['contentType'] = ObjectSerializer.serialize(contentType, "string");
        }

        if (parentId !== undefined) {
            localVarQueryParameters['parentId'] = ObjectSerializer.serialize(parentId, "number");
        }

        if (parentType !== undefined) {
            localVarQueryParameters['parentType'] = ObjectSerializer.serialize(parentType, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.
     * @summary Send Custom Notifications
     * @param version 
     * @param deviceId the unique id of the device making the request (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param receiverAccountIds comma separated list of account IDs that will receive the notification
     * @param includeFriendGroup determines whether to send to all of the user\&#39;s friends, this flag must be true or receiverAccountIds must not be empty
     * @param appKey the application key
     * @param gameType This parameter is deprecated.
     * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
     * @param contentId default notification pay-load field (usage is dependent on the app and the type of event)
     * @param contentName default notification pay-load field (usage is dependent on the app and the type of event)
     * @param contentType default notification pay-load field (usage is dependent on the app and the type of event)
     * @param parentId default notification pay-load field (usage is dependent on the app and the type of event)
     * @param parentType default notification pay-load field (usage is dependent on the app and the type of event)
     * @param actionCategory 
     * @param subject the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)
     * @param customMessage message string that will be displayed in on the notification
     * @param friendOnlyAPNS only sends APNS to people who are friends of the user (still saves the notification message for feed polling)
     * @param latitude latitude used to update the user\&#39;s current location
     * @param longitude longitude used to update the user\&#39;s current location
     */
    public async sendCustomNotifications (version: number, deviceId?: string, accountId?: number, receiverAccountIds?: string, includeFriendGroup?: boolean, appKey?: string, gameType?: string, conduit?: string, contentId?: number, contentName?: string, contentType?: string, parentId?: number, parentType?: string, actionCategory?: string, subject?: string, customMessage?: string, friendOnlyAPNS?: boolean, latitude?: number, longitude?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/notification/custom'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling sendCustomNotifications.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (receiverAccountIds !== undefined) {
            localVarQueryParameters['receiverAccountIds'] = ObjectSerializer.serialize(receiverAccountIds, "string");
        }

        if (includeFriendGroup !== undefined) {
            localVarQueryParameters['includeFriendGroup'] = ObjectSerializer.serialize(includeFriendGroup, "boolean");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (gameType !== undefined) {
            localVarQueryParameters['gameType'] = ObjectSerializer.serialize(gameType, "string");
        }

        if (conduit !== undefined) {
            localVarQueryParameters['conduit'] = ObjectSerializer.serialize(conduit, "string");
        }

        if (contentId !== undefined) {
            localVarQueryParameters['contentId'] = ObjectSerializer.serialize(contentId, "number");
        }

        if (contentName !== undefined) {
            localVarQueryParameters['contentName'] = ObjectSerializer.serialize(contentName, "string");
        }

        if (contentType !== undefined) {
            localVarQueryParameters['contentType'] = ObjectSerializer.serialize(contentType, "string");
        }

        if (parentId !== undefined) {
            localVarQueryParameters['parentId'] = ObjectSerializer.serialize(parentId, "number");
        }

        if (parentType !== undefined) {
            localVarQueryParameters['parentType'] = ObjectSerializer.serialize(parentType, "string");
        }

        if (actionCategory !== undefined) {
            localVarQueryParameters['actionCategory'] = ObjectSerializer.serialize(actionCategory, "string");
        }

        if (subject !== undefined) {
            localVarQueryParameters['subject'] = ObjectSerializer.serialize(subject, "string");
        }

        if (customMessage !== undefined) {
            localVarQueryParameters['customMessage'] = ObjectSerializer.serialize(customMessage, "string");
        }

        if (friendOnlyAPNS !== undefined) {
            localVarQueryParameters['friendOnlyAPNS'] = ObjectSerializer.serialize(friendOnlyAPNS, "boolean");
        }

        if (latitude !== undefined) {
            localVarQueryParameters['latitude'] = ObjectSerializer.serialize(latitude, "number");
        }

        if (longitude !== undefined) {
            localVarQueryParameters['longitude'] = ObjectSerializer.serialize(longitude, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update a notification template. Developers will only be able to update notification templates for their own applications.
     * @summary Update Notification Template
     * @param version 
     * @param accountId The account ID of the user.
     * @param notificationTemplateId The notification template ID to update.
     * @param title The title of the message (this would become the subject title for emails). There is a 191 character limit.
     * @param body The body of the message.
     * @param tags The search tags on the template used during search queries.
     */
    public async updateNotificationTemplate (version: number, accountId: number, notificationTemplateId: number, title?: string, body?: string, tags?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: NotificationTemplateResponse;  }> {
        const localVarPath = this.basePath + '/api/{version}/notification/template/update'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling updateNotificationTemplate.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateNotificationTemplate.');
        }

        // verify required parameter 'notificationTemplateId' is not null or undefined
        if (notificationTemplateId === null || notificationTemplateId === undefined) {
            throw new Error('Required parameter notificationTemplateId was null or undefined when calling updateNotificationTemplate.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (notificationTemplateId !== undefined) {
            localVarQueryParameters['notificationTemplateId'] = ObjectSerializer.serialize(notificationTemplateId, "number");
        }

        if (title !== undefined) {
            localVarQueryParameters['title'] = ObjectSerializer.serialize(title, "string");
        }

        if (body !== undefined) {
            localVarQueryParameters['body'] = ObjectSerializer.serialize(body, "string");
        }

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: NotificationTemplateResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "NotificationTemplateResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
