/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET[\'appKey\']);$b = htmlspecialchars($_GET[\'appRestKey\']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { GameLevelListResponse } from '../model/gameLevelListResponse';
import { GameLevelResponse } from '../model/gameLevelResponse';
import { QuestionResponse } from '../model/questionResponse';
import { SirqulResponse } from '../model/sirqulResponse';
import { WordzWordResponse } from '../model/wordzWordResponse';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://dev.sirqul.com/api/3.18';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum GameLevelApiApiKeys {
    appKey,
    restKey,
}

export class GameLevelApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'appKey': new ApiKeyAuth('header', 'Application-Key'),
        'restKey': new ApiKeyAuth('header', 'Application-Rest-Key'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: GameLevelApiApiKeys, value: string) {
        (this.authentications as any)[GameLevelApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Create a game level. Currently does NOT support game objects.
     * @summary Create Game Level
     * @param accountId The logged in user.
     * @param name The name of the level.
     * @param gameData The game level data: xml, json, or other text based format.
     * @param gameDataSuffix The game level data format type.
     * @param appKey The game application key to save the level for.
     * @param description The description of the level.
     * @param difficulty The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD.
     * @param appVersion The version number of the application required to correctly load/play the level.
     * @param assetImageId The asset Id of the level image.
     * @param assetIconId The asset Id of the level icon.
     * @param visibility Is the level visible to others, possible values are: PUBLIC, PRIVATE.
     * @param friendGroup Make the level be readable by all friends.
     * @param connectionIds Make the level be readable by connections in this list.
     * @param connectionGroupIds Make the level be readable by connection groups in this list.
     * @param balance Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.
     * @param active If true set the game level as active. Default is false.
     * @param allocateTickets If true then scoring will give tickets. Default is false.
     * @param ticketCount The number of tickets to reward
     * @param ticketType The type of ticket to reward, null means default type
     * @param points The number of points to award for completing a level
     * @param tutorialTitle Title of the tutorial.
     * @param tutorialMessage Message of the tutotrial.
     * @param tutorialAlignment Alignment of the tutorial image. Default to NONE. Possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY
     * @param tutorialImageAssetId Asset id of the tutorial image.
     * @param offerId id of the offer
     * @param metaData external custom client defined data
     */
    public async createGameLevel (accountId: number, name: string, gameData: string, gameDataSuffix: string, appKey?: string, description?: string, difficulty?: string, appVersion?: string, assetImageId?: number, assetIconId?: number, visibility?: string, friendGroup?: boolean, connectionIds?: string, connectionGroupIds?: string, balance?: number, active?: boolean, allocateTickets?: boolean, ticketCount?: number, ticketType?: string, points?: number, tutorialTitle?: string, tutorialMessage?: string, tutorialAlignment?: string, tutorialImageAssetId?: number, offerId?: number, metaData?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GameLevelResponse;  }> {
        const localVarPath = this.basePath + '/level/create';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createGameLevel.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createGameLevel.');
        }

        // verify required parameter 'gameData' is not null or undefined
        if (gameData === null || gameData === undefined) {
            throw new Error('Required parameter gameData was null or undefined when calling createGameLevel.');
        }

        // verify required parameter 'gameDataSuffix' is not null or undefined
        if (gameDataSuffix === null || gameDataSuffix === undefined) {
            throw new Error('Required parameter gameDataSuffix was null or undefined when calling createGameLevel.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (difficulty !== undefined) {
            localVarQueryParameters['difficulty'] = ObjectSerializer.serialize(difficulty, "string");
        }

        if (appVersion !== undefined) {
            localVarQueryParameters['appVersion'] = ObjectSerializer.serialize(appVersion, "string");
        }

        if (assetImageId !== undefined) {
            localVarQueryParameters['assetImageId'] = ObjectSerializer.serialize(assetImageId, "number");
        }

        if (assetIconId !== undefined) {
            localVarQueryParameters['assetIconId'] = ObjectSerializer.serialize(assetIconId, "number");
        }

        if (gameData !== undefined) {
            localVarQueryParameters['gameData'] = ObjectSerializer.serialize(gameData, "string");
        }

        if (gameDataSuffix !== undefined) {
            localVarQueryParameters['gameDataSuffix'] = ObjectSerializer.serialize(gameDataSuffix, "string");
        }

        if (visibility !== undefined) {
            localVarQueryParameters['visibility'] = ObjectSerializer.serialize(visibility, "string");
        }

        if (friendGroup !== undefined) {
            localVarQueryParameters['friendGroup'] = ObjectSerializer.serialize(friendGroup, "boolean");
        }

        if (connectionIds !== undefined) {
            localVarQueryParameters['connectionIds'] = ObjectSerializer.serialize(connectionIds, "string");
        }

        if (connectionGroupIds !== undefined) {
            localVarQueryParameters['connectionGroupIds'] = ObjectSerializer.serialize(connectionGroupIds, "string");
        }

        if (balance !== undefined) {
            localVarQueryParameters['balance'] = ObjectSerializer.serialize(balance, "number");
        }

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (allocateTickets !== undefined) {
            localVarQueryParameters['allocateTickets'] = ObjectSerializer.serialize(allocateTickets, "boolean");
        }

        if (ticketCount !== undefined) {
            localVarQueryParameters['ticketCount'] = ObjectSerializer.serialize(ticketCount, "number");
        }

        if (ticketType !== undefined) {
            localVarQueryParameters['ticketType'] = ObjectSerializer.serialize(ticketType, "string");
        }

        if (points !== undefined) {
            localVarQueryParameters['points'] = ObjectSerializer.serialize(points, "number");
        }

        if (tutorialTitle !== undefined) {
            localVarQueryParameters['tutorialTitle'] = ObjectSerializer.serialize(tutorialTitle, "string");
        }

        if (tutorialMessage !== undefined) {
            localVarQueryParameters['tutorialMessage'] = ObjectSerializer.serialize(tutorialMessage, "string");
        }

        if (tutorialAlignment !== undefined) {
            localVarQueryParameters['tutorialAlignment'] = ObjectSerializer.serialize(tutorialAlignment, "string");
        }

        if (tutorialImageAssetId !== undefined) {
            localVarQueryParameters['tutorialImageAssetId'] = ObjectSerializer.serialize(tutorialImageAssetId, "number");
        }

        if (offerId !== undefined) {
            localVarQueryParameters['offerId'] = ObjectSerializer.serialize(offerId, "number");
        }

        if (metaData !== undefined) {
            localVarQueryParameters['metaData'] = ObjectSerializer.serialize(metaData, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GameLevelResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GameLevelResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Delete a game level. The level and account must be valid and have the appropirate permissions to view the content.
     * @summary Delete Game Level
     * @param accountId The logged in user.
     * @param levelId The id of the level to return.
     */
    public async deleteGameLevel (accountId: number, levelId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/level/delete';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteGameLevel.');
        }

        // verify required parameter 'levelId' is not null or undefined
        if (levelId === null || levelId === undefined) {
            throw new Error('Required parameter levelId was null or undefined when calling deleteGameLevel.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (levelId !== undefined) {
            localVarQueryParameters['levelId'] = ObjectSerializer.serialize(levelId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a game level. The level and account must be valid and have the appropirate permissions to view the content.
     * @summary Get Game Level
     * @param accountId The logged in user.
     * @param levelId The id of the level to return.
     * @param includeGameData If true include the game level data, otherwise don\&#39;t. default is false.
     */
    public async getGameLevel (accountId: number, levelId: number, includeGameData?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GameLevelResponse;  }> {
        const localVarPath = this.basePath + '/level/get';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getGameLevel.');
        }

        // verify required parameter 'levelId' is not null or undefined
        if (levelId === null || levelId === undefined) {
            throw new Error('Required parameter levelId was null or undefined when calling getGameLevel.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (levelId !== undefined) {
            localVarQueryParameters['levelId'] = ObjectSerializer.serialize(levelId, "number");
        }

        if (includeGameData !== undefined) {
            localVarQueryParameters['includeGameData'] = ObjectSerializer.serialize(includeGameData, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GameLevelResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GameLevelResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a list of levels for an application, just those the account has permissions to view.
     * @summary Search Game Levels
     * @param accountId The logged in user.
     * @param appKey the application key
     * @param keyword Match the keyword to the owner name or level name.
     * @param sortField what field to sort on
     * @param descending whether to return levels in ascending or descending order
     * @param start Start the result set at some index.
     * @param limit Limit the result to some number.
     * @param appVersion The maximum version of the level to return.
     * @param includeGameData If true include the game level data, otherwise don\&#39;t. default is false.
     * @param filters 
     */
    public async getGameLevelsByApplication (accountId: number, appKey: string, keyword?: string, sortField?: string, descending?: boolean, start?: number, limit?: number, appVersion?: string, includeGameData?: boolean, filters?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GameLevelListResponse;  }> {
        const localVarPath = this.basePath + '/level/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getGameLevelsByApplication.');
        }

        // verify required parameter 'appKey' is not null or undefined
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling getGameLevelsByApplication.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (keyword !== undefined) {
            localVarQueryParameters['keyword'] = ObjectSerializer.serialize(keyword, "string");
        }

        if (sortField !== undefined) {
            localVarQueryParameters['sortField'] = ObjectSerializer.serialize(sortField, "string");
        }

        if (descending !== undefined) {
            localVarQueryParameters['descending'] = ObjectSerializer.serialize(descending, "boolean");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (appVersion !== undefined) {
            localVarQueryParameters['appVersion'] = ObjectSerializer.serialize(appVersion, "string");
        }

        if (includeGameData !== undefined) {
            localVarQueryParameters['includeGameData'] = ObjectSerializer.serialize(includeGameData, "boolean");
        }

        if (filters !== undefined) {
            localVarQueryParameters['filters'] = ObjectSerializer.serialize(filters, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GameLevelListResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GameLevelListResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Searches on game levels that the logged in user has access to. A user would have access if the creator of the game level is managed under the same BillableEntity.
     * @summary Search Game Level by Billable Entity
     * @param accountId The account id of the user
     * @param appKey the application key
     * @param keyword The keyword used to search
     * @param sortField The column to sort the search on
     * @param descending The order to return the search results
     * @param activeOnly Return only active results
     * @param start The record to begin the return set on
     * @param limit The number of records to return
     */
    public async getGameLevelsByBillableEntity (accountId: number, appKey?: string, keyword?: string, sortField?: 'LEVEL_ACTIVE' | 'LEVEL_NAME' | 'LEVEL_DESCRIPTION' | 'LEVEL_CREATED' | 'LEVEL_UPDATED' | 'LEVEL_LIKES' | 'LEVEL_DISLIKES' | 'LEVEL_NOTES' | 'LEVEL_PLAYS' | 'LEVEL_DOWNLOADS' | 'LEVEL_QUITS' | 'LEVEL_COMPLETES' | 'LEVEL_VERSION' | 'LEVEL_MISSION_TYPE' | 'LEVEL_OWNER_DISPLAY' | 'GAME_OWNER_DISPLAY' | 'GAME_TITLE' | 'GAME_DESCRIPTION' | 'GAME_LIKES' | 'GAME_DISLIKES' | 'APP_NAME' | 'APP_SCORING_TYPE', descending?: boolean, activeOnly?: boolean, start?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GameLevelResponse;  }> {
        const localVarPath = this.basePath + '/level/searchByBillableEntity';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getGameLevelsByBillableEntity.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (keyword !== undefined) {
            localVarQueryParameters['keyword'] = ObjectSerializer.serialize(keyword, "string");
        }

        if (sortField !== undefined) {
            localVarQueryParameters['sortField'] = ObjectSerializer.serialize(sortField, "'LEVEL_ACTIVE' | 'LEVEL_NAME' | 'LEVEL_DESCRIPTION' | 'LEVEL_CREATED' | 'LEVEL_UPDATED' | 'LEVEL_LIKES' | 'LEVEL_DISLIKES' | 'LEVEL_NOTES' | 'LEVEL_PLAYS' | 'LEVEL_DOWNLOADS' | 'LEVEL_QUITS' | 'LEVEL_COMPLETES' | 'LEVEL_VERSION' | 'LEVEL_MISSION_TYPE' | 'LEVEL_OWNER_DISPLAY' | 'GAME_OWNER_DISPLAY' | 'GAME_TITLE' | 'GAME_DESCRIPTION' | 'GAME_LIKES' | 'GAME_DISLIKES' | 'APP_NAME' | 'APP_SCORING_TYPE'");
        }

        if (descending !== undefined) {
            localVarQueryParameters['descending'] = ObjectSerializer.serialize(descending, "boolean");
        }

        if (activeOnly !== undefined) {
            localVarQueryParameters['activeOnly'] = ObjectSerializer.serialize(activeOnly, "boolean");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GameLevelResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GameLevelResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get questions within a level.
     * @summary Get Level Questions
     * @param levelId the id of the level to get questions from
     * @param accountId the id of the logged in user
     */
    public async getQuestionsInLevel (levelId: number, accountId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: QuestionResponse;  }> {
        const localVarPath = this.basePath + '/level/questions/get';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'levelId' is not null or undefined
        if (levelId === null || levelId === undefined) {
            throw new Error('Required parameter levelId was null or undefined when calling getQuestionsInLevel.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getQuestionsInLevel.');
        }

        if (levelId !== undefined) {
            localVarQueryParameters['levelId'] = ObjectSerializer.serialize(levelId, "number");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: QuestionResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "QuestionResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get words within a level.
     * @summary Get Level Words
     * @param levelId the id of the level to get words for
     * @param accountId the id of the logged in user
     */
    public async getWordsInLevel (levelId: number, accountId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: WordzWordResponse;  }> {
        const localVarPath = this.basePath + '/level/words/get';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'levelId' is not null or undefined
        if (levelId === null || levelId === undefined) {
            throw new Error('Required parameter levelId was null or undefined when calling getWordsInLevel.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getWordsInLevel.');
        }

        if (levelId !== undefined) {
            localVarQueryParameters['levelId'] = ObjectSerializer.serialize(levelId, "number");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: WordzWordResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "WordzWordResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update a game level. Currently does NOT support game objects.
     * @summary Update Game Level
     * @param accountId The logged in user.
     * @param levelId If update then include the level Id.
     * @param appKey The game application key to save the level for.
     * @param name The name of the level.
     * @param description The description of the level.
     * @param difficulty The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD.
     * @param appVersion The version number of the applicatuion required to correctly load/play the level.
     * @param assetImageId The asset Id of the level image.
     * @param assetIconId The asset Id of the level icon.
     * @param gameData The game level data: xml, json, or other texted based format.
     * @param gameDataSuffix The game level data format type.
     * @param visibility Is the level visible to others, possible values are: PUBLIC, PRIVATE.
     * @param friendGroup Make the level be readable by all friends.
     * @param connectionIds Make the level be readable by connections in this list.
     * @param connectionGroupIds Make the level be readable by connection groups in this list.
     * @param balance Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.
     * @param active If true set the game level as active.
     * @param allocateTickets If true then scoring will give tickets.
     * @param ticketCount The number of tickets to reward
     * @param ticketType The type of ticket to reward, null means default type
     * @param points The number of points to award for completing a level
     * @param tutorialTitle Title of the tutorial.
     * @param tutorialMessage Message of the tutorial.
     * @param tutorialAlignment Alignment of the tutorial image, possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY
     * @param tutorialImageAssetId Asset id of the tutorial image.
     * @param offerId 
     * @param metaData external custom client defined data
     */
    public async updateGameLevel (accountId: number, levelId: number, appKey?: string, name?: string, description?: string, difficulty?: string, appVersion?: string, assetImageId?: number, assetIconId?: number, gameData?: string, gameDataSuffix?: string, visibility?: string, friendGroup?: boolean, connectionIds?: string, connectionGroupIds?: string, balance?: number, active?: boolean, allocateTickets?: boolean, ticketCount?: number, ticketType?: string, points?: number, tutorialTitle?: string, tutorialMessage?: string, tutorialAlignment?: string, tutorialImageAssetId?: number, offerId?: number, metaData?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GameLevelResponse;  }> {
        const localVarPath = this.basePath + '/level/update';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateGameLevel.');
        }

        // verify required parameter 'levelId' is not null or undefined
        if (levelId === null || levelId === undefined) {
            throw new Error('Required parameter levelId was null or undefined when calling updateGameLevel.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (levelId !== undefined) {
            localVarQueryParameters['levelId'] = ObjectSerializer.serialize(levelId, "number");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (difficulty !== undefined) {
            localVarQueryParameters['difficulty'] = ObjectSerializer.serialize(difficulty, "string");
        }

        if (appVersion !== undefined) {
            localVarQueryParameters['appVersion'] = ObjectSerializer.serialize(appVersion, "string");
        }

        if (assetImageId !== undefined) {
            localVarQueryParameters['assetImageId'] = ObjectSerializer.serialize(assetImageId, "number");
        }

        if (assetIconId !== undefined) {
            localVarQueryParameters['assetIconId'] = ObjectSerializer.serialize(assetIconId, "number");
        }

        if (gameData !== undefined) {
            localVarQueryParameters['gameData'] = ObjectSerializer.serialize(gameData, "string");
        }

        if (gameDataSuffix !== undefined) {
            localVarQueryParameters['gameDataSuffix'] = ObjectSerializer.serialize(gameDataSuffix, "string");
        }

        if (visibility !== undefined) {
            localVarQueryParameters['visibility'] = ObjectSerializer.serialize(visibility, "string");
        }

        if (friendGroup !== undefined) {
            localVarQueryParameters['friendGroup'] = ObjectSerializer.serialize(friendGroup, "boolean");
        }

        if (connectionIds !== undefined) {
            localVarQueryParameters['connectionIds'] = ObjectSerializer.serialize(connectionIds, "string");
        }

        if (connectionGroupIds !== undefined) {
            localVarQueryParameters['connectionGroupIds'] = ObjectSerializer.serialize(connectionGroupIds, "string");
        }

        if (balance !== undefined) {
            localVarQueryParameters['balance'] = ObjectSerializer.serialize(balance, "number");
        }

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (allocateTickets !== undefined) {
            localVarQueryParameters['allocateTickets'] = ObjectSerializer.serialize(allocateTickets, "boolean");
        }

        if (ticketCount !== undefined) {
            localVarQueryParameters['ticketCount'] = ObjectSerializer.serialize(ticketCount, "number");
        }

        if (ticketType !== undefined) {
            localVarQueryParameters['ticketType'] = ObjectSerializer.serialize(ticketType, "string");
        }

        if (points !== undefined) {
            localVarQueryParameters['points'] = ObjectSerializer.serialize(points, "number");
        }

        if (tutorialTitle !== undefined) {
            localVarQueryParameters['tutorialTitle'] = ObjectSerializer.serialize(tutorialTitle, "string");
        }

        if (tutorialMessage !== undefined) {
            localVarQueryParameters['tutorialMessage'] = ObjectSerializer.serialize(tutorialMessage, "string");
        }

        if (tutorialAlignment !== undefined) {
            localVarQueryParameters['tutorialAlignment'] = ObjectSerializer.serialize(tutorialAlignment, "string");
        }

        if (tutorialImageAssetId !== undefined) {
            localVarQueryParameters['tutorialImageAssetId'] = ObjectSerializer.serialize(tutorialImageAssetId, "number");
        }

        if (offerId !== undefined) {
            localVarQueryParameters['offerId'] = ObjectSerializer.serialize(offerId, "number");
        }

        if (metaData !== undefined) {
            localVarQueryParameters['metaData'] = ObjectSerializer.serialize(metaData, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GameLevelResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GameLevelResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Updates a level with question game objects.
     * @summary Update Level Questions
     * @param levelId the id of the level to update questions on
     * @param accountId the id of the logged in user
     * @param questionIds the IDs of the questions to update
     */
    public async updateQuestionsInLevel (levelId: number, accountId: number, questionIds: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/level/questions/update';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'levelId' is not null or undefined
        if (levelId === null || levelId === undefined) {
            throw new Error('Required parameter levelId was null or undefined when calling updateQuestionsInLevel.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateQuestionsInLevel.');
        }

        // verify required parameter 'questionIds' is not null or undefined
        if (questionIds === null || questionIds === undefined) {
            throw new Error('Required parameter questionIds was null or undefined when calling updateQuestionsInLevel.');
        }

        if (levelId !== undefined) {
            localVarQueryParameters['levelId'] = ObjectSerializer.serialize(levelId, "number");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (questionIds !== undefined) {
            localVarQueryParameters['questionIds'] = ObjectSerializer.serialize(questionIds, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Updates a level with word game objects.
     * @summary Update Level Words
     * @param levelId the id of the level to update words for
     * @param accountId the id of the logged in user
     * @param wordIds the ids of the words to update for the level
     */
    public async updateWordsInLevel (levelId: number, accountId: number, wordIds: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/level/words/update';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'levelId' is not null or undefined
        if (levelId === null || levelId === undefined) {
            throw new Error('Required parameter levelId was null or undefined when calling updateWordsInLevel.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateWordsInLevel.');
        }

        // verify required parameter 'wordIds' is not null or undefined
        if (wordIds === null || wordIds === undefined) {
            throw new Error('Required parameter wordIds was null or undefined when calling updateWordsInLevel.');
        }

        if (levelId !== undefined) {
            localVarQueryParameters['levelId'] = ObjectSerializer.serialize(levelId, "number");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (wordIds !== undefined) {
            localVarQueryParameters['wordIds'] = ObjectSerializer.serialize(wordIds, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
