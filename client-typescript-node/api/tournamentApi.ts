/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET[\'appKey\']);$b = htmlspecialchars($_GET[\'appRestKey\']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { MissionShortResponse } from '../model/missionShortResponse';
import { SirqulResponse } from '../model/sirqulResponse';
import { TournamentResponse } from '../model/tournamentResponse';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://dev.sirqul.com/api/3.18';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum TournamentApiApiKeys {
    appKey,
    restKey,
}

export class TournamentApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'appKey': new ApiKeyAuth('header', 'Application-Key'),
        'restKey': new ApiKeyAuth('header', 'Application-Rest-Key'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: TournamentApiApiKeys, value: string) {
        (this.authentications as any)[TournamentApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Create a tournament.
     * @summary Create Tournament
     * @param accountId The logged in user.
     * @param appKey The appKey the tournament is created for.
     * @param title The title of the tournament
     * @param costToPlay The number of tickets required to pay to enter the tournament
     * @param startDate The date/time to start the tournament
     * @param subType Custom string client apps can use for searching/filtering tournaments
     * @param imageAssetId The asset ID to attach to the tournament
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game/group
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
     * @param costToPlayType The type of ticket required to pay
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played
     * @param startingLimit The starting number of players for a tournament (filled with AI\&#39;s)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced)
     * @param description The description of the tournament
     * @param metaData External custom client defined data
     * @param audienceIds The audiences associated with the tournament
     * @param active Activate/deactivate the tournament
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament
     * @param offerIds The list of offers to give as a reward beyond the tickets
     * @param offerAssetId The artwork ID to attach to the reward tickets offers
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content
     * @param missionType The style of tournament to build, options are: TOURNAMENT, POOLPLAY
     * @param visibility Sets the visibility flag for the tournament
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not
     * @param winnerTag This sets what analytic tag is used when a winner is determined
     * @param tieTag This sets what analytic tag is used when a tie has occurred
     */
    public async createTournament (accountId: number, appKey: string, title: string, costToPlay: number, startDate: number, subType?: string, imageAssetId?: number, secondsBetweenLevels?: number, secondsForTieBreaker?: number, secondsBetweenPacks?: number, maximumLevelLength?: number, costToPlayType?: string, minimumToPlay?: number, startingLimit?: number, availableLimit?: number, description?: string, metaData?: string, audienceIds?: string, active?: boolean, enableBuyBack?: boolean, offerIds?: string, offerAssetId?: number, fixedReward?: boolean, splitReward?: 'EVEN' | 'ALL' | 'FIRST' | 'RANDOM', allocateTickets?: boolean, tournamentData?: string, missionType?: 'TOURNAMENT' | 'POOLPLAY' | 'MULTISTAGE', visibility?: 'PUBLIC' | 'LISTABLE' | 'REWARDABLE' | 'TRIGGERABLE' | 'PRIVATE', preliminaryGroups?: number, preliminaryGroupAdvancements?: string, enableMultipleEntries?: boolean, enableMultipleVotes?: boolean, featured?: boolean, winnerTag?: string, tieTag?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TournamentResponse;  }> {
        const localVarPath = this.basePath + '/tournament/create';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createTournament.');
        }

        // verify required parameter 'appKey' is not null or undefined
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling createTournament.');
        }

        // verify required parameter 'title' is not null or undefined
        if (title === null || title === undefined) {
            throw new Error('Required parameter title was null or undefined when calling createTournament.');
        }

        // verify required parameter 'costToPlay' is not null or undefined
        if (costToPlay === null || costToPlay === undefined) {
            throw new Error('Required parameter costToPlay was null or undefined when calling createTournament.');
        }

        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling createTournament.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (title !== undefined) {
            localVarQueryParameters['title'] = ObjectSerializer.serialize(title, "string");
        }

        if (subType !== undefined) {
            localVarQueryParameters['subType'] = ObjectSerializer.serialize(subType, "string");
        }

        if (imageAssetId !== undefined) {
            localVarQueryParameters['imageAssetId'] = ObjectSerializer.serialize(imageAssetId, "number");
        }

        if (secondsBetweenLevels !== undefined) {
            localVarQueryParameters['secondsBetweenLevels'] = ObjectSerializer.serialize(secondsBetweenLevels, "number");
        }

        if (secondsForTieBreaker !== undefined) {
            localVarQueryParameters['secondsForTieBreaker'] = ObjectSerializer.serialize(secondsForTieBreaker, "number");
        }

        if (secondsBetweenPacks !== undefined) {
            localVarQueryParameters['secondsBetweenPacks'] = ObjectSerializer.serialize(secondsBetweenPacks, "number");
        }

        if (maximumLevelLength !== undefined) {
            localVarQueryParameters['maximumLevelLength'] = ObjectSerializer.serialize(maximumLevelLength, "number");
        }

        if (costToPlay !== undefined) {
            localVarQueryParameters['costToPlay'] = ObjectSerializer.serialize(costToPlay, "number");
        }

        if (costToPlayType !== undefined) {
            localVarQueryParameters['costToPlayType'] = ObjectSerializer.serialize(costToPlayType, "string");
        }

        if (minimumToPlay !== undefined) {
            localVarQueryParameters['minimumToPlay'] = ObjectSerializer.serialize(minimumToPlay, "number");
        }

        if (startingLimit !== undefined) {
            localVarQueryParameters['startingLimit'] = ObjectSerializer.serialize(startingLimit, "number");
        }

        if (availableLimit !== undefined) {
            localVarQueryParameters['availableLimit'] = ObjectSerializer.serialize(availableLimit, "number");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (metaData !== undefined) {
            localVarQueryParameters['metaData'] = ObjectSerializer.serialize(metaData, "string");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (audienceIds !== undefined) {
            localVarQueryParameters['audienceIds'] = ObjectSerializer.serialize(audienceIds, "string");
        }

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (enableBuyBack !== undefined) {
            localVarQueryParameters['enableBuyBack'] = ObjectSerializer.serialize(enableBuyBack, "boolean");
        }

        if (offerIds !== undefined) {
            localVarQueryParameters['offerIds'] = ObjectSerializer.serialize(offerIds, "string");
        }

        if (offerAssetId !== undefined) {
            localVarQueryParameters['offerAssetId'] = ObjectSerializer.serialize(offerAssetId, "number");
        }

        if (fixedReward !== undefined) {
            localVarQueryParameters['fixedReward'] = ObjectSerializer.serialize(fixedReward, "boolean");
        }

        if (splitReward !== undefined) {
            localVarQueryParameters['splitReward'] = ObjectSerializer.serialize(splitReward, "'EVEN' | 'ALL' | 'FIRST' | 'RANDOM'");
        }

        if (allocateTickets !== undefined) {
            localVarQueryParameters['allocateTickets'] = ObjectSerializer.serialize(allocateTickets, "boolean");
        }

        if (tournamentData !== undefined) {
            localVarQueryParameters['tournamentData'] = ObjectSerializer.serialize(tournamentData, "string");
        }

        if (missionType !== undefined) {
            localVarQueryParameters['missionType'] = ObjectSerializer.serialize(missionType, "'TOURNAMENT' | 'POOLPLAY' | 'MULTISTAGE'");
        }

        if (visibility !== undefined) {
            localVarQueryParameters['visibility'] = ObjectSerializer.serialize(visibility, "'PUBLIC' | 'LISTABLE' | 'REWARDABLE' | 'TRIGGERABLE' | 'PRIVATE'");
        }

        if (preliminaryGroups !== undefined) {
            localVarQueryParameters['preliminaryGroups'] = ObjectSerializer.serialize(preliminaryGroups, "number");
        }

        if (preliminaryGroupAdvancements !== undefined) {
            localVarQueryParameters['preliminaryGroupAdvancements'] = ObjectSerializer.serialize(preliminaryGroupAdvancements, "string");
        }

        if (enableMultipleEntries !== undefined) {
            localVarQueryParameters['enableMultipleEntries'] = ObjectSerializer.serialize(enableMultipleEntries, "boolean");
        }

        if (enableMultipleVotes !== undefined) {
            localVarQueryParameters['enableMultipleVotes'] = ObjectSerializer.serialize(enableMultipleVotes, "boolean");
        }

        if (featured !== undefined) {
            localVarQueryParameters['featured'] = ObjectSerializer.serialize(featured, "boolean");
        }

        if (winnerTag !== undefined) {
            localVarQueryParameters['winnerTag'] = ObjectSerializer.serialize(winnerTag, "string");
        }

        if (tieTag !== undefined) {
            localVarQueryParameters['tieTag'] = ObjectSerializer.serialize(tieTag, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TournamentResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TournamentResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Delete a tournament.
     * @summary Delete Tournament
     * @param accountId the id of the logged in user
     * @param missionId the id of the mission to delete
     */
    public async deleteTournament (accountId: number, missionId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/tournament/delete';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteTournament.');
        }

        // verify required parameter 'missionId' is not null or undefined
        if (missionId === null || missionId === undefined) {
            throw new Error('Required parameter missionId was null or undefined when calling deleteTournament.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (missionId !== undefined) {
            localVarQueryParameters['missionId'] = ObjectSerializer.serialize(missionId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a tournament.
     * @summary Get Tournament
     * @param accountId The id of the logged in user
     * @param missionId The id of the mission to return (either missionId or joinCode is required)
     * @param joinCode Optional identifier for getting the tournament (either missionId or joinCode is required)
     * @param includeScores Determines which type of scores are returned. Possible values include: ALL, MINE
     * @param objectPreviewSize Determines the max number of game objects that will get returned for each game level response
     */
    public async getTournament (accountId: number, missionId?: number, joinCode?: string, includeScores?: 'ALL' | 'MINE', objectPreviewSize?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TournamentResponse;  }> {
        const localVarPath = this.basePath + '/tournament/get';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getTournament.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (missionId !== undefined) {
            localVarQueryParameters['missionId'] = ObjectSerializer.serialize(missionId, "number");
        }

        if (joinCode !== undefined) {
            localVarQueryParameters['joinCode'] = ObjectSerializer.serialize(joinCode, "string");
        }

        if (includeScores !== undefined) {
            localVarQueryParameters['includeScores'] = ObjectSerializer.serialize(includeScores, "'ALL' | 'MINE'");
        }

        if (objectPreviewSize !== undefined) {
            localVarQueryParameters['objectPreviewSize'] = ObjectSerializer.serialize(objectPreviewSize, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TournamentResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TournamentResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Search on game objects of tournaments
     * @summary Search Tournament Objects
     * @param accountId the account ID
     * @param gameLevelId the game level id to filter results by
     * @param sortField the field to sort by
     * @param descending determines whether the sorted list is in descending or ascending order
     * @param start the start index for pagination
     * @param limit the limit for pagination
     */
    public async searchObjects (accountId: number, gameLevelId: number, sortField?: 'ID' | 'PLAYER_SCORE_COUNT', descending?: boolean, start?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/tournament/object/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling searchObjects.');
        }

        // verify required parameter 'gameLevelId' is not null or undefined
        if (gameLevelId === null || gameLevelId === undefined) {
            throw new Error('Required parameter gameLevelId was null or undefined when calling searchObjects.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (gameLevelId !== undefined) {
            localVarQueryParameters['gameLevelId'] = ObjectSerializer.serialize(gameLevelId, "number");
        }

        if (sortField !== undefined) {
            localVarQueryParameters['sortField'] = ObjectSerializer.serialize(sortField, "'ID' | 'PLAYER_SCORE_COUNT'");
        }

        if (descending !== undefined) {
            localVarQueryParameters['descending'] = ObjectSerializer.serialize(descending, "boolean");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Search for the user\'s tournament games.
     * @summary Search Tournament Rounds
     * @param accountId the account ID
     * @param appKey the application key
     * @param status comma separated list of statuses to filter results by
     * @param missionType The style of tournament to search for, options are: TOURNAMENT, POOLPLAY
     * @param currentOnly search for games that are flagged current only
     * @param visibilities Filter tournament rounds by the mission visibility flag
     * @param start the start index for pagination
     * @param limit the limit for pagination
     */
    public async searchRounds (accountId: number, appKey: string, status?: string, missionType?: 'TOURNAMENT' | 'POOLPLAY', currentOnly?: boolean, visibilities?: string, start?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/tournament/round/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling searchRounds.');
        }

        // verify required parameter 'appKey' is not null or undefined
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling searchRounds.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }

        if (missionType !== undefined) {
            localVarQueryParameters['missionType'] = ObjectSerializer.serialize(missionType, "'TOURNAMENT' | 'POOLPLAY'");
        }

        if (currentOnly !== undefined) {
            localVarQueryParameters['currentOnly'] = ObjectSerializer.serialize(currentOnly, "boolean");
        }

        if (visibilities !== undefined) {
            localVarQueryParameters['visibilities'] = ObjectSerializer.serialize(visibilities, "string");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Search for tournaments
     * @summary Search Tournaments
     * @param accountId The logged in user.
     * @param appKey The application key
     * @param keyword the keyword to search tournament on
     * @param subType filter results by subType
     * @param includeInactive whether to include inactives in the search or not
     * @param missionTypes comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE
     * @param filter filter tournaments by the tournament\&#39;s current state
     * @param sortField which field to sort on
     * @param descending Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false.
     * @param visibility Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE
     * @param start Start the result set at some index.
     * @param limit Limit the result to some number
     */
    public async searchTournaments (accountId: number, appKey: string, keyword?: string, subType?: string, includeInactive?: boolean, missionTypes?: string, filter?: 'ALL' | 'UPCOMING' | 'PAST' | 'PRESENT' | 'ACTIVE', sortField?: 'ACTIVE' | 'TITLE' | 'DESCRIPTION' | 'CREATED' | 'UPDATED' | 'MISSION_TYPE' | 'OWNER_DISPLAY' | 'START_DATE' | 'END_DATE' | 'STARTING_LIMIT' | 'AVAILABLE_LIMIT' | 'INVITE_COUNT' | 'ACCEPTED_COUNT', descending?: boolean, visibility?: string, start?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: MissionShortResponse;  }> {
        const localVarPath = this.basePath + '/tournament/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling searchTournaments.');
        }

        // verify required parameter 'appKey' is not null or undefined
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling searchTournaments.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (keyword !== undefined) {
            localVarQueryParameters['keyword'] = ObjectSerializer.serialize(keyword, "string");
        }

        if (subType !== undefined) {
            localVarQueryParameters['subType'] = ObjectSerializer.serialize(subType, "string");
        }

        if (includeInactive !== undefined) {
            localVarQueryParameters['includeInactive'] = ObjectSerializer.serialize(includeInactive, "boolean");
        }

        if (missionTypes !== undefined) {
            localVarQueryParameters['missionTypes'] = ObjectSerializer.serialize(missionTypes, "string");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "'ALL' | 'UPCOMING' | 'PAST' | 'PRESENT' | 'ACTIVE'");
        }

        if (sortField !== undefined) {
            localVarQueryParameters['sortField'] = ObjectSerializer.serialize(sortField, "'ACTIVE' | 'TITLE' | 'DESCRIPTION' | 'CREATED' | 'UPDATED' | 'MISSION_TYPE' | 'OWNER_DISPLAY' | 'START_DATE' | 'END_DATE' | 'STARTING_LIMIT' | 'AVAILABLE_LIMIT' | 'INVITE_COUNT' | 'ACCEPTED_COUNT'");
        }

        if (descending !== undefined) {
            localVarQueryParameters['descending'] = ObjectSerializer.serialize(descending, "boolean");
        }

        if (visibility !== undefined) {
            localVarQueryParameters['visibility'] = ObjectSerializer.serialize(visibility, "string");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: MissionShortResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "MissionShortResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Submit an array of scores for a tournament match. 
     * @summary Submit Tournament Score
     * @param accountId The logged in user account ID.
     * @param appKey The application key.
     * @param missionId The missionId to score for
     * @param gameId The gameId to score for
     * @param packId The packId to score for
     * @param scores a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60; 
     * @param gameLevelId The gameLevelId to score for
     */
    public async submitTournamentScore (accountId: number, appKey: string, missionId: number, gameId: number, packId: number, scores: string, gameLevelId?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/tournament/score';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling submitTournamentScore.');
        }

        // verify required parameter 'appKey' is not null or undefined
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling submitTournamentScore.');
        }

        // verify required parameter 'missionId' is not null or undefined
        if (missionId === null || missionId === undefined) {
            throw new Error('Required parameter missionId was null or undefined when calling submitTournamentScore.');
        }

        // verify required parameter 'gameId' is not null or undefined
        if (gameId === null || gameId === undefined) {
            throw new Error('Required parameter gameId was null or undefined when calling submitTournamentScore.');
        }

        // verify required parameter 'packId' is not null or undefined
        if (packId === null || packId === undefined) {
            throw new Error('Required parameter packId was null or undefined when calling submitTournamentScore.');
        }

        // verify required parameter 'scores' is not null or undefined
        if (scores === null || scores === undefined) {
            throw new Error('Required parameter scores was null or undefined when calling submitTournamentScore.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (missionId !== undefined) {
            localVarQueryParameters['missionId'] = ObjectSerializer.serialize(missionId, "number");
        }

        if (gameId !== undefined) {
            localVarQueryParameters['gameId'] = ObjectSerializer.serialize(gameId, "number");
        }

        if (packId !== undefined) {
            localVarQueryParameters['packId'] = ObjectSerializer.serialize(packId, "number");
        }

        if (gameLevelId !== undefined) {
            localVarQueryParameters['gameLevelId'] = ObjectSerializer.serialize(gameLevelId, "number");
        }

        if (scores !== undefined) {
            localVarQueryParameters['scores'] = ObjectSerializer.serialize(scores, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Submit a vote for a multi-stage album tournament.
     * @summary Submit a vote for a multi-stage album tournament.
     * @param accountId The logged in user.
     * @param appKey The application to target
     * @param missionId The tournament\&#39;s primary id
     * @param gameObjectId The tournament game object the user wants to vote on
     * @param deviceId The unique id of the device making the request (optional)
     * @param checkIfDeviceAlreadyVoted When true, check if the device already voted to prevent duplicate votes from the same device
     */
    public async submitTournamentVote (accountId: number, appKey: string, missionId: number, gameObjectId: number, deviceId?: string, checkIfDeviceAlreadyVoted?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/tournament/vote';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling submitTournamentVote.');
        }

        // verify required parameter 'appKey' is not null or undefined
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling submitTournamentVote.');
        }

        // verify required parameter 'missionId' is not null or undefined
        if (missionId === null || missionId === undefined) {
            throw new Error('Required parameter missionId was null or undefined when calling submitTournamentVote.');
        }

        // verify required parameter 'gameObjectId' is not null or undefined
        if (gameObjectId === null || gameObjectId === undefined) {
            throw new Error('Required parameter gameObjectId was null or undefined when calling submitTournamentVote.');
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (appKey !== undefined) {
            localVarQueryParameters['appKey'] = ObjectSerializer.serialize(appKey, "string");
        }

        if (missionId !== undefined) {
            localVarQueryParameters['missionId'] = ObjectSerializer.serialize(missionId, "number");
        }

        if (gameObjectId !== undefined) {
            localVarQueryParameters['gameObjectId'] = ObjectSerializer.serialize(gameObjectId, "number");
        }

        if (checkIfDeviceAlreadyVoted !== undefined) {
            localVarQueryParameters['checkIfDeviceAlreadyVoted'] = ObjectSerializer.serialize(checkIfDeviceAlreadyVoted, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Service to replace the user\'s opponent in the current level - pack - mission with an AI account.
     * @summary Substitute Tournament Player
     * @param accountId the id of the logged in user
     * @param missionId the id of the mission
     * @param packId the id of the pack
     * @param gameLevelId the id of the game level
     */
    public async substituteTournamentPlayer (accountId: number, missionId: number, packId: number, gameLevelId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }> {
        const localVarPath = this.basePath + '/tournament/substitute';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling substituteTournamentPlayer.');
        }

        // verify required parameter 'missionId' is not null or undefined
        if (missionId === null || missionId === undefined) {
            throw new Error('Required parameter missionId was null or undefined when calling substituteTournamentPlayer.');
        }

        // verify required parameter 'packId' is not null or undefined
        if (packId === null || packId === undefined) {
            throw new Error('Required parameter packId was null or undefined when calling substituteTournamentPlayer.');
        }

        // verify required parameter 'gameLevelId' is not null or undefined
        if (gameLevelId === null || gameLevelId === undefined) {
            throw new Error('Required parameter gameLevelId was null or undefined when calling substituteTournamentPlayer.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (missionId !== undefined) {
            localVarQueryParameters['missionId'] = ObjectSerializer.serialize(missionId, "number");
        }

        if (packId !== undefined) {
            localVarQueryParameters['packId'] = ObjectSerializer.serialize(packId, "number");
        }

        if (gameLevelId !== undefined) {
            localVarQueryParameters['gameLevelId'] = ObjectSerializer.serialize(gameLevelId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SirqulResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SirqulResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update a tournament.
     * @summary Update Tournament
     * @param accountId The logged in user.
     * @param missionId The mission/tournament to update
     * @param title The title of the tournament
     * @param subType Custom string client apps can use for searching/filtering missions
     * @param imageAssetId The asset ID to attach to the tournament
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
     * @param costToPlay The number of tickets required to pay to enter the tournament
     * @param costToPlayType The type of ticket required to pay
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played
     * @param startingLimit The starting number of players for a tournament (filled with AI\&#39;s)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced)
     * @param description The description of the tournament
     * @param metaData External custom client defined data
     * @param startDate The date/time to start the tournament
     * @param audienceIds The audiences associated with the tournament
     * @param active Activate/deactivate the mission
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament
     * @param offerIds The list of offers to give as a reward beyond the tickets
     * @param offerAssetId The artwork ID to attach to the reward offer
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content
     * @param visibility Sets the visibility flag for the tournament
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not
     * @param winnerTag This sets what analytic tag is used when a winner is determined
     * @param tieTag This sets what analytic tag is used when a winner is determined
     */
    public async updateTournament (accountId: number, missionId: number, title?: string, subType?: string, imageAssetId?: number, secondsBetweenLevels?: number, secondsForTieBreaker?: number, secondsBetweenPacks?: number, maximumLevelLength?: number, costToPlay?: number, costToPlayType?: string, minimumToPlay?: number, startingLimit?: number, availableLimit?: number, description?: string, metaData?: string, startDate?: number, audienceIds?: string, active?: boolean, enableBuyBack?: boolean, offerIds?: string, offerAssetId?: number, fixedReward?: boolean, splitReward?: 'EVEN' | 'ALL' | 'FIRST' | 'RANDOM', allocateTickets?: boolean, tournamentData?: string, visibility?: 'PUBLIC' | 'LISTABLE' | 'REWARDABLE' | 'TRIGGERABLE' | 'PRIVATE', preliminaryGroups?: number, preliminaryGroupAdvancements?: string, enableMultipleEntries?: boolean, enableMultipleVotes?: boolean, featured?: boolean, winnerTag?: string, tieTag?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TournamentResponse;  }> {
        const localVarPath = this.basePath + '/tournament/update';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['*/*'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateTournament.');
        }

        // verify required parameter 'missionId' is not null or undefined
        if (missionId === null || missionId === undefined) {
            throw new Error('Required parameter missionId was null or undefined when calling updateTournament.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['accountId'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (missionId !== undefined) {
            localVarQueryParameters['missionId'] = ObjectSerializer.serialize(missionId, "number");
        }

        if (title !== undefined) {
            localVarQueryParameters['title'] = ObjectSerializer.serialize(title, "string");
        }

        if (subType !== undefined) {
            localVarQueryParameters['subType'] = ObjectSerializer.serialize(subType, "string");
        }

        if (imageAssetId !== undefined) {
            localVarQueryParameters['imageAssetId'] = ObjectSerializer.serialize(imageAssetId, "number");
        }

        if (secondsBetweenLevels !== undefined) {
            localVarQueryParameters['secondsBetweenLevels'] = ObjectSerializer.serialize(secondsBetweenLevels, "number");
        }

        if (secondsForTieBreaker !== undefined) {
            localVarQueryParameters['secondsForTieBreaker'] = ObjectSerializer.serialize(secondsForTieBreaker, "number");
        }

        if (secondsBetweenPacks !== undefined) {
            localVarQueryParameters['secondsBetweenPacks'] = ObjectSerializer.serialize(secondsBetweenPacks, "number");
        }

        if (maximumLevelLength !== undefined) {
            localVarQueryParameters['maximumLevelLength'] = ObjectSerializer.serialize(maximumLevelLength, "number");
        }

        if (costToPlay !== undefined) {
            localVarQueryParameters['costToPlay'] = ObjectSerializer.serialize(costToPlay, "number");
        }

        if (costToPlayType !== undefined) {
            localVarQueryParameters['costToPlayType'] = ObjectSerializer.serialize(costToPlayType, "string");
        }

        if (minimumToPlay !== undefined) {
            localVarQueryParameters['minimumToPlay'] = ObjectSerializer.serialize(minimumToPlay, "number");
        }

        if (startingLimit !== undefined) {
            localVarQueryParameters['startingLimit'] = ObjectSerializer.serialize(startingLimit, "number");
        }

        if (availableLimit !== undefined) {
            localVarQueryParameters['availableLimit'] = ObjectSerializer.serialize(availableLimit, "number");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (metaData !== undefined) {
            localVarQueryParameters['metaData'] = ObjectSerializer.serialize(metaData, "string");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (audienceIds !== undefined) {
            localVarQueryParameters['audienceIds'] = ObjectSerializer.serialize(audienceIds, "string");
        }

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (enableBuyBack !== undefined) {
            localVarQueryParameters['enableBuyBack'] = ObjectSerializer.serialize(enableBuyBack, "boolean");
        }

        if (offerIds !== undefined) {
            localVarQueryParameters['offerIds'] = ObjectSerializer.serialize(offerIds, "string");
        }

        if (offerAssetId !== undefined) {
            localVarQueryParameters['offerAssetId'] = ObjectSerializer.serialize(offerAssetId, "number");
        }

        if (fixedReward !== undefined) {
            localVarQueryParameters['fixedReward'] = ObjectSerializer.serialize(fixedReward, "boolean");
        }

        if (splitReward !== undefined) {
            localVarQueryParameters['splitReward'] = ObjectSerializer.serialize(splitReward, "'EVEN' | 'ALL' | 'FIRST' | 'RANDOM'");
        }

        if (allocateTickets !== undefined) {
            localVarQueryParameters['allocateTickets'] = ObjectSerializer.serialize(allocateTickets, "boolean");
        }

        if (tournamentData !== undefined) {
            localVarQueryParameters['tournamentData'] = ObjectSerializer.serialize(tournamentData, "string");
        }

        if (visibility !== undefined) {
            localVarQueryParameters['visibility'] = ObjectSerializer.serialize(visibility, "'PUBLIC' | 'LISTABLE' | 'REWARDABLE' | 'TRIGGERABLE' | 'PRIVATE'");
        }

        if (preliminaryGroups !== undefined) {
            localVarQueryParameters['preliminaryGroups'] = ObjectSerializer.serialize(preliminaryGroups, "number");
        }

        if (preliminaryGroupAdvancements !== undefined) {
            localVarQueryParameters['preliminaryGroupAdvancements'] = ObjectSerializer.serialize(preliminaryGroupAdvancements, "string");
        }

        if (enableMultipleEntries !== undefined) {
            localVarQueryParameters['enableMultipleEntries'] = ObjectSerializer.serialize(enableMultipleEntries, "boolean");
        }

        if (enableMultipleVotes !== undefined) {
            localVarQueryParameters['enableMultipleVotes'] = ObjectSerializer.serialize(enableMultipleVotes, "boolean");
        }

        if (featured !== undefined) {
            localVarQueryParameters['featured'] = ObjectSerializer.serialize(featured, "boolean");
        }

        if (winnerTag !== undefined) {
            localVarQueryParameters['winnerTag'] = ObjectSerializer.serialize(winnerTag, "string");
        }

        if (tieTag !== undefined) {
            localVarQueryParameters['tieTag'] = ObjectSerializer.serialize(tieTag, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TournamentResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TournamentResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
