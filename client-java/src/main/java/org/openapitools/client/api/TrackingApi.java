/*
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.AccountMiniResponse;
import org.openapitools.client.model.Leg;
import org.openapitools.client.model.LegResponse;
import org.openapitools.client.model.PredictedLocationResponse;
import org.openapitools.client.model.PreferredLocationResponse;
import org.openapitools.client.model.SirqulResponse;
import org.openapitools.client.model.StepResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class TrackingApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public TrackingApi() {
        this(Configuration.getDefaultApiClient());
    }

    public TrackingApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for batchSaveTracking
     * @param data JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60;  (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param generateAccounts Whether to generate accounts for tracking entries when the owner does not exist (optional)
     * @param updateAccountLocations Whether to update the account&#39;s current location from the incoming tracking data (optional)
     * @param defaultTag The default tag to apply to incoming legs when no tag is provided (optional, default to PASSIVE)
     * @param slaveUID  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call batchSaveTrackingCall(@javax.annotation.Nonnull String data, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Boolean generateAccounts, @javax.annotation.Nullable Boolean updateAccountLocations, @javax.annotation.Nullable String defaultTag, @javax.annotation.Nullable String slaveUID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tracking/batch/create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceId", deviceId));
        }

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (data != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("data", data));
        }

        if (generateAccounts != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("generateAccounts", generateAccounts));
        }

        if (updateAccountLocations != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("updateAccountLocations", updateAccountLocations));
        }

        if (defaultTag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("defaultTag", defaultTag));
        }

        if (slaveUID != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("slaveUID", slaveUID));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call batchSaveTrackingValidateBeforeCall(@javax.annotation.Nonnull String data, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Boolean generateAccounts, @javax.annotation.Nullable Boolean updateAccountLocations, @javax.annotation.Nullable String defaultTag, @javax.annotation.Nullable String slaveUID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'data' is set
        if (data == null) {
            throw new ApiException("Missing the required parameter 'data' when calling batchSaveTracking(Async)");
        }

        return batchSaveTrackingCall(data, deviceId, accountId, generateAccounts, updateAccountLocations, defaultTag, slaveUID, _callback);

    }

    /**
     * Create Batch Tracking
     * Batch create tracking legs
     * @param data JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60;  (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param generateAccounts Whether to generate accounts for tracking entries when the owner does not exist (optional)
     * @param updateAccountLocations Whether to update the account&#39;s current location from the incoming tracking data (optional)
     * @param defaultTag The default tag to apply to incoming legs when no tag is provided (optional, default to PASSIVE)
     * @param slaveUID  (optional)
     * @return List&lt;Leg&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public List<Leg> batchSaveTracking(@javax.annotation.Nonnull String data, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Boolean generateAccounts, @javax.annotation.Nullable Boolean updateAccountLocations, @javax.annotation.Nullable String defaultTag, @javax.annotation.Nullable String slaveUID) throws ApiException {
        ApiResponse<List<Leg>> localVarResp = batchSaveTrackingWithHttpInfo(data, deviceId, accountId, generateAccounts, updateAccountLocations, defaultTag, slaveUID);
        return localVarResp.getData();
    }

    /**
     * Create Batch Tracking
     * Batch create tracking legs
     * @param data JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60;  (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param generateAccounts Whether to generate accounts for tracking entries when the owner does not exist (optional)
     * @param updateAccountLocations Whether to update the account&#39;s current location from the incoming tracking data (optional)
     * @param defaultTag The default tag to apply to incoming legs when no tag is provided (optional, default to PASSIVE)
     * @param slaveUID  (optional)
     * @return ApiResponse&lt;List&lt;Leg&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Leg>> batchSaveTrackingWithHttpInfo(@javax.annotation.Nonnull String data, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Boolean generateAccounts, @javax.annotation.Nullable Boolean updateAccountLocations, @javax.annotation.Nullable String defaultTag, @javax.annotation.Nullable String slaveUID) throws ApiException {
        okhttp3.Call localVarCall = batchSaveTrackingValidateBeforeCall(data, deviceId, accountId, generateAccounts, updateAccountLocations, defaultTag, slaveUID, null);
        Type localVarReturnType = new TypeToken<List<Leg>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Batch Tracking (asynchronously)
     * Batch create tracking legs
     * @param data JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60;  (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param generateAccounts Whether to generate accounts for tracking entries when the owner does not exist (optional)
     * @param updateAccountLocations Whether to update the account&#39;s current location from the incoming tracking data (optional)
     * @param defaultTag The default tag to apply to incoming legs when no tag is provided (optional, default to PASSIVE)
     * @param slaveUID  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call batchSaveTrackingAsync(@javax.annotation.Nonnull String data, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Boolean generateAccounts, @javax.annotation.Nullable Boolean updateAccountLocations, @javax.annotation.Nullable String defaultTag, @javax.annotation.Nullable String slaveUID, final ApiCallback<List<Leg>> _callback) throws ApiException {

        okhttp3.Call localVarCall = batchSaveTrackingValidateBeforeCall(data, deviceId, accountId, generateAccounts, updateAccountLocations, defaultTag, slaveUID, _callback);
        Type localVarReturnType = new TypeToken<List<Leg>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPredictedLocations
     * @param accountId The account id of the customer (required)
     * @param latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param dateCheck Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)
     * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param threshold The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1)
     * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to MILES)
     * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param sortOrder The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to MATCHES)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPredictedLocationsCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable Double latitude, @javax.annotation.Nullable Double longitude, @javax.annotation.Nullable Long dateCheck, @javax.annotation.Nullable String hourCheck, @javax.annotation.Nullable Long threshold, @javax.annotation.Nullable String distanceUnit, @javax.annotation.Nullable Double searchRange, @javax.annotation.Nullable String sortOrder, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tracking/predicted/get";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (latitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latitude", latitude));
        }

        if (longitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("longitude", longitude));
        }

        if (dateCheck != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("dateCheck", dateCheck));
        }

        if (hourCheck != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hourCheck", hourCheck));
        }

        if (threshold != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("threshold", threshold));
        }

        if (distanceUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("distanceUnit", distanceUnit));
        }

        if (searchRange != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("searchRange", searchRange));
        }

        if (sortOrder != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sortOrder", sortOrder));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPredictedLocationsValidateBeforeCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable Double latitude, @javax.annotation.Nullable Double longitude, @javax.annotation.Nullable Long dateCheck, @javax.annotation.Nullable String hourCheck, @javax.annotation.Nullable Long threshold, @javax.annotation.Nullable String distanceUnit, @javax.annotation.Nullable Double searchRange, @javax.annotation.Nullable String sortOrder, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling getPredictedLocations(Async)");
        }

        return getPredictedLocationsCall(accountId, latitude, longitude, dateCheck, hourCheck, threshold, distanceUnit, searchRange, sortOrder, _callback);

    }

    /**
     * Get Predicted Locations
     * Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.
     * @param accountId The account id of the customer (required)
     * @param latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param dateCheck Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)
     * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param threshold The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1)
     * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to MILES)
     * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param sortOrder The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to MATCHES)
     * @return PredictedLocationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public PredictedLocationResponse getPredictedLocations(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable Double latitude, @javax.annotation.Nullable Double longitude, @javax.annotation.Nullable Long dateCheck, @javax.annotation.Nullable String hourCheck, @javax.annotation.Nullable Long threshold, @javax.annotation.Nullable String distanceUnit, @javax.annotation.Nullable Double searchRange, @javax.annotation.Nullable String sortOrder) throws ApiException {
        ApiResponse<PredictedLocationResponse> localVarResp = getPredictedLocationsWithHttpInfo(accountId, latitude, longitude, dateCheck, hourCheck, threshold, distanceUnit, searchRange, sortOrder);
        return localVarResp.getData();
    }

    /**
     * Get Predicted Locations
     * Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.
     * @param accountId The account id of the customer (required)
     * @param latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param dateCheck Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)
     * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param threshold The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1)
     * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to MILES)
     * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param sortOrder The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to MATCHES)
     * @return ApiResponse&lt;PredictedLocationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PredictedLocationResponse> getPredictedLocationsWithHttpInfo(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable Double latitude, @javax.annotation.Nullable Double longitude, @javax.annotation.Nullable Long dateCheck, @javax.annotation.Nullable String hourCheck, @javax.annotation.Nullable Long threshold, @javax.annotation.Nullable String distanceUnit, @javax.annotation.Nullable Double searchRange, @javax.annotation.Nullable String sortOrder) throws ApiException {
        okhttp3.Call localVarCall = getPredictedLocationsValidateBeforeCall(accountId, latitude, longitude, dateCheck, hourCheck, threshold, distanceUnit, searchRange, sortOrder, null);
        Type localVarReturnType = new TypeToken<PredictedLocationResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Predicted Locations (asynchronously)
     * Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.
     * @param accountId The account id of the customer (required)
     * @param latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param dateCheck Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)
     * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param threshold The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1)
     * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to MILES)
     * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param sortOrder The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to MATCHES)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPredictedLocationsAsync(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable Double latitude, @javax.annotation.Nullable Double longitude, @javax.annotation.Nullable Long dateCheck, @javax.annotation.Nullable String hourCheck, @javax.annotation.Nullable Long threshold, @javax.annotation.Nullable String distanceUnit, @javax.annotation.Nullable Double searchRange, @javax.annotation.Nullable String sortOrder, final ApiCallback<PredictedLocationResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPredictedLocationsValidateBeforeCall(accountId, latitude, longitude, dateCheck, hourCheck, threshold, distanceUnit, searchRange, sortOrder, _callback);
        Type localVarReturnType = new TypeToken<PredictedLocationResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPredictedPath
     * @param accountId The account id of the customer (required)
     * @param startStepId The stepId to begin from (required)
     * @param endStepId The stepId to end with (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPredictedPathCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long startStepId, @javax.annotation.Nonnull Long endStepId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tracking/path/get";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (startStepId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startStepId", startStepId));
        }

        if (endStepId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endStepId", endStepId));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPredictedPathValidateBeforeCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long startStepId, @javax.annotation.Nonnull Long endStepId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling getPredictedPath(Async)");
        }

        // verify the required parameter 'startStepId' is set
        if (startStepId == null) {
            throw new ApiException("Missing the required parameter 'startStepId' when calling getPredictedPath(Async)");
        }

        // verify the required parameter 'endStepId' is set
        if (endStepId == null) {
            throw new ApiException("Missing the required parameter 'endStepId' when calling getPredictedPath(Async)");
        }

        return getPredictedPathCall(accountId, startStepId, endStepId, _callback);

    }

    /**
     * Get Tracking Path
     * Get the path (lat/long coordinates) between 2 steps previously logged for a customer.
     * @param accountId The account id of the customer (required)
     * @param startStepId The stepId to begin from (required)
     * @param endStepId The stepId to end with (required)
     * @return List&lt;StepResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public List<StepResponse> getPredictedPath(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long startStepId, @javax.annotation.Nonnull Long endStepId) throws ApiException {
        ApiResponse<List<StepResponse>> localVarResp = getPredictedPathWithHttpInfo(accountId, startStepId, endStepId);
        return localVarResp.getData();
    }

    /**
     * Get Tracking Path
     * Get the path (lat/long coordinates) between 2 steps previously logged for a customer.
     * @param accountId The account id of the customer (required)
     * @param startStepId The stepId to begin from (required)
     * @param endStepId The stepId to end with (required)
     * @return ApiResponse&lt;List&lt;StepResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<StepResponse>> getPredictedPathWithHttpInfo(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long startStepId, @javax.annotation.Nonnull Long endStepId) throws ApiException {
        okhttp3.Call localVarCall = getPredictedPathValidateBeforeCall(accountId, startStepId, endStepId, null);
        Type localVarReturnType = new TypeToken<List<StepResponse>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Tracking Path (asynchronously)
     * Get the path (lat/long coordinates) between 2 steps previously logged for a customer.
     * @param accountId The account id of the customer (required)
     * @param startStepId The stepId to begin from (required)
     * @param endStepId The stepId to end with (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPredictedPathAsync(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long startStepId, @javax.annotation.Nonnull Long endStepId, final ApiCallback<List<StepResponse>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPredictedPathValidateBeforeCall(accountId, startStepId, endStepId, _callback);
        Type localVarReturnType = new TypeToken<List<StepResponse>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPreferredLocations
     * @param accountId The account id of the customer (required)
     * @param latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param dateCheck Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)
     * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param sortField Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to PREFERRED_DATE)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to MILES)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPreferredLocationsCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable Double latitude, @javax.annotation.Nullable Double longitude, @javax.annotation.Nullable Long dateCheck, @javax.annotation.Nullable String hourCheck, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, @javax.annotation.Nullable Double searchRange, @javax.annotation.Nullable String distanceUnit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tracking/preferred/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (latitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latitude", latitude));
        }

        if (longitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("longitude", longitude));
        }

        if (dateCheck != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("dateCheck", dateCheck));
        }

        if (hourCheck != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hourCheck", hourCheck));
        }

        if (sortField != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sortField", sortField));
        }

        if (descending != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("descending", descending));
        }

        if (start != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start", start));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (searchRange != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("searchRange", searchRange));
        }

        if (distanceUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("distanceUnit", distanceUnit));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPreferredLocationsValidateBeforeCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable Double latitude, @javax.annotation.Nullable Double longitude, @javax.annotation.Nullable Long dateCheck, @javax.annotation.Nullable String hourCheck, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, @javax.annotation.Nullable Double searchRange, @javax.annotation.Nullable String distanceUnit, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling getPreferredLocations(Async)");
        }

        return getPreferredLocationsCall(accountId, latitude, longitude, dateCheck, hourCheck, sortField, descending, start, limit, searchRange, distanceUnit, _callback);

    }

    /**
     * Search Preferred Locations
     * Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.
     * @param accountId The account id of the customer (required)
     * @param latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param dateCheck Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)
     * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param sortField Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to PREFERRED_DATE)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to MILES)
     * @return List&lt;PreferredLocationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public List<PreferredLocationResponse> getPreferredLocations(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable Double latitude, @javax.annotation.Nullable Double longitude, @javax.annotation.Nullable Long dateCheck, @javax.annotation.Nullable String hourCheck, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, @javax.annotation.Nullable Double searchRange, @javax.annotation.Nullable String distanceUnit) throws ApiException {
        ApiResponse<List<PreferredLocationResponse>> localVarResp = getPreferredLocationsWithHttpInfo(accountId, latitude, longitude, dateCheck, hourCheck, sortField, descending, start, limit, searchRange, distanceUnit);
        return localVarResp.getData();
    }

    /**
     * Search Preferred Locations
     * Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.
     * @param accountId The account id of the customer (required)
     * @param latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param dateCheck Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)
     * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param sortField Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to PREFERRED_DATE)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to MILES)
     * @return ApiResponse&lt;List&lt;PreferredLocationResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<PreferredLocationResponse>> getPreferredLocationsWithHttpInfo(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable Double latitude, @javax.annotation.Nullable Double longitude, @javax.annotation.Nullable Long dateCheck, @javax.annotation.Nullable String hourCheck, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, @javax.annotation.Nullable Double searchRange, @javax.annotation.Nullable String distanceUnit) throws ApiException {
        okhttp3.Call localVarCall = getPreferredLocationsValidateBeforeCall(accountId, latitude, longitude, dateCheck, hourCheck, sortField, descending, start, limit, searchRange, distanceUnit, null);
        Type localVarReturnType = new TypeToken<List<PreferredLocationResponse>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search Preferred Locations (asynchronously)
     * Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.
     * @param accountId The account id of the customer (required)
     * @param latitude latitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param longitude longitude to return a more likely result set based on the user&#39;s current location (optional)
     * @param dateCheck Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)
     * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
     * @param sortField Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to PREFERRED_DATE)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 20)
     * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
     * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to MILES)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPreferredLocationsAsync(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable Double latitude, @javax.annotation.Nullable Double longitude, @javax.annotation.Nullable Long dateCheck, @javax.annotation.Nullable String hourCheck, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, @javax.annotation.Nullable Double searchRange, @javax.annotation.Nullable String distanceUnit, final ApiCallback<List<PreferredLocationResponse>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPreferredLocationsValidateBeforeCall(accountId, latitude, longitude, dateCheck, hourCheck, sortField, descending, start, limit, searchRange, distanceUnit, _callback);
        Type localVarReturnType = new TypeToken<List<PreferredLocationResponse>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getTrackingLegs
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param ownerId the account id of the person the user wants to tracking data for (optional)
     * @param trackingDeviceId the id of the tracking device (optional)
     * @param startDate the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)
     * @param endDate the end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param tags filter results by tag (optional)
     * @param getLastPoint gets the last known location of the user (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTrackingLegsCall(@javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Long ownerId, @javax.annotation.Nullable String trackingDeviceId, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String tags, @javax.annotation.Nullable Boolean getLastPoint, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tracking/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceId", deviceId));
        }

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (ownerId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ownerId", ownerId));
        }

        if (trackingDeviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("trackingDeviceId", trackingDeviceId));
        }

        if (startDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startDate", startDate));
        }

        if (endDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endDate", endDate));
        }

        if (tags != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tags", tags));
        }

        if (getLastPoint != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("getLastPoint", getLastPoint));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTrackingLegsValidateBeforeCall(@javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Long ownerId, @javax.annotation.Nullable String trackingDeviceId, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String tags, @javax.annotation.Nullable Boolean getLastPoint, final ApiCallback _callback) throws ApiException {
        return getTrackingLegsCall(deviceId, accountId, ownerId, trackingDeviceId, startDate, endDate, tags, getLastPoint, _callback);

    }

    /**
     * Search Tracking
     * Retrieve tracking data to be able to show where a user has been.
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param ownerId the account id of the person the user wants to tracking data for (optional)
     * @param trackingDeviceId the id of the tracking device (optional)
     * @param startDate the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)
     * @param endDate the end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param tags filter results by tag (optional)
     * @param getLastPoint gets the last known location of the user (optional, default to false)
     * @return List&lt;LegResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public List<LegResponse> getTrackingLegs(@javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Long ownerId, @javax.annotation.Nullable String trackingDeviceId, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String tags, @javax.annotation.Nullable Boolean getLastPoint) throws ApiException {
        ApiResponse<List<LegResponse>> localVarResp = getTrackingLegsWithHttpInfo(deviceId, accountId, ownerId, trackingDeviceId, startDate, endDate, tags, getLastPoint);
        return localVarResp.getData();
    }

    /**
     * Search Tracking
     * Retrieve tracking data to be able to show where a user has been.
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param ownerId the account id of the person the user wants to tracking data for (optional)
     * @param trackingDeviceId the id of the tracking device (optional)
     * @param startDate the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)
     * @param endDate the end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param tags filter results by tag (optional)
     * @param getLastPoint gets the last known location of the user (optional, default to false)
     * @return ApiResponse&lt;List&lt;LegResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<LegResponse>> getTrackingLegsWithHttpInfo(@javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Long ownerId, @javax.annotation.Nullable String trackingDeviceId, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String tags, @javax.annotation.Nullable Boolean getLastPoint) throws ApiException {
        okhttp3.Call localVarCall = getTrackingLegsValidateBeforeCall(deviceId, accountId, ownerId, trackingDeviceId, startDate, endDate, tags, getLastPoint, null);
        Type localVarReturnType = new TypeToken<List<LegResponse>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search Tracking (asynchronously)
     * Retrieve tracking data to be able to show where a user has been.
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param ownerId the account id of the person the user wants to tracking data for (optional)
     * @param trackingDeviceId the id of the tracking device (optional)
     * @param startDate the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)
     * @param endDate the end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param tags filter results by tag (optional)
     * @param getLastPoint gets the last known location of the user (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTrackingLegsAsync(@javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Long ownerId, @javax.annotation.Nullable String trackingDeviceId, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String tags, @javax.annotation.Nullable Boolean getLastPoint, final ApiCallback<List<LegResponse>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTrackingLegsValidateBeforeCall(deviceId, accountId, ownerId, trackingDeviceId, startDate, endDate, tags, getLastPoint, _callback);
        Type localVarReturnType = new TypeToken<List<LegResponse>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for saveTrackingLeg
     * @param startLat the latitude of the first point (required)
     * @param startLng the longitude of the first point (required)
     * @param startDate the start date (in UTC milliseconds) of the first point (required)
     * @param endLat the latitude of the last point (required)
     * @param endLng the longitude of the last point (required)
     * @param endDate the end date (in UTC milliseconds) of the last point (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param distance the total distance (optional)
     * @param duration the total duration (optional)
     * @param steps JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60;  (optional)
     * @param tags name the leg for searching (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call saveTrackingLegCall(@javax.annotation.Nonnull Double startLat, @javax.annotation.Nonnull Double startLng, @javax.annotation.Nonnull Long startDate, @javax.annotation.Nonnull Double endLat, @javax.annotation.Nonnull Double endLng, @javax.annotation.Nonnull Long endDate, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Double distance, @javax.annotation.Nullable Long duration, @javax.annotation.Nullable String steps, @javax.annotation.Nullable String tags, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tracking/leg/create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceId", deviceId));
        }

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (distance != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("distance", distance));
        }

        if (duration != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("duration", duration));
        }

        if (startLat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startLat", startLat));
        }

        if (startLng != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startLng", startLng));
        }

        if (startDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startDate", startDate));
        }

        if (endLat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endLat", endLat));
        }

        if (endLng != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endLng", endLng));
        }

        if (endDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endDate", endDate));
        }

        if (steps != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("steps", steps));
        }

        if (tags != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tags", tags));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call saveTrackingLegValidateBeforeCall(@javax.annotation.Nonnull Double startLat, @javax.annotation.Nonnull Double startLng, @javax.annotation.Nonnull Long startDate, @javax.annotation.Nonnull Double endLat, @javax.annotation.Nonnull Double endLng, @javax.annotation.Nonnull Long endDate, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Double distance, @javax.annotation.Nullable Long duration, @javax.annotation.Nullable String steps, @javax.annotation.Nullable String tags, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'startLat' is set
        if (startLat == null) {
            throw new ApiException("Missing the required parameter 'startLat' when calling saveTrackingLeg(Async)");
        }

        // verify the required parameter 'startLng' is set
        if (startLng == null) {
            throw new ApiException("Missing the required parameter 'startLng' when calling saveTrackingLeg(Async)");
        }

        // verify the required parameter 'startDate' is set
        if (startDate == null) {
            throw new ApiException("Missing the required parameter 'startDate' when calling saveTrackingLeg(Async)");
        }

        // verify the required parameter 'endLat' is set
        if (endLat == null) {
            throw new ApiException("Missing the required parameter 'endLat' when calling saveTrackingLeg(Async)");
        }

        // verify the required parameter 'endLng' is set
        if (endLng == null) {
            throw new ApiException("Missing the required parameter 'endLng' when calling saveTrackingLeg(Async)");
        }

        // verify the required parameter 'endDate' is set
        if (endDate == null) {
            throw new ApiException("Missing the required parameter 'endDate' when calling saveTrackingLeg(Async)");
        }

        return saveTrackingLegCall(startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration, steps, tags, _callback);

    }

    /**
     * Create Tracking Leg
     * Send tracking points to be able to generate pathing data
     * @param startLat the latitude of the first point (required)
     * @param startLng the longitude of the first point (required)
     * @param startDate the start date (in UTC milliseconds) of the first point (required)
     * @param endLat the latitude of the last point (required)
     * @param endLng the longitude of the last point (required)
     * @param endDate the end date (in UTC milliseconds) of the last point (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param distance the total distance (optional)
     * @param duration the total duration (optional)
     * @param steps JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60;  (optional)
     * @param tags name the leg for searching (optional)
     * @return SirqulResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public SirqulResponse saveTrackingLeg(@javax.annotation.Nonnull Double startLat, @javax.annotation.Nonnull Double startLng, @javax.annotation.Nonnull Long startDate, @javax.annotation.Nonnull Double endLat, @javax.annotation.Nonnull Double endLng, @javax.annotation.Nonnull Long endDate, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Double distance, @javax.annotation.Nullable Long duration, @javax.annotation.Nullable String steps, @javax.annotation.Nullable String tags) throws ApiException {
        ApiResponse<SirqulResponse> localVarResp = saveTrackingLegWithHttpInfo(startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration, steps, tags);
        return localVarResp.getData();
    }

    /**
     * Create Tracking Leg
     * Send tracking points to be able to generate pathing data
     * @param startLat the latitude of the first point (required)
     * @param startLng the longitude of the first point (required)
     * @param startDate the start date (in UTC milliseconds) of the first point (required)
     * @param endLat the latitude of the last point (required)
     * @param endLng the longitude of the last point (required)
     * @param endDate the end date (in UTC milliseconds) of the last point (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param distance the total distance (optional)
     * @param duration the total duration (optional)
     * @param steps JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60;  (optional)
     * @param tags name the leg for searching (optional)
     * @return ApiResponse&lt;SirqulResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SirqulResponse> saveTrackingLegWithHttpInfo(@javax.annotation.Nonnull Double startLat, @javax.annotation.Nonnull Double startLng, @javax.annotation.Nonnull Long startDate, @javax.annotation.Nonnull Double endLat, @javax.annotation.Nonnull Double endLng, @javax.annotation.Nonnull Long endDate, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Double distance, @javax.annotation.Nullable Long duration, @javax.annotation.Nullable String steps, @javax.annotation.Nullable String tags) throws ApiException {
        okhttp3.Call localVarCall = saveTrackingLegValidateBeforeCall(startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration, steps, tags, null);
        Type localVarReturnType = new TypeToken<SirqulResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Tracking Leg (asynchronously)
     * Send tracking points to be able to generate pathing data
     * @param startLat the latitude of the first point (required)
     * @param startLng the longitude of the first point (required)
     * @param startDate the start date (in UTC milliseconds) of the first point (required)
     * @param endLat the latitude of the last point (required)
     * @param endLng the longitude of the last point (required)
     * @param endDate the end date (in UTC milliseconds) of the last point (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param distance the total distance (optional)
     * @param duration the total duration (optional)
     * @param steps JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60;  (optional)
     * @param tags name the leg for searching (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call saveTrackingLegAsync(@javax.annotation.Nonnull Double startLat, @javax.annotation.Nonnull Double startLng, @javax.annotation.Nonnull Long startDate, @javax.annotation.Nonnull Double endLat, @javax.annotation.Nonnull Double endLng, @javax.annotation.Nonnull Long endDate, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Double distance, @javax.annotation.Nullable Long duration, @javax.annotation.Nullable String steps, @javax.annotation.Nullable String tags, final ApiCallback<SirqulResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = saveTrackingLegValidateBeforeCall(startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration, steps, tags, _callback);
        Type localVarReturnType = new TypeToken<SirqulResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for saveTrackingStep
     * @param legId the leg to add the step to (required)
     * @param startLat the latitude of the first point (required)
     * @param startLng the longitude of the first point (required)
     * @param startDate the start date (in UTC milliseconds) of the first point (required)
     * @param endLat the latitude of the last point (required)
     * @param endLng the longitude of the last point (required)
     * @param endDate the end date (in UTC milliseconds) of the last point (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param distance the total distance (optional)
     * @param duration the total duration (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call saveTrackingStepCall(@javax.annotation.Nonnull Long legId, @javax.annotation.Nonnull Double startLat, @javax.annotation.Nonnull Double startLng, @javax.annotation.Nonnull Long startDate, @javax.annotation.Nonnull Double endLat, @javax.annotation.Nonnull Double endLng, @javax.annotation.Nonnull Long endDate, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Double distance, @javax.annotation.Nullable Long duration, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tracking/step/create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceId", deviceId));
        }

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (legId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("legId", legId));
        }

        if (distance != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("distance", distance));
        }

        if (duration != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("duration", duration));
        }

        if (startLat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startLat", startLat));
        }

        if (startLng != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startLng", startLng));
        }

        if (startDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startDate", startDate));
        }

        if (endLat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endLat", endLat));
        }

        if (endLng != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endLng", endLng));
        }

        if (endDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endDate", endDate));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call saveTrackingStepValidateBeforeCall(@javax.annotation.Nonnull Long legId, @javax.annotation.Nonnull Double startLat, @javax.annotation.Nonnull Double startLng, @javax.annotation.Nonnull Long startDate, @javax.annotation.Nonnull Double endLat, @javax.annotation.Nonnull Double endLng, @javax.annotation.Nonnull Long endDate, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Double distance, @javax.annotation.Nullable Long duration, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'legId' is set
        if (legId == null) {
            throw new ApiException("Missing the required parameter 'legId' when calling saveTrackingStep(Async)");
        }

        // verify the required parameter 'startLat' is set
        if (startLat == null) {
            throw new ApiException("Missing the required parameter 'startLat' when calling saveTrackingStep(Async)");
        }

        // verify the required parameter 'startLng' is set
        if (startLng == null) {
            throw new ApiException("Missing the required parameter 'startLng' when calling saveTrackingStep(Async)");
        }

        // verify the required parameter 'startDate' is set
        if (startDate == null) {
            throw new ApiException("Missing the required parameter 'startDate' when calling saveTrackingStep(Async)");
        }

        // verify the required parameter 'endLat' is set
        if (endLat == null) {
            throw new ApiException("Missing the required parameter 'endLat' when calling saveTrackingStep(Async)");
        }

        // verify the required parameter 'endLng' is set
        if (endLng == null) {
            throw new ApiException("Missing the required parameter 'endLng' when calling saveTrackingStep(Async)");
        }

        // verify the required parameter 'endDate' is set
        if (endDate == null) {
            throw new ApiException("Missing the required parameter 'endDate' when calling saveTrackingStep(Async)");
        }

        return saveTrackingStepCall(legId, startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration, _callback);

    }

    /**
     * Create Tracking Step
     * Send tracking points to be able to generate pathing data
     * @param legId the leg to add the step to (required)
     * @param startLat the latitude of the first point (required)
     * @param startLng the longitude of the first point (required)
     * @param startDate the start date (in UTC milliseconds) of the first point (required)
     * @param endLat the latitude of the last point (required)
     * @param endLng the longitude of the last point (required)
     * @param endDate the end date (in UTC milliseconds) of the last point (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param distance the total distance (optional)
     * @param duration the total duration (optional)
     * @return SirqulResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public SirqulResponse saveTrackingStep(@javax.annotation.Nonnull Long legId, @javax.annotation.Nonnull Double startLat, @javax.annotation.Nonnull Double startLng, @javax.annotation.Nonnull Long startDate, @javax.annotation.Nonnull Double endLat, @javax.annotation.Nonnull Double endLng, @javax.annotation.Nonnull Long endDate, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Double distance, @javax.annotation.Nullable Long duration) throws ApiException {
        ApiResponse<SirqulResponse> localVarResp = saveTrackingStepWithHttpInfo(legId, startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration);
        return localVarResp.getData();
    }

    /**
     * Create Tracking Step
     * Send tracking points to be able to generate pathing data
     * @param legId the leg to add the step to (required)
     * @param startLat the latitude of the first point (required)
     * @param startLng the longitude of the first point (required)
     * @param startDate the start date (in UTC milliseconds) of the first point (required)
     * @param endLat the latitude of the last point (required)
     * @param endLng the longitude of the last point (required)
     * @param endDate the end date (in UTC milliseconds) of the last point (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param distance the total distance (optional)
     * @param duration the total duration (optional)
     * @return ApiResponse&lt;SirqulResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SirqulResponse> saveTrackingStepWithHttpInfo(@javax.annotation.Nonnull Long legId, @javax.annotation.Nonnull Double startLat, @javax.annotation.Nonnull Double startLng, @javax.annotation.Nonnull Long startDate, @javax.annotation.Nonnull Double endLat, @javax.annotation.Nonnull Double endLng, @javax.annotation.Nonnull Long endDate, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Double distance, @javax.annotation.Nullable Long duration) throws ApiException {
        okhttp3.Call localVarCall = saveTrackingStepValidateBeforeCall(legId, startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration, null);
        Type localVarReturnType = new TypeToken<SirqulResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Tracking Step (asynchronously)
     * Send tracking points to be able to generate pathing data
     * @param legId the leg to add the step to (required)
     * @param startLat the latitude of the first point (required)
     * @param startLng the longitude of the first point (required)
     * @param startDate the start date (in UTC milliseconds) of the first point (required)
     * @param endLat the latitude of the last point (required)
     * @param endLng the longitude of the last point (required)
     * @param endDate the end date (in UTC milliseconds) of the last point (required)
     * @param deviceId the device id (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param distance the total distance (optional)
     * @param duration the total duration (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call saveTrackingStepAsync(@javax.annotation.Nonnull Long legId, @javax.annotation.Nonnull Double startLat, @javax.annotation.Nonnull Double startLng, @javax.annotation.Nonnull Long startDate, @javax.annotation.Nonnull Double endLat, @javax.annotation.Nonnull Double endLng, @javax.annotation.Nonnull Long endDate, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Long accountId, @javax.annotation.Nullable Double distance, @javax.annotation.Nullable Long duration, final ApiCallback<SirqulResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = saveTrackingStepValidateBeforeCall(legId, startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration, _callback);
        Type localVarReturnType = new TypeToken<SirqulResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchAccountsWithTrackingLegs
     * @param accountId The account id of the user (required)
     * @param keyword Used for LIKE search of first or last name on the acocunt (optional)
     * @param startDate Range to begin in UTC milliseconds (optional)
     * @param endDate Range to end in UTC milliseconds (optional)
     * @param tags Exact match on tag field of Legs&#39;s searchTag (optional)
     * @param audienceIds  (optional)
     * @param latitude Origin latitude to perform searching constraints with given range (optional)
     * @param longitude Origin longitude to perform searching constraints with given range (optional)
     * @param range The radius, in miles, to perform the search for (optional, default to 5)
     * @param sortField The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to LEG_START_DATE)
     * @param descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)
     * @param start The index into the record set to start with. Default is 0. (optional, default to 0)
     * @param limit The total number of records to return. Default is 20. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results. Default is false. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchAccountsWithTrackingLegsCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable String keyword, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String tags, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable Double latitude, @javax.annotation.Nullable Double longitude, @javax.annotation.Nullable Double range, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, @javax.annotation.Nullable Boolean activeOnly, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tracking/list";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (keyword != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("keyword", keyword));
        }

        if (startDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startDate", startDate));
        }

        if (endDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endDate", endDate));
        }

        if (tags != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tags", tags));
        }

        if (audienceIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audienceIds", audienceIds));
        }

        if (latitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latitude", latitude));
        }

        if (longitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("longitude", longitude));
        }

        if (range != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("range", range));
        }

        if (sortField != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sortField", sortField));
        }

        if (descending != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("descending", descending));
        }

        if (start != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start", start));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (activeOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("activeOnly", activeOnly));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchAccountsWithTrackingLegsValidateBeforeCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable String keyword, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String tags, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable Double latitude, @javax.annotation.Nullable Double longitude, @javax.annotation.Nullable Double range, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, @javax.annotation.Nullable Boolean activeOnly, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling searchAccountsWithTrackingLegs(Async)");
        }

        return searchAccountsWithTrackingLegsCall(accountId, keyword, startDate, endDate, tags, audienceIds, latitude, longitude, range, sortField, descending, start, limit, activeOnly, _callback);

    }

    /**
     * List Tracking
     * Search for all accounts that have tracking legs data by the given constraints.
     * @param accountId The account id of the user (required)
     * @param keyword Used for LIKE search of first or last name on the acocunt (optional)
     * @param startDate Range to begin in UTC milliseconds (optional)
     * @param endDate Range to end in UTC milliseconds (optional)
     * @param tags Exact match on tag field of Legs&#39;s searchTag (optional)
     * @param audienceIds  (optional)
     * @param latitude Origin latitude to perform searching constraints with given range (optional)
     * @param longitude Origin longitude to perform searching constraints with given range (optional)
     * @param range The radius, in miles, to perform the search for (optional, default to 5)
     * @param sortField The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to LEG_START_DATE)
     * @param descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)
     * @param start The index into the record set to start with. Default is 0. (optional, default to 0)
     * @param limit The total number of records to return. Default is 20. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results. Default is false. (optional, default to false)
     * @return List&lt;AccountMiniResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public List<AccountMiniResponse> searchAccountsWithTrackingLegs(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable String keyword, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String tags, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable Double latitude, @javax.annotation.Nullable Double longitude, @javax.annotation.Nullable Double range, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, @javax.annotation.Nullable Boolean activeOnly) throws ApiException {
        ApiResponse<List<AccountMiniResponse>> localVarResp = searchAccountsWithTrackingLegsWithHttpInfo(accountId, keyword, startDate, endDate, tags, audienceIds, latitude, longitude, range, sortField, descending, start, limit, activeOnly);
        return localVarResp.getData();
    }

    /**
     * List Tracking
     * Search for all accounts that have tracking legs data by the given constraints.
     * @param accountId The account id of the user (required)
     * @param keyword Used for LIKE search of first or last name on the acocunt (optional)
     * @param startDate Range to begin in UTC milliseconds (optional)
     * @param endDate Range to end in UTC milliseconds (optional)
     * @param tags Exact match on tag field of Legs&#39;s searchTag (optional)
     * @param audienceIds  (optional)
     * @param latitude Origin latitude to perform searching constraints with given range (optional)
     * @param longitude Origin longitude to perform searching constraints with given range (optional)
     * @param range The radius, in miles, to perform the search for (optional, default to 5)
     * @param sortField The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to LEG_START_DATE)
     * @param descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)
     * @param start The index into the record set to start with. Default is 0. (optional, default to 0)
     * @param limit The total number of records to return. Default is 20. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results. Default is false. (optional, default to false)
     * @return ApiResponse&lt;List&lt;AccountMiniResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<AccountMiniResponse>> searchAccountsWithTrackingLegsWithHttpInfo(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable String keyword, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String tags, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable Double latitude, @javax.annotation.Nullable Double longitude, @javax.annotation.Nullable Double range, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, @javax.annotation.Nullable Boolean activeOnly) throws ApiException {
        okhttp3.Call localVarCall = searchAccountsWithTrackingLegsValidateBeforeCall(accountId, keyword, startDate, endDate, tags, audienceIds, latitude, longitude, range, sortField, descending, start, limit, activeOnly, null);
        Type localVarReturnType = new TypeToken<List<AccountMiniResponse>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Tracking (asynchronously)
     * Search for all accounts that have tracking legs data by the given constraints.
     * @param accountId The account id of the user (required)
     * @param keyword Used for LIKE search of first or last name on the acocunt (optional)
     * @param startDate Range to begin in UTC milliseconds (optional)
     * @param endDate Range to end in UTC milliseconds (optional)
     * @param tags Exact match on tag field of Legs&#39;s searchTag (optional)
     * @param audienceIds  (optional)
     * @param latitude Origin latitude to perform searching constraints with given range (optional)
     * @param longitude Origin longitude to perform searching constraints with given range (optional)
     * @param range The radius, in miles, to perform the search for (optional, default to 5)
     * @param sortField The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to LEG_START_DATE)
     * @param descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)
     * @param start The index into the record set to start with. Default is 0. (optional, default to 0)
     * @param limit The total number of records to return. Default is 20. (optional, default to 20)
     * @param activeOnly Determines whether to return only active results. Default is false. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchAccountsWithTrackingLegsAsync(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable String keyword, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String tags, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable Double latitude, @javax.annotation.Nullable Double longitude, @javax.annotation.Nullable Double range, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, @javax.annotation.Nullable Boolean activeOnly, final ApiCallback<List<AccountMiniResponse>> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchAccountsWithTrackingLegsValidateBeforeCall(accountId, keyword, startDate, endDate, tags, audienceIds, latitude, longitude, range, sortField, descending, start, limit, activeOnly, _callback);
        Type localVarReturnType = new TypeToken<List<AccountMiniResponse>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchTrackingLegs
     * @param accountId The account id to search tracking for (required)
     * @param appKey The application key (required)
     * @param trackingDeviceId The id of the tracking device (optional)
     * @param startDate The start date in (UTC milliseconds) to filter the tracking results (optional)
     * @param endDate The end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param tags Filter results by tag (optional)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 100)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchTrackingLegsCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nullable String trackingDeviceId, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String tags, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tracking/searchByBillable";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (appKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appKey", appKey));
        }

        if (trackingDeviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("trackingDeviceId", trackingDeviceId));
        }

        if (startDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startDate", startDate));
        }

        if (endDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endDate", endDate));
        }

        if (tags != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tags", tags));
        }

        if (start != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start", start));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchTrackingLegsValidateBeforeCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nullable String trackingDeviceId, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String tags, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling searchTrackingLegs(Async)");
        }

        // verify the required parameter 'appKey' is set
        if (appKey == null) {
            throw new ApiException("Missing the required parameter 'appKey' when calling searchTrackingLegs(Async)");
        }

        return searchTrackingLegsCall(accountId, appKey, trackingDeviceId, startDate, endDate, tags, start, limit, _callback);

    }

    /**
     * Search Tracking (Billable)
     * Retrieve tracking data for billable/account scoped queries.
     * @param accountId The account id to search tracking for (required)
     * @param appKey The application key (required)
     * @param trackingDeviceId The id of the tracking device (optional)
     * @param startDate The start date in (UTC milliseconds) to filter the tracking results (optional)
     * @param endDate The end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param tags Filter results by tag (optional)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 100)
     * @return List&lt;LegResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public List<LegResponse> searchTrackingLegs(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nullable String trackingDeviceId, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String tags, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit) throws ApiException {
        ApiResponse<List<LegResponse>> localVarResp = searchTrackingLegsWithHttpInfo(accountId, appKey, trackingDeviceId, startDate, endDate, tags, start, limit);
        return localVarResp.getData();
    }

    /**
     * Search Tracking (Billable)
     * Retrieve tracking data for billable/account scoped queries.
     * @param accountId The account id to search tracking for (required)
     * @param appKey The application key (required)
     * @param trackingDeviceId The id of the tracking device (optional)
     * @param startDate The start date in (UTC milliseconds) to filter the tracking results (optional)
     * @param endDate The end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param tags Filter results by tag (optional)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 100)
     * @return ApiResponse&lt;List&lt;LegResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<LegResponse>> searchTrackingLegsWithHttpInfo(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nullable String trackingDeviceId, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String tags, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit) throws ApiException {
        okhttp3.Call localVarCall = searchTrackingLegsValidateBeforeCall(accountId, appKey, trackingDeviceId, startDate, endDate, tags, start, limit, null);
        Type localVarReturnType = new TypeToken<List<LegResponse>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search Tracking (Billable) (asynchronously)
     * Retrieve tracking data for billable/account scoped queries.
     * @param accountId The account id to search tracking for (required)
     * @param appKey The application key (required)
     * @param trackingDeviceId The id of the tracking device (optional)
     * @param startDate The start date in (UTC milliseconds) to filter the tracking results (optional)
     * @param endDate The end date in (UTC milliseconds) to filter the tracking results (optional)
     * @param tags Filter results by tag (optional)
     * @param start The start index for pagination (optional, default to 0)
     * @param limit The limit for pagination (optional, default to 100)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchTrackingLegsAsync(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nullable String trackingDeviceId, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String tags, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, final ApiCallback<List<LegResponse>> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchTrackingLegsValidateBeforeCall(accountId, appKey, trackingDeviceId, startDate, endDate, tags, start, limit, _callback);
        Type localVarReturnType = new TypeToken<List<LegResponse>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
