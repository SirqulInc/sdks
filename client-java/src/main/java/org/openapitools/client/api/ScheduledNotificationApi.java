/*
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import org.openapitools.client.model.ScheduledNotificationFullResponse;
import org.openapitools.client.model.SirqulResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ScheduledNotificationApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ScheduledNotificationApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ScheduledNotificationApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for createScheduledNotification
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param name The name of the scheduled notification (required)
     * @param type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (required)
     * @param message The message to send (required)
     * @param contentId The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentName The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentType The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentId The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentType The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param appKey The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param groupingId Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param connectionGroupIds The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param connectionAccountIds The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param audienceId This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param audienceIds The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param albumIds The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param reportId The report used to generate the the list of recipients (optional)
     * @param reportParams The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param startDate The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param endDate The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param cronExpression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param cronType The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param metaData Additional metadata for the scheduled notification (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param templateType This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;. (optional)
     * @param sendNow  (optional)
     * @param eventType Sets the event type for the notification (optional, default to CUSTOM)
     * @param deepLinkURI The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param sendToAll Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createScheduledNotificationCall(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String name, @javax.annotation.Nonnull String type, @javax.annotation.Nonnull String message, @javax.annotation.Nullable Long contentId, @javax.annotation.Nullable String contentName, @javax.annotation.Nullable String contentType, @javax.annotation.Nullable Long parentId, @javax.annotation.Nullable String parentType, @javax.annotation.Nullable String appKey, @javax.annotation.Nullable String groupingId, @javax.annotation.Nullable String connectionGroupIds, @javax.annotation.Nullable String connectionAccountIds, @javax.annotation.Nullable Long audienceId, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable String albumIds, @javax.annotation.Nullable Long reportId, @javax.annotation.Nullable String reportParams, @javax.annotation.Nullable String endpointURL, @javax.annotation.Nullable String payload, @javax.annotation.Nullable Long scheduledDate, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String cronExpression, @javax.annotation.Nullable String cronType, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable String conditionalInput, @javax.annotation.Nullable String templateType, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable Boolean sendNow, @javax.annotation.Nullable String eventType, @javax.annotation.Nullable String deepLinkURI, @javax.annotation.Nullable Boolean sendToAll, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/{version}/notification/schedule/create"
            .replace("{" + "version" + "}", localVarApiClient.escapeString(version.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (name != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("name", name));
        }

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        if (message != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("message", message));
        }

        if (contentId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("contentId", contentId));
        }

        if (contentName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("contentName", contentName));
        }

        if (contentType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("contentType", contentType));
        }

        if (parentId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("parentId", parentId));
        }

        if (parentType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("parentType", parentType));
        }

        if (appKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appKey", appKey));
        }

        if (groupingId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("groupingId", groupingId));
        }

        if (connectionGroupIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("connectionGroupIds", connectionGroupIds));
        }

        if (connectionAccountIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("connectionAccountIds", connectionAccountIds));
        }

        if (audienceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audienceId", audienceId));
        }

        if (audienceIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audienceIds", audienceIds));
        }

        if (albumIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("albumIds", albumIds));
        }

        if (reportId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("reportId", reportId));
        }

        if (reportParams != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("reportParams", reportParams));
        }

        if (endpointURL != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endpointURL", endpointURL));
        }

        if (payload != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("payload", payload));
        }

        if (scheduledDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scheduledDate", scheduledDate));
        }

        if (startDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startDate", startDate));
        }

        if (endDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endDate", endDate));
        }

        if (cronExpression != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cronExpression", cronExpression));
        }

        if (cronType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cronType", cronType));
        }

        if (metaData != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("metaData", metaData));
        }

        if (conditionalInput != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("conditionalInput", conditionalInput));
        }

        if (templateType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("templateType", templateType));
        }

        if (visibility != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("visibility", visibility));
        }

        if (active != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("active", active));
        }

        if (sendNow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sendNow", sendNow));
        }

        if (eventType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("eventType", eventType));
        }

        if (deepLinkURI != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deepLinkURI", deepLinkURI));
        }

        if (sendToAll != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sendToAll", sendToAll));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createScheduledNotificationValidateBeforeCall(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String name, @javax.annotation.Nonnull String type, @javax.annotation.Nonnull String message, @javax.annotation.Nullable Long contentId, @javax.annotation.Nullable String contentName, @javax.annotation.Nullable String contentType, @javax.annotation.Nullable Long parentId, @javax.annotation.Nullable String parentType, @javax.annotation.Nullable String appKey, @javax.annotation.Nullable String groupingId, @javax.annotation.Nullable String connectionGroupIds, @javax.annotation.Nullable String connectionAccountIds, @javax.annotation.Nullable Long audienceId, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable String albumIds, @javax.annotation.Nullable Long reportId, @javax.annotation.Nullable String reportParams, @javax.annotation.Nullable String endpointURL, @javax.annotation.Nullable String payload, @javax.annotation.Nullable Long scheduledDate, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String cronExpression, @javax.annotation.Nullable String cronType, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable String conditionalInput, @javax.annotation.Nullable String templateType, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable Boolean sendNow, @javax.annotation.Nullable String eventType, @javax.annotation.Nullable String deepLinkURI, @javax.annotation.Nullable Boolean sendToAll, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling createScheduledNotification(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling createScheduledNotification(Async)");
        }

        // verify the required parameter 'name' is set
        if (name == null) {
            throw new ApiException("Missing the required parameter 'name' when calling createScheduledNotification(Async)");
        }

        // verify the required parameter 'type' is set
        if (type == null) {
            throw new ApiException("Missing the required parameter 'type' when calling createScheduledNotification(Async)");
        }

        // verify the required parameter 'message' is set
        if (message == null) {
            throw new ApiException("Missing the required parameter 'message' when calling createScheduledNotification(Async)");
        }

        return createScheduledNotificationCall(version, accountId, name, type, message, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, payload, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, sendNow, eventType, deepLinkURI, sendToAll, _callback);

    }

    /**
     * Create Scheduled Notification
     * This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param name The name of the scheduled notification (required)
     * @param type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (required)
     * @param message The message to send (required)
     * @param contentId The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentName The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentType The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentId The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentType The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param appKey The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param groupingId Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param connectionGroupIds The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param connectionAccountIds The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param audienceId This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param audienceIds The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param albumIds The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param reportId The report used to generate the the list of recipients (optional)
     * @param reportParams The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param startDate The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param endDate The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param cronExpression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param cronType The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param metaData Additional metadata for the scheduled notification (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param templateType This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;. (optional)
     * @param sendNow  (optional)
     * @param eventType Sets the event type for the notification (optional, default to CUSTOM)
     * @param deepLinkURI The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param sendToAll Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @return ScheduledNotificationFullResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ScheduledNotificationFullResponse createScheduledNotification(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String name, @javax.annotation.Nonnull String type, @javax.annotation.Nonnull String message, @javax.annotation.Nullable Long contentId, @javax.annotation.Nullable String contentName, @javax.annotation.Nullable String contentType, @javax.annotation.Nullable Long parentId, @javax.annotation.Nullable String parentType, @javax.annotation.Nullable String appKey, @javax.annotation.Nullable String groupingId, @javax.annotation.Nullable String connectionGroupIds, @javax.annotation.Nullable String connectionAccountIds, @javax.annotation.Nullable Long audienceId, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable String albumIds, @javax.annotation.Nullable Long reportId, @javax.annotation.Nullable String reportParams, @javax.annotation.Nullable String endpointURL, @javax.annotation.Nullable String payload, @javax.annotation.Nullable Long scheduledDate, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String cronExpression, @javax.annotation.Nullable String cronType, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable String conditionalInput, @javax.annotation.Nullable String templateType, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable Boolean sendNow, @javax.annotation.Nullable String eventType, @javax.annotation.Nullable String deepLinkURI, @javax.annotation.Nullable Boolean sendToAll) throws ApiException {
        ApiResponse<ScheduledNotificationFullResponse> localVarResp = createScheduledNotificationWithHttpInfo(version, accountId, name, type, message, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, payload, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, sendNow, eventType, deepLinkURI, sendToAll);
        return localVarResp.getData();
    }

    /**
     * Create Scheduled Notification
     * This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param name The name of the scheduled notification (required)
     * @param type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (required)
     * @param message The message to send (required)
     * @param contentId The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentName The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentType The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentId The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentType The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param appKey The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param groupingId Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param connectionGroupIds The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param connectionAccountIds The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param audienceId This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param audienceIds The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param albumIds The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param reportId The report used to generate the the list of recipients (optional)
     * @param reportParams The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param startDate The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param endDate The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param cronExpression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param cronType The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param metaData Additional metadata for the scheduled notification (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param templateType This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;. (optional)
     * @param sendNow  (optional)
     * @param eventType Sets the event type for the notification (optional, default to CUSTOM)
     * @param deepLinkURI The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param sendToAll Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @return ApiResponse&lt;ScheduledNotificationFullResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ScheduledNotificationFullResponse> createScheduledNotificationWithHttpInfo(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String name, @javax.annotation.Nonnull String type, @javax.annotation.Nonnull String message, @javax.annotation.Nullable Long contentId, @javax.annotation.Nullable String contentName, @javax.annotation.Nullable String contentType, @javax.annotation.Nullable Long parentId, @javax.annotation.Nullable String parentType, @javax.annotation.Nullable String appKey, @javax.annotation.Nullable String groupingId, @javax.annotation.Nullable String connectionGroupIds, @javax.annotation.Nullable String connectionAccountIds, @javax.annotation.Nullable Long audienceId, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable String albumIds, @javax.annotation.Nullable Long reportId, @javax.annotation.Nullable String reportParams, @javax.annotation.Nullable String endpointURL, @javax.annotation.Nullable String payload, @javax.annotation.Nullable Long scheduledDate, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String cronExpression, @javax.annotation.Nullable String cronType, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable String conditionalInput, @javax.annotation.Nullable String templateType, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable Boolean sendNow, @javax.annotation.Nullable String eventType, @javax.annotation.Nullable String deepLinkURI, @javax.annotation.Nullable Boolean sendToAll) throws ApiException {
        okhttp3.Call localVarCall = createScheduledNotificationValidateBeforeCall(version, accountId, name, type, message, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, payload, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, sendNow, eventType, deepLinkURI, sendToAll, null);
        Type localVarReturnType = new TypeToken<ScheduledNotificationFullResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Scheduled Notification (asynchronously)
     * This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param name The name of the scheduled notification (required)
     * @param type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (required)
     * @param message The message to send (required)
     * @param contentId The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentName The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentType The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentId The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentType The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param appKey The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param groupingId Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param connectionGroupIds The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param connectionAccountIds The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param audienceId This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param audienceIds The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param albumIds The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param reportId The report used to generate the the list of recipients (optional)
     * @param reportParams The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param startDate The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param endDate The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param cronExpression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param cronType The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param metaData Additional metadata for the scheduled notification (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param templateType This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;. (optional)
     * @param sendNow  (optional)
     * @param eventType Sets the event type for the notification (optional, default to CUSTOM)
     * @param deepLinkURI The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param sendToAll Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createScheduledNotificationAsync(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String name, @javax.annotation.Nonnull String type, @javax.annotation.Nonnull String message, @javax.annotation.Nullable Long contentId, @javax.annotation.Nullable String contentName, @javax.annotation.Nullable String contentType, @javax.annotation.Nullable Long parentId, @javax.annotation.Nullable String parentType, @javax.annotation.Nullable String appKey, @javax.annotation.Nullable String groupingId, @javax.annotation.Nullable String connectionGroupIds, @javax.annotation.Nullable String connectionAccountIds, @javax.annotation.Nullable Long audienceId, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable String albumIds, @javax.annotation.Nullable Long reportId, @javax.annotation.Nullable String reportParams, @javax.annotation.Nullable String endpointURL, @javax.annotation.Nullable String payload, @javax.annotation.Nullable Long scheduledDate, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String cronExpression, @javax.annotation.Nullable String cronType, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable String conditionalInput, @javax.annotation.Nullable String templateType, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable Boolean sendNow, @javax.annotation.Nullable String eventType, @javax.annotation.Nullable String deepLinkURI, @javax.annotation.Nullable Boolean sendToAll, final ApiCallback<ScheduledNotificationFullResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createScheduledNotificationValidateBeforeCall(version, accountId, name, type, message, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, payload, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, sendNow, eventType, deepLinkURI, sendToAll, _callback);
        Type localVarReturnType = new TypeToken<ScheduledNotificationFullResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteScheduledNotification
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param scheduledNotificationId the id of the scheduled notification to delete (required)
     * @param deleteByGroupingId If set to true, also deletes Scheduled Notifications under the same account with the same groupingId. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteScheduledNotificationCall(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long scheduledNotificationId, @javax.annotation.Nullable Boolean deleteByGroupingId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/{version}/notification/schedule/delete"
            .replace("{" + "version" + "}", localVarApiClient.escapeString(version.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (scheduledNotificationId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scheduledNotificationId", scheduledNotificationId));
        }

        if (deleteByGroupingId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deleteByGroupingId", deleteByGroupingId));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteScheduledNotificationValidateBeforeCall(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long scheduledNotificationId, @javax.annotation.Nullable Boolean deleteByGroupingId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling deleteScheduledNotification(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling deleteScheduledNotification(Async)");
        }

        // verify the required parameter 'scheduledNotificationId' is set
        if (scheduledNotificationId == null) {
            throw new ApiException("Missing the required parameter 'scheduledNotificationId' when calling deleteScheduledNotification(Async)");
        }

        return deleteScheduledNotificationCall(version, accountId, scheduledNotificationId, deleteByGroupingId, _callback);

    }

    /**
     * Delete Scheduled Notification
     * This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param scheduledNotificationId the id of the scheduled notification to delete (required)
     * @param deleteByGroupingId If set to true, also deletes Scheduled Notifications under the same account with the same groupingId. (optional)
     * @return ScheduledNotificationFullResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ScheduledNotificationFullResponse deleteScheduledNotification(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long scheduledNotificationId, @javax.annotation.Nullable Boolean deleteByGroupingId) throws ApiException {
        ApiResponse<ScheduledNotificationFullResponse> localVarResp = deleteScheduledNotificationWithHttpInfo(version, accountId, scheduledNotificationId, deleteByGroupingId);
        return localVarResp.getData();
    }

    /**
     * Delete Scheduled Notification
     * This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param scheduledNotificationId the id of the scheduled notification to delete (required)
     * @param deleteByGroupingId If set to true, also deletes Scheduled Notifications under the same account with the same groupingId. (optional)
     * @return ApiResponse&lt;ScheduledNotificationFullResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ScheduledNotificationFullResponse> deleteScheduledNotificationWithHttpInfo(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long scheduledNotificationId, @javax.annotation.Nullable Boolean deleteByGroupingId) throws ApiException {
        okhttp3.Call localVarCall = deleteScheduledNotificationValidateBeforeCall(version, accountId, scheduledNotificationId, deleteByGroupingId, null);
        Type localVarReturnType = new TypeToken<ScheduledNotificationFullResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete Scheduled Notification (asynchronously)
     * This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.
     * @param version  (required)
     * @param accountId the id of the logged in user (required)
     * @param scheduledNotificationId the id of the scheduled notification to delete (required)
     * @param deleteByGroupingId If set to true, also deletes Scheduled Notifications under the same account with the same groupingId. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteScheduledNotificationAsync(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long scheduledNotificationId, @javax.annotation.Nullable Boolean deleteByGroupingId, final ApiCallback<ScheduledNotificationFullResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteScheduledNotificationValidateBeforeCall(version, accountId, scheduledNotificationId, deleteByGroupingId, _callback);
        Type localVarReturnType = new TypeToken<ScheduledNotificationFullResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getScheduledNotification
     * @param version  (required)
     * @param accountId the id of the account logged in (required)
     * @param scheduledNotificationId the id of the scheduled notification to get (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getScheduledNotificationCall(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long scheduledNotificationId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/{version}/notification/schedule/get"
            .replace("{" + "version" + "}", localVarApiClient.escapeString(version.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (scheduledNotificationId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scheduledNotificationId", scheduledNotificationId));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getScheduledNotificationValidateBeforeCall(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long scheduledNotificationId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling getScheduledNotification(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling getScheduledNotification(Async)");
        }

        // verify the required parameter 'scheduledNotificationId' is set
        if (scheduledNotificationId == null) {
            throw new ApiException("Missing the required parameter 'scheduledNotificationId' when calling getScheduledNotification(Async)");
        }

        return getScheduledNotificationCall(version, accountId, scheduledNotificationId, _callback);

    }

    /**
     * Get Scheduled Notification
     * Get a ScheduledNotification
     * @param version  (required)
     * @param accountId the id of the account logged in (required)
     * @param scheduledNotificationId the id of the scheduled notification to get (required)
     * @return ScheduledNotificationFullResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ScheduledNotificationFullResponse getScheduledNotification(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long scheduledNotificationId) throws ApiException {
        ApiResponse<ScheduledNotificationFullResponse> localVarResp = getScheduledNotificationWithHttpInfo(version, accountId, scheduledNotificationId);
        return localVarResp.getData();
    }

    /**
     * Get Scheduled Notification
     * Get a ScheduledNotification
     * @param version  (required)
     * @param accountId the id of the account logged in (required)
     * @param scheduledNotificationId the id of the scheduled notification to get (required)
     * @return ApiResponse&lt;ScheduledNotificationFullResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ScheduledNotificationFullResponse> getScheduledNotificationWithHttpInfo(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long scheduledNotificationId) throws ApiException {
        okhttp3.Call localVarCall = getScheduledNotificationValidateBeforeCall(version, accountId, scheduledNotificationId, null);
        Type localVarReturnType = new TypeToken<ScheduledNotificationFullResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Scheduled Notification (asynchronously)
     * Get a ScheduledNotification
     * @param version  (required)
     * @param accountId the id of the account logged in (required)
     * @param scheduledNotificationId the id of the scheduled notification to get (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getScheduledNotificationAsync(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long scheduledNotificationId, final ApiCallback<ScheduledNotificationFullResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getScheduledNotificationValidateBeforeCall(version, accountId, scheduledNotificationId, _callback);
        Type localVarReturnType = new TypeToken<ScheduledNotificationFullResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for scheduleNotificationListings
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param appKey The application to target (required)
     * @param reportName The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail (required)
     * @param message The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in (required)
     * @param offset Time in munites before the event starts to notify recipients (required)
     * @param recipientReportId The report id used to generate the recipient list (required)
     * @param reportParams The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)
     * @param type The type of scheduled notification; supported values are: MOBILE_NOTIFICATION (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call scheduleNotificationListingsCall(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull String reportName, @javax.annotation.Nonnull String message, @javax.annotation.Nonnull Integer offset, @javax.annotation.Nonnull Long recipientReportId, @javax.annotation.Nullable String reportParams, @javax.annotation.Nullable String type, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/{version}/notification/schedule/generate"
            .replace("{" + "version" + "}", localVarApiClient.escapeString(version.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (appKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appKey", appKey));
        }

        if (reportName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("reportName", reportName));
        }

        if (reportParams != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("reportParams", reportParams));
        }

        if (message != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("message", message));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        if (recipientReportId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recipientReportId", recipientReportId));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call scheduleNotificationListingsValidateBeforeCall(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull String reportName, @javax.annotation.Nonnull String message, @javax.annotation.Nonnull Integer offset, @javax.annotation.Nonnull Long recipientReportId, @javax.annotation.Nullable String reportParams, @javax.annotation.Nullable String type, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling scheduleNotificationListings(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling scheduleNotificationListings(Async)");
        }

        // verify the required parameter 'appKey' is set
        if (appKey == null) {
            throw new ApiException("Missing the required parameter 'appKey' when calling scheduleNotificationListings(Async)");
        }

        // verify the required parameter 'reportName' is set
        if (reportName == null) {
            throw new ApiException("Missing the required parameter 'reportName' when calling scheduleNotificationListings(Async)");
        }

        // verify the required parameter 'message' is set
        if (message == null) {
            throw new ApiException("Missing the required parameter 'message' when calling scheduleNotificationListings(Async)");
        }

        // verify the required parameter 'offset' is set
        if (offset == null) {
            throw new ApiException("Missing the required parameter 'offset' when calling scheduleNotificationListings(Async)");
        }

        // verify the required parameter 'recipientReportId' is set
        if (recipientReportId == null) {
            throw new ApiException("Missing the required parameter 'recipientReportId' when calling scheduleNotificationListings(Async)");
        }

        return scheduleNotificationListingsCall(version, accountId, appKey, reportName, message, offset, recipientReportId, reportParams, type, _callback);

    }

    /**
     * Generate Schedule Notifications
     * Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param appKey The application to target (required)
     * @param reportName The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail (required)
     * @param message The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in (required)
     * @param offset Time in munites before the event starts to notify recipients (required)
     * @param recipientReportId The report id used to generate the recipient list (required)
     * @param reportParams The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)
     * @param type The type of scheduled notification; supported values are: MOBILE_NOTIFICATION (optional)
     * @return SirqulResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public SirqulResponse scheduleNotificationListings(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull String reportName, @javax.annotation.Nonnull String message, @javax.annotation.Nonnull Integer offset, @javax.annotation.Nonnull Long recipientReportId, @javax.annotation.Nullable String reportParams, @javax.annotation.Nullable String type) throws ApiException {
        ApiResponse<SirqulResponse> localVarResp = scheduleNotificationListingsWithHttpInfo(version, accountId, appKey, reportName, message, offset, recipientReportId, reportParams, type);
        return localVarResp.getData();
    }

    /**
     * Generate Schedule Notifications
     * Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param appKey The application to target (required)
     * @param reportName The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail (required)
     * @param message The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in (required)
     * @param offset Time in munites before the event starts to notify recipients (required)
     * @param recipientReportId The report id used to generate the recipient list (required)
     * @param reportParams The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)
     * @param type The type of scheduled notification; supported values are: MOBILE_NOTIFICATION (optional)
     * @return ApiResponse&lt;SirqulResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SirqulResponse> scheduleNotificationListingsWithHttpInfo(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull String reportName, @javax.annotation.Nonnull String message, @javax.annotation.Nonnull Integer offset, @javax.annotation.Nonnull Long recipientReportId, @javax.annotation.Nullable String reportParams, @javax.annotation.Nullable String type) throws ApiException {
        okhttp3.Call localVarCall = scheduleNotificationListingsValidateBeforeCall(version, accountId, appKey, reportName, message, offset, recipientReportId, reportParams, type, null);
        Type localVarReturnType = new TypeToken<SirqulResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Generate Schedule Notifications (asynchronously)
     * Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param appKey The application to target (required)
     * @param reportName The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail (required)
     * @param message The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in (required)
     * @param offset Time in munites before the event starts to notify recipients (required)
     * @param recipientReportId The report id used to generate the recipient list (required)
     * @param reportParams The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)
     * @param type The type of scheduled notification; supported values are: MOBILE_NOTIFICATION (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call scheduleNotificationListingsAsync(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull String reportName, @javax.annotation.Nonnull String message, @javax.annotation.Nonnull Integer offset, @javax.annotation.Nonnull Long recipientReportId, @javax.annotation.Nullable String reportParams, @javax.annotation.Nullable String type, final ApiCallback<SirqulResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = scheduleNotificationListingsValidateBeforeCall(version, accountId, appKey, reportName, message, offset, recipientReportId, reportParams, type, _callback);
        Type localVarReturnType = new TypeToken<SirqulResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchScheduledNotifications
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param groupingId Filter results by a grouping identifier defined by the client (optional)
     * @param audienceId Filter results by audience (optional)
     * @param filter a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications. (optional)
     * @param types Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION (optional)
     * @param contentIds search using content IDs (optional)
     * @param contentTypes search using content types (optional)
     * @param parentIds search using parent IDs (optional)
     * @param parentTypes search using parent types (optional)
     * @param statuses Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending (optional)
     * @param templateTypes  (optional)
     * @param appKey Filter the list by a specific application (optional)
     * @param keyword Keyword search on the scheduled notification names. (optional)
     * @param sortField The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param start Start the result set at some index. (optional)
     * @param limit Limit the result to some number. (optional)
     * @param activeOnly Determines whether to return only active results (optional)
     * @param groupByGroupingId Determines whether to group results with the same groupingId together. (optional)
     * @param returnAudienceAccountCount If true, include audience account counts in the response (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchScheduledNotificationsCall(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable String groupingId, @javax.annotation.Nullable Long audienceId, @javax.annotation.Nullable String filter, @javax.annotation.Nullable String types, @javax.annotation.Nullable String contentIds, @javax.annotation.Nullable String contentTypes, @javax.annotation.Nullable String parentIds, @javax.annotation.Nullable String parentTypes, @javax.annotation.Nullable String statuses, @javax.annotation.Nullable String templateTypes, @javax.annotation.Nullable String appKey, @javax.annotation.Nullable String keyword, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, @javax.annotation.Nullable Boolean activeOnly, @javax.annotation.Nullable Boolean groupByGroupingId, @javax.annotation.Nullable Boolean returnAudienceAccountCount, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/{version}/notification/schedule/search"
            .replace("{" + "version" + "}", localVarApiClient.escapeString(version.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (groupingId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("groupingId", groupingId));
        }

        if (audienceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audienceId", audienceId));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (types != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("types", types));
        }

        if (contentIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("contentIds", contentIds));
        }

        if (contentTypes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("contentTypes", contentTypes));
        }

        if (parentIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("parentIds", parentIds));
        }

        if (parentTypes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("parentTypes", parentTypes));
        }

        if (statuses != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("statuses", statuses));
        }

        if (templateTypes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("templateTypes", templateTypes));
        }

        if (appKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appKey", appKey));
        }

        if (keyword != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("keyword", keyword));
        }

        if (sortField != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sortField", sortField));
        }

        if (descending != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("descending", descending));
        }

        if (start != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start", start));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (activeOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("activeOnly", activeOnly));
        }

        if (groupByGroupingId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("groupByGroupingId", groupByGroupingId));
        }

        if (returnAudienceAccountCount != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("returnAudienceAccountCount", returnAudienceAccountCount));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchScheduledNotificationsValidateBeforeCall(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable String groupingId, @javax.annotation.Nullable Long audienceId, @javax.annotation.Nullable String filter, @javax.annotation.Nullable String types, @javax.annotation.Nullable String contentIds, @javax.annotation.Nullable String contentTypes, @javax.annotation.Nullable String parentIds, @javax.annotation.Nullable String parentTypes, @javax.annotation.Nullable String statuses, @javax.annotation.Nullable String templateTypes, @javax.annotation.Nullable String appKey, @javax.annotation.Nullable String keyword, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, @javax.annotation.Nullable Boolean activeOnly, @javax.annotation.Nullable Boolean groupByGroupingId, @javax.annotation.Nullable Boolean returnAudienceAccountCount, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling searchScheduledNotifications(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling searchScheduledNotifications(Async)");
        }

        return searchScheduledNotificationsCall(version, accountId, groupingId, audienceId, filter, types, contentIds, contentTypes, parentIds, parentTypes, statuses, templateTypes, appKey, keyword, sortField, descending, start, limit, activeOnly, groupByGroupingId, returnAudienceAccountCount, _callback);

    }

    /**
     * Search Scheduled Notifications
     * This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param groupingId Filter results by a grouping identifier defined by the client (optional)
     * @param audienceId Filter results by audience (optional)
     * @param filter a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications. (optional)
     * @param types Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION (optional)
     * @param contentIds search using content IDs (optional)
     * @param contentTypes search using content types (optional)
     * @param parentIds search using parent IDs (optional)
     * @param parentTypes search using parent types (optional)
     * @param statuses Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending (optional)
     * @param templateTypes  (optional)
     * @param appKey Filter the list by a specific application (optional)
     * @param keyword Keyword search on the scheduled notification names. (optional)
     * @param sortField The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param start Start the result set at some index. (optional)
     * @param limit Limit the result to some number. (optional)
     * @param activeOnly Determines whether to return only active results (optional)
     * @param groupByGroupingId Determines whether to group results with the same groupingId together. (optional)
     * @param returnAudienceAccountCount If true, include audience account counts in the response (optional)
     * @return ScheduledNotificationFullResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ScheduledNotificationFullResponse searchScheduledNotifications(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable String groupingId, @javax.annotation.Nullable Long audienceId, @javax.annotation.Nullable String filter, @javax.annotation.Nullable String types, @javax.annotation.Nullable String contentIds, @javax.annotation.Nullable String contentTypes, @javax.annotation.Nullable String parentIds, @javax.annotation.Nullable String parentTypes, @javax.annotation.Nullable String statuses, @javax.annotation.Nullable String templateTypes, @javax.annotation.Nullable String appKey, @javax.annotation.Nullable String keyword, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, @javax.annotation.Nullable Boolean activeOnly, @javax.annotation.Nullable Boolean groupByGroupingId, @javax.annotation.Nullable Boolean returnAudienceAccountCount) throws ApiException {
        ApiResponse<ScheduledNotificationFullResponse> localVarResp = searchScheduledNotificationsWithHttpInfo(version, accountId, groupingId, audienceId, filter, types, contentIds, contentTypes, parentIds, parentTypes, statuses, templateTypes, appKey, keyword, sortField, descending, start, limit, activeOnly, groupByGroupingId, returnAudienceAccountCount);
        return localVarResp.getData();
    }

    /**
     * Search Scheduled Notifications
     * This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param groupingId Filter results by a grouping identifier defined by the client (optional)
     * @param audienceId Filter results by audience (optional)
     * @param filter a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications. (optional)
     * @param types Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION (optional)
     * @param contentIds search using content IDs (optional)
     * @param contentTypes search using content types (optional)
     * @param parentIds search using parent IDs (optional)
     * @param parentTypes search using parent types (optional)
     * @param statuses Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending (optional)
     * @param templateTypes  (optional)
     * @param appKey Filter the list by a specific application (optional)
     * @param keyword Keyword search on the scheduled notification names. (optional)
     * @param sortField The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param start Start the result set at some index. (optional)
     * @param limit Limit the result to some number. (optional)
     * @param activeOnly Determines whether to return only active results (optional)
     * @param groupByGroupingId Determines whether to group results with the same groupingId together. (optional)
     * @param returnAudienceAccountCount If true, include audience account counts in the response (optional)
     * @return ApiResponse&lt;ScheduledNotificationFullResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ScheduledNotificationFullResponse> searchScheduledNotificationsWithHttpInfo(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable String groupingId, @javax.annotation.Nullable Long audienceId, @javax.annotation.Nullable String filter, @javax.annotation.Nullable String types, @javax.annotation.Nullable String contentIds, @javax.annotation.Nullable String contentTypes, @javax.annotation.Nullable String parentIds, @javax.annotation.Nullable String parentTypes, @javax.annotation.Nullable String statuses, @javax.annotation.Nullable String templateTypes, @javax.annotation.Nullable String appKey, @javax.annotation.Nullable String keyword, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, @javax.annotation.Nullable Boolean activeOnly, @javax.annotation.Nullable Boolean groupByGroupingId, @javax.annotation.Nullable Boolean returnAudienceAccountCount) throws ApiException {
        okhttp3.Call localVarCall = searchScheduledNotificationsValidateBeforeCall(version, accountId, groupingId, audienceId, filter, types, contentIds, contentTypes, parentIds, parentTypes, statuses, templateTypes, appKey, keyword, sortField, descending, start, limit, activeOnly, groupByGroupingId, returnAudienceAccountCount, null);
        Type localVarReturnType = new TypeToken<ScheduledNotificationFullResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search Scheduled Notifications (asynchronously)
     * This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.
     * @param version  (required)
     * @param accountId The logged in user. (required)
     * @param groupingId Filter results by a grouping identifier defined by the client (optional)
     * @param audienceId Filter results by audience (optional)
     * @param filter a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications. (optional)
     * @param types Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION (optional)
     * @param contentIds search using content IDs (optional)
     * @param contentTypes search using content types (optional)
     * @param parentIds search using parent IDs (optional)
     * @param parentTypes search using parent types (optional)
     * @param statuses Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending (optional)
     * @param templateTypes  (optional)
     * @param appKey Filter the list by a specific application (optional)
     * @param keyword Keyword search on the scheduled notification names. (optional)
     * @param sortField The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param start Start the result set at some index. (optional)
     * @param limit Limit the result to some number. (optional)
     * @param activeOnly Determines whether to return only active results (optional)
     * @param groupByGroupingId Determines whether to group results with the same groupingId together. (optional)
     * @param returnAudienceAccountCount If true, include audience account counts in the response (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchScheduledNotificationsAsync(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable String groupingId, @javax.annotation.Nullable Long audienceId, @javax.annotation.Nullable String filter, @javax.annotation.Nullable String types, @javax.annotation.Nullable String contentIds, @javax.annotation.Nullable String contentTypes, @javax.annotation.Nullable String parentIds, @javax.annotation.Nullable String parentTypes, @javax.annotation.Nullable String statuses, @javax.annotation.Nullable String templateTypes, @javax.annotation.Nullable String appKey, @javax.annotation.Nullable String keyword, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, @javax.annotation.Nullable Boolean activeOnly, @javax.annotation.Nullable Boolean groupByGroupingId, @javax.annotation.Nullable Boolean returnAudienceAccountCount, final ApiCallback<ScheduledNotificationFullResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchScheduledNotificationsValidateBeforeCall(version, accountId, groupingId, audienceId, filter, types, contentIds, contentTypes, parentIds, parentTypes, statuses, templateTypes, appKey, keyword, sortField, descending, start, limit, activeOnly, groupByGroupingId, returnAudienceAccountCount, _callback);
        Type localVarReturnType = new TypeToken<ScheduledNotificationFullResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateScheduledNotification
     * @param version  (required)
     * @param scheduledNotificationId The id of scheduled notification to update (required)
     * @param accountId The logged in user. (required)
     * @param name The name of the scheduled notification (optional)
     * @param type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (optional)
     * @param message The message to send (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param contentId The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentName The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentType The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentId The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentType The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param appKey The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param groupingId Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param connectionGroupIds The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param connectionAccountIds The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param audienceId This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param audienceIds The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param albumIds The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param reportId The report used to generate the the list of recipients (optional)
     * @param reportParams The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param scheduledDate The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param startDate The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param endDate The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param cronExpression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param cronType The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param metaData Additional metadata for the scheduled notification (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param templateType This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. (optional)
     * @param errorMessage the error message associated with the scheduled notification (optional)
     * @param status the status of the scheduled notification (optional)
     * @param updateByGroupingId also updates ScheduledNotifications with the same groupingId and account (optional)
     * @param sendNow whether to send the scheduled notification now or not (optional)
     * @param eventType Sets the event type for the notification (optional, default to CUSTOM)
     * @param deepLinkURI The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param sendToAll Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateScheduledNotificationCall(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long scheduledNotificationId, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable String name, @javax.annotation.Nullable String type, @javax.annotation.Nullable String message, @javax.annotation.Nullable String payload, @javax.annotation.Nullable Long contentId, @javax.annotation.Nullable String contentName, @javax.annotation.Nullable String contentType, @javax.annotation.Nullable Long parentId, @javax.annotation.Nullable String parentType, @javax.annotation.Nullable String appKey, @javax.annotation.Nullable String groupingId, @javax.annotation.Nullable String connectionGroupIds, @javax.annotation.Nullable String connectionAccountIds, @javax.annotation.Nullable Long audienceId, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable String albumIds, @javax.annotation.Nullable Long reportId, @javax.annotation.Nullable String reportParams, @javax.annotation.Nullable String endpointURL, @javax.annotation.Nullable Long scheduledDate, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String cronExpression, @javax.annotation.Nullable String cronType, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable String conditionalInput, @javax.annotation.Nullable String templateType, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable String errorMessage, @javax.annotation.Nullable String status, @javax.annotation.Nullable Boolean updateByGroupingId, @javax.annotation.Nullable Boolean sendNow, @javax.annotation.Nullable String eventType, @javax.annotation.Nullable String deepLinkURI, @javax.annotation.Nullable Boolean sendToAll, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/{version}/notification/schedule/update"
            .replace("{" + "version" + "}", localVarApiClient.escapeString(version.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (scheduledNotificationId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scheduledNotificationId", scheduledNotificationId));
        }

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (name != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("name", name));
        }

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        if (message != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("message", message));
        }

        if (payload != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("payload", payload));
        }

        if (contentId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("contentId", contentId));
        }

        if (contentName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("contentName", contentName));
        }

        if (contentType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("contentType", contentType));
        }

        if (parentId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("parentId", parentId));
        }

        if (parentType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("parentType", parentType));
        }

        if (appKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appKey", appKey));
        }

        if (groupingId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("groupingId", groupingId));
        }

        if (connectionGroupIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("connectionGroupIds", connectionGroupIds));
        }

        if (connectionAccountIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("connectionAccountIds", connectionAccountIds));
        }

        if (audienceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audienceId", audienceId));
        }

        if (audienceIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audienceIds", audienceIds));
        }

        if (albumIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("albumIds", albumIds));
        }

        if (reportId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("reportId", reportId));
        }

        if (reportParams != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("reportParams", reportParams));
        }

        if (endpointURL != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endpointURL", endpointURL));
        }

        if (scheduledDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scheduledDate", scheduledDate));
        }

        if (startDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startDate", startDate));
        }

        if (endDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endDate", endDate));
        }

        if (cronExpression != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cronExpression", cronExpression));
        }

        if (cronType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cronType", cronType));
        }

        if (metaData != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("metaData", metaData));
        }

        if (conditionalInput != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("conditionalInput", conditionalInput));
        }

        if (templateType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("templateType", templateType));
        }

        if (visibility != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("visibility", visibility));
        }

        if (active != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("active", active));
        }

        if (errorMessage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("errorMessage", errorMessage));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (updateByGroupingId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("updateByGroupingId", updateByGroupingId));
        }

        if (sendNow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sendNow", sendNow));
        }

        if (eventType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("eventType", eventType));
        }

        if (deepLinkURI != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deepLinkURI", deepLinkURI));
        }

        if (sendToAll != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sendToAll", sendToAll));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateScheduledNotificationValidateBeforeCall(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long scheduledNotificationId, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable String name, @javax.annotation.Nullable String type, @javax.annotation.Nullable String message, @javax.annotation.Nullable String payload, @javax.annotation.Nullable Long contentId, @javax.annotation.Nullable String contentName, @javax.annotation.Nullable String contentType, @javax.annotation.Nullable Long parentId, @javax.annotation.Nullable String parentType, @javax.annotation.Nullable String appKey, @javax.annotation.Nullable String groupingId, @javax.annotation.Nullable String connectionGroupIds, @javax.annotation.Nullable String connectionAccountIds, @javax.annotation.Nullable Long audienceId, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable String albumIds, @javax.annotation.Nullable Long reportId, @javax.annotation.Nullable String reportParams, @javax.annotation.Nullable String endpointURL, @javax.annotation.Nullable Long scheduledDate, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String cronExpression, @javax.annotation.Nullable String cronType, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable String conditionalInput, @javax.annotation.Nullable String templateType, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable String errorMessage, @javax.annotation.Nullable String status, @javax.annotation.Nullable Boolean updateByGroupingId, @javax.annotation.Nullable Boolean sendNow, @javax.annotation.Nullable String eventType, @javax.annotation.Nullable String deepLinkURI, @javax.annotation.Nullable Boolean sendToAll, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling updateScheduledNotification(Async)");
        }

        // verify the required parameter 'scheduledNotificationId' is set
        if (scheduledNotificationId == null) {
            throw new ApiException("Missing the required parameter 'scheduledNotificationId' when calling updateScheduledNotification(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling updateScheduledNotification(Async)");
        }

        return updateScheduledNotificationCall(version, scheduledNotificationId, accountId, name, type, message, payload, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, errorMessage, status, updateByGroupingId, sendNow, eventType, deepLinkURI, sendToAll, _callback);

    }

    /**
     * Update Scheduled Notification
     * This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.
     * @param version  (required)
     * @param scheduledNotificationId The id of scheduled notification to update (required)
     * @param accountId The logged in user. (required)
     * @param name The name of the scheduled notification (optional)
     * @param type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (optional)
     * @param message The message to send (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param contentId The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentName The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentType The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentId The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentType The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param appKey The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param groupingId Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param connectionGroupIds The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param connectionAccountIds The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param audienceId This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param audienceIds The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param albumIds The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param reportId The report used to generate the the list of recipients (optional)
     * @param reportParams The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param scheduledDate The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param startDate The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param endDate The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param cronExpression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param cronType The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param metaData Additional metadata for the scheduled notification (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param templateType This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. (optional)
     * @param errorMessage the error message associated with the scheduled notification (optional)
     * @param status the status of the scheduled notification (optional)
     * @param updateByGroupingId also updates ScheduledNotifications with the same groupingId and account (optional)
     * @param sendNow whether to send the scheduled notification now or not (optional)
     * @param eventType Sets the event type for the notification (optional, default to CUSTOM)
     * @param deepLinkURI The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param sendToAll Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @return ScheduledNotificationFullResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ScheduledNotificationFullResponse updateScheduledNotification(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long scheduledNotificationId, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable String name, @javax.annotation.Nullable String type, @javax.annotation.Nullable String message, @javax.annotation.Nullable String payload, @javax.annotation.Nullable Long contentId, @javax.annotation.Nullable String contentName, @javax.annotation.Nullable String contentType, @javax.annotation.Nullable Long parentId, @javax.annotation.Nullable String parentType, @javax.annotation.Nullable String appKey, @javax.annotation.Nullable String groupingId, @javax.annotation.Nullable String connectionGroupIds, @javax.annotation.Nullable String connectionAccountIds, @javax.annotation.Nullable Long audienceId, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable String albumIds, @javax.annotation.Nullable Long reportId, @javax.annotation.Nullable String reportParams, @javax.annotation.Nullable String endpointURL, @javax.annotation.Nullable Long scheduledDate, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String cronExpression, @javax.annotation.Nullable String cronType, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable String conditionalInput, @javax.annotation.Nullable String templateType, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable String errorMessage, @javax.annotation.Nullable String status, @javax.annotation.Nullable Boolean updateByGroupingId, @javax.annotation.Nullable Boolean sendNow, @javax.annotation.Nullable String eventType, @javax.annotation.Nullable String deepLinkURI, @javax.annotation.Nullable Boolean sendToAll) throws ApiException {
        ApiResponse<ScheduledNotificationFullResponse> localVarResp = updateScheduledNotificationWithHttpInfo(version, scheduledNotificationId, accountId, name, type, message, payload, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, errorMessage, status, updateByGroupingId, sendNow, eventType, deepLinkURI, sendToAll);
        return localVarResp.getData();
    }

    /**
     * Update Scheduled Notification
     * This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.
     * @param version  (required)
     * @param scheduledNotificationId The id of scheduled notification to update (required)
     * @param accountId The logged in user. (required)
     * @param name The name of the scheduled notification (optional)
     * @param type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (optional)
     * @param message The message to send (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param contentId The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentName The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentType The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentId The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentType The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param appKey The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param groupingId Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param connectionGroupIds The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param connectionAccountIds The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param audienceId This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param audienceIds The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param albumIds The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param reportId The report used to generate the the list of recipients (optional)
     * @param reportParams The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param scheduledDate The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param startDate The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param endDate The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param cronExpression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param cronType The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param metaData Additional metadata for the scheduled notification (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param templateType This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. (optional)
     * @param errorMessage the error message associated with the scheduled notification (optional)
     * @param status the status of the scheduled notification (optional)
     * @param updateByGroupingId also updates ScheduledNotifications with the same groupingId and account (optional)
     * @param sendNow whether to send the scheduled notification now or not (optional)
     * @param eventType Sets the event type for the notification (optional, default to CUSTOM)
     * @param deepLinkURI The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param sendToAll Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @return ApiResponse&lt;ScheduledNotificationFullResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ScheduledNotificationFullResponse> updateScheduledNotificationWithHttpInfo(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long scheduledNotificationId, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable String name, @javax.annotation.Nullable String type, @javax.annotation.Nullable String message, @javax.annotation.Nullable String payload, @javax.annotation.Nullable Long contentId, @javax.annotation.Nullable String contentName, @javax.annotation.Nullable String contentType, @javax.annotation.Nullable Long parentId, @javax.annotation.Nullable String parentType, @javax.annotation.Nullable String appKey, @javax.annotation.Nullable String groupingId, @javax.annotation.Nullable String connectionGroupIds, @javax.annotation.Nullable String connectionAccountIds, @javax.annotation.Nullable Long audienceId, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable String albumIds, @javax.annotation.Nullable Long reportId, @javax.annotation.Nullable String reportParams, @javax.annotation.Nullable String endpointURL, @javax.annotation.Nullable Long scheduledDate, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String cronExpression, @javax.annotation.Nullable String cronType, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable String conditionalInput, @javax.annotation.Nullable String templateType, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable String errorMessage, @javax.annotation.Nullable String status, @javax.annotation.Nullable Boolean updateByGroupingId, @javax.annotation.Nullable Boolean sendNow, @javax.annotation.Nullable String eventType, @javax.annotation.Nullable String deepLinkURI, @javax.annotation.Nullable Boolean sendToAll) throws ApiException {
        okhttp3.Call localVarCall = updateScheduledNotificationValidateBeforeCall(version, scheduledNotificationId, accountId, name, type, message, payload, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, errorMessage, status, updateByGroupingId, sendNow, eventType, deepLinkURI, sendToAll, null);
        Type localVarReturnType = new TypeToken<ScheduledNotificationFullResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Scheduled Notification (asynchronously)
     * This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.
     * @param version  (required)
     * @param scheduledNotificationId The id of scheduled notification to update (required)
     * @param accountId The logged in user. (required)
     * @param name The name of the scheduled notification (optional)
     * @param type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (optional)
     * @param message The message to send (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param contentId The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentName The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentType The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentId The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentType The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param appKey The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param groupingId Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param connectionGroupIds The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param connectionAccountIds The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param audienceId This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param audienceIds The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param albumIds The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param reportId The report used to generate the the list of recipients (optional)
     * @param reportParams The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param scheduledDate The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param startDate The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param endDate The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param cronExpression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param cronType The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param metaData Additional metadata for the scheduled notification (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param templateType This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. (optional)
     * @param errorMessage the error message associated with the scheduled notification (optional)
     * @param status the status of the scheduled notification (optional)
     * @param updateByGroupingId also updates ScheduledNotifications with the same groupingId and account (optional)
     * @param sendNow whether to send the scheduled notification now or not (optional)
     * @param eventType Sets the event type for the notification (optional, default to CUSTOM)
     * @param deepLinkURI The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param sendToAll Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateScheduledNotificationAsync(@javax.annotation.Nonnull BigDecimal version, @javax.annotation.Nonnull Long scheduledNotificationId, @javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable String name, @javax.annotation.Nullable String type, @javax.annotation.Nullable String message, @javax.annotation.Nullable String payload, @javax.annotation.Nullable Long contentId, @javax.annotation.Nullable String contentName, @javax.annotation.Nullable String contentType, @javax.annotation.Nullable Long parentId, @javax.annotation.Nullable String parentType, @javax.annotation.Nullable String appKey, @javax.annotation.Nullable String groupingId, @javax.annotation.Nullable String connectionGroupIds, @javax.annotation.Nullable String connectionAccountIds, @javax.annotation.Nullable Long audienceId, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable String albumIds, @javax.annotation.Nullable Long reportId, @javax.annotation.Nullable String reportParams, @javax.annotation.Nullable String endpointURL, @javax.annotation.Nullable Long scheduledDate, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable Long endDate, @javax.annotation.Nullable String cronExpression, @javax.annotation.Nullable String cronType, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable String conditionalInput, @javax.annotation.Nullable String templateType, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable String errorMessage, @javax.annotation.Nullable String status, @javax.annotation.Nullable Boolean updateByGroupingId, @javax.annotation.Nullable Boolean sendNow, @javax.annotation.Nullable String eventType, @javax.annotation.Nullable String deepLinkURI, @javax.annotation.Nullable Boolean sendToAll, final ApiCallback<ScheduledNotificationFullResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateScheduledNotificationValidateBeforeCall(version, scheduledNotificationId, accountId, name, type, message, payload, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, errorMessage, status, updateByGroupingId, sendNow, eventType, deepLinkURI, sendToAll, _callback);
        Type localVarReturnType = new TypeToken<ScheduledNotificationFullResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
