/*
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.MissionShortResponse;
import org.openapitools.client.model.SirqulResponse;
import org.openapitools.client.model.TournamentResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class TournamentApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public TournamentApi() {
        this(Configuration.getDefaultApiClient());
    }

    public TournamentApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for createTournament
     * @param accountId The logged in user. (required)
     * @param appKey The appKey the tournament is created for. (required)
     * @param title The title of the tournament (required)
     * @param costToPlay The number of tickets required to pay to enter the tournament (required)
     * @param startDate The date/time to start the tournament (required)
     * @param subType Custom string client apps can use for searching/filtering tournaments (optional)
     * @param imageAssetId The asset ID to attach to the tournament (optional)
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game/group (optional, default to 600)
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker (optional, default to 600)
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round (optional, default to 86400)
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional, default to 1800)
     * @param costToPlayType The type of ticket required to pay (optional)
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played (optional, default to 1)
     * @param startingLimit The starting number of players for a tournament (filled with AI&#39;s) (optional)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced) (optional)
     * @param description The description of the tournament (optional)
     * @param metaData External custom client defined data (optional)
     * @param audienceIds The audiences associated with the tournament (optional)
     * @param active Activate/deactivate the tournament (optional)
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament (optional, default to false)
     * @param offerIds The list of offers to give as a reward beyond the tickets (optional)
     * @param offerAssetId The artwork ID to attach to the reward tickets offers (optional)
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided (optional, default to false)
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional, default to ALL)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content (optional)
     * @param missionType The style of tournament to build, options are: TOURNAMENT, POOLPLAY (optional, default to MULTISTAGE)
     * @param visibility Sets the visibility flag for the tournament (optional, default to PUBLIC)
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional, default to 1)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional, default to 1)
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional, default to false)
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional, default to false)
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not (optional, default to false)
     * @param winnerTag This sets what analytic tag is used when a winner is determined (optional)
     * @param tieTag This sets what analytic tag is used when a tie has occurred (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createTournamentCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull String title, @javax.annotation.Nonnull Integer costToPlay, @javax.annotation.Nonnull Long startDate, @javax.annotation.Nullable String subType, @javax.annotation.Nullable Long imageAssetId, @javax.annotation.Nullable Integer secondsBetweenLevels, @javax.annotation.Nullable Integer secondsForTieBreaker, @javax.annotation.Nullable Integer secondsBetweenPacks, @javax.annotation.Nullable Integer maximumLevelLength, @javax.annotation.Nullable String costToPlayType, @javax.annotation.Nullable Integer minimumToPlay, @javax.annotation.Nullable Integer startingLimit, @javax.annotation.Nullable Integer availableLimit, @javax.annotation.Nullable String description, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable Boolean enableBuyBack, @javax.annotation.Nullable String offerIds, @javax.annotation.Nullable Long offerAssetId, @javax.annotation.Nullable Boolean fixedReward, @javax.annotation.Nullable String splitReward, @javax.annotation.Nullable Boolean allocateTickets, @javax.annotation.Nullable String tournamentData, @javax.annotation.Nullable String missionType, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Integer preliminaryGroups, @javax.annotation.Nullable String preliminaryGroupAdvancements, @javax.annotation.Nullable Boolean enableMultipleEntries, @javax.annotation.Nullable Boolean enableMultipleVotes, @javax.annotation.Nullable Boolean featured, @javax.annotation.Nullable String winnerTag, @javax.annotation.Nullable String tieTag, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tournament/create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (appKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appKey", appKey));
        }

        if (title != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("title", title));
        }

        if (subType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subType", subType));
        }

        if (imageAssetId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("imageAssetId", imageAssetId));
        }

        if (secondsBetweenLevels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secondsBetweenLevels", secondsBetweenLevels));
        }

        if (secondsForTieBreaker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secondsForTieBreaker", secondsForTieBreaker));
        }

        if (secondsBetweenPacks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secondsBetweenPacks", secondsBetweenPacks));
        }

        if (maximumLevelLength != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maximumLevelLength", maximumLevelLength));
        }

        if (costToPlay != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("costToPlay", costToPlay));
        }

        if (costToPlayType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("costToPlayType", costToPlayType));
        }

        if (minimumToPlay != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minimumToPlay", minimumToPlay));
        }

        if (startingLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startingLimit", startingLimit));
        }

        if (availableLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("availableLimit", availableLimit));
        }

        if (description != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("description", description));
        }

        if (metaData != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("metaData", metaData));
        }

        if (startDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startDate", startDate));
        }

        if (audienceIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audienceIds", audienceIds));
        }

        if (active != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("active", active));
        }

        if (enableBuyBack != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableBuyBack", enableBuyBack));
        }

        if (offerIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offerIds", offerIds));
        }

        if (offerAssetId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offerAssetId", offerAssetId));
        }

        if (fixedReward != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fixedReward", fixedReward));
        }

        if (splitReward != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("splitReward", splitReward));
        }

        if (allocateTickets != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allocateTickets", allocateTickets));
        }

        if (tournamentData != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tournamentData", tournamentData));
        }

        if (missionType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("missionType", missionType));
        }

        if (visibility != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("visibility", visibility));
        }

        if (preliminaryGroups != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("preliminaryGroups", preliminaryGroups));
        }

        if (preliminaryGroupAdvancements != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("preliminaryGroupAdvancements", preliminaryGroupAdvancements));
        }

        if (enableMultipleEntries != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableMultipleEntries", enableMultipleEntries));
        }

        if (enableMultipleVotes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableMultipleVotes", enableMultipleVotes));
        }

        if (featured != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("featured", featured));
        }

        if (winnerTag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("winnerTag", winnerTag));
        }

        if (tieTag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tieTag", tieTag));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createTournamentValidateBeforeCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull String title, @javax.annotation.Nonnull Integer costToPlay, @javax.annotation.Nonnull Long startDate, @javax.annotation.Nullable String subType, @javax.annotation.Nullable Long imageAssetId, @javax.annotation.Nullable Integer secondsBetweenLevels, @javax.annotation.Nullable Integer secondsForTieBreaker, @javax.annotation.Nullable Integer secondsBetweenPacks, @javax.annotation.Nullable Integer maximumLevelLength, @javax.annotation.Nullable String costToPlayType, @javax.annotation.Nullable Integer minimumToPlay, @javax.annotation.Nullable Integer startingLimit, @javax.annotation.Nullable Integer availableLimit, @javax.annotation.Nullable String description, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable Boolean enableBuyBack, @javax.annotation.Nullable String offerIds, @javax.annotation.Nullable Long offerAssetId, @javax.annotation.Nullable Boolean fixedReward, @javax.annotation.Nullable String splitReward, @javax.annotation.Nullable Boolean allocateTickets, @javax.annotation.Nullable String tournamentData, @javax.annotation.Nullable String missionType, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Integer preliminaryGroups, @javax.annotation.Nullable String preliminaryGroupAdvancements, @javax.annotation.Nullable Boolean enableMultipleEntries, @javax.annotation.Nullable Boolean enableMultipleVotes, @javax.annotation.Nullable Boolean featured, @javax.annotation.Nullable String winnerTag, @javax.annotation.Nullable String tieTag, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling createTournament(Async)");
        }

        // verify the required parameter 'appKey' is set
        if (appKey == null) {
            throw new ApiException("Missing the required parameter 'appKey' when calling createTournament(Async)");
        }

        // verify the required parameter 'title' is set
        if (title == null) {
            throw new ApiException("Missing the required parameter 'title' when calling createTournament(Async)");
        }

        // verify the required parameter 'costToPlay' is set
        if (costToPlay == null) {
            throw new ApiException("Missing the required parameter 'costToPlay' when calling createTournament(Async)");
        }

        // verify the required parameter 'startDate' is set
        if (startDate == null) {
            throw new ApiException("Missing the required parameter 'startDate' when calling createTournament(Async)");
        }

        return createTournamentCall(accountId, appKey, title, costToPlay, startDate, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, missionType, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag, _callback);

    }

    /**
     * Create Tournament
     * Create a tournament.
     * @param accountId The logged in user. (required)
     * @param appKey The appKey the tournament is created for. (required)
     * @param title The title of the tournament (required)
     * @param costToPlay The number of tickets required to pay to enter the tournament (required)
     * @param startDate The date/time to start the tournament (required)
     * @param subType Custom string client apps can use for searching/filtering tournaments (optional)
     * @param imageAssetId The asset ID to attach to the tournament (optional)
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game/group (optional, default to 600)
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker (optional, default to 600)
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round (optional, default to 86400)
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional, default to 1800)
     * @param costToPlayType The type of ticket required to pay (optional)
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played (optional, default to 1)
     * @param startingLimit The starting number of players for a tournament (filled with AI&#39;s) (optional)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced) (optional)
     * @param description The description of the tournament (optional)
     * @param metaData External custom client defined data (optional)
     * @param audienceIds The audiences associated with the tournament (optional)
     * @param active Activate/deactivate the tournament (optional)
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament (optional, default to false)
     * @param offerIds The list of offers to give as a reward beyond the tickets (optional)
     * @param offerAssetId The artwork ID to attach to the reward tickets offers (optional)
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided (optional, default to false)
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional, default to ALL)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content (optional)
     * @param missionType The style of tournament to build, options are: TOURNAMENT, POOLPLAY (optional, default to MULTISTAGE)
     * @param visibility Sets the visibility flag for the tournament (optional, default to PUBLIC)
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional, default to 1)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional, default to 1)
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional, default to false)
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional, default to false)
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not (optional, default to false)
     * @param winnerTag This sets what analytic tag is used when a winner is determined (optional)
     * @param tieTag This sets what analytic tag is used when a tie has occurred (optional)
     * @return TournamentResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public TournamentResponse createTournament(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull String title, @javax.annotation.Nonnull Integer costToPlay, @javax.annotation.Nonnull Long startDate, @javax.annotation.Nullable String subType, @javax.annotation.Nullable Long imageAssetId, @javax.annotation.Nullable Integer secondsBetweenLevels, @javax.annotation.Nullable Integer secondsForTieBreaker, @javax.annotation.Nullable Integer secondsBetweenPacks, @javax.annotation.Nullable Integer maximumLevelLength, @javax.annotation.Nullable String costToPlayType, @javax.annotation.Nullable Integer minimumToPlay, @javax.annotation.Nullable Integer startingLimit, @javax.annotation.Nullable Integer availableLimit, @javax.annotation.Nullable String description, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable Boolean enableBuyBack, @javax.annotation.Nullable String offerIds, @javax.annotation.Nullable Long offerAssetId, @javax.annotation.Nullable Boolean fixedReward, @javax.annotation.Nullable String splitReward, @javax.annotation.Nullable Boolean allocateTickets, @javax.annotation.Nullable String tournamentData, @javax.annotation.Nullable String missionType, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Integer preliminaryGroups, @javax.annotation.Nullable String preliminaryGroupAdvancements, @javax.annotation.Nullable Boolean enableMultipleEntries, @javax.annotation.Nullable Boolean enableMultipleVotes, @javax.annotation.Nullable Boolean featured, @javax.annotation.Nullable String winnerTag, @javax.annotation.Nullable String tieTag) throws ApiException {
        ApiResponse<TournamentResponse> localVarResp = createTournamentWithHttpInfo(accountId, appKey, title, costToPlay, startDate, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, missionType, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag);
        return localVarResp.getData();
    }

    /**
     * Create Tournament
     * Create a tournament.
     * @param accountId The logged in user. (required)
     * @param appKey The appKey the tournament is created for. (required)
     * @param title The title of the tournament (required)
     * @param costToPlay The number of tickets required to pay to enter the tournament (required)
     * @param startDate The date/time to start the tournament (required)
     * @param subType Custom string client apps can use for searching/filtering tournaments (optional)
     * @param imageAssetId The asset ID to attach to the tournament (optional)
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game/group (optional, default to 600)
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker (optional, default to 600)
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round (optional, default to 86400)
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional, default to 1800)
     * @param costToPlayType The type of ticket required to pay (optional)
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played (optional, default to 1)
     * @param startingLimit The starting number of players for a tournament (filled with AI&#39;s) (optional)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced) (optional)
     * @param description The description of the tournament (optional)
     * @param metaData External custom client defined data (optional)
     * @param audienceIds The audiences associated with the tournament (optional)
     * @param active Activate/deactivate the tournament (optional)
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament (optional, default to false)
     * @param offerIds The list of offers to give as a reward beyond the tickets (optional)
     * @param offerAssetId The artwork ID to attach to the reward tickets offers (optional)
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided (optional, default to false)
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional, default to ALL)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content (optional)
     * @param missionType The style of tournament to build, options are: TOURNAMENT, POOLPLAY (optional, default to MULTISTAGE)
     * @param visibility Sets the visibility flag for the tournament (optional, default to PUBLIC)
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional, default to 1)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional, default to 1)
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional, default to false)
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional, default to false)
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not (optional, default to false)
     * @param winnerTag This sets what analytic tag is used when a winner is determined (optional)
     * @param tieTag This sets what analytic tag is used when a tie has occurred (optional)
     * @return ApiResponse&lt;TournamentResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TournamentResponse> createTournamentWithHttpInfo(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull String title, @javax.annotation.Nonnull Integer costToPlay, @javax.annotation.Nonnull Long startDate, @javax.annotation.Nullable String subType, @javax.annotation.Nullable Long imageAssetId, @javax.annotation.Nullable Integer secondsBetweenLevels, @javax.annotation.Nullable Integer secondsForTieBreaker, @javax.annotation.Nullable Integer secondsBetweenPacks, @javax.annotation.Nullable Integer maximumLevelLength, @javax.annotation.Nullable String costToPlayType, @javax.annotation.Nullable Integer minimumToPlay, @javax.annotation.Nullable Integer startingLimit, @javax.annotation.Nullable Integer availableLimit, @javax.annotation.Nullable String description, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable Boolean enableBuyBack, @javax.annotation.Nullable String offerIds, @javax.annotation.Nullable Long offerAssetId, @javax.annotation.Nullable Boolean fixedReward, @javax.annotation.Nullable String splitReward, @javax.annotation.Nullable Boolean allocateTickets, @javax.annotation.Nullable String tournamentData, @javax.annotation.Nullable String missionType, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Integer preliminaryGroups, @javax.annotation.Nullable String preliminaryGroupAdvancements, @javax.annotation.Nullable Boolean enableMultipleEntries, @javax.annotation.Nullable Boolean enableMultipleVotes, @javax.annotation.Nullable Boolean featured, @javax.annotation.Nullable String winnerTag, @javax.annotation.Nullable String tieTag) throws ApiException {
        okhttp3.Call localVarCall = createTournamentValidateBeforeCall(accountId, appKey, title, costToPlay, startDate, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, missionType, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag, null);
        Type localVarReturnType = new TypeToken<TournamentResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Tournament (asynchronously)
     * Create a tournament.
     * @param accountId The logged in user. (required)
     * @param appKey The appKey the tournament is created for. (required)
     * @param title The title of the tournament (required)
     * @param costToPlay The number of tickets required to pay to enter the tournament (required)
     * @param startDate The date/time to start the tournament (required)
     * @param subType Custom string client apps can use for searching/filtering tournaments (optional)
     * @param imageAssetId The asset ID to attach to the tournament (optional)
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game/group (optional, default to 600)
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker (optional, default to 600)
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round (optional, default to 86400)
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional, default to 1800)
     * @param costToPlayType The type of ticket required to pay (optional)
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played (optional, default to 1)
     * @param startingLimit The starting number of players for a tournament (filled with AI&#39;s) (optional)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced) (optional)
     * @param description The description of the tournament (optional)
     * @param metaData External custom client defined data (optional)
     * @param audienceIds The audiences associated with the tournament (optional)
     * @param active Activate/deactivate the tournament (optional)
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament (optional, default to false)
     * @param offerIds The list of offers to give as a reward beyond the tickets (optional)
     * @param offerAssetId The artwork ID to attach to the reward tickets offers (optional)
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided (optional, default to false)
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional, default to ALL)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content (optional)
     * @param missionType The style of tournament to build, options are: TOURNAMENT, POOLPLAY (optional, default to MULTISTAGE)
     * @param visibility Sets the visibility flag for the tournament (optional, default to PUBLIC)
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional, default to 1)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional, default to 1)
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional, default to false)
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional, default to false)
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not (optional, default to false)
     * @param winnerTag This sets what analytic tag is used when a winner is determined (optional)
     * @param tieTag This sets what analytic tag is used when a tie has occurred (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createTournamentAsync(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull String title, @javax.annotation.Nonnull Integer costToPlay, @javax.annotation.Nonnull Long startDate, @javax.annotation.Nullable String subType, @javax.annotation.Nullable Long imageAssetId, @javax.annotation.Nullable Integer secondsBetweenLevels, @javax.annotation.Nullable Integer secondsForTieBreaker, @javax.annotation.Nullable Integer secondsBetweenPacks, @javax.annotation.Nullable Integer maximumLevelLength, @javax.annotation.Nullable String costToPlayType, @javax.annotation.Nullable Integer minimumToPlay, @javax.annotation.Nullable Integer startingLimit, @javax.annotation.Nullable Integer availableLimit, @javax.annotation.Nullable String description, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable Boolean enableBuyBack, @javax.annotation.Nullable String offerIds, @javax.annotation.Nullable Long offerAssetId, @javax.annotation.Nullable Boolean fixedReward, @javax.annotation.Nullable String splitReward, @javax.annotation.Nullable Boolean allocateTickets, @javax.annotation.Nullable String tournamentData, @javax.annotation.Nullable String missionType, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Integer preliminaryGroups, @javax.annotation.Nullable String preliminaryGroupAdvancements, @javax.annotation.Nullable Boolean enableMultipleEntries, @javax.annotation.Nullable Boolean enableMultipleVotes, @javax.annotation.Nullable Boolean featured, @javax.annotation.Nullable String winnerTag, @javax.annotation.Nullable String tieTag, final ApiCallback<TournamentResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createTournamentValidateBeforeCall(accountId, appKey, title, costToPlay, startDate, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, missionType, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag, _callback);
        Type localVarReturnType = new TypeToken<TournamentResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteTournament
     * @param accountId the id of the logged in user (required)
     * @param missionId the id of the mission to delete (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteTournamentCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long missionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tournament/delete";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (missionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("missionId", missionId));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteTournamentValidateBeforeCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long missionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling deleteTournament(Async)");
        }

        // verify the required parameter 'missionId' is set
        if (missionId == null) {
            throw new ApiException("Missing the required parameter 'missionId' when calling deleteTournament(Async)");
        }

        return deleteTournamentCall(accountId, missionId, _callback);

    }

    /**
     * Delete Tournament
     * Delete a tournament.
     * @param accountId the id of the logged in user (required)
     * @param missionId the id of the mission to delete (required)
     * @return SirqulResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public SirqulResponse deleteTournament(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long missionId) throws ApiException {
        ApiResponse<SirqulResponse> localVarResp = deleteTournamentWithHttpInfo(accountId, missionId);
        return localVarResp.getData();
    }

    /**
     * Delete Tournament
     * Delete a tournament.
     * @param accountId the id of the logged in user (required)
     * @param missionId the id of the mission to delete (required)
     * @return ApiResponse&lt;SirqulResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SirqulResponse> deleteTournamentWithHttpInfo(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long missionId) throws ApiException {
        okhttp3.Call localVarCall = deleteTournamentValidateBeforeCall(accountId, missionId, null);
        Type localVarReturnType = new TypeToken<SirqulResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete Tournament (asynchronously)
     * Delete a tournament.
     * @param accountId the id of the logged in user (required)
     * @param missionId the id of the mission to delete (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteTournamentAsync(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long missionId, final ApiCallback<SirqulResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteTournamentValidateBeforeCall(accountId, missionId, _callback);
        Type localVarReturnType = new TypeToken<SirqulResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getTournament
     * @param accountId The id of the logged in user (required)
     * @param missionId The id of the mission to return (either missionId or joinCode is required) (optional)
     * @param joinCode Optional identifier for getting the tournament (either missionId or joinCode is required) (optional)
     * @param includeScores Determines which type of scores are returned. Possible values include: ALL, MINE (optional)
     * @param objectPreviewSize Determines the max number of game objects that will get returned for each game level response (optional, default to 50)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTournamentCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable Long missionId, @javax.annotation.Nullable String joinCode, @javax.annotation.Nullable String includeScores, @javax.annotation.Nullable Integer objectPreviewSize, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tournament/get";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (missionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("missionId", missionId));
        }

        if (joinCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("joinCode", joinCode));
        }

        if (includeScores != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeScores", includeScores));
        }

        if (objectPreviewSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("objectPreviewSize", objectPreviewSize));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTournamentValidateBeforeCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable Long missionId, @javax.annotation.Nullable String joinCode, @javax.annotation.Nullable String includeScores, @javax.annotation.Nullable Integer objectPreviewSize, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling getTournament(Async)");
        }

        return getTournamentCall(accountId, missionId, joinCode, includeScores, objectPreviewSize, _callback);

    }

    /**
     * Get Tournament
     * Get a tournament.
     * @param accountId The id of the logged in user (required)
     * @param missionId The id of the mission to return (either missionId or joinCode is required) (optional)
     * @param joinCode Optional identifier for getting the tournament (either missionId or joinCode is required) (optional)
     * @param includeScores Determines which type of scores are returned. Possible values include: ALL, MINE (optional)
     * @param objectPreviewSize Determines the max number of game objects that will get returned for each game level response (optional, default to 50)
     * @return TournamentResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public TournamentResponse getTournament(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable Long missionId, @javax.annotation.Nullable String joinCode, @javax.annotation.Nullable String includeScores, @javax.annotation.Nullable Integer objectPreviewSize) throws ApiException {
        ApiResponse<TournamentResponse> localVarResp = getTournamentWithHttpInfo(accountId, missionId, joinCode, includeScores, objectPreviewSize);
        return localVarResp.getData();
    }

    /**
     * Get Tournament
     * Get a tournament.
     * @param accountId The id of the logged in user (required)
     * @param missionId The id of the mission to return (either missionId or joinCode is required) (optional)
     * @param joinCode Optional identifier for getting the tournament (either missionId or joinCode is required) (optional)
     * @param includeScores Determines which type of scores are returned. Possible values include: ALL, MINE (optional)
     * @param objectPreviewSize Determines the max number of game objects that will get returned for each game level response (optional, default to 50)
     * @return ApiResponse&lt;TournamentResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TournamentResponse> getTournamentWithHttpInfo(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable Long missionId, @javax.annotation.Nullable String joinCode, @javax.annotation.Nullable String includeScores, @javax.annotation.Nullable Integer objectPreviewSize) throws ApiException {
        okhttp3.Call localVarCall = getTournamentValidateBeforeCall(accountId, missionId, joinCode, includeScores, objectPreviewSize, null);
        Type localVarReturnType = new TypeToken<TournamentResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Tournament (asynchronously)
     * Get a tournament.
     * @param accountId The id of the logged in user (required)
     * @param missionId The id of the mission to return (either missionId or joinCode is required) (optional)
     * @param joinCode Optional identifier for getting the tournament (either missionId or joinCode is required) (optional)
     * @param includeScores Determines which type of scores are returned. Possible values include: ALL, MINE (optional)
     * @param objectPreviewSize Determines the max number of game objects that will get returned for each game level response (optional, default to 50)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTournamentAsync(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nullable Long missionId, @javax.annotation.Nullable String joinCode, @javax.annotation.Nullable String includeScores, @javax.annotation.Nullable Integer objectPreviewSize, final ApiCallback<TournamentResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTournamentValidateBeforeCall(accountId, missionId, joinCode, includeScores, objectPreviewSize, _callback);
        Type localVarReturnType = new TypeToken<TournamentResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchObjects
     * @param accountId the account ID (required)
     * @param gameLevelId the game level id to filter results by (required)
     * @param sortField the field to sort by (optional, default to PLAYER_SCORE_COUNT)
     * @param descending determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchObjectsCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long gameLevelId, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tournament/object/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (gameLevelId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("gameLevelId", gameLevelId));
        }

        if (sortField != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sortField", sortField));
        }

        if (descending != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("descending", descending));
        }

        if (start != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start", start));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchObjectsValidateBeforeCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long gameLevelId, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling searchObjects(Async)");
        }

        // verify the required parameter 'gameLevelId' is set
        if (gameLevelId == null) {
            throw new ApiException("Missing the required parameter 'gameLevelId' when calling searchObjects(Async)");
        }

        return searchObjectsCall(accountId, gameLevelId, sortField, descending, start, limit, _callback);

    }

    /**
     * Search Tournament Objects
     * Search on game objects of tournaments
     * @param accountId the account ID (required)
     * @param gameLevelId the game level id to filter results by (required)
     * @param sortField the field to sort by (optional, default to PLAYER_SCORE_COUNT)
     * @param descending determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @return SirqulResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public SirqulResponse searchObjects(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long gameLevelId, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit) throws ApiException {
        ApiResponse<SirqulResponse> localVarResp = searchObjectsWithHttpInfo(accountId, gameLevelId, sortField, descending, start, limit);
        return localVarResp.getData();
    }

    /**
     * Search Tournament Objects
     * Search on game objects of tournaments
     * @param accountId the account ID (required)
     * @param gameLevelId the game level id to filter results by (required)
     * @param sortField the field to sort by (optional, default to PLAYER_SCORE_COUNT)
     * @param descending determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @return ApiResponse&lt;SirqulResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SirqulResponse> searchObjectsWithHttpInfo(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long gameLevelId, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit) throws ApiException {
        okhttp3.Call localVarCall = searchObjectsValidateBeforeCall(accountId, gameLevelId, sortField, descending, start, limit, null);
        Type localVarReturnType = new TypeToken<SirqulResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search Tournament Objects (asynchronously)
     * Search on game objects of tournaments
     * @param accountId the account ID (required)
     * @param gameLevelId the game level id to filter results by (required)
     * @param sortField the field to sort by (optional, default to PLAYER_SCORE_COUNT)
     * @param descending determines whether the sorted list is in descending or ascending order (optional, default to true)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchObjectsAsync(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long gameLevelId, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, final ApiCallback<SirqulResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchObjectsValidateBeforeCall(accountId, gameLevelId, sortField, descending, start, limit, _callback);
        Type localVarReturnType = new TypeToken<SirqulResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchRounds
     * @param accountId the account ID (required)
     * @param appKey the application key (required)
     * @param status comma separated list of statuses to filter results by (optional, default to ACCEPTED,ACTIVE)
     * @param missionType The style of tournament to search for, options are: TOURNAMENT, POOLPLAY (optional)
     * @param currentOnly search for games that are flagged current only (optional, default to true)
     * @param visibilities Filter tournament rounds by the mission visibility flag (optional, default to PUBLIC)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchRoundsCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nullable String status, @javax.annotation.Nullable String missionType, @javax.annotation.Nullable Boolean currentOnly, @javax.annotation.Nullable String visibilities, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tournament/round/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (appKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appKey", appKey));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (missionType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("missionType", missionType));
        }

        if (currentOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currentOnly", currentOnly));
        }

        if (visibilities != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("visibilities", visibilities));
        }

        if (start != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start", start));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchRoundsValidateBeforeCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nullable String status, @javax.annotation.Nullable String missionType, @javax.annotation.Nullable Boolean currentOnly, @javax.annotation.Nullable String visibilities, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling searchRounds(Async)");
        }

        // verify the required parameter 'appKey' is set
        if (appKey == null) {
            throw new ApiException("Missing the required parameter 'appKey' when calling searchRounds(Async)");
        }

        return searchRoundsCall(accountId, appKey, status, missionType, currentOnly, visibilities, start, limit, _callback);

    }

    /**
     * Search Tournament Rounds
     * Search for the user&#39;s tournament games.
     * @param accountId the account ID (required)
     * @param appKey the application key (required)
     * @param status comma separated list of statuses to filter results by (optional, default to ACCEPTED,ACTIVE)
     * @param missionType The style of tournament to search for, options are: TOURNAMENT, POOLPLAY (optional)
     * @param currentOnly search for games that are flagged current only (optional, default to true)
     * @param visibilities Filter tournament rounds by the mission visibility flag (optional, default to PUBLIC)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @return SirqulResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public SirqulResponse searchRounds(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nullable String status, @javax.annotation.Nullable String missionType, @javax.annotation.Nullable Boolean currentOnly, @javax.annotation.Nullable String visibilities, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit) throws ApiException {
        ApiResponse<SirqulResponse> localVarResp = searchRoundsWithHttpInfo(accountId, appKey, status, missionType, currentOnly, visibilities, start, limit);
        return localVarResp.getData();
    }

    /**
     * Search Tournament Rounds
     * Search for the user&#39;s tournament games.
     * @param accountId the account ID (required)
     * @param appKey the application key (required)
     * @param status comma separated list of statuses to filter results by (optional, default to ACCEPTED,ACTIVE)
     * @param missionType The style of tournament to search for, options are: TOURNAMENT, POOLPLAY (optional)
     * @param currentOnly search for games that are flagged current only (optional, default to true)
     * @param visibilities Filter tournament rounds by the mission visibility flag (optional, default to PUBLIC)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @return ApiResponse&lt;SirqulResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SirqulResponse> searchRoundsWithHttpInfo(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nullable String status, @javax.annotation.Nullable String missionType, @javax.annotation.Nullable Boolean currentOnly, @javax.annotation.Nullable String visibilities, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit) throws ApiException {
        okhttp3.Call localVarCall = searchRoundsValidateBeforeCall(accountId, appKey, status, missionType, currentOnly, visibilities, start, limit, null);
        Type localVarReturnType = new TypeToken<SirqulResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search Tournament Rounds (asynchronously)
     * Search for the user&#39;s tournament games.
     * @param accountId the account ID (required)
     * @param appKey the application key (required)
     * @param status comma separated list of statuses to filter results by (optional, default to ACCEPTED,ACTIVE)
     * @param missionType The style of tournament to search for, options are: TOURNAMENT, POOLPLAY (optional)
     * @param currentOnly search for games that are flagged current only (optional, default to true)
     * @param visibilities Filter tournament rounds by the mission visibility flag (optional, default to PUBLIC)
     * @param start the start index for pagination (optional, default to 0)
     * @param limit the limit for pagination (optional, default to 20)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchRoundsAsync(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nullable String status, @javax.annotation.Nullable String missionType, @javax.annotation.Nullable Boolean currentOnly, @javax.annotation.Nullable String visibilities, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, final ApiCallback<SirqulResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchRoundsValidateBeforeCall(accountId, appKey, status, missionType, currentOnly, visibilities, start, limit, _callback);
        Type localVarReturnType = new TypeToken<SirqulResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchTournaments
     * @param accountId The logged in user. (required)
     * @param appKey The application key (required)
     * @param keyword the keyword to search tournament on (optional)
     * @param subType filter results by subType (optional)
     * @param includeInactive whether to include inactives in the search or not (optional, default to false)
     * @param missionTypes comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (optional, default to MULTISTAGE,TOURNAMENT,POOLPLAY)
     * @param filter filter tournaments by the tournament&#39;s current state (optional, default to UPCOMING)
     * @param sortField which field to sort on (optional, default to START_DATE)
     * @param descending Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false. (optional)
     * @param visibility Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (optional, default to PUBLIC)
     * @param start Start the result set at some index. (optional, default to 0)
     * @param limit Limit the result to some number (optional, default to 20)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchTournamentsCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nullable String keyword, @javax.annotation.Nullable String subType, @javax.annotation.Nullable Boolean includeInactive, @javax.annotation.Nullable String missionTypes, @javax.annotation.Nullable String filter, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tournament/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (appKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appKey", appKey));
        }

        if (keyword != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("keyword", keyword));
        }

        if (subType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subType", subType));
        }

        if (includeInactive != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeInactive", includeInactive));
        }

        if (missionTypes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("missionTypes", missionTypes));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (sortField != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sortField", sortField));
        }

        if (descending != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("descending", descending));
        }

        if (visibility != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("visibility", visibility));
        }

        if (start != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start", start));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchTournamentsValidateBeforeCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nullable String keyword, @javax.annotation.Nullable String subType, @javax.annotation.Nullable Boolean includeInactive, @javax.annotation.Nullable String missionTypes, @javax.annotation.Nullable String filter, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling searchTournaments(Async)");
        }

        // verify the required parameter 'appKey' is set
        if (appKey == null) {
            throw new ApiException("Missing the required parameter 'appKey' when calling searchTournaments(Async)");
        }

        return searchTournamentsCall(accountId, appKey, keyword, subType, includeInactive, missionTypes, filter, sortField, descending, visibility, start, limit, _callback);

    }

    /**
     * Search Tournaments
     * Search for tournaments
     * @param accountId The logged in user. (required)
     * @param appKey The application key (required)
     * @param keyword the keyword to search tournament on (optional)
     * @param subType filter results by subType (optional)
     * @param includeInactive whether to include inactives in the search or not (optional, default to false)
     * @param missionTypes comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (optional, default to MULTISTAGE,TOURNAMENT,POOLPLAY)
     * @param filter filter tournaments by the tournament&#39;s current state (optional, default to UPCOMING)
     * @param sortField which field to sort on (optional, default to START_DATE)
     * @param descending Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false. (optional)
     * @param visibility Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (optional, default to PUBLIC)
     * @param start Start the result set at some index. (optional, default to 0)
     * @param limit Limit the result to some number (optional, default to 20)
     * @return MissionShortResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public MissionShortResponse searchTournaments(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nullable String keyword, @javax.annotation.Nullable String subType, @javax.annotation.Nullable Boolean includeInactive, @javax.annotation.Nullable String missionTypes, @javax.annotation.Nullable String filter, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit) throws ApiException {
        ApiResponse<MissionShortResponse> localVarResp = searchTournamentsWithHttpInfo(accountId, appKey, keyword, subType, includeInactive, missionTypes, filter, sortField, descending, visibility, start, limit);
        return localVarResp.getData();
    }

    /**
     * Search Tournaments
     * Search for tournaments
     * @param accountId The logged in user. (required)
     * @param appKey The application key (required)
     * @param keyword the keyword to search tournament on (optional)
     * @param subType filter results by subType (optional)
     * @param includeInactive whether to include inactives in the search or not (optional, default to false)
     * @param missionTypes comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (optional, default to MULTISTAGE,TOURNAMENT,POOLPLAY)
     * @param filter filter tournaments by the tournament&#39;s current state (optional, default to UPCOMING)
     * @param sortField which field to sort on (optional, default to START_DATE)
     * @param descending Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false. (optional)
     * @param visibility Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (optional, default to PUBLIC)
     * @param start Start the result set at some index. (optional, default to 0)
     * @param limit Limit the result to some number (optional, default to 20)
     * @return ApiResponse&lt;MissionShortResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MissionShortResponse> searchTournamentsWithHttpInfo(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nullable String keyword, @javax.annotation.Nullable String subType, @javax.annotation.Nullable Boolean includeInactive, @javax.annotation.Nullable String missionTypes, @javax.annotation.Nullable String filter, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit) throws ApiException {
        okhttp3.Call localVarCall = searchTournamentsValidateBeforeCall(accountId, appKey, keyword, subType, includeInactive, missionTypes, filter, sortField, descending, visibility, start, limit, null);
        Type localVarReturnType = new TypeToken<MissionShortResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search Tournaments (asynchronously)
     * Search for tournaments
     * @param accountId The logged in user. (required)
     * @param appKey The application key (required)
     * @param keyword the keyword to search tournament on (optional)
     * @param subType filter results by subType (optional)
     * @param includeInactive whether to include inactives in the search or not (optional, default to false)
     * @param missionTypes comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (optional, default to MULTISTAGE,TOURNAMENT,POOLPLAY)
     * @param filter filter tournaments by the tournament&#39;s current state (optional, default to UPCOMING)
     * @param sortField which field to sort on (optional, default to START_DATE)
     * @param descending Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false. (optional)
     * @param visibility Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (optional, default to PUBLIC)
     * @param start Start the result set at some index. (optional, default to 0)
     * @param limit Limit the result to some number (optional, default to 20)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchTournamentsAsync(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nullable String keyword, @javax.annotation.Nullable String subType, @javax.annotation.Nullable Boolean includeInactive, @javax.annotation.Nullable String missionTypes, @javax.annotation.Nullable String filter, @javax.annotation.Nullable String sortField, @javax.annotation.Nullable Boolean descending, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Integer start, @javax.annotation.Nullable Integer limit, final ApiCallback<MissionShortResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchTournamentsValidateBeforeCall(accountId, appKey, keyword, subType, includeInactive, missionTypes, filter, sortField, descending, visibility, start, limit, _callback);
        Type localVarReturnType = new TypeToken<MissionShortResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for submitTournamentScore
     * @param accountId The logged in user account ID. (required)
     * @param appKey The application key. (required)
     * @param missionId The missionId to score for (required)
     * @param gameId The gameId to score for (required)
     * @param packId The packId to score for (required)
     * @param scores a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60;  (required)
     * @param gameLevelId The gameLevelId to score for (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call submitTournamentScoreCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nonnull Long gameId, @javax.annotation.Nonnull Long packId, @javax.annotation.Nonnull String scores, @javax.annotation.Nullable Long gameLevelId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tournament/score";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (appKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appKey", appKey));
        }

        if (missionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("missionId", missionId));
        }

        if (gameId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("gameId", gameId));
        }

        if (packId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("packId", packId));
        }

        if (gameLevelId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("gameLevelId", gameLevelId));
        }

        if (scores != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scores", scores));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call submitTournamentScoreValidateBeforeCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nonnull Long gameId, @javax.annotation.Nonnull Long packId, @javax.annotation.Nonnull String scores, @javax.annotation.Nullable Long gameLevelId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling submitTournamentScore(Async)");
        }

        // verify the required parameter 'appKey' is set
        if (appKey == null) {
            throw new ApiException("Missing the required parameter 'appKey' when calling submitTournamentScore(Async)");
        }

        // verify the required parameter 'missionId' is set
        if (missionId == null) {
            throw new ApiException("Missing the required parameter 'missionId' when calling submitTournamentScore(Async)");
        }

        // verify the required parameter 'gameId' is set
        if (gameId == null) {
            throw new ApiException("Missing the required parameter 'gameId' when calling submitTournamentScore(Async)");
        }

        // verify the required parameter 'packId' is set
        if (packId == null) {
            throw new ApiException("Missing the required parameter 'packId' when calling submitTournamentScore(Async)");
        }

        // verify the required parameter 'scores' is set
        if (scores == null) {
            throw new ApiException("Missing the required parameter 'scores' when calling submitTournamentScore(Async)");
        }

        return submitTournamentScoreCall(accountId, appKey, missionId, gameId, packId, scores, gameLevelId, _callback);

    }

    /**
     * Submit Tournament Score
     * Submit an array of scores for a tournament match. 
     * @param accountId The logged in user account ID. (required)
     * @param appKey The application key. (required)
     * @param missionId The missionId to score for (required)
     * @param gameId The gameId to score for (required)
     * @param packId The packId to score for (required)
     * @param scores a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60;  (required)
     * @param gameLevelId The gameLevelId to score for (optional)
     * @return SirqulResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public SirqulResponse submitTournamentScore(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nonnull Long gameId, @javax.annotation.Nonnull Long packId, @javax.annotation.Nonnull String scores, @javax.annotation.Nullable Long gameLevelId) throws ApiException {
        ApiResponse<SirqulResponse> localVarResp = submitTournamentScoreWithHttpInfo(accountId, appKey, missionId, gameId, packId, scores, gameLevelId);
        return localVarResp.getData();
    }

    /**
     * Submit Tournament Score
     * Submit an array of scores for a tournament match. 
     * @param accountId The logged in user account ID. (required)
     * @param appKey The application key. (required)
     * @param missionId The missionId to score for (required)
     * @param gameId The gameId to score for (required)
     * @param packId The packId to score for (required)
     * @param scores a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60;  (required)
     * @param gameLevelId The gameLevelId to score for (optional)
     * @return ApiResponse&lt;SirqulResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SirqulResponse> submitTournamentScoreWithHttpInfo(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nonnull Long gameId, @javax.annotation.Nonnull Long packId, @javax.annotation.Nonnull String scores, @javax.annotation.Nullable Long gameLevelId) throws ApiException {
        okhttp3.Call localVarCall = submitTournamentScoreValidateBeforeCall(accountId, appKey, missionId, gameId, packId, scores, gameLevelId, null);
        Type localVarReturnType = new TypeToken<SirqulResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Submit Tournament Score (asynchronously)
     * Submit an array of scores for a tournament match. 
     * @param accountId The logged in user account ID. (required)
     * @param appKey The application key. (required)
     * @param missionId The missionId to score for (required)
     * @param gameId The gameId to score for (required)
     * @param packId The packId to score for (required)
     * @param scores a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60;  (required)
     * @param gameLevelId The gameLevelId to score for (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call submitTournamentScoreAsync(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nonnull Long gameId, @javax.annotation.Nonnull Long packId, @javax.annotation.Nonnull String scores, @javax.annotation.Nullable Long gameLevelId, final ApiCallback<SirqulResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = submitTournamentScoreValidateBeforeCall(accountId, appKey, missionId, gameId, packId, scores, gameLevelId, _callback);
        Type localVarReturnType = new TypeToken<SirqulResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for submitTournamentVote
     * @param accountId The logged in user. (required)
     * @param appKey The application to target (required)
     * @param missionId The tournament&#39;s primary id (required)
     * @param gameObjectId The tournament game object the user wants to vote on (required)
     * @param deviceId The unique id of the device making the request (optional) (optional)
     * @param checkIfDeviceAlreadyVoted When true, check if the device already voted to prevent duplicate votes from the same device (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call submitTournamentVoteCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nonnull Long gameObjectId, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Boolean checkIfDeviceAlreadyVoted, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tournament/vote";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceId", deviceId));
        }

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (appKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("appKey", appKey));
        }

        if (missionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("missionId", missionId));
        }

        if (gameObjectId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("gameObjectId", gameObjectId));
        }

        if (checkIfDeviceAlreadyVoted != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("checkIfDeviceAlreadyVoted", checkIfDeviceAlreadyVoted));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call submitTournamentVoteValidateBeforeCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nonnull Long gameObjectId, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Boolean checkIfDeviceAlreadyVoted, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling submitTournamentVote(Async)");
        }

        // verify the required parameter 'appKey' is set
        if (appKey == null) {
            throw new ApiException("Missing the required parameter 'appKey' when calling submitTournamentVote(Async)");
        }

        // verify the required parameter 'missionId' is set
        if (missionId == null) {
            throw new ApiException("Missing the required parameter 'missionId' when calling submitTournamentVote(Async)");
        }

        // verify the required parameter 'gameObjectId' is set
        if (gameObjectId == null) {
            throw new ApiException("Missing the required parameter 'gameObjectId' when calling submitTournamentVote(Async)");
        }

        return submitTournamentVoteCall(accountId, appKey, missionId, gameObjectId, deviceId, checkIfDeviceAlreadyVoted, _callback);

    }

    /**
     * Submit a vote for a multi-stage album tournament.
     * Submit a vote for a multi-stage album tournament.
     * @param accountId The logged in user. (required)
     * @param appKey The application to target (required)
     * @param missionId The tournament&#39;s primary id (required)
     * @param gameObjectId The tournament game object the user wants to vote on (required)
     * @param deviceId The unique id of the device making the request (optional) (optional)
     * @param checkIfDeviceAlreadyVoted When true, check if the device already voted to prevent duplicate votes from the same device (optional, default to false)
     * @return SirqulResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public SirqulResponse submitTournamentVote(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nonnull Long gameObjectId, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Boolean checkIfDeviceAlreadyVoted) throws ApiException {
        ApiResponse<SirqulResponse> localVarResp = submitTournamentVoteWithHttpInfo(accountId, appKey, missionId, gameObjectId, deviceId, checkIfDeviceAlreadyVoted);
        return localVarResp.getData();
    }

    /**
     * Submit a vote for a multi-stage album tournament.
     * Submit a vote for a multi-stage album tournament.
     * @param accountId The logged in user. (required)
     * @param appKey The application to target (required)
     * @param missionId The tournament&#39;s primary id (required)
     * @param gameObjectId The tournament game object the user wants to vote on (required)
     * @param deviceId The unique id of the device making the request (optional) (optional)
     * @param checkIfDeviceAlreadyVoted When true, check if the device already voted to prevent duplicate votes from the same device (optional, default to false)
     * @return ApiResponse&lt;SirqulResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SirqulResponse> submitTournamentVoteWithHttpInfo(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nonnull Long gameObjectId, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Boolean checkIfDeviceAlreadyVoted) throws ApiException {
        okhttp3.Call localVarCall = submitTournamentVoteValidateBeforeCall(accountId, appKey, missionId, gameObjectId, deviceId, checkIfDeviceAlreadyVoted, null);
        Type localVarReturnType = new TypeToken<SirqulResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Submit a vote for a multi-stage album tournament. (asynchronously)
     * Submit a vote for a multi-stage album tournament.
     * @param accountId The logged in user. (required)
     * @param appKey The application to target (required)
     * @param missionId The tournament&#39;s primary id (required)
     * @param gameObjectId The tournament game object the user wants to vote on (required)
     * @param deviceId The unique id of the device making the request (optional) (optional)
     * @param checkIfDeviceAlreadyVoted When true, check if the device already voted to prevent duplicate votes from the same device (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call submitTournamentVoteAsync(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull String appKey, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nonnull Long gameObjectId, @javax.annotation.Nullable String deviceId, @javax.annotation.Nullable Boolean checkIfDeviceAlreadyVoted, final ApiCallback<SirqulResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = submitTournamentVoteValidateBeforeCall(accountId, appKey, missionId, gameObjectId, deviceId, checkIfDeviceAlreadyVoted, _callback);
        Type localVarReturnType = new TypeToken<SirqulResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for substituteTournamentPlayer
     * @param accountId the id of the logged in user (required)
     * @param missionId the id of the mission (required)
     * @param packId the id of the pack (required)
     * @param gameLevelId the id of the game level (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call substituteTournamentPlayerCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nonnull Long packId, @javax.annotation.Nonnull Long gameLevelId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tournament/substitute";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (missionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("missionId", missionId));
        }

        if (packId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("packId", packId));
        }

        if (gameLevelId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("gameLevelId", gameLevelId));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call substituteTournamentPlayerValidateBeforeCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nonnull Long packId, @javax.annotation.Nonnull Long gameLevelId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling substituteTournamentPlayer(Async)");
        }

        // verify the required parameter 'missionId' is set
        if (missionId == null) {
            throw new ApiException("Missing the required parameter 'missionId' when calling substituteTournamentPlayer(Async)");
        }

        // verify the required parameter 'packId' is set
        if (packId == null) {
            throw new ApiException("Missing the required parameter 'packId' when calling substituteTournamentPlayer(Async)");
        }

        // verify the required parameter 'gameLevelId' is set
        if (gameLevelId == null) {
            throw new ApiException("Missing the required parameter 'gameLevelId' when calling substituteTournamentPlayer(Async)");
        }

        return substituteTournamentPlayerCall(accountId, missionId, packId, gameLevelId, _callback);

    }

    /**
     * Substitute Tournament Player
     * Service to replace the user&#39;s opponent in the current level - pack - mission with an AI account.
     * @param accountId the id of the logged in user (required)
     * @param missionId the id of the mission (required)
     * @param packId the id of the pack (required)
     * @param gameLevelId the id of the game level (required)
     * @return SirqulResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public SirqulResponse substituteTournamentPlayer(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nonnull Long packId, @javax.annotation.Nonnull Long gameLevelId) throws ApiException {
        ApiResponse<SirqulResponse> localVarResp = substituteTournamentPlayerWithHttpInfo(accountId, missionId, packId, gameLevelId);
        return localVarResp.getData();
    }

    /**
     * Substitute Tournament Player
     * Service to replace the user&#39;s opponent in the current level - pack - mission with an AI account.
     * @param accountId the id of the logged in user (required)
     * @param missionId the id of the mission (required)
     * @param packId the id of the pack (required)
     * @param gameLevelId the id of the game level (required)
     * @return ApiResponse&lt;SirqulResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SirqulResponse> substituteTournamentPlayerWithHttpInfo(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nonnull Long packId, @javax.annotation.Nonnull Long gameLevelId) throws ApiException {
        okhttp3.Call localVarCall = substituteTournamentPlayerValidateBeforeCall(accountId, missionId, packId, gameLevelId, null);
        Type localVarReturnType = new TypeToken<SirqulResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Substitute Tournament Player (asynchronously)
     * Service to replace the user&#39;s opponent in the current level - pack - mission with an AI account.
     * @param accountId the id of the logged in user (required)
     * @param missionId the id of the mission (required)
     * @param packId the id of the pack (required)
     * @param gameLevelId the id of the game level (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call substituteTournamentPlayerAsync(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nonnull Long packId, @javax.annotation.Nonnull Long gameLevelId, final ApiCallback<SirqulResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = substituteTournamentPlayerValidateBeforeCall(accountId, missionId, packId, gameLevelId, _callback);
        Type localVarReturnType = new TypeToken<SirqulResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateTournament
     * @param accountId The logged in user. (required)
     * @param missionId The mission/tournament to update (required)
     * @param title The title of the tournament (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param imageAssetId The asset ID to attach to the tournament (optional)
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game (optional)
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker (optional)
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round (optional)
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional)
     * @param costToPlay The number of tickets required to pay to enter the tournament (optional)
     * @param costToPlayType The type of ticket required to pay (optional)
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played (optional)
     * @param startingLimit The starting number of players for a tournament (filled with AI&#39;s) (optional)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced) (optional)
     * @param description The description of the tournament (optional)
     * @param metaData External custom client defined data (optional)
     * @param startDate The date/time to start the tournament (optional)
     * @param audienceIds The audiences associated with the tournament (optional)
     * @param active Activate/deactivate the mission (optional)
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament (optional)
     * @param offerIds The list of offers to give as a reward beyond the tickets (optional)
     * @param offerAssetId The artwork ID to attach to the reward offer (optional)
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided (optional)
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content (optional)
     * @param visibility Sets the visibility flag for the tournament (optional)
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional)
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional)
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional)
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not (optional)
     * @param winnerTag This sets what analytic tag is used when a winner is determined (optional)
     * @param tieTag This sets what analytic tag is used when a winner is determined (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateTournamentCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nullable String title, @javax.annotation.Nullable String subType, @javax.annotation.Nullable Long imageAssetId, @javax.annotation.Nullable Integer secondsBetweenLevels, @javax.annotation.Nullable Integer secondsForTieBreaker, @javax.annotation.Nullable Integer secondsBetweenPacks, @javax.annotation.Nullable Integer maximumLevelLength, @javax.annotation.Nullable Integer costToPlay, @javax.annotation.Nullable String costToPlayType, @javax.annotation.Nullable Integer minimumToPlay, @javax.annotation.Nullable Integer startingLimit, @javax.annotation.Nullable Integer availableLimit, @javax.annotation.Nullable String description, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable Boolean enableBuyBack, @javax.annotation.Nullable String offerIds, @javax.annotation.Nullable Long offerAssetId, @javax.annotation.Nullable Boolean fixedReward, @javax.annotation.Nullable String splitReward, @javax.annotation.Nullable Boolean allocateTickets, @javax.annotation.Nullable String tournamentData, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Integer preliminaryGroups, @javax.annotation.Nullable String preliminaryGroupAdvancements, @javax.annotation.Nullable Boolean enableMultipleEntries, @javax.annotation.Nullable Boolean enableMultipleVotes, @javax.annotation.Nullable Boolean featured, @javax.annotation.Nullable String winnerTag, @javax.annotation.Nullable String tieTag, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/tournament/update";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accountId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accountId", accountId));
        }

        if (missionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("missionId", missionId));
        }

        if (title != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("title", title));
        }

        if (subType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subType", subType));
        }

        if (imageAssetId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("imageAssetId", imageAssetId));
        }

        if (secondsBetweenLevels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secondsBetweenLevels", secondsBetweenLevels));
        }

        if (secondsForTieBreaker != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secondsForTieBreaker", secondsForTieBreaker));
        }

        if (secondsBetweenPacks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secondsBetweenPacks", secondsBetweenPacks));
        }

        if (maximumLevelLength != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maximumLevelLength", maximumLevelLength));
        }

        if (costToPlay != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("costToPlay", costToPlay));
        }

        if (costToPlayType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("costToPlayType", costToPlayType));
        }

        if (minimumToPlay != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minimumToPlay", minimumToPlay));
        }

        if (startingLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startingLimit", startingLimit));
        }

        if (availableLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("availableLimit", availableLimit));
        }

        if (description != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("description", description));
        }

        if (metaData != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("metaData", metaData));
        }

        if (startDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startDate", startDate));
        }

        if (audienceIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audienceIds", audienceIds));
        }

        if (active != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("active", active));
        }

        if (enableBuyBack != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableBuyBack", enableBuyBack));
        }

        if (offerIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offerIds", offerIds));
        }

        if (offerAssetId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offerAssetId", offerAssetId));
        }

        if (fixedReward != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fixedReward", fixedReward));
        }

        if (splitReward != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("splitReward", splitReward));
        }

        if (allocateTickets != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allocateTickets", allocateTickets));
        }

        if (tournamentData != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tournamentData", tournamentData));
        }

        if (visibility != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("visibility", visibility));
        }

        if (preliminaryGroups != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("preliminaryGroups", preliminaryGroups));
        }

        if (preliminaryGroupAdvancements != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("preliminaryGroupAdvancements", preliminaryGroupAdvancements));
        }

        if (enableMultipleEntries != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableMultipleEntries", enableMultipleEntries));
        }

        if (enableMultipleVotes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableMultipleVotes", enableMultipleVotes));
        }

        if (featured != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("featured", featured));
        }

        if (winnerTag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("winnerTag", winnerTag));
        }

        if (tieTag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tieTag", tieTag));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateTournamentValidateBeforeCall(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nullable String title, @javax.annotation.Nullable String subType, @javax.annotation.Nullable Long imageAssetId, @javax.annotation.Nullable Integer secondsBetweenLevels, @javax.annotation.Nullable Integer secondsForTieBreaker, @javax.annotation.Nullable Integer secondsBetweenPacks, @javax.annotation.Nullable Integer maximumLevelLength, @javax.annotation.Nullable Integer costToPlay, @javax.annotation.Nullable String costToPlayType, @javax.annotation.Nullable Integer minimumToPlay, @javax.annotation.Nullable Integer startingLimit, @javax.annotation.Nullable Integer availableLimit, @javax.annotation.Nullable String description, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable Boolean enableBuyBack, @javax.annotation.Nullable String offerIds, @javax.annotation.Nullable Long offerAssetId, @javax.annotation.Nullable Boolean fixedReward, @javax.annotation.Nullable String splitReward, @javax.annotation.Nullable Boolean allocateTickets, @javax.annotation.Nullable String tournamentData, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Integer preliminaryGroups, @javax.annotation.Nullable String preliminaryGroupAdvancements, @javax.annotation.Nullable Boolean enableMultipleEntries, @javax.annotation.Nullable Boolean enableMultipleVotes, @javax.annotation.Nullable Boolean featured, @javax.annotation.Nullable String winnerTag, @javax.annotation.Nullable String tieTag, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling updateTournament(Async)");
        }

        // verify the required parameter 'missionId' is set
        if (missionId == null) {
            throw new ApiException("Missing the required parameter 'missionId' when calling updateTournament(Async)");
        }

        return updateTournamentCall(accountId, missionId, title, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlay, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, startDate, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag, _callback);

    }

    /**
     * Update Tournament
     * Update a tournament.
     * @param accountId The logged in user. (required)
     * @param missionId The mission/tournament to update (required)
     * @param title The title of the tournament (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param imageAssetId The asset ID to attach to the tournament (optional)
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game (optional)
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker (optional)
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round (optional)
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional)
     * @param costToPlay The number of tickets required to pay to enter the tournament (optional)
     * @param costToPlayType The type of ticket required to pay (optional)
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played (optional)
     * @param startingLimit The starting number of players for a tournament (filled with AI&#39;s) (optional)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced) (optional)
     * @param description The description of the tournament (optional)
     * @param metaData External custom client defined data (optional)
     * @param startDate The date/time to start the tournament (optional)
     * @param audienceIds The audiences associated with the tournament (optional)
     * @param active Activate/deactivate the mission (optional)
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament (optional)
     * @param offerIds The list of offers to give as a reward beyond the tickets (optional)
     * @param offerAssetId The artwork ID to attach to the reward offer (optional)
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided (optional)
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content (optional)
     * @param visibility Sets the visibility flag for the tournament (optional)
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional)
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional)
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional)
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not (optional)
     * @param winnerTag This sets what analytic tag is used when a winner is determined (optional)
     * @param tieTag This sets what analytic tag is used when a winner is determined (optional)
     * @return TournamentResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public TournamentResponse updateTournament(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nullable String title, @javax.annotation.Nullable String subType, @javax.annotation.Nullable Long imageAssetId, @javax.annotation.Nullable Integer secondsBetweenLevels, @javax.annotation.Nullable Integer secondsForTieBreaker, @javax.annotation.Nullable Integer secondsBetweenPacks, @javax.annotation.Nullable Integer maximumLevelLength, @javax.annotation.Nullable Integer costToPlay, @javax.annotation.Nullable String costToPlayType, @javax.annotation.Nullable Integer minimumToPlay, @javax.annotation.Nullable Integer startingLimit, @javax.annotation.Nullable Integer availableLimit, @javax.annotation.Nullable String description, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable Boolean enableBuyBack, @javax.annotation.Nullable String offerIds, @javax.annotation.Nullable Long offerAssetId, @javax.annotation.Nullable Boolean fixedReward, @javax.annotation.Nullable String splitReward, @javax.annotation.Nullable Boolean allocateTickets, @javax.annotation.Nullable String tournamentData, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Integer preliminaryGroups, @javax.annotation.Nullable String preliminaryGroupAdvancements, @javax.annotation.Nullable Boolean enableMultipleEntries, @javax.annotation.Nullable Boolean enableMultipleVotes, @javax.annotation.Nullable Boolean featured, @javax.annotation.Nullable String winnerTag, @javax.annotation.Nullable String tieTag) throws ApiException {
        ApiResponse<TournamentResponse> localVarResp = updateTournamentWithHttpInfo(accountId, missionId, title, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlay, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, startDate, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag);
        return localVarResp.getData();
    }

    /**
     * Update Tournament
     * Update a tournament.
     * @param accountId The logged in user. (required)
     * @param missionId The mission/tournament to update (required)
     * @param title The title of the tournament (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param imageAssetId The asset ID to attach to the tournament (optional)
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game (optional)
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker (optional)
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round (optional)
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional)
     * @param costToPlay The number of tickets required to pay to enter the tournament (optional)
     * @param costToPlayType The type of ticket required to pay (optional)
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played (optional)
     * @param startingLimit The starting number of players for a tournament (filled with AI&#39;s) (optional)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced) (optional)
     * @param description The description of the tournament (optional)
     * @param metaData External custom client defined data (optional)
     * @param startDate The date/time to start the tournament (optional)
     * @param audienceIds The audiences associated with the tournament (optional)
     * @param active Activate/deactivate the mission (optional)
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament (optional)
     * @param offerIds The list of offers to give as a reward beyond the tickets (optional)
     * @param offerAssetId The artwork ID to attach to the reward offer (optional)
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided (optional)
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content (optional)
     * @param visibility Sets the visibility flag for the tournament (optional)
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional)
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional)
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional)
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not (optional)
     * @param winnerTag This sets what analytic tag is used when a winner is determined (optional)
     * @param tieTag This sets what analytic tag is used when a winner is determined (optional)
     * @return ApiResponse&lt;TournamentResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TournamentResponse> updateTournamentWithHttpInfo(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nullable String title, @javax.annotation.Nullable String subType, @javax.annotation.Nullable Long imageAssetId, @javax.annotation.Nullable Integer secondsBetweenLevels, @javax.annotation.Nullable Integer secondsForTieBreaker, @javax.annotation.Nullable Integer secondsBetweenPacks, @javax.annotation.Nullable Integer maximumLevelLength, @javax.annotation.Nullable Integer costToPlay, @javax.annotation.Nullable String costToPlayType, @javax.annotation.Nullable Integer minimumToPlay, @javax.annotation.Nullable Integer startingLimit, @javax.annotation.Nullable Integer availableLimit, @javax.annotation.Nullable String description, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable Boolean enableBuyBack, @javax.annotation.Nullable String offerIds, @javax.annotation.Nullable Long offerAssetId, @javax.annotation.Nullable Boolean fixedReward, @javax.annotation.Nullable String splitReward, @javax.annotation.Nullable Boolean allocateTickets, @javax.annotation.Nullable String tournamentData, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Integer preliminaryGroups, @javax.annotation.Nullable String preliminaryGroupAdvancements, @javax.annotation.Nullable Boolean enableMultipleEntries, @javax.annotation.Nullable Boolean enableMultipleVotes, @javax.annotation.Nullable Boolean featured, @javax.annotation.Nullable String winnerTag, @javax.annotation.Nullable String tieTag) throws ApiException {
        okhttp3.Call localVarCall = updateTournamentValidateBeforeCall(accountId, missionId, title, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlay, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, startDate, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag, null);
        Type localVarReturnType = new TypeToken<TournamentResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Tournament (asynchronously)
     * Update a tournament.
     * @param accountId The logged in user. (required)
     * @param missionId The mission/tournament to update (required)
     * @param title The title of the tournament (optional)
     * @param subType Custom string client apps can use for searching/filtering missions (optional)
     * @param imageAssetId The asset ID to attach to the tournament (optional)
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game (optional)
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker (optional)
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round (optional)
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional)
     * @param costToPlay The number of tickets required to pay to enter the tournament (optional)
     * @param costToPlayType The type of ticket required to pay (optional)
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played (optional)
     * @param startingLimit The starting number of players for a tournament (filled with AI&#39;s) (optional)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced) (optional)
     * @param description The description of the tournament (optional)
     * @param metaData External custom client defined data (optional)
     * @param startDate The date/time to start the tournament (optional)
     * @param audienceIds The audiences associated with the tournament (optional)
     * @param active Activate/deactivate the mission (optional)
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament (optional)
     * @param offerIds The list of offers to give as a reward beyond the tickets (optional)
     * @param offerAssetId The artwork ID to attach to the reward offer (optional)
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided (optional)
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional)
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions (optional)
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content (optional)
     * @param visibility Sets the visibility flag for the tournament (optional)
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional)
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional)
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional)
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not (optional)
     * @param winnerTag This sets what analytic tag is used when a winner is determined (optional)
     * @param tieTag This sets what analytic tag is used when a winner is determined (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateTournamentAsync(@javax.annotation.Nonnull Long accountId, @javax.annotation.Nonnull Long missionId, @javax.annotation.Nullable String title, @javax.annotation.Nullable String subType, @javax.annotation.Nullable Long imageAssetId, @javax.annotation.Nullable Integer secondsBetweenLevels, @javax.annotation.Nullable Integer secondsForTieBreaker, @javax.annotation.Nullable Integer secondsBetweenPacks, @javax.annotation.Nullable Integer maximumLevelLength, @javax.annotation.Nullable Integer costToPlay, @javax.annotation.Nullable String costToPlayType, @javax.annotation.Nullable Integer minimumToPlay, @javax.annotation.Nullable Integer startingLimit, @javax.annotation.Nullable Integer availableLimit, @javax.annotation.Nullable String description, @javax.annotation.Nullable String metaData, @javax.annotation.Nullable Long startDate, @javax.annotation.Nullable String audienceIds, @javax.annotation.Nullable Boolean active, @javax.annotation.Nullable Boolean enableBuyBack, @javax.annotation.Nullable String offerIds, @javax.annotation.Nullable Long offerAssetId, @javax.annotation.Nullable Boolean fixedReward, @javax.annotation.Nullable String splitReward, @javax.annotation.Nullable Boolean allocateTickets, @javax.annotation.Nullable String tournamentData, @javax.annotation.Nullable String visibility, @javax.annotation.Nullable Integer preliminaryGroups, @javax.annotation.Nullable String preliminaryGroupAdvancements, @javax.annotation.Nullable Boolean enableMultipleEntries, @javax.annotation.Nullable Boolean enableMultipleVotes, @javax.annotation.Nullable Boolean featured, @javax.annotation.Nullable String winnerTag, @javax.annotation.Nullable String tieTag, final ApiCallback<TournamentResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateTournamentValidateBeforeCall(accountId, missionId, title, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlay, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, startDate, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag, _callback);
        Type localVarReturnType = new TypeToken<TournamentResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
