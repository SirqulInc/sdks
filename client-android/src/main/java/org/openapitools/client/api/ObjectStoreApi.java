/*
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client.api;

import org.openapitools.client.ApiInvoker;
import org.openapitools.client.ApiException;
import org.openapitools.client.Pair;

import org.openapitools.client.model.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import org.openapitools.client.model.ObjectStoreResponse;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class ObjectStoreApi {
  String basePath = "https://dev.sirqul.com/api/3.18";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * Create Field
  * Add a field to a specific object.  The field name should be camel   case with the first letter lower case, for example: myFieldName.  Duplicate   field names are not allowed.   The field name cannot be any of the following   reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE,   BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE,   CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE,   CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP,   CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE,   DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE,   DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE,   ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4,   FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY,   HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE,   INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER,   INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT,   LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG,   LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT,   MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND,   MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC,   ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION,   PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES,   REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN,   REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE,   SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION,   SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT,   SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT,   TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED,   UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY,   VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH,   ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW.     The following field names are reserved (cannot be used directly) and are automatically   included during object creation: ID, OBJECTID, CREATED, UPDATED, DELETED.   Additionally the field names must start with a letter or number.
   * @param accountId The account id of the logged in user
   * @param appKey The application key for updating an existing application
   * @param objectName The name of the object to add the field to
   * @param fieldName field name The name of the field to add.
   * @param fieldType field type The field type to create, supported types are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY
   * @return ObjectStoreResponse
  */
  public ObjectStoreResponse addField (Long accountId, String appKey, String objectName, String fieldName, String fieldType) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling addField",
        new ApiException(400, "Missing the required parameter 'accountId' when calling addField"));
    }
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling addField",
        new ApiException(400, "Missing the required parameter 'appKey' when calling addField"));
    }
    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling addField",
        new ApiException(400, "Missing the required parameter 'objectName' when calling addField"));
    }
    // verify the required parameter 'fieldName' is set
    if (fieldName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'fieldName' when calling addField",
        new ApiException(400, "Missing the required parameter 'fieldName' when calling addField"));
    }
    // verify the required parameter 'fieldType' is set
    if (fieldType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'fieldType' when calling addField",
        new ApiException(400, "Missing the required parameter 'fieldType' when calling addField"));
    }

    // create path and map variables
    String path = "/object/field/add";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "objectName", objectName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "fieldName", fieldName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "fieldType", fieldType));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse, "", ObjectStoreResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Create Field
   * Add a field to a specific object.  The field name should be camel   case with the first letter lower case, for example: myFieldName.  Duplicate   field names are not allowed.   The field name cannot be any of the following   reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE,   BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE,   CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE,   CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP,   CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE,   DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE,   DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE,   ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4,   FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY,   HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE,   INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER,   INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT,   LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG,   LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT,   MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND,   MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC,   ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION,   PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES,   REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN,   REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE,   SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION,   SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT,   SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT,   TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED,   UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY,   VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH,   ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW.     The following field names are reserved (cannot be used directly) and are automatically   included during object creation: ID, OBJECTID, CREATED, UPDATED, DELETED.   Additionally the field names must start with a letter or number.
   * @param accountId The account id of the logged in user   * @param appKey The application key for updating an existing application   * @param objectName The name of the object to add the field to   * @param fieldName field name The name of the field to add.   * @param fieldType field type The field type to create, supported types are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY
  */
  public void addField (Long accountId, String appKey, String objectName, String fieldName, String fieldType, final Response.Listener<ObjectStoreResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling addField",
        new ApiException(400, "Missing the required parameter 'accountId' when calling addField"));
    }
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling addField",
        new ApiException(400, "Missing the required parameter 'appKey' when calling addField"));
    }
    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling addField",
        new ApiException(400, "Missing the required parameter 'objectName' when calling addField"));
    }
    // verify the required parameter 'fieldName' is set
    if (fieldName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'fieldName' when calling addField",
        new ApiException(400, "Missing the required parameter 'fieldName' when calling addField"));
    }
    // verify the required parameter 'fieldType' is set
    if (fieldType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'fieldType' when calling addField",
        new ApiException(400, "Missing the required parameter 'fieldType' when calling addField"));
    }

    // create path and map variables
    String path = "/object/field/add".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "objectName", objectName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "fieldName", fieldName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "fieldType", fieldType));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse,  "", ObjectStoreResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Create Data
  * Create a record for the specified object.  If the object does not exist then a new one will be created prior to inserting the record.  If any of the fields included does not exist for the object then they are added to the object. 
   * @param objectName the name of the object to create data for
   * @param accountId the account id
   * @param body 
   * @return ObjectStoreResponse
  */
  public ObjectStoreResponse createData (String objectName, Long accountId, String body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling createData",
        new ApiException(400, "Missing the required parameter 'objectName' when calling createData"));
    }

    // create path and map variables
    String path = "/object/data/{objectName}".replaceAll("\\{" + "objectName" + "\\}", apiInvoker.escapeString(objectName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse, "", ObjectStoreResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Create Data
   * Create a record for the specified object.  If the object does not exist then a new one will be created prior to inserting the record.  If any of the fields included does not exist for the object then they are added to the object. 
   * @param objectName the name of the object to create data for   * @param accountId the account id   * @param body 
  */
  public void createData (String objectName, Long accountId, String body, final Response.Listener<ObjectStoreResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling createData",
        new ApiException(400, "Missing the required parameter 'objectName' when calling createData"));
    }

    // create path and map variables
    String path = "/object/data/{objectName}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "objectName" + "\\}", apiInvoker.escapeString(objectName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse,  "", ObjectStoreResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Create Object
  * Create an Object Store table.  By default tables will have the columns: id, created, updated, deleted.  Names og objects should be camel case with the first letter capitalized, for example: MyTableName.   Duplicate object names are not allowed.   The object name cannot be any of the following reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE, BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE, CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE, CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP, CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE, DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE, DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE, ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4, FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY, HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE, INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER, INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT, LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG, LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT, MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND, MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC, ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION, PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES, REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN, REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE, SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION, SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT, SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT, TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED, UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY, VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH, ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW. 
   * @param accountId The account id of the logged in user
   * @param appKey The application key for updating an existing application
   * @param objectName The name of the object to create
   * @return ObjectStoreResponse
  */
  public ObjectStoreResponse createObject (Long accountId, String appKey, String objectName) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling createObject",
        new ApiException(400, "Missing the required parameter 'accountId' when calling createObject"));
    }
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling createObject",
        new ApiException(400, "Missing the required parameter 'appKey' when calling createObject"));
    }
    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling createObject",
        new ApiException(400, "Missing the required parameter 'objectName' when calling createObject"));
    }

    // create path and map variables
    String path = "/object/create";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "objectName", objectName));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse, "", ObjectStoreResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Create Object
   * Create an Object Store table.  By default tables will have the columns: id, created, updated, deleted.  Names og objects should be camel case with the first letter capitalized, for example: MyTableName.   Duplicate object names are not allowed.   The object name cannot be any of the following reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE, BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE, CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE, CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP, CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE, DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE, DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE, ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4, FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY, HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE, INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER, INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT, LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG, LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT, MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND, MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC, ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION, PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES, REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN, REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE, SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION, SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT, SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT, TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED, UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY, VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH, ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW. 
   * @param accountId The account id of the logged in user   * @param appKey The application key for updating an existing application   * @param objectName The name of the object to create
  */
  public void createObject (Long accountId, String appKey, String objectName, final Response.Listener<ObjectStoreResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling createObject",
        new ApiException(400, "Missing the required parameter 'accountId' when calling createObject"));
    }
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling createObject",
        new ApiException(400, "Missing the required parameter 'appKey' when calling createObject"));
    }
    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling createObject",
        new ApiException(400, "Missing the required parameter 'objectName' when calling createObject"));
    }

    // create path and map variables
    String path = "/object/create".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "objectName", objectName));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse,  "", ObjectStoreResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Delete Data
  * Delete a record for the specified object. Cannot be undone so use only when abolutely sure.
   * @param objectName The name of the object to search upon
   * @param objectId objectId The id of the record to return
   * @param accountId The account id of the logged in user
   * @return ObjectStoreResponse
  */
  public ObjectStoreResponse deleteData (String objectName, String objectId, Long accountId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling deleteData",
        new ApiException(400, "Missing the required parameter 'objectName' when calling deleteData"));
    }
    // verify the required parameter 'objectId' is set
    if (objectId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectId' when calling deleteData",
        new ApiException(400, "Missing the required parameter 'objectId' when calling deleteData"));
    }

    // create path and map variables
    String path = "/object/data/{objectName}/{objectId}".replaceAll("\\{" + "objectName" + "\\}", apiInvoker.escapeString(objectName.toString())).replaceAll("\\{" + "objectId" + "\\}", apiInvoker.escapeString(objectId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse, "", ObjectStoreResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Delete Data
   * Delete a record for the specified object. Cannot be undone so use only when abolutely sure.
   * @param objectName The name of the object to search upon   * @param objectId objectId The id of the record to return   * @param accountId The account id of the logged in user
  */
  public void deleteData (String objectName, String objectId, Long accountId, final Response.Listener<ObjectStoreResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling deleteData",
        new ApiException(400, "Missing the required parameter 'objectName' when calling deleteData"));
    }
    // verify the required parameter 'objectId' is set
    if (objectId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectId' when calling deleteData",
        new ApiException(400, "Missing the required parameter 'objectId' when calling deleteData"));
    }

    // create path and map variables
    String path = "/object/data/{objectName}/{objectId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "objectName" + "\\}", apiInvoker.escapeString(objectName.toString())).replaceAll("\\{" + "objectId" + "\\}", apiInvoker.escapeString(objectId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "DELETE", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse,  "", ObjectStoreResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Delete Field
  * Delete a field from an object.  This will remove the field, indexes,   and foreign keys associated with the field.   The following field names   are reserved and cannot be removed from the object: ID, OBJECTID, CREATED,   UPDATED, DELETED
   * @param accountId The account id of the logged in user
   * @param appKey The application key for updating an existing application
   * @param objectName The name of the object to remove the field from
   * @param fieldName field name The name of the field to remove.
   * @return ObjectStoreResponse
  */
  public ObjectStoreResponse deleteField (Long accountId, String appKey, String objectName, String fieldName) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling deleteField",
        new ApiException(400, "Missing the required parameter 'accountId' when calling deleteField"));
    }
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling deleteField",
        new ApiException(400, "Missing the required parameter 'appKey' when calling deleteField"));
    }
    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling deleteField",
        new ApiException(400, "Missing the required parameter 'objectName' when calling deleteField"));
    }
    // verify the required parameter 'fieldName' is set
    if (fieldName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'fieldName' when calling deleteField",
        new ApiException(400, "Missing the required parameter 'fieldName' when calling deleteField"));
    }

    // create path and map variables
    String path = "/object/field/delete";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "objectName", objectName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "fieldName", fieldName));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse, "", ObjectStoreResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Delete Field
   * Delete a field from an object.  This will remove the field, indexes,   and foreign keys associated with the field.   The following field names   are reserved and cannot be removed from the object: ID, OBJECTID, CREATED,   UPDATED, DELETED
   * @param accountId The account id of the logged in user   * @param appKey The application key for updating an existing application   * @param objectName The name of the object to remove the field from   * @param fieldName field name The name of the field to remove.
  */
  public void deleteField (Long accountId, String appKey, String objectName, String fieldName, final Response.Listener<ObjectStoreResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling deleteField",
        new ApiException(400, "Missing the required parameter 'accountId' when calling deleteField"));
    }
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling deleteField",
        new ApiException(400, "Missing the required parameter 'appKey' when calling deleteField"));
    }
    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling deleteField",
        new ApiException(400, "Missing the required parameter 'objectName' when calling deleteField"));
    }
    // verify the required parameter 'fieldName' is set
    if (fieldName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'fieldName' when calling deleteField",
        new ApiException(400, "Missing the required parameter 'fieldName' when calling deleteField"));
    }

    // create path and map variables
    String path = "/object/field/delete".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "objectName", objectName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "fieldName", fieldName));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse,  "", ObjectStoreResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Delete Object
  * Delete and Object in the store.  This will delete the table and clean up and foreign keys referencing it. Cannot be undone so use only when abolutely sure.
   * @param accountId the id of the logged in user
   * @param appKey the application key
   * @param objectName the name of the object to delete
   * @return ObjectStoreResponse
  */
  public ObjectStoreResponse deleteObject (Long accountId, String appKey, String objectName) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling deleteObject",
        new ApiException(400, "Missing the required parameter 'accountId' when calling deleteObject"));
    }
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling deleteObject",
        new ApiException(400, "Missing the required parameter 'appKey' when calling deleteObject"));
    }
    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling deleteObject",
        new ApiException(400, "Missing the required parameter 'objectName' when calling deleteObject"));
    }

    // create path and map variables
    String path = "/object/delete";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "objectName", objectName));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse, "", ObjectStoreResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Delete Object
   * Delete and Object in the store.  This will delete the table and clean up and foreign keys referencing it. Cannot be undone so use only when abolutely sure.
   * @param accountId the id of the logged in user   * @param appKey the application key   * @param objectName the name of the object to delete
  */
  public void deleteObject (Long accountId, String appKey, String objectName, final Response.Listener<ObjectStoreResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling deleteObject",
        new ApiException(400, "Missing the required parameter 'accountId' when calling deleteObject"));
    }
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling deleteObject",
        new ApiException(400, "Missing the required parameter 'appKey' when calling deleteObject"));
    }
    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling deleteObject",
        new ApiException(400, "Missing the required parameter 'objectName' when calling deleteObject"));
    }

    // create path and map variables
    String path = "/object/delete".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "objectName", objectName));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse,  "", ObjectStoreResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Data
  * Get a specific record from a specified object.
   * @param objectName The name of the object to search upon
   * @param objectId objectId The id of the record to return
   * @param accountId The account id of the logged in user
   * @param include 
   * @return ObjectStoreResponse
  */
  public ObjectStoreResponse getData (String objectName, String objectId, Long accountId, String include) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling getData",
        new ApiException(400, "Missing the required parameter 'objectName' when calling getData"));
    }
    // verify the required parameter 'objectId' is set
    if (objectId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectId' when calling getData",
        new ApiException(400, "Missing the required parameter 'objectId' when calling getData"));
    }

    // create path and map variables
    String path = "/object/data/{objectName}/{objectId}".replaceAll("\\{" + "objectName" + "\\}", apiInvoker.escapeString(objectName.toString())).replaceAll("\\{" + "objectId" + "\\}", apiInvoker.escapeString(objectId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "include", include));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse, "", ObjectStoreResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Data
   * Get a specific record from a specified object.
   * @param objectName The name of the object to search upon   * @param objectId objectId The id of the record to return   * @param accountId The account id of the logged in user   * @param include 
  */
  public void getData (String objectName, String objectId, Long accountId, String include, final Response.Listener<ObjectStoreResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling getData",
        new ApiException(400, "Missing the required parameter 'objectName' when calling getData"));
    }
    // verify the required parameter 'objectId' is set
    if (objectId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectId' when calling getData",
        new ApiException(400, "Missing the required parameter 'objectId' when calling getData"));
    }

    // create path and map variables
    String path = "/object/data/{objectName}/{objectId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "objectName" + "\\}", apiInvoker.escapeString(objectName.toString())).replaceAll("\\{" + "objectId" + "\\}", apiInvoker.escapeString(objectId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "include", include));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse,  "", ObjectStoreResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Object
  * Get the definition of an Object. Returns all field names, types, and current size. The types supported are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY.
   * @param accountId The account id of the logged in user
   * @param appKey The application key for updating an existing application
   * @param objectName The name of the object to get the definition for
   * @return ObjectStoreResponse
  */
  public ObjectStoreResponse getObject (Long accountId, String appKey, String objectName) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling getObject",
        new ApiException(400, "Missing the required parameter 'accountId' when calling getObject"));
    }
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling getObject",
        new ApiException(400, "Missing the required parameter 'appKey' when calling getObject"));
    }
    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling getObject",
        new ApiException(400, "Missing the required parameter 'objectName' when calling getObject"));
    }

    // create path and map variables
    String path = "/object/get";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "objectName", objectName));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse, "", ObjectStoreResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Object
   * Get the definition of an Object. Returns all field names, types, and current size. The types supported are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY.
   * @param accountId The account id of the logged in user   * @param appKey The application key for updating an existing application   * @param objectName The name of the object to get the definition for
  */
  public void getObject (Long accountId, String appKey, String objectName, final Response.Listener<ObjectStoreResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling getObject",
        new ApiException(400, "Missing the required parameter 'accountId' when calling getObject"));
    }
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling getObject",
        new ApiException(400, "Missing the required parameter 'appKey' when calling getObject"));
    }
    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling getObject",
        new ApiException(400, "Missing the required parameter 'objectName' when calling getObject"));
    }

    // create path and map variables
    String path = "/object/get".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "objectName", objectName));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse,  "", ObjectStoreResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search Data
  * Search for records given the specified criteria.  The criteria is a defined set of json values used to build a query
   * @param objectName The name of the object to search upon
   * @param count If true just return the record count of the search. False (default) will return the actual records
   * @param start The start of the pagination
   * @param limit The limit of the pagination
   * @param accountId The account id of the logged in user
   * @param criteria The search criteria
   * @param order The order of results; comma seperated list of field names. Illegal field names will be ignored. Direction by defualt is ascending. Prepend a minus to the field name to make that field descending.
   * @param include 
   * @return ObjectStoreResponse
  */
  public ObjectStoreResponse searchData (String objectName, Boolean count, Long start, Long limit, Long accountId, String criteria, String order, String include) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling searchData",
        new ApiException(400, "Missing the required parameter 'objectName' when calling searchData"));
    }
    // verify the required parameter 'count' is set
    if (count == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'count' when calling searchData",
        new ApiException(400, "Missing the required parameter 'count' when calling searchData"));
    }
    // verify the required parameter 'start' is set
    if (start == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'start' when calling searchData",
        new ApiException(400, "Missing the required parameter 'start' when calling searchData"));
    }
    // verify the required parameter 'limit' is set
    if (limit == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'limit' when calling searchData",
        new ApiException(400, "Missing the required parameter 'limit' when calling searchData"));
    }

    // create path and map variables
    String path = "/object/data/{objectName}".replaceAll("\\{" + "objectName" + "\\}", apiInvoker.escapeString(objectName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "criteria", criteria));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "count", count));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "order", order));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "include", include));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse, "", ObjectStoreResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search Data
   * Search for records given the specified criteria.  The criteria is a defined set of json values used to build a query
   * @param objectName The name of the object to search upon   * @param count If true just return the record count of the search. False (default) will return the actual records   * @param start The start of the pagination   * @param limit The limit of the pagination   * @param accountId The account id of the logged in user   * @param criteria The search criteria   * @param order The order of results; comma seperated list of field names. Illegal field names will be ignored. Direction by defualt is ascending. Prepend a minus to the field name to make that field descending.   * @param include 
  */
  public void searchData (String objectName, Boolean count, Long start, Long limit, Long accountId, String criteria, String order, String include, final Response.Listener<ObjectStoreResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling searchData",
        new ApiException(400, "Missing the required parameter 'objectName' when calling searchData"));
    }
    // verify the required parameter 'count' is set
    if (count == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'count' when calling searchData",
        new ApiException(400, "Missing the required parameter 'count' when calling searchData"));
    }
    // verify the required parameter 'start' is set
    if (start == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'start' when calling searchData",
        new ApiException(400, "Missing the required parameter 'start' when calling searchData"));
    }
    // verify the required parameter 'limit' is set
    if (limit == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'limit' when calling searchData",
        new ApiException(400, "Missing the required parameter 'limit' when calling searchData"));
    }

    // create path and map variables
    String path = "/object/data/{objectName}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "objectName" + "\\}", apiInvoker.escapeString(objectName.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "criteria", criteria));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "count", count));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "order", order));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "include", include));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse,  "", ObjectStoreResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search Objects
  * Search for Objects and return the list of names found.  Use this in conjunction with the object get service to present the current data model defined.
   * @param accountId The account id of the logged in user
   * @param appKey The application key for updating an existing application
   * @param start The start of the pagination
   * @param limit The limit of the pagination
   * @param keyword The name of the object(s) to search for, can be a partial match
   * @return ObjectStoreResponse
  */
  public ObjectStoreResponse searchObject (Long accountId, String appKey, Long start, Long limit, String keyword) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling searchObject",
        new ApiException(400, "Missing the required parameter 'accountId' when calling searchObject"));
    }
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling searchObject",
        new ApiException(400, "Missing the required parameter 'appKey' when calling searchObject"));
    }
    // verify the required parameter 'start' is set
    if (start == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'start' when calling searchObject",
        new ApiException(400, "Missing the required parameter 'start' when calling searchObject"));
    }
    // verify the required parameter 'limit' is set
    if (limit == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'limit' when calling searchObject",
        new ApiException(400, "Missing the required parameter 'limit' when calling searchObject"));
    }

    // create path and map variables
    String path = "/object/search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse, "", ObjectStoreResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search Objects
   * Search for Objects and return the list of names found.  Use this in conjunction with the object get service to present the current data model defined.
   * @param accountId The account id of the logged in user   * @param appKey The application key for updating an existing application   * @param start The start of the pagination   * @param limit The limit of the pagination   * @param keyword The name of the object(s) to search for, can be a partial match
  */
  public void searchObject (Long accountId, String appKey, Long start, Long limit, String keyword, final Response.Listener<ObjectStoreResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling searchObject",
        new ApiException(400, "Missing the required parameter 'accountId' when calling searchObject"));
    }
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling searchObject",
        new ApiException(400, "Missing the required parameter 'appKey' when calling searchObject"));
    }
    // verify the required parameter 'start' is set
    if (start == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'start' when calling searchObject",
        new ApiException(400, "Missing the required parameter 'start' when calling searchObject"));
    }
    // verify the required parameter 'limit' is set
    if (limit == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'limit' when calling searchObject",
        new ApiException(400, "Missing the required parameter 'limit' when calling searchObject"));
    }

    // create path and map variables
    String path = "/object/search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse,  "", ObjectStoreResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Update Data
  * Update a record for the specified object.  If the object does not exist the request will be rejected, use the data create service for the first entry. If any of the fields included does not exist for the object then they are added to the object.
   * @param objectName The name of the object to search upon
   * @param objectId objectId The id of the record to return
   * @param accountId The account id of the logged in user
   * @param body 
   * @return ObjectStoreResponse
  */
  public ObjectStoreResponse updateData (String objectName, String objectId, Long accountId, String body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling updateData",
        new ApiException(400, "Missing the required parameter 'objectName' when calling updateData"));
    }
    // verify the required parameter 'objectId' is set
    if (objectId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectId' when calling updateData",
        new ApiException(400, "Missing the required parameter 'objectId' when calling updateData"));
    }

    // create path and map variables
    String path = "/object/data/{objectName}/{objectId}".replaceAll("\\{" + "objectName" + "\\}", apiInvoker.escapeString(objectName.toString())).replaceAll("\\{" + "objectId" + "\\}", apiInvoker.escapeString(objectId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "PUT", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse, "", ObjectStoreResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Update Data
   * Update a record for the specified object.  If the object does not exist the request will be rejected, use the data create service for the first entry. If any of the fields included does not exist for the object then they are added to the object.
   * @param objectName The name of the object to search upon   * @param objectId objectId The id of the record to return   * @param accountId The account id of the logged in user   * @param body 
  */
  public void updateData (String objectName, String objectId, Long accountId, String body, final Response.Listener<ObjectStoreResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'objectName' is set
    if (objectName == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectName' when calling updateData",
        new ApiException(400, "Missing the required parameter 'objectName' when calling updateData"));
    }
    // verify the required parameter 'objectId' is set
    if (objectId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'objectId' when calling updateData",
        new ApiException(400, "Missing the required parameter 'objectId' when calling updateData"));
    }

    // create path and map variables
    String path = "/object/data/{objectName}/{objectId}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "objectName" + "\\}", apiInvoker.escapeString(objectName.toString())).replaceAll("\\{" + "objectId" + "\\}", apiInvoker.escapeString(objectId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "PUT", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((ObjectStoreResponse) ApiInvoker.deserialize(localVarResponse,  "", ObjectStoreResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
