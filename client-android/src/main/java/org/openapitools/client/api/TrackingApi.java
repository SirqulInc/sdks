/*
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client.api;

import org.openapitools.client.ApiInvoker;
import org.openapitools.client.ApiException;
import org.openapitools.client.Pair;

import org.openapitools.client.model.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import org.openapitools.client.model.AccountMiniResponse;
import org.openapitools.client.model.Leg;
import org.openapitools.client.model.LegResponse;
import java.util.*;
import org.openapitools.client.model.PredictedLocationResponse;
import org.openapitools.client.model.PreferredLocationResponse;
import org.openapitools.client.model.SirqulResponse;
import org.openapitools.client.model.StepResponse;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class TrackingApi {
  String basePath = "https://dev.sirqul.com/api/3.18";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * Create Batch Tracking
  * Batch create tracking legs
   * @param data JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60; 
   * @param deviceId the device id (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param generateAccounts Whether to generate accounts for tracking entries when the owner does not exist
   * @param updateAccountLocations Whether to update the account&#39;s current location from the incoming tracking data
   * @param defaultTag The default tag to apply to incoming legs when no tag is provided
   * @param slaveUID 
   * @return List<Leg>
  */
  public List<Leg> batchSaveTracking (String data, String deviceId, Long accountId, Boolean generateAccounts, Boolean updateAccountLocations, String defaultTag, String slaveUID) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'data' is set
    if (data == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'data' when calling batchSaveTracking",
        new ApiException(400, "Missing the required parameter 'data' when calling batchSaveTracking"));
    }

    // create path and map variables
    String path = "/tracking/batch/create";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "data", data));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "generateAccounts", generateAccounts));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "updateAccountLocations", updateAccountLocations));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "defaultTag", defaultTag));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "slaveUID", slaveUID));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<Leg>) ApiInvoker.deserialize(localVarResponse, "array", Leg.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Create Batch Tracking
   * Batch create tracking legs
   * @param data JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60;    * @param deviceId the device id (deviceId or accountId required)   * @param accountId the account id of the user (deviceId or accountId required)   * @param generateAccounts Whether to generate accounts for tracking entries when the owner does not exist   * @param updateAccountLocations Whether to update the account&#39;s current location from the incoming tracking data   * @param defaultTag The default tag to apply to incoming legs when no tag is provided   * @param slaveUID 
  */
  public void batchSaveTracking (String data, String deviceId, Long accountId, Boolean generateAccounts, Boolean updateAccountLocations, String defaultTag, String slaveUID, final Response.Listener<List<Leg>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'data' is set
    if (data == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'data' when calling batchSaveTracking",
        new ApiException(400, "Missing the required parameter 'data' when calling batchSaveTracking"));
    }

    // create path and map variables
    String path = "/tracking/batch/create".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "data", data));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "generateAccounts", generateAccounts));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "updateAccountLocations", updateAccountLocations));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "defaultTag", defaultTag));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "slaveUID", slaveUID));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<Leg>) ApiInvoker.deserialize(localVarResponse,  "array", Leg.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Predicted Locations
  * Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.
   * @param accountId The account id of the customer
   * @param latitude latitude to return a more likely result set based on the user&#39;s current location
   * @param longitude longitude to return a more likely result set based on the user&#39;s current location
   * @param dateCheck Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used.
   * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;.
   * @param threshold The minimum number matches in 1 hour to be considered a likely location.
   * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}
   * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction.
   * @param sortOrder The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED}
   * @return PredictedLocationResponse
  */
  public PredictedLocationResponse getPredictedLocations (Long accountId, Double latitude, Double longitude, Long dateCheck, String hourCheck, Long threshold, String distanceUnit, Double searchRange, String sortOrder) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling getPredictedLocations",
        new ApiException(400, "Missing the required parameter 'accountId' when calling getPredictedLocations"));
    }

    // create path and map variables
    String path = "/tracking/predicted/get";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "dateCheck", dateCheck));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "hourCheck", hourCheck));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "threshold", threshold));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "distanceUnit", distanceUnit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "searchRange", searchRange));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortOrder", sortOrder));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (PredictedLocationResponse) ApiInvoker.deserialize(localVarResponse, "", PredictedLocationResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Predicted Locations
   * Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.
   * @param accountId The account id of the customer   * @param latitude latitude to return a more likely result set based on the user&#39;s current location   * @param longitude longitude to return a more likely result set based on the user&#39;s current location   * @param dateCheck Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used.   * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;.   * @param threshold The minimum number matches in 1 hour to be considered a likely location.   * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}   * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction.   * @param sortOrder The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED}
  */
  public void getPredictedLocations (Long accountId, Double latitude, Double longitude, Long dateCheck, String hourCheck, Long threshold, String distanceUnit, Double searchRange, String sortOrder, final Response.Listener<PredictedLocationResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling getPredictedLocations",
        new ApiException(400, "Missing the required parameter 'accountId' when calling getPredictedLocations"));
    }

    // create path and map variables
    String path = "/tracking/predicted/get".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "dateCheck", dateCheck));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "hourCheck", hourCheck));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "threshold", threshold));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "distanceUnit", distanceUnit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "searchRange", searchRange));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortOrder", sortOrder));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((PredictedLocationResponse) ApiInvoker.deserialize(localVarResponse,  "", PredictedLocationResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Tracking Path
  * Get the path (lat/long coordinates) between 2 steps previously logged for a customer.
   * @param accountId The account id of the customer
   * @param startStepId The stepId to begin from
   * @param endStepId The stepId to end with
   * @return List<StepResponse>
  */
  public List<StepResponse> getPredictedPath (Long accountId, Long startStepId, Long endStepId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling getPredictedPath",
        new ApiException(400, "Missing the required parameter 'accountId' when calling getPredictedPath"));
    }
    // verify the required parameter 'startStepId' is set
    if (startStepId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'startStepId' when calling getPredictedPath",
        new ApiException(400, "Missing the required parameter 'startStepId' when calling getPredictedPath"));
    }
    // verify the required parameter 'endStepId' is set
    if (endStepId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'endStepId' when calling getPredictedPath",
        new ApiException(400, "Missing the required parameter 'endStepId' when calling getPredictedPath"));
    }

    // create path and map variables
    String path = "/tracking/path/get";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startStepId", startStepId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endStepId", endStepId));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<StepResponse>) ApiInvoker.deserialize(localVarResponse, "array", StepResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Tracking Path
   * Get the path (lat/long coordinates) between 2 steps previously logged for a customer.
   * @param accountId The account id of the customer   * @param startStepId The stepId to begin from   * @param endStepId The stepId to end with
  */
  public void getPredictedPath (Long accountId, Long startStepId, Long endStepId, final Response.Listener<List<StepResponse>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling getPredictedPath",
        new ApiException(400, "Missing the required parameter 'accountId' when calling getPredictedPath"));
    }
    // verify the required parameter 'startStepId' is set
    if (startStepId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'startStepId' when calling getPredictedPath",
        new ApiException(400, "Missing the required parameter 'startStepId' when calling getPredictedPath"));
    }
    // verify the required parameter 'endStepId' is set
    if (endStepId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'endStepId' when calling getPredictedPath",
        new ApiException(400, "Missing the required parameter 'endStepId' when calling getPredictedPath"));
    }

    // create path and map variables
    String path = "/tracking/path/get".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startStepId", startStepId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endStepId", endStepId));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<StepResponse>) ApiInvoker.deserialize(localVarResponse,  "array", StepResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search Preferred Locations
  * Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.
   * @param accountId The account id of the customer
   * @param latitude latitude to return a more likely result set based on the user&#39;s current location
   * @param longitude longitude to return a more likely result set based on the user&#39;s current location
   * @param dateCheck Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.
   * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;.
   * @param sortField Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location
   * @param descending Determines whether the sorted list is in descending or ascending order
   * @param start The start index for pagination
   * @param limit The limit for pagination
   * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction.
   * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}
   * @return List<PreferredLocationResponse>
  */
  public List<PreferredLocationResponse> getPreferredLocations (Long accountId, Double latitude, Double longitude, Long dateCheck, String hourCheck, String sortField, Boolean descending, Integer start, Integer limit, Double searchRange, String distanceUnit) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling getPreferredLocations",
        new ApiException(400, "Missing the required parameter 'accountId' when calling getPreferredLocations"));
    }

    // create path and map variables
    String path = "/tracking/preferred/search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "dateCheck", dateCheck));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "hourCheck", hourCheck));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "searchRange", searchRange));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "distanceUnit", distanceUnit));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<PreferredLocationResponse>) ApiInvoker.deserialize(localVarResponse, "array", PreferredLocationResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search Preferred Locations
   * Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.
   * @param accountId The account id of the customer   * @param latitude latitude to return a more likely result set based on the user&#39;s current location   * @param longitude longitude to return a more likely result set based on the user&#39;s current location   * @param dateCheck Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.   * @param hourCheck Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;.   * @param sortField Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location   * @param descending Determines whether the sorted list is in descending or ascending order   * @param start The start index for pagination   * @param limit The limit for pagination   * @param searchRange Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction.   * @param distanceUnit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}
  */
  public void getPreferredLocations (Long accountId, Double latitude, Double longitude, Long dateCheck, String hourCheck, String sortField, Boolean descending, Integer start, Integer limit, Double searchRange, String distanceUnit, final Response.Listener<List<PreferredLocationResponse>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling getPreferredLocations",
        new ApiException(400, "Missing the required parameter 'accountId' when calling getPreferredLocations"));
    }

    // create path and map variables
    String path = "/tracking/preferred/search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "dateCheck", dateCheck));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "hourCheck", hourCheck));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "searchRange", searchRange));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "distanceUnit", distanceUnit));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<PreferredLocationResponse>) ApiInvoker.deserialize(localVarResponse,  "array", PreferredLocationResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search Tracking
  * Retrieve tracking data to be able to show where a user has been.
   * @param deviceId the device id (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param ownerId the account id of the person the user wants to tracking data for
   * @param trackingDeviceId the id of the tracking device
   * @param startDate the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.
   * @param endDate the end date in (UTC milliseconds) to filter the tracking results
   * @param tags filter results by tag
   * @param getLastPoint gets the last known location of the user
   * @return List<LegResponse>
  */
  public List<LegResponse> getTrackingLegs (String deviceId, Long accountId, Long ownerId, String trackingDeviceId, Long startDate, Long endDate, String tags, Boolean getLastPoint) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/tracking/search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ownerId", ownerId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "trackingDeviceId", trackingDeviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startDate", startDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endDate", endDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "tags", tags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "getLastPoint", getLastPoint));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<LegResponse>) ApiInvoker.deserialize(localVarResponse, "array", LegResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search Tracking
   * Retrieve tracking data to be able to show where a user has been.
   * @param deviceId the device id (deviceId or accountId required)   * @param accountId the account id of the user (deviceId or accountId required)   * @param ownerId the account id of the person the user wants to tracking data for   * @param trackingDeviceId the id of the tracking device   * @param startDate the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.   * @param endDate the end date in (UTC milliseconds) to filter the tracking results   * @param tags filter results by tag   * @param getLastPoint gets the last known location of the user
  */
  public void getTrackingLegs (String deviceId, Long accountId, Long ownerId, String trackingDeviceId, Long startDate, Long endDate, String tags, Boolean getLastPoint, final Response.Listener<List<LegResponse>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/tracking/search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ownerId", ownerId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "trackingDeviceId", trackingDeviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startDate", startDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endDate", endDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "tags", tags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "getLastPoint", getLastPoint));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<LegResponse>) ApiInvoker.deserialize(localVarResponse,  "array", LegResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Create Tracking Leg
  * Send tracking points to be able to generate pathing data
   * @param startLat the latitude of the first point
   * @param startLng the longitude of the first point
   * @param startDate the start date (in UTC milliseconds) of the first point
   * @param endLat the latitude of the last point
   * @param endLng the longitude of the last point
   * @param endDate the end date (in UTC milliseconds) of the last point
   * @param deviceId the device id (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param distance the total distance
   * @param duration the total duration
   * @param steps JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60; 
   * @param tags name the leg for searching
   * @return SirqulResponse
  */
  public SirqulResponse saveTrackingLeg (Double startLat, Double startLng, Long startDate, Double endLat, Double endLng, Long endDate, String deviceId, Long accountId, Double distance, Long duration, String steps, String tags) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'startLat' is set
    if (startLat == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'startLat' when calling saveTrackingLeg",
        new ApiException(400, "Missing the required parameter 'startLat' when calling saveTrackingLeg"));
    }
    // verify the required parameter 'startLng' is set
    if (startLng == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'startLng' when calling saveTrackingLeg",
        new ApiException(400, "Missing the required parameter 'startLng' when calling saveTrackingLeg"));
    }
    // verify the required parameter 'startDate' is set
    if (startDate == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'startDate' when calling saveTrackingLeg",
        new ApiException(400, "Missing the required parameter 'startDate' when calling saveTrackingLeg"));
    }
    // verify the required parameter 'endLat' is set
    if (endLat == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'endLat' when calling saveTrackingLeg",
        new ApiException(400, "Missing the required parameter 'endLat' when calling saveTrackingLeg"));
    }
    // verify the required parameter 'endLng' is set
    if (endLng == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'endLng' when calling saveTrackingLeg",
        new ApiException(400, "Missing the required parameter 'endLng' when calling saveTrackingLeg"));
    }
    // verify the required parameter 'endDate' is set
    if (endDate == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'endDate' when calling saveTrackingLeg",
        new ApiException(400, "Missing the required parameter 'endDate' when calling saveTrackingLeg"));
    }

    // create path and map variables
    String path = "/tracking/leg/create";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "distance", distance));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "duration", duration));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startLat", startLat));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startLng", startLng));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startDate", startDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endLat", endLat));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endLng", endLng));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endDate", endDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "steps", steps));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "tags", tags));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SirqulResponse) ApiInvoker.deserialize(localVarResponse, "", SirqulResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Create Tracking Leg
   * Send tracking points to be able to generate pathing data
   * @param startLat the latitude of the first point   * @param startLng the longitude of the first point   * @param startDate the start date (in UTC milliseconds) of the first point   * @param endLat the latitude of the last point   * @param endLng the longitude of the last point   * @param endDate the end date (in UTC milliseconds) of the last point   * @param deviceId the device id (deviceId or accountId required)   * @param accountId the account id of the user (deviceId or accountId required)   * @param distance the total distance   * @param duration the total duration   * @param steps JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60;    * @param tags name the leg for searching
  */
  public void saveTrackingLeg (Double startLat, Double startLng, Long startDate, Double endLat, Double endLng, Long endDate, String deviceId, Long accountId, Double distance, Long duration, String steps, String tags, final Response.Listener<SirqulResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'startLat' is set
    if (startLat == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'startLat' when calling saveTrackingLeg",
        new ApiException(400, "Missing the required parameter 'startLat' when calling saveTrackingLeg"));
    }
    // verify the required parameter 'startLng' is set
    if (startLng == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'startLng' when calling saveTrackingLeg",
        new ApiException(400, "Missing the required parameter 'startLng' when calling saveTrackingLeg"));
    }
    // verify the required parameter 'startDate' is set
    if (startDate == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'startDate' when calling saveTrackingLeg",
        new ApiException(400, "Missing the required parameter 'startDate' when calling saveTrackingLeg"));
    }
    // verify the required parameter 'endLat' is set
    if (endLat == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'endLat' when calling saveTrackingLeg",
        new ApiException(400, "Missing the required parameter 'endLat' when calling saveTrackingLeg"));
    }
    // verify the required parameter 'endLng' is set
    if (endLng == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'endLng' when calling saveTrackingLeg",
        new ApiException(400, "Missing the required parameter 'endLng' when calling saveTrackingLeg"));
    }
    // verify the required parameter 'endDate' is set
    if (endDate == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'endDate' when calling saveTrackingLeg",
        new ApiException(400, "Missing the required parameter 'endDate' when calling saveTrackingLeg"));
    }

    // create path and map variables
    String path = "/tracking/leg/create".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "distance", distance));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "duration", duration));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startLat", startLat));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startLng", startLng));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startDate", startDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endLat", endLat));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endLng", endLng));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endDate", endDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "steps", steps));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "tags", tags));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SirqulResponse) ApiInvoker.deserialize(localVarResponse,  "", SirqulResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Create Tracking Step
  * Send tracking points to be able to generate pathing data
   * @param legId the leg to add the step to
   * @param startLat the latitude of the first point
   * @param startLng the longitude of the first point
   * @param startDate the start date (in UTC milliseconds) of the first point
   * @param endLat the latitude of the last point
   * @param endLng the longitude of the last point
   * @param endDate the end date (in UTC milliseconds) of the last point
   * @param deviceId the device id (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param distance the total distance
   * @param duration the total duration
   * @return SirqulResponse
  */
  public SirqulResponse saveTrackingStep (Long legId, Double startLat, Double startLng, Long startDate, Double endLat, Double endLng, Long endDate, String deviceId, Long accountId, Double distance, Long duration) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'legId' is set
    if (legId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'legId' when calling saveTrackingStep",
        new ApiException(400, "Missing the required parameter 'legId' when calling saveTrackingStep"));
    }
    // verify the required parameter 'startLat' is set
    if (startLat == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'startLat' when calling saveTrackingStep",
        new ApiException(400, "Missing the required parameter 'startLat' when calling saveTrackingStep"));
    }
    // verify the required parameter 'startLng' is set
    if (startLng == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'startLng' when calling saveTrackingStep",
        new ApiException(400, "Missing the required parameter 'startLng' when calling saveTrackingStep"));
    }
    // verify the required parameter 'startDate' is set
    if (startDate == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'startDate' when calling saveTrackingStep",
        new ApiException(400, "Missing the required parameter 'startDate' when calling saveTrackingStep"));
    }
    // verify the required parameter 'endLat' is set
    if (endLat == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'endLat' when calling saveTrackingStep",
        new ApiException(400, "Missing the required parameter 'endLat' when calling saveTrackingStep"));
    }
    // verify the required parameter 'endLng' is set
    if (endLng == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'endLng' when calling saveTrackingStep",
        new ApiException(400, "Missing the required parameter 'endLng' when calling saveTrackingStep"));
    }
    // verify the required parameter 'endDate' is set
    if (endDate == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'endDate' when calling saveTrackingStep",
        new ApiException(400, "Missing the required parameter 'endDate' when calling saveTrackingStep"));
    }

    // create path and map variables
    String path = "/tracking/step/create";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "legId", legId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "distance", distance));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "duration", duration));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startLat", startLat));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startLng", startLng));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startDate", startDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endLat", endLat));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endLng", endLng));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endDate", endDate));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SirqulResponse) ApiInvoker.deserialize(localVarResponse, "", SirqulResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Create Tracking Step
   * Send tracking points to be able to generate pathing data
   * @param legId the leg to add the step to   * @param startLat the latitude of the first point   * @param startLng the longitude of the first point   * @param startDate the start date (in UTC milliseconds) of the first point   * @param endLat the latitude of the last point   * @param endLng the longitude of the last point   * @param endDate the end date (in UTC milliseconds) of the last point   * @param deviceId the device id (deviceId or accountId required)   * @param accountId the account id of the user (deviceId or accountId required)   * @param distance the total distance   * @param duration the total duration
  */
  public void saveTrackingStep (Long legId, Double startLat, Double startLng, Long startDate, Double endLat, Double endLng, Long endDate, String deviceId, Long accountId, Double distance, Long duration, final Response.Listener<SirqulResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'legId' is set
    if (legId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'legId' when calling saveTrackingStep",
        new ApiException(400, "Missing the required parameter 'legId' when calling saveTrackingStep"));
    }
    // verify the required parameter 'startLat' is set
    if (startLat == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'startLat' when calling saveTrackingStep",
        new ApiException(400, "Missing the required parameter 'startLat' when calling saveTrackingStep"));
    }
    // verify the required parameter 'startLng' is set
    if (startLng == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'startLng' when calling saveTrackingStep",
        new ApiException(400, "Missing the required parameter 'startLng' when calling saveTrackingStep"));
    }
    // verify the required parameter 'startDate' is set
    if (startDate == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'startDate' when calling saveTrackingStep",
        new ApiException(400, "Missing the required parameter 'startDate' when calling saveTrackingStep"));
    }
    // verify the required parameter 'endLat' is set
    if (endLat == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'endLat' when calling saveTrackingStep",
        new ApiException(400, "Missing the required parameter 'endLat' when calling saveTrackingStep"));
    }
    // verify the required parameter 'endLng' is set
    if (endLng == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'endLng' when calling saveTrackingStep",
        new ApiException(400, "Missing the required parameter 'endLng' when calling saveTrackingStep"));
    }
    // verify the required parameter 'endDate' is set
    if (endDate == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'endDate' when calling saveTrackingStep",
        new ApiException(400, "Missing the required parameter 'endDate' when calling saveTrackingStep"));
    }

    // create path and map variables
    String path = "/tracking/step/create".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "legId", legId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "distance", distance));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "duration", duration));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startLat", startLat));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startLng", startLng));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startDate", startDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endLat", endLat));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endLng", endLng));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endDate", endDate));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SirqulResponse) ApiInvoker.deserialize(localVarResponse,  "", SirqulResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * List Tracking
  * Search for all accounts that have tracking legs data by the given constraints.
   * @param accountId The account id of the user
   * @param keyword Used for LIKE search of first or last name on the acocunt
   * @param startDate Range to begin in UTC milliseconds
   * @param endDate Range to end in UTC milliseconds
   * @param tags Exact match on tag field of Legs&#39;s searchTag
   * @param audienceIds 
   * @param latitude Origin latitude to perform searching constraints with given range
   * @param longitude Origin longitude to perform searching constraints with given range
   * @param range The radius, in miles, to perform the search for
   * @param sortField The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY}
   * @param descending The order to return the results. Default is false, which will return the results in ascending order.
   * @param start The index into the record set to start with. Default is 0.
   * @param limit The total number of records to return. Default is 20.
   * @param activeOnly Determines whether to return only active results. Default is false.
   * @return List<AccountMiniResponse>
  */
  public List<AccountMiniResponse> searchAccountsWithTrackingLegs (Long accountId, String keyword, Long startDate, Long endDate, String tags, String audienceIds, Double latitude, Double longitude, Double range, String sortField, Boolean descending, Integer start, Integer limit, Boolean activeOnly) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling searchAccountsWithTrackingLegs",
        new ApiException(400, "Missing the required parameter 'accountId' when calling searchAccountsWithTrackingLegs"));
    }

    // create path and map variables
    String path = "/tracking/list";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startDate", startDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endDate", endDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "tags", tags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceIds", audienceIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "range", range));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "activeOnly", activeOnly));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<AccountMiniResponse>) ApiInvoker.deserialize(localVarResponse, "array", AccountMiniResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * List Tracking
   * Search for all accounts that have tracking legs data by the given constraints.
   * @param accountId The account id of the user   * @param keyword Used for LIKE search of first or last name on the acocunt   * @param startDate Range to begin in UTC milliseconds   * @param endDate Range to end in UTC milliseconds   * @param tags Exact match on tag field of Legs&#39;s searchTag   * @param audienceIds    * @param latitude Origin latitude to perform searching constraints with given range   * @param longitude Origin longitude to perform searching constraints with given range   * @param range The radius, in miles, to perform the search for   * @param sortField The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY}   * @param descending The order to return the results. Default is false, which will return the results in ascending order.   * @param start The index into the record set to start with. Default is 0.   * @param limit The total number of records to return. Default is 20.   * @param activeOnly Determines whether to return only active results. Default is false.
  */
  public void searchAccountsWithTrackingLegs (Long accountId, String keyword, Long startDate, Long endDate, String tags, String audienceIds, Double latitude, Double longitude, Double range, String sortField, Boolean descending, Integer start, Integer limit, Boolean activeOnly, final Response.Listener<List<AccountMiniResponse>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling searchAccountsWithTrackingLegs",
        new ApiException(400, "Missing the required parameter 'accountId' when calling searchAccountsWithTrackingLegs"));
    }

    // create path and map variables
    String path = "/tracking/list".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startDate", startDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endDate", endDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "tags", tags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceIds", audienceIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "range", range));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "activeOnly", activeOnly));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<AccountMiniResponse>) ApiInvoker.deserialize(localVarResponse,  "array", AccountMiniResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search Tracking (Billable)
  * Retrieve tracking data for billable/account scoped queries.
   * @param accountId The account id to search tracking for
   * @param appKey The application key
   * @param trackingDeviceId The id of the tracking device
   * @param startDate The start date in (UTC milliseconds) to filter the tracking results
   * @param endDate The end date in (UTC milliseconds) to filter the tracking results
   * @param tags Filter results by tag
   * @param start The start index for pagination
   * @param limit The limit for pagination
   * @return List<LegResponse>
  */
  public List<LegResponse> searchTrackingLegs (Long accountId, String appKey, String trackingDeviceId, Long startDate, Long endDate, String tags, Integer start, Integer limit) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling searchTrackingLegs",
        new ApiException(400, "Missing the required parameter 'accountId' when calling searchTrackingLegs"));
    }
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling searchTrackingLegs",
        new ApiException(400, "Missing the required parameter 'appKey' when calling searchTrackingLegs"));
    }

    // create path and map variables
    String path = "/tracking/searchByBillable";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "trackingDeviceId", trackingDeviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startDate", startDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endDate", endDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "tags", tags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<LegResponse>) ApiInvoker.deserialize(localVarResponse, "array", LegResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search Tracking (Billable)
   * Retrieve tracking data for billable/account scoped queries.
   * @param accountId The account id to search tracking for   * @param appKey The application key   * @param trackingDeviceId The id of the tracking device   * @param startDate The start date in (UTC milliseconds) to filter the tracking results   * @param endDate The end date in (UTC milliseconds) to filter the tracking results   * @param tags Filter results by tag   * @param start The start index for pagination   * @param limit The limit for pagination
  */
  public void searchTrackingLegs (Long accountId, String appKey, String trackingDeviceId, Long startDate, Long endDate, String tags, Integer start, Integer limit, final Response.Listener<List<LegResponse>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling searchTrackingLegs",
        new ApiException(400, "Missing the required parameter 'accountId' when calling searchTrackingLegs"));
    }
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling searchTrackingLegs",
        new ApiException(400, "Missing the required parameter 'appKey' when calling searchTrackingLegs"));
    }

    // create path and map variables
    String path = "/tracking/searchByBillable".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "trackingDeviceId", trackingDeviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startDate", startDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endDate", endDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "tags", tags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<LegResponse>) ApiInvoker.deserialize(localVarResponse,  "array", LegResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
