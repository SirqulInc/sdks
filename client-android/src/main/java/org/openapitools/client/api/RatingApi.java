/*
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client.api;

import org.openapitools.client.ApiInvoker;
import org.openapitools.client.ApiException;
import org.openapitools.client.Pair;

import org.openapitools.client.model.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import java.math.BigDecimal;
import java.util.*;
import org.openapitools.client.model.RatingIndexResponse;
import org.openapitools.client.model.RatingResponse;
import org.openapitools.client.model.SirqulResponse;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class RatingApi {
  String basePath = "http://localhost";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * Create Rating
  * This is used to leave rating on a ratable object (i.e. retailer locations). Each user can only rate on a ratable object once per category. If a user rates on the same object and category, the previous rating will be overwritten. Leaving a rating on a ratable object will be visible to everyone who has access to view the object.
   * @param version 
   * @param ratableType The ratable object type {RETAILER_LOCATION}
   * @param ratableId The id of the ratable object
   * @param ratingValue The integer value of 0-100
   * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used)
   * @param accountId The unique accountId that made the request (either deviceId or accountId must be used)
   * @param categoryId 
   * @param display A subject title for the user rating (limited to 255 characters)
   * @param description The description of the rating
   * @param locationDescription The description of the location
   * @param latitude The current location of the user
   * @param longitude The current location of the user
   * @return RatingResponse
  */
  public RatingResponse createRating (BigDecimal version, String ratableType, Long ratableId, Integer ratingValue, String deviceId, Long accountId, Long categoryId, String display, String description, String locationDescription, Double latitude, Double longitude) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling createRating",
        new ApiException(400, "Missing the required parameter 'version' when calling createRating"));
    }
    // verify the required parameter 'ratableType' is set
    if (ratableType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'ratableType' when calling createRating",
        new ApiException(400, "Missing the required parameter 'ratableType' when calling createRating"));
    }
    // verify the required parameter 'ratableId' is set
    if (ratableId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'ratableId' when calling createRating",
        new ApiException(400, "Missing the required parameter 'ratableId' when calling createRating"));
    }
    // verify the required parameter 'ratingValue' is set
    if (ratingValue == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'ratingValue' when calling createRating",
        new ApiException(400, "Missing the required parameter 'ratingValue' when calling createRating"));
    }

    // create path and map variables
    String path = "/api/{version}/rating/create".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratableType", ratableType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratableId", ratableId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratingValue", ratingValue));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "categoryId", categoryId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "display", display));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "description", description));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locationDescription", locationDescription));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (RatingResponse) ApiInvoker.deserialize(localVarResponse, "", RatingResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Create Rating
   * This is used to leave rating on a ratable object (i.e. retailer locations). Each user can only rate on a ratable object once per category. If a user rates on the same object and category, the previous rating will be overwritten. Leaving a rating on a ratable object will be visible to everyone who has access to view the object.
   * @param version    * @param ratableType The ratable object type {RETAILER_LOCATION}   * @param ratableId The id of the ratable object   * @param ratingValue The integer value of 0-100   * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used)   * @param accountId The unique accountId that made the request (either deviceId or accountId must be used)   * @param categoryId    * @param display A subject title for the user rating (limited to 255 characters)   * @param description The description of the rating   * @param locationDescription The description of the location   * @param latitude The current location of the user   * @param longitude The current location of the user
  */
  public void createRating (BigDecimal version, String ratableType, Long ratableId, Integer ratingValue, String deviceId, Long accountId, Long categoryId, String display, String description, String locationDescription, Double latitude, Double longitude, final Response.Listener<RatingResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling createRating",
        new ApiException(400, "Missing the required parameter 'version' when calling createRating"));
    }
    // verify the required parameter 'ratableType' is set
    if (ratableType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'ratableType' when calling createRating",
        new ApiException(400, "Missing the required parameter 'ratableType' when calling createRating"));
    }
    // verify the required parameter 'ratableId' is set
    if (ratableId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'ratableId' when calling createRating",
        new ApiException(400, "Missing the required parameter 'ratableId' when calling createRating"));
    }
    // verify the required parameter 'ratingValue' is set
    if (ratingValue == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'ratingValue' when calling createRating",
        new ApiException(400, "Missing the required parameter 'ratingValue' when calling createRating"));
    }

    // create path and map variables
    String path = "/api/{version}/rating/create".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratableType", ratableType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratableId", ratableId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratingValue", ratingValue));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "categoryId", categoryId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "display", display));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "description", description));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locationDescription", locationDescription));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((RatingResponse) ApiInvoker.deserialize(localVarResponse,  "", RatingResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Delete Rating
  * Sets a rating as deleted.
   * @param version 
   * @param ratingId The ID of the rating to delete
   * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used)
   * @param accountId The unique accountId that made the request (either deviceId or accountId must be used)
   * @return SirqulResponse
  */
  public SirqulResponse deleteRating (BigDecimal version, Long ratingId, String deviceId, Long accountId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling deleteRating",
        new ApiException(400, "Missing the required parameter 'version' when calling deleteRating"));
    }
    // verify the required parameter 'ratingId' is set
    if (ratingId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'ratingId' when calling deleteRating",
        new ApiException(400, "Missing the required parameter 'ratingId' when calling deleteRating"));
    }

    // create path and map variables
    String path = "/api/{version}/rating/delete".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratingId", ratingId));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SirqulResponse) ApiInvoker.deserialize(localVarResponse, "", SirqulResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Delete Rating
   * Sets a rating as deleted.
   * @param version    * @param ratingId The ID of the rating to delete   * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used)   * @param accountId The unique accountId that made the request (either deviceId or accountId must be used)
  */
  public void deleteRating (BigDecimal version, Long ratingId, String deviceId, Long accountId, final Response.Listener<SirqulResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling deleteRating",
        new ApiException(400, "Missing the required parameter 'version' when calling deleteRating"));
    }
    // verify the required parameter 'ratingId' is set
    if (ratingId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'ratingId' when calling deleteRating",
        new ApiException(400, "Missing the required parameter 'ratingId' when calling deleteRating"));
    }

    // create path and map variables
    String path = "/api/{version}/rating/delete".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratingId", ratingId));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SirqulResponse) ApiInvoker.deserialize(localVarResponse,  "", SirqulResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search Location Rating Indexes
  * Search for retailer locations by averages near you.
   * @param version 
   * @param categoryIds Comma separated list of category ids to filter the results by
   * @param keyword The keyword used to search
   * @param locationType The type of location to filter the results by
   * @param sortField The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}
   * @param descending The order to return the search results
   * @param start The record to begin the return set on
   * @param limit The number of records to return
   * @param searchRange The search radius in kilometers to filter results
   * @param latitude The current location of the user
   * @param longitude The current location of the user
   * @param returnOverallRating Determines whether to return the overall rating record instead
   * @param distanceUnit 
   * @param returnRetailer whether to return the retailer or not
   * @param returnAssets whether to return the assets or not
   * @param returnOffers whether to return the offers or not
   * @param returnCategories whether to return the categories or not
   * @param returnFilters whether to return the filters or not
   * @return List<RatingIndexResponse>
  */
  public List<RatingIndexResponse> searchLocationRatingIndexes (BigDecimal version, String categoryIds, String keyword, String locationType, String sortField, Boolean descending, Integer start, Integer limit, Double searchRange, Double latitude, Double longitude, Boolean returnOverallRating, String distanceUnit, Boolean returnRetailer, Boolean returnAssets, Boolean returnOffers, Boolean returnCategories, Boolean returnFilters) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling searchLocationRatingIndexes",
        new ApiException(400, "Missing the required parameter 'version' when calling searchLocationRatingIndexes"));
    }

    // create path and map variables
    String path = "/api/{version}/location/rating/index/search".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "categoryIds", categoryIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locationType", locationType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "searchRange", searchRange));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnOverallRating", returnOverallRating));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "distanceUnit", distanceUnit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnRetailer", returnRetailer));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnAssets", returnAssets));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnOffers", returnOffers));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnCategories", returnCategories));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnFilters", returnFilters));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<RatingIndexResponse>) ApiInvoker.deserialize(localVarResponse, "array", RatingIndexResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search Location Rating Indexes
   * Search for retailer locations by averages near you.
   * @param version    * @param categoryIds Comma separated list of category ids to filter the results by   * @param keyword The keyword used to search   * @param locationType The type of location to filter the results by   * @param sortField The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}   * @param descending The order to return the search results   * @param start The record to begin the return set on   * @param limit The number of records to return   * @param searchRange The search radius in kilometers to filter results   * @param latitude The current location of the user   * @param longitude The current location of the user   * @param returnOverallRating Determines whether to return the overall rating record instead   * @param distanceUnit    * @param returnRetailer whether to return the retailer or not   * @param returnAssets whether to return the assets or not   * @param returnOffers whether to return the offers or not   * @param returnCategories whether to return the categories or not   * @param returnFilters whether to return the filters or not
  */
  public void searchLocationRatingIndexes (BigDecimal version, String categoryIds, String keyword, String locationType, String sortField, Boolean descending, Integer start, Integer limit, Double searchRange, Double latitude, Double longitude, Boolean returnOverallRating, String distanceUnit, Boolean returnRetailer, Boolean returnAssets, Boolean returnOffers, Boolean returnCategories, Boolean returnFilters, final Response.Listener<List<RatingIndexResponse>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling searchLocationRatingIndexes",
        new ApiException(400, "Missing the required parameter 'version' when calling searchLocationRatingIndexes"));
    }

    // create path and map variables
    String path = "/api/{version}/location/rating/index/search".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "categoryIds", categoryIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locationType", locationType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "searchRange", searchRange));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnOverallRating", returnOverallRating));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "distanceUnit", distanceUnit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnRetailer", returnRetailer));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnAssets", returnAssets));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnOffers", returnOffers));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnCategories", returnCategories));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnFilters", returnFilters));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<RatingIndexResponse>) ApiInvoker.deserialize(localVarResponse,  "array", RatingIndexResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search Rating Indexes
  * Search for ratable items by averages.
   * @param version 
   * @param ratableType Filter results by a ratable type {RETAILER_LOCATION}
   * @param ratableIds Comma separated list of ratable ids to filter the resuts by
   * @param categoryIds Comma separated list of category ids to filter the results by
   * @param secondaryType 
   * @param keyword The keyword used to search
   * @param sortField The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}
   * @param descending The order to return the search results
   * @param start The record to begin the return set on
   * @param limit The number of records to return
   * @param latitude 
   * @param longitude 
   * @param returnRatable Determines whether to return the ratable object in the response
   * @param returnOverallRating Determines whether to return the overall rating record instead
   * @return List<RatingIndexResponse>
  */
  public List<RatingIndexResponse> searchRatingIndexes (BigDecimal version, String ratableType, String ratableIds, String categoryIds, String secondaryType, String keyword, String sortField, Boolean descending, Integer start, Integer limit, Double latitude, Double longitude, Boolean returnRatable, Boolean returnOverallRating) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling searchRatingIndexes",
        new ApiException(400, "Missing the required parameter 'version' when calling searchRatingIndexes"));
    }
    // verify the required parameter 'ratableType' is set
    if (ratableType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'ratableType' when calling searchRatingIndexes",
        new ApiException(400, "Missing the required parameter 'ratableType' when calling searchRatingIndexes"));
    }

    // create path and map variables
    String path = "/api/{version}/rating/index/search".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratableType", ratableType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratableIds", ratableIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "categoryIds", categoryIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "secondaryType", secondaryType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnRatable", returnRatable));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnOverallRating", returnOverallRating));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<RatingIndexResponse>) ApiInvoker.deserialize(localVarResponse, "array", RatingIndexResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search Rating Indexes
   * Search for ratable items by averages.
   * @param version    * @param ratableType Filter results by a ratable type {RETAILER_LOCATION}   * @param ratableIds Comma separated list of ratable ids to filter the resuts by   * @param categoryIds Comma separated list of category ids to filter the results by   * @param secondaryType    * @param keyword The keyword used to search   * @param sortField The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}   * @param descending The order to return the search results   * @param start The record to begin the return set on   * @param limit The number of records to return   * @param latitude    * @param longitude    * @param returnRatable Determines whether to return the ratable object in the response   * @param returnOverallRating Determines whether to return the overall rating record instead
  */
  public void searchRatingIndexes (BigDecimal version, String ratableType, String ratableIds, String categoryIds, String secondaryType, String keyword, String sortField, Boolean descending, Integer start, Integer limit, Double latitude, Double longitude, Boolean returnRatable, Boolean returnOverallRating, final Response.Listener<List<RatingIndexResponse>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling searchRatingIndexes",
        new ApiException(400, "Missing the required parameter 'version' when calling searchRatingIndexes"));
    }
    // verify the required parameter 'ratableType' is set
    if (ratableType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'ratableType' when calling searchRatingIndexes",
        new ApiException(400, "Missing the required parameter 'ratableType' when calling searchRatingIndexes"));
    }

    // create path and map variables
    String path = "/api/{version}/rating/index/search".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratableType", ratableType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratableIds", ratableIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "categoryIds", categoryIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "secondaryType", secondaryType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnRatable", returnRatable));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnOverallRating", returnOverallRating));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<RatingIndexResponse>) ApiInvoker.deserialize(localVarResponse,  "array", RatingIndexResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search Ratings
  * Search for ratings on a ratable object.
   * @param version 
   * @param deviceId The device id (deviceId or accountId required)
   * @param accountId The account id of the user (deviceId or accountId required)
   * @param filterAccountId Filter results for a particular account
   * @param ratableType The ratable object type {RETAILER_LOCATION}
   * @param ratableId The id of the ratable object
   * @param categoryIds Comma separated list of category ids to filter the results by
   * @param keyword The keyword used to search
   * @param sortField The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, OWNER_DISPLAY, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, VALUE}
   * @param descending The order to return the search results
   * @param start The record to begin the return set on
   * @param limit The number of records to return
   * @return List<RatingResponse>
  */
  public List<RatingResponse> searchRatings (BigDecimal version, String deviceId, Long accountId, Long filterAccountId, String ratableType, Long ratableId, String categoryIds, String keyword, String sortField, Boolean descending, Integer start, Integer limit) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling searchRatings",
        new ApiException(400, "Missing the required parameter 'version' when calling searchRatings"));
    }

    // create path and map variables
    String path = "/api/{version}/rating/search".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "filterAccountId", filterAccountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratableType", ratableType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratableId", ratableId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "categoryIds", categoryIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<RatingResponse>) ApiInvoker.deserialize(localVarResponse, "array", RatingResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search Ratings
   * Search for ratings on a ratable object.
   * @param version    * @param deviceId The device id (deviceId or accountId required)   * @param accountId The account id of the user (deviceId or accountId required)   * @param filterAccountId Filter results for a particular account   * @param ratableType The ratable object type {RETAILER_LOCATION}   * @param ratableId The id of the ratable object   * @param categoryIds Comma separated list of category ids to filter the results by   * @param keyword The keyword used to search   * @param sortField The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, OWNER_DISPLAY, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, VALUE}   * @param descending The order to return the search results   * @param start The record to begin the return set on   * @param limit The number of records to return
  */
  public void searchRatings (BigDecimal version, String deviceId, Long accountId, Long filterAccountId, String ratableType, Long ratableId, String categoryIds, String keyword, String sortField, Boolean descending, Integer start, Integer limit, final Response.Listener<List<RatingResponse>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling searchRatings",
        new ApiException(400, "Missing the required parameter 'version' when calling searchRatings"));
    }

    // create path and map variables
    String path = "/api/{version}/rating/search".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "filterAccountId", filterAccountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratableType", ratableType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratableId", ratableId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "categoryIds", categoryIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<RatingResponse>) ApiInvoker.deserialize(localVarResponse,  "array", RatingResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Update Rating
  * Update an existing rating. Only the creator of the rating have permission to update.
   * @param version 
   * @param ratingId The id of the rating (Note: this is not the ratable object id)
   * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used)
   * @param accountId The unique accountId that made the request (either deviceId or accountId must be used)
   * @param ratingValue The rating value to update
   * @param categoryId 
   * @param display A subject title for the user rating (limited to 255 characters)
   * @param description The description of the rating
   * @param locationDescription The description of the location
   * @param latitude The current location of the user
   * @param longitude The current location of the user
   * @return RatingResponse
  */
  public RatingResponse updateRating (BigDecimal version, Long ratingId, String deviceId, Long accountId, Integer ratingValue, Long categoryId, String display, String description, String locationDescription, Double latitude, Double longitude) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling updateRating",
        new ApiException(400, "Missing the required parameter 'version' when calling updateRating"));
    }
    // verify the required parameter 'ratingId' is set
    if (ratingId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'ratingId' when calling updateRating",
        new ApiException(400, "Missing the required parameter 'ratingId' when calling updateRating"));
    }

    // create path and map variables
    String path = "/api/{version}/rating/update".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratingId", ratingId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratingValue", ratingValue));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "categoryId", categoryId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "display", display));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "description", description));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locationDescription", locationDescription));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (RatingResponse) ApiInvoker.deserialize(localVarResponse, "", RatingResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Update Rating
   * Update an existing rating. Only the creator of the rating have permission to update.
   * @param version    * @param ratingId The id of the rating (Note: this is not the ratable object id)   * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used)   * @param accountId The unique accountId that made the request (either deviceId or accountId must be used)   * @param ratingValue The rating value to update   * @param categoryId    * @param display A subject title for the user rating (limited to 255 characters)   * @param description The description of the rating   * @param locationDescription The description of the location   * @param latitude The current location of the user   * @param longitude The current location of the user
  */
  public void updateRating (BigDecimal version, Long ratingId, String deviceId, Long accountId, Integer ratingValue, Long categoryId, String display, String description, String locationDescription, Double latitude, Double longitude, final Response.Listener<RatingResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling updateRating",
        new ApiException(400, "Missing the required parameter 'version' when calling updateRating"));
    }
    // verify the required parameter 'ratingId' is set
    if (ratingId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'ratingId' when calling updateRating",
        new ApiException(400, "Missing the required parameter 'ratingId' when calling updateRating"));
    }

    // create path and map variables
    String path = "/api/{version}/rating/update".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratingId", ratingId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ratingValue", ratingValue));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "categoryId", categoryId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "display", display));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "description", description));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locationDescription", locationDescription));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((RatingResponse) ApiInvoker.deserialize(localVarResponse,  "", RatingResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
