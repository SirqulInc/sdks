/*
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client.api;

import org.openapitools.client.ApiInvoker;
import org.openapitools.client.ApiException;
import org.openapitools.client.Pair;

import org.openapitools.client.model.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import org.openapitools.client.model.AgeGroupResponse;
import org.openapitools.client.model.AudienceDeviceResponse;
import org.openapitools.client.model.AudienceResponse;
import java.math.BigDecimal;
import java.util.*;
import org.openapitools.client.model.OfferListResponse;
import org.openapitools.client.model.SearchResponse;
import org.openapitools.client.model.SirqulResponse;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class AudienceApi {
  String basePath = "http://localhost";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * Create Audience
  * Create a user defined audience.
   * @param version 
   * @param accountId The logged in user.
   * @param name The name of the audience
   * @param description The description of the audience
   * @param searchTags The search tags
   * @param gender The gender; possible values are: MALE, FEMALE, ANY
   * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
   * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
   * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
   * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
   * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
   * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
   * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
   * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
   * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
   * @param startTimeOffset Seconds from the start time of an event
   * @param endTimeOffset Seconds from the end time of an event
   * @param sendSuggestion If true, then notify matching users when they are inside the radius
   * @param associateDescription The description of the associated object
   * @param associateType The type of the object to center the audience geofence
   * @param associateId The ID of the object to center the audience geofence
   * @param groupingId Optional grouping id for the audience
   * @param metaData External custom client defined data
   * @param visibility Visibility of the audience
   * @param audienceType Type of audience
   * @param useOrder Use order for cohort
   * @param cohortRegionsData Cohort data for \&quot;cohort\&quot; audience type
   * @param appKey Filter results by application key
   * @param trilaterationTypes Trilateration types
   * @param uniqueName If true, makes sure the audience name is unique
   * @return AudienceResponse
  */
  public AudienceResponse createAudience (BigDecimal version, Long accountId, String name, String description, String searchTags, String gender, String ageGroups, String categoryIds, String applicationIds, String gameExperienceLevel, String devices, String deviceIds, String deviceVersions, String locations, String radius, Integer startTimeOffset, Integer endTimeOffset, Boolean sendSuggestion, String associateDescription, String associateType, Long associateId, String groupingId, String metaData, String visibility, String audienceType, Boolean useOrder, String cohortRegionsData, String appKey, String trilaterationTypes, Boolean uniqueName) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling createAudience",
        new ApiException(400, "Missing the required parameter 'version' when calling createAudience"));
    }
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling createAudience",
        new ApiException(400, "Missing the required parameter 'accountId' when calling createAudience"));
    }
    // verify the required parameter 'name' is set
    if (name == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'name' when calling createAudience",
        new ApiException(400, "Missing the required parameter 'name' when calling createAudience"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/create".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "name", name));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "description", description));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "searchTags", searchTags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "gender", gender));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ageGroups", ageGroups));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "categoryIds", categoryIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "applicationIds", applicationIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "gameExperienceLevel", gameExperienceLevel));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "devices", devices));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceIds", deviceIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceVersions", deviceVersions));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locations", locations));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "radius", radius));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startTimeOffset", startTimeOffset));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endTimeOffset", endTimeOffset));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sendSuggestion", sendSuggestion));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "associateDescription", associateDescription));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "associateType", associateType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "associateId", associateId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "groupingId", groupingId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "metaData", metaData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "visibility", visibility));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceType", audienceType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "useOrder", useOrder));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "cohortRegionsData", cohortRegionsData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "trilaterationTypes", trilaterationTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "uniqueName", uniqueName));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (AudienceResponse) ApiInvoker.deserialize(localVarResponse, "", AudienceResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Create Audience
   * Create a user defined audience.
   * @param version    * @param accountId The logged in user.   * @param name The name of the audience   * @param description The description of the audience   * @param searchTags The search tags   * @param gender The gender; possible values are: MALE, FEMALE, ANY   * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)   * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)   * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)   * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT   * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)   * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)   * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)   * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)   * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.   * @param startTimeOffset Seconds from the start time of an event   * @param endTimeOffset Seconds from the end time of an event   * @param sendSuggestion If true, then notify matching users when they are inside the radius   * @param associateDescription The description of the associated object   * @param associateType The type of the object to center the audience geofence   * @param associateId The ID of the object to center the audience geofence   * @param groupingId Optional grouping id for the audience   * @param metaData External custom client defined data   * @param visibility Visibility of the audience   * @param audienceType Type of audience   * @param useOrder Use order for cohort   * @param cohortRegionsData Cohort data for \&quot;cohort\&quot; audience type   * @param appKey Filter results by application key   * @param trilaterationTypes Trilateration types   * @param uniqueName If true, makes sure the audience name is unique
  */
  public void createAudience (BigDecimal version, Long accountId, String name, String description, String searchTags, String gender, String ageGroups, String categoryIds, String applicationIds, String gameExperienceLevel, String devices, String deviceIds, String deviceVersions, String locations, String radius, Integer startTimeOffset, Integer endTimeOffset, Boolean sendSuggestion, String associateDescription, String associateType, Long associateId, String groupingId, String metaData, String visibility, String audienceType, Boolean useOrder, String cohortRegionsData, String appKey, String trilaterationTypes, Boolean uniqueName, final Response.Listener<AudienceResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling createAudience",
        new ApiException(400, "Missing the required parameter 'version' when calling createAudience"));
    }
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling createAudience",
        new ApiException(400, "Missing the required parameter 'accountId' when calling createAudience"));
    }
    // verify the required parameter 'name' is set
    if (name == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'name' when calling createAudience",
        new ApiException(400, "Missing the required parameter 'name' when calling createAudience"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/create".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "name", name));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "description", description));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "searchTags", searchTags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "gender", gender));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ageGroups", ageGroups));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "categoryIds", categoryIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "applicationIds", applicationIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "gameExperienceLevel", gameExperienceLevel));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "devices", devices));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceIds", deviceIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceVersions", deviceVersions));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locations", locations));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "radius", radius));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startTimeOffset", startTimeOffset));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endTimeOffset", endTimeOffset));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sendSuggestion", sendSuggestion));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "associateDescription", associateDescription));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "associateType", associateType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "associateId", associateId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "groupingId", groupingId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "metaData", metaData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "visibility", visibility));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceType", audienceType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "useOrder", useOrder));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "cohortRegionsData", cohortRegionsData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "trilaterationTypes", trilaterationTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "uniqueName", uniqueName));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((AudienceResponse) ApiInvoker.deserialize(localVarResponse,  "", AudienceResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Delete Audience
  * Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.
   * @param version 
   * @param accountId The logged in user.
   * @param audienceId The id of the audience to delete.
   * @return SirqulResponse
  */
  public SirqulResponse deleteAudience (BigDecimal version, Long accountId, Long audienceId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling deleteAudience",
        new ApiException(400, "Missing the required parameter 'version' when calling deleteAudience"));
    }
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling deleteAudience",
        new ApiException(400, "Missing the required parameter 'accountId' when calling deleteAudience"));
    }
    // verify the required parameter 'audienceId' is set
    if (audienceId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'audienceId' when calling deleteAudience",
        new ApiException(400, "Missing the required parameter 'audienceId' when calling deleteAudience"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/delete".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceId", audienceId));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SirqulResponse) ApiInvoker.deserialize(localVarResponse, "", SirqulResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Delete Audience
   * Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.
   * @param version    * @param accountId The logged in user.   * @param audienceId The id of the audience to delete.
  */
  public void deleteAudience (BigDecimal version, Long accountId, Long audienceId, final Response.Listener<SirqulResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling deleteAudience",
        new ApiException(400, "Missing the required parameter 'version' when calling deleteAudience"));
    }
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling deleteAudience",
        new ApiException(400, "Missing the required parameter 'accountId' when calling deleteAudience"));
    }
    // verify the required parameter 'audienceId' is set
    if (audienceId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'audienceId' when calling deleteAudience",
        new ApiException(400, "Missing the required parameter 'audienceId' when calling deleteAudience"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/delete".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceId", audienceId));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SirqulResponse) ApiInvoker.deserialize(localVarResponse,  "", SirqulResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Age Groups
  * Gets the list of available age groups that can be selected by consumers and retailers targeting offers.
   * @param version 
   * @return List<AgeGroupResponse>
  */
  public List<AgeGroupResponse> getAgeGroups (BigDecimal version) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling getAgeGroups",
        new ApiException(400, "Missing the required parameter 'version' when calling getAgeGroups"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/ageGroups".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<AgeGroupResponse>) ApiInvoker.deserialize(localVarResponse, "array", AgeGroupResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Age Groups
   * Gets the list of available age groups that can be selected by consumers and retailers targeting offers.
   * @param version 
  */
  public void getAgeGroups (BigDecimal version, final Response.Listener<List<AgeGroupResponse>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling getAgeGroups",
        new ApiException(400, "Missing the required parameter 'version' when calling getAgeGroups"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/ageGroups".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<AgeGroupResponse>) ApiInvoker.deserialize(localVarResponse,  "array", AgeGroupResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Audience
  * Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.
   * @param version 
   * @param accountId The logged in user.
   * @param audienceId The id of the audience to return.
   * @param appKey The application key (optional). If provided, results may be scoped to this application.
   * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app
   * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app
   * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned.
   * @return AudienceResponse
  */
  public AudienceResponse getAudience (BigDecimal version, Long accountId, Long audienceId, String appKey, Boolean returnAccountCount, Boolean returnAlbumCount, String albumTypesForCount) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling getAudience",
        new ApiException(400, "Missing the required parameter 'version' when calling getAudience"));
    }
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling getAudience",
        new ApiException(400, "Missing the required parameter 'accountId' when calling getAudience"));
    }
    // verify the required parameter 'audienceId' is set
    if (audienceId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'audienceId' when calling getAudience",
        new ApiException(400, "Missing the required parameter 'audienceId' when calling getAudience"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/get".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceId", audienceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnAccountCount", returnAccountCount));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnAlbumCount", returnAlbumCount));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "albumTypesForCount", albumTypesForCount));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (AudienceResponse) ApiInvoker.deserialize(localVarResponse, "", AudienceResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Audience
   * Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.
   * @param version    * @param accountId The logged in user.   * @param audienceId The id of the audience to return.   * @param appKey The application key (optional). If provided, results may be scoped to this application.   * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app   * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app   * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned.
  */
  public void getAudience (BigDecimal version, Long accountId, Long audienceId, String appKey, Boolean returnAccountCount, Boolean returnAlbumCount, String albumTypesForCount, final Response.Listener<AudienceResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling getAudience",
        new ApiException(400, "Missing the required parameter 'version' when calling getAudience"));
    }
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling getAudience",
        new ApiException(400, "Missing the required parameter 'accountId' when calling getAudience"));
    }
    // verify the required parameter 'audienceId' is set
    if (audienceId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'audienceId' when calling getAudience",
        new ApiException(400, "Missing the required parameter 'audienceId' when calling getAudience"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/get".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceId", audienceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnAccountCount", returnAccountCount));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnAlbumCount", returnAlbumCount));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "albumTypesForCount", albumTypesForCount));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((AudienceResponse) ApiInvoker.deserialize(localVarResponse,  "", AudienceResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search Audiences
  * Get the list audiences owned by the account
   * @param version 
   * @param accountId The logged in user.
   * @param albumIds Comma separated list of album IDs to filter results with
   * @param keyword The keyword used to search
   * @param keywordFields Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY
   * @param sortField The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}
   * @param descending The order to return the results. Default is false, which will return the results in ascending order.
   * @param start The index into the record set to start with.
   * @param limit The total number of record to return (there is a hard limit of 100).
   * @param sendSuggestion Filter results based on whether or not the audience is set to send suggestions
   * @param activeOnly Determines whether to return only active results. Default is false.
   * @param groupByGroupingId Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)
   * @param appKey Filter results by application key
   * @param returnGlobal If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well
   * @param exactKeyword If true, match keyword exactly
   * @param audienceType (Deprecated) Filter results by audience type
   * @param audienceTypes comma separated string with the different audience types you want to filter for
   * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app
   * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app
   * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned.
   * @return List<SearchResponse>
  */
  public List<SearchResponse> getAudienceList (BigDecimal version, Long accountId, String albumIds, String keyword, String keywordFields, String sortField, Boolean descending, Integer start, Integer limit, Boolean sendSuggestion, Boolean activeOnly, Boolean groupByGroupingId, String appKey, Boolean returnGlobal, Boolean exactKeyword, String audienceType, String audienceTypes, Boolean returnAccountCount, Boolean returnAlbumCount, String albumTypesForCount) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling getAudienceList",
        new ApiException(400, "Missing the required parameter 'version' when calling getAudienceList"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/search".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "albumIds", albumIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keywordFields", keywordFields));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sendSuggestion", sendSuggestion));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "activeOnly", activeOnly));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "groupByGroupingId", groupByGroupingId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnGlobal", returnGlobal));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "exactKeyword", exactKeyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceType", audienceType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceTypes", audienceTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnAccountCount", returnAccountCount));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnAlbumCount", returnAlbumCount));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "albumTypesForCount", albumTypesForCount));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<SearchResponse>) ApiInvoker.deserialize(localVarResponse, "array", SearchResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search Audiences
   * Get the list audiences owned by the account
   * @param version    * @param accountId The logged in user.   * @param albumIds Comma separated list of album IDs to filter results with   * @param keyword The keyword used to search   * @param keywordFields Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY   * @param sortField The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}   * @param descending The order to return the results. Default is false, which will return the results in ascending order.   * @param start The index into the record set to start with.   * @param limit The total number of record to return (there is a hard limit of 100).   * @param sendSuggestion Filter results based on whether or not the audience is set to send suggestions   * @param activeOnly Determines whether to return only active results. Default is false.   * @param groupByGroupingId Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)   * @param appKey Filter results by application key   * @param returnGlobal If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well   * @param exactKeyword If true, match keyword exactly   * @param audienceType (Deprecated) Filter results by audience type   * @param audienceTypes comma separated string with the different audience types you want to filter for   * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app   * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app   * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned.
  */
  public void getAudienceList (BigDecimal version, Long accountId, String albumIds, String keyword, String keywordFields, String sortField, Boolean descending, Integer start, Integer limit, Boolean sendSuggestion, Boolean activeOnly, Boolean groupByGroupingId, String appKey, Boolean returnGlobal, Boolean exactKeyword, String audienceType, String audienceTypes, Boolean returnAccountCount, Boolean returnAlbumCount, String albumTypesForCount, final Response.Listener<List<SearchResponse>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling getAudienceList",
        new ApiException(400, "Missing the required parameter 'version' when calling getAudienceList"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/search".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "albumIds", albumIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keywordFields", keywordFields));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sendSuggestion", sendSuggestion));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "activeOnly", activeOnly));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "groupByGroupingId", groupByGroupingId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnGlobal", returnGlobal));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "exactKeyword", exactKeyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceType", audienceType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceTypes", audienceTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnAccountCount", returnAccountCount));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnAlbumCount", returnAlbumCount));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "albumTypesForCount", albumTypesForCount));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<SearchResponse>) ApiInvoker.deserialize(localVarResponse,  "array", SearchResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Devices
  * Gets the list of available devices that can be selected by consumers and retailers.
   * @param version 
   * @param includeInactive If true return inactive record as well. default is false.
   * @return List<AudienceDeviceResponse>
  */
  public List<AudienceDeviceResponse> getDevices (BigDecimal version, Boolean includeInactive) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling getDevices",
        new ApiException(400, "Missing the required parameter 'version' when calling getDevices"));
    }
    // verify the required parameter 'includeInactive' is set
    if (includeInactive == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'includeInactive' when calling getDevices",
        new ApiException(400, "Missing the required parameter 'includeInactive' when calling getDevices"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/devices".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "includeInactive", includeInactive));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<AudienceDeviceResponse>) ApiInvoker.deserialize(localVarResponse, "array", AudienceDeviceResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Devices
   * Gets the list of available devices that can be selected by consumers and retailers.
   * @param version    * @param includeInactive If true return inactive record as well. default is false.
  */
  public void getDevices (BigDecimal version, Boolean includeInactive, final Response.Listener<List<AudienceDeviceResponse>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling getDevices",
        new ApiException(400, "Missing the required parameter 'version' when calling getDevices"));
    }
    // verify the required parameter 'includeInactive' is set
    if (includeInactive == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'includeInactive' when calling getDevices",
        new ApiException(400, "Missing the required parameter 'includeInactive' when calling getDevices"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/devices".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "includeInactive", includeInactive));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<AudienceDeviceResponse>) ApiInvoker.deserialize(localVarResponse,  "array", AudienceDeviceResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Experiences
  * Gets the list of available experiences that can be selected by consumers and retailers.
   * @param version 
   * @return SirqulResponse
  */
  public SirqulResponse getExperiences (BigDecimal version) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling getExperiences",
        new ApiException(400, "Missing the required parameter 'version' when calling getExperiences"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/experiences".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SirqulResponse) ApiInvoker.deserialize(localVarResponse, "", SirqulResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Experiences
   * Gets the list of available experiences that can be selected by consumers and retailers.
   * @param version 
  */
  public void getExperiences (BigDecimal version, final Response.Listener<SirqulResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling getExperiences",
        new ApiException(400, "Missing the required parameter 'version' when calling getExperiences"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/experiences".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SirqulResponse) ApiInvoker.deserialize(localVarResponse,  "", SirqulResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get GroupedAudiences
  * Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.
   * @param version 
   * @param accountId The logged in user.
   * @param audienceGroupingId The audience grouping id to return.
   * @return AudienceResponse
  */
  public AudienceResponse getGroupedAudiences (BigDecimal version, Long accountId, String audienceGroupingId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling getGroupedAudiences",
        new ApiException(400, "Missing the required parameter 'version' when calling getGroupedAudiences"));
    }
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling getGroupedAudiences",
        new ApiException(400, "Missing the required parameter 'accountId' when calling getGroupedAudiences"));
    }
    // verify the required parameter 'audienceGroupingId' is set
    if (audienceGroupingId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'audienceGroupingId' when calling getGroupedAudiences",
        new ApiException(400, "Missing the required parameter 'audienceGroupingId' when calling getGroupedAudiences"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/grouped/get".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceGroupingId", audienceGroupingId));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (AudienceResponse) ApiInvoker.deserialize(localVarResponse, "", AudienceResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get GroupedAudiences
   * Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.
   * @param version    * @param accountId The logged in user.   * @param audienceGroupingId The audience grouping id to return.
  */
  public void getGroupedAudiences (BigDecimal version, Long accountId, String audienceGroupingId, final Response.Listener<AudienceResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling getGroupedAudiences",
        new ApiException(400, "Missing the required parameter 'version' when calling getGroupedAudiences"));
    }
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling getGroupedAudiences",
        new ApiException(400, "Missing the required parameter 'accountId' when calling getGroupedAudiences"));
    }
    // verify the required parameter 'audienceGroupingId' is set
    if (audienceGroupingId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'audienceGroupingId' when calling getGroupedAudiences",
        new ApiException(400, "Missing the required parameter 'audienceGroupingId' when calling getGroupedAudiences"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/grouped/get".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceGroupingId", audienceGroupingId));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((AudienceResponse) ApiInvoker.deserialize(localVarResponse,  "", AudienceResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * List Suggestions by Audience
  * List either Missions or Offers that the user matches the assigned audience.
   * @param version 
   * @param accountId The account to match offers for.
   * @param limit the limit of the index
   * @param suggestionType the type of suggestion
   * @return OfferListResponse
  */
  public OfferListResponse listByAccount (BigDecimal version, Long accountId, Integer limit, String suggestionType) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling listByAccount",
        new ApiException(400, "Missing the required parameter 'version' when calling listByAccount"));
    }
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling listByAccount",
        new ApiException(400, "Missing the required parameter 'accountId' when calling listByAccount"));
    }
    // verify the required parameter 'limit' is set
    if (limit == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'limit' when calling listByAccount",
        new ApiException(400, "Missing the required parameter 'limit' when calling listByAccount"));
    }
    // verify the required parameter 'suggestionType' is set
    if (suggestionType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'suggestionType' when calling listByAccount",
        new ApiException(400, "Missing the required parameter 'suggestionType' when calling listByAccount"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/suggestion/list".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "suggestionType", suggestionType));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (OfferListResponse) ApiInvoker.deserialize(localVarResponse, "", OfferListResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * List Suggestions by Audience
   * List either Missions or Offers that the user matches the assigned audience.
   * @param version    * @param accountId The account to match offers for.   * @param limit the limit of the index   * @param suggestionType the type of suggestion
  */
  public void listByAccount (BigDecimal version, Long accountId, Integer limit, String suggestionType, final Response.Listener<OfferListResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling listByAccount",
        new ApiException(400, "Missing the required parameter 'version' when calling listByAccount"));
    }
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling listByAccount",
        new ApiException(400, "Missing the required parameter 'accountId' when calling listByAccount"));
    }
    // verify the required parameter 'limit' is set
    if (limit == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'limit' when calling listByAccount",
        new ApiException(400, "Missing the required parameter 'limit' when calling listByAccount"));
    }
    // verify the required parameter 'suggestionType' is set
    if (suggestionType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'suggestionType' when calling listByAccount",
        new ApiException(400, "Missing the required parameter 'suggestionType' when calling listByAccount"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/suggestion/list".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "suggestionType", suggestionType));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((OfferListResponse) ApiInvoker.deserialize(localVarResponse,  "", OfferListResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * List Offers by Audience
  * Get a list of offer locations based on audience information provided.
   * @param version 
   * @param limit this is the limit of the index
   * @param gender this is the gender to list offers by
   * @param age this is the age to list offers by
   * @param categoryIds this is the category IDs to list offers by
   * @param latitude this is the latitude to list offers by
   * @param longitude this is the longitude to list offers by
   * @return OfferListResponse
  */
  public OfferListResponse listByAudience (BigDecimal version, Integer limit, String gender, Integer age, String categoryIds, Double latitude, Double longitude) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling listByAudience",
        new ApiException(400, "Missing the required parameter 'version' when calling listByAudience"));
    }
    // verify the required parameter 'limit' is set
    if (limit == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'limit' when calling listByAudience",
        new ApiException(400, "Missing the required parameter 'limit' when calling listByAudience"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/suggestion/offersByAudience".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "gender", gender));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "age", age));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "categoryIds", categoryIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (OfferListResponse) ApiInvoker.deserialize(localVarResponse, "", OfferListResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * List Offers by Audience
   * Get a list of offer locations based on audience information provided.
   * @param version    * @param limit this is the limit of the index   * @param gender this is the gender to list offers by   * @param age this is the age to list offers by   * @param categoryIds this is the category IDs to list offers by   * @param latitude this is the latitude to list offers by   * @param longitude this is the longitude to list offers by
  */
  public void listByAudience (BigDecimal version, Integer limit, String gender, Integer age, String categoryIds, Double latitude, Double longitude, final Response.Listener<OfferListResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling listByAudience",
        new ApiException(400, "Missing the required parameter 'version' when calling listByAudience"));
    }
    // verify the required parameter 'limit' is set
    if (limit == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'limit' when calling listByAudience",
        new ApiException(400, "Missing the required parameter 'limit' when calling listByAudience"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/suggestion/offersByAudience".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "gender", gender));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "age", age));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "categoryIds", categoryIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((OfferListResponse) ApiInvoker.deserialize(localVarResponse,  "", OfferListResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * List Sent Suggestions 
  * Return list of recent trigger suggestions that have been sent to the user.
   * @param version 
   * @param accountId The account to match offers for.
   * @param timeframe The timeframe in seconds of the latest suggestions
   * @param suggestionType The type of trigger suggestions to return
   * @return OfferListResponse
  */
  public OfferListResponse listLastestByAccount (BigDecimal version, Long accountId, Integer timeframe, String suggestionType) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling listLastestByAccount",
        new ApiException(400, "Missing the required parameter 'version' when calling listLastestByAccount"));
    }
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling listLastestByAccount",
        new ApiException(400, "Missing the required parameter 'accountId' when calling listLastestByAccount"));
    }
    // verify the required parameter 'timeframe' is set
    if (timeframe == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'timeframe' when calling listLastestByAccount",
        new ApiException(400, "Missing the required parameter 'timeframe' when calling listLastestByAccount"));
    }
    // verify the required parameter 'suggestionType' is set
    if (suggestionType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'suggestionType' when calling listLastestByAccount",
        new ApiException(400, "Missing the required parameter 'suggestionType' when calling listLastestByAccount"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/suggestion/latest".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "timeframe", timeframe));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "suggestionType", suggestionType));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (OfferListResponse) ApiInvoker.deserialize(localVarResponse, "", OfferListResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * List Sent Suggestions 
   * Return list of recent trigger suggestions that have been sent to the user.
   * @param version    * @param accountId The account to match offers for.   * @param timeframe The timeframe in seconds of the latest suggestions   * @param suggestionType The type of trigger suggestions to return
  */
  public void listLastestByAccount (BigDecimal version, Long accountId, Integer timeframe, String suggestionType, final Response.Listener<OfferListResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling listLastestByAccount",
        new ApiException(400, "Missing the required parameter 'version' when calling listLastestByAccount"));
    }
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling listLastestByAccount",
        new ApiException(400, "Missing the required parameter 'accountId' when calling listLastestByAccount"));
    }
    // verify the required parameter 'timeframe' is set
    if (timeframe == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'timeframe' when calling listLastestByAccount",
        new ApiException(400, "Missing the required parameter 'timeframe' when calling listLastestByAccount"));
    }
    // verify the required parameter 'suggestionType' is set
    if (suggestionType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'suggestionType' when calling listLastestByAccount",
        new ApiException(400, "Missing the required parameter 'suggestionType' when calling listLastestByAccount"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/suggestion/latest".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "timeframe", timeframe));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "suggestionType", suggestionType));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((OfferListResponse) ApiInvoker.deserialize(localVarResponse,  "", OfferListResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Send Suggestions
  * Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.
   * @param version 
   * @param accountId The account to match offers for.
   * @param latitude the latitude
   * @param longitude the longitude
   * @return SirqulResponse
  */
  public SirqulResponse sendByAccount (BigDecimal version, Long accountId, Double latitude, Double longitude) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling sendByAccount",
        new ApiException(400, "Missing the required parameter 'version' when calling sendByAccount"));
    }
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling sendByAccount",
        new ApiException(400, "Missing the required parameter 'accountId' when calling sendByAccount"));
    }
    // verify the required parameter 'latitude' is set
    if (latitude == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'latitude' when calling sendByAccount",
        new ApiException(400, "Missing the required parameter 'latitude' when calling sendByAccount"));
    }
    // verify the required parameter 'longitude' is set
    if (longitude == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'longitude' when calling sendByAccount",
        new ApiException(400, "Missing the required parameter 'longitude' when calling sendByAccount"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/suggestion/send".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SirqulResponse) ApiInvoker.deserialize(localVarResponse, "", SirqulResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Send Suggestions
   * Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.
   * @param version    * @param accountId The account to match offers for.   * @param latitude the latitude   * @param longitude the longitude
  */
  public void sendByAccount (BigDecimal version, Long accountId, Double latitude, Double longitude, final Response.Listener<SirqulResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling sendByAccount",
        new ApiException(400, "Missing the required parameter 'version' when calling sendByAccount"));
    }
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling sendByAccount",
        new ApiException(400, "Missing the required parameter 'accountId' when calling sendByAccount"));
    }
    // verify the required parameter 'latitude' is set
    if (latitude == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'latitude' when calling sendByAccount",
        new ApiException(400, "Missing the required parameter 'latitude' when calling sendByAccount"));
    }
    // verify the required parameter 'longitude' is set
    if (longitude == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'longitude' when calling sendByAccount",
        new ApiException(400, "Missing the required parameter 'longitude' when calling sendByAccount"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/suggestion/send".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SirqulResponse) ApiInvoker.deserialize(localVarResponse,  "", SirqulResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Update Audience
  * Update a user defined audience.
   * @param version 
   * @param accountId The logged in user.
   * @param audienceId The id of the audience to update.
   * @param name The name of the audience
   * @param description The description of the audience
   * @param searchTags The search tags
   * @param gender The gender; possible values are: MALE, FEMALE, ANY
   * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
   * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
   * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
   * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
   * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
   * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
   * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
   * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
   * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
   * @param active if audience is active
   * @param sendSuggestion If true, then notify matching users when they are inside the radius
   * @param startTimeOffset Seconds from the start time of an event
   * @param endTimeOffset Seconds from the end time of an event
   * @param associateDescription the associate description
   * @param associateType The type of the object to center the audience geofence
   * @param associateId The ID of the object to center the audience geofence
   * @param groupingId Optional grouping id for the audience
   * @param metaData External custom client defined data
   * @param visibility Visibility of the audience
   * @param audienceType Type of audience
   * @param useOrder Use order for cohort
   * @param cohortRegionsData Cohort data for \&quot;cohort\&quot; audience type
   * @param appKey Filter results by application key
   * @param trilaterationTypes Trilateration types
   * @param uniqueName If true, makes sure the audience name is unique
   * @return AudienceResponse
  */
  public AudienceResponse updateAudience (BigDecimal version, Long accountId, Long audienceId, String name, String description, String searchTags, String gender, String ageGroups, String categoryIds, String applicationIds, String gameExperienceLevel, String devices, String deviceIds, String deviceVersions, String locations, String radius, Boolean active, Boolean sendSuggestion, Integer startTimeOffset, Integer endTimeOffset, String associateDescription, String associateType, Long associateId, String groupingId, String metaData, String visibility, String audienceType, Boolean useOrder, String cohortRegionsData, String appKey, String trilaterationTypes, Boolean uniqueName) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling updateAudience",
        new ApiException(400, "Missing the required parameter 'version' when calling updateAudience"));
    }
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling updateAudience",
        new ApiException(400, "Missing the required parameter 'accountId' when calling updateAudience"));
    }
    // verify the required parameter 'audienceId' is set
    if (audienceId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'audienceId' when calling updateAudience",
        new ApiException(400, "Missing the required parameter 'audienceId' when calling updateAudience"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/update".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceId", audienceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "name", name));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "description", description));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "searchTags", searchTags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "gender", gender));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ageGroups", ageGroups));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "categoryIds", categoryIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "applicationIds", applicationIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "gameExperienceLevel", gameExperienceLevel));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "devices", devices));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceIds", deviceIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceVersions", deviceVersions));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locations", locations));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "radius", radius));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "active", active));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sendSuggestion", sendSuggestion));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startTimeOffset", startTimeOffset));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endTimeOffset", endTimeOffset));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "associateDescription", associateDescription));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "associateType", associateType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "associateId", associateId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "groupingId", groupingId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "metaData", metaData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "visibility", visibility));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceType", audienceType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "useOrder", useOrder));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "cohortRegionsData", cohortRegionsData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "trilaterationTypes", trilaterationTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "uniqueName", uniqueName));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (AudienceResponse) ApiInvoker.deserialize(localVarResponse, "", AudienceResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Update Audience
   * Update a user defined audience.
   * @param version    * @param accountId The logged in user.   * @param audienceId The id of the audience to update.   * @param name The name of the audience   * @param description The description of the audience   * @param searchTags The search tags   * @param gender The gender; possible values are: MALE, FEMALE, ANY   * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)   * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)   * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)   * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT   * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)   * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)   * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)   * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)   * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.   * @param active if audience is active   * @param sendSuggestion If true, then notify matching users when they are inside the radius   * @param startTimeOffset Seconds from the start time of an event   * @param endTimeOffset Seconds from the end time of an event   * @param associateDescription the associate description   * @param associateType The type of the object to center the audience geofence   * @param associateId The ID of the object to center the audience geofence   * @param groupingId Optional grouping id for the audience   * @param metaData External custom client defined data   * @param visibility Visibility of the audience   * @param audienceType Type of audience   * @param useOrder Use order for cohort   * @param cohortRegionsData Cohort data for \&quot;cohort\&quot; audience type   * @param appKey Filter results by application key   * @param trilaterationTypes Trilateration types   * @param uniqueName If true, makes sure the audience name is unique
  */
  public void updateAudience (BigDecimal version, Long accountId, Long audienceId, String name, String description, String searchTags, String gender, String ageGroups, String categoryIds, String applicationIds, String gameExperienceLevel, String devices, String deviceIds, String deviceVersions, String locations, String radius, Boolean active, Boolean sendSuggestion, Integer startTimeOffset, Integer endTimeOffset, String associateDescription, String associateType, Long associateId, String groupingId, String metaData, String visibility, String audienceType, Boolean useOrder, String cohortRegionsData, String appKey, String trilaterationTypes, Boolean uniqueName, final Response.Listener<AudienceResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling updateAudience",
        new ApiException(400, "Missing the required parameter 'version' when calling updateAudience"));
    }
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling updateAudience",
        new ApiException(400, "Missing the required parameter 'accountId' when calling updateAudience"));
    }
    // verify the required parameter 'audienceId' is set
    if (audienceId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'audienceId' when calling updateAudience",
        new ApiException(400, "Missing the required parameter 'audienceId' when calling updateAudience"));
    }

    // create path and map variables
    String path = "/api/{version}/audience/update".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceId", audienceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "name", name));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "description", description));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "searchTags", searchTags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "gender", gender));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ageGroups", ageGroups));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "categoryIds", categoryIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "applicationIds", applicationIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "gameExperienceLevel", gameExperienceLevel));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "devices", devices));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceIds", deviceIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceVersions", deviceVersions));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locations", locations));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "radius", radius));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "active", active));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sendSuggestion", sendSuggestion));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startTimeOffset", startTimeOffset));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endTimeOffset", endTimeOffset));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "associateDescription", associateDescription));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "associateType", associateType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "associateId", associateId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "groupingId", groupingId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "metaData", metaData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "visibility", visibility));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceType", audienceType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "useOrder", useOrder));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "cohortRegionsData", cohortRegionsData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "trilaterationTypes", trilaterationTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "uniqueName", uniqueName));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((AudienceResponse) ApiInvoker.deserialize(localVarResponse,  "", AudienceResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
