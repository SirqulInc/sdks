/*
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client.api;

import org.openapitools.client.ApiInvoker;
import org.openapitools.client.ApiException;
import org.openapitools.client.Pair;

import org.openapitools.client.model.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import java.math.BigDecimal;
import org.openapitools.client.model.CoordsResponse;
import java.io.File;
import org.openapitools.client.model.GeoPointResponse;
import org.openapitools.client.model.LocationSearchResponse;
import org.openapitools.client.model.SirqulResponse;
import org.openapitools.client.model.TrilatCacheRequest;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class LocationApi {
  String basePath = "http://localhost";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * Create Trilateration Data with File
  * Creates trilateration samples for a source device (i.e. a router).
   * @param version 
   * @param udid The unique identifier of the source device
   * @param sourceTime The current timestamp of the source device
   * @param minimumSampleSize the minimum number of Edysen devices that must be used to be able to trilaterate a device
   * @param data The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;:\&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;: \&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60; 
   * @param dataFile Binary file containing data (multipart upload)
   * @return SirqulResponse
  */
  public SirqulResponse cacheTrilaterationData (BigDecimal version, String udid, Long sourceTime, Integer minimumSampleSize, String data, File dataFile) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling cacheTrilaterationData",
        new ApiException(400, "Missing the required parameter 'version' when calling cacheTrilaterationData"));
    }
    // verify the required parameter 'udid' is set
    if (udid == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'udid' when calling cacheTrilaterationData",
        new ApiException(400, "Missing the required parameter 'udid' when calling cacheTrilaterationData"));
    }

    // create path and map variables
    String path = "/api/{version}/location/trilaterate/cache".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "udid", udid));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sourceTime", sourceTime));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "minimumSampleSize", minimumSampleSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "data", data));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "dataFile", dataFile));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SirqulResponse) ApiInvoker.deserialize(localVarResponse, "", SirqulResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Create Trilateration Data with File
   * Creates trilateration samples for a source device (i.e. a router).
   * @param version    * @param udid The unique identifier of the source device   * @param sourceTime The current timestamp of the source device   * @param minimumSampleSize the minimum number of Edysen devices that must be used to be able to trilaterate a device   * @param data The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;:\&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;: \&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60;    * @param dataFile Binary file containing data (multipart upload)
  */
  public void cacheTrilaterationData (BigDecimal version, String udid, Long sourceTime, Integer minimumSampleSize, String data, File dataFile, final Response.Listener<SirqulResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling cacheTrilaterationData",
        new ApiException(400, "Missing the required parameter 'version' when calling cacheTrilaterationData"));
    }
    // verify the required parameter 'udid' is set
    if (udid == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'udid' when calling cacheTrilaterationData",
        new ApiException(400, "Missing the required parameter 'udid' when calling cacheTrilaterationData"));
    }

    // create path and map variables
    String path = "/api/{version}/location/trilaterate/cache".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "udid", udid));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sourceTime", sourceTime));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "minimumSampleSize", minimumSampleSize));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "data", data));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "dataFile", dataFile));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SirqulResponse) ApiInvoker.deserialize(localVarResponse,  "", SirqulResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Create Trilateration Data with Rest
  * Creates trilateration samples for a source device (i.e. a router).
   * @param version 
   * @param body 
   * @return SirqulResponse
  */
  public SirqulResponse cacheTrilaterationDataGzip (BigDecimal version, TrilatCacheRequest body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling cacheTrilaterationDataGzip",
        new ApiException(400, "Missing the required parameter 'version' when calling cacheTrilaterationDataGzip"));
    }

    // create path and map variables
    String path = "/api/{version}/location/trilaterate/cache/submit".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SirqulResponse) ApiInvoker.deserialize(localVarResponse, "", SirqulResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Create Trilateration Data with Rest
   * Creates trilateration samples for a source device (i.e. a router).
   * @param version    * @param body 
  */
  public void cacheTrilaterationDataGzip (BigDecimal version, TrilatCacheRequest body, final Response.Listener<SirqulResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = body;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling cacheTrilaterationDataGzip",
        new ApiException(400, "Missing the required parameter 'version' when calling cacheTrilaterationDataGzip"));
    }

    // create path and map variables
    String path = "/api/{version}/location/trilaterate/cache/submit".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SirqulResponse) ApiInvoker.deserialize(localVarResponse,  "", SirqulResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Location by IP
  * Get location information based on an IP address.
   * @param version 
   * @param ip the ip address of the client device
   * @return CoordsResponse
  */
  public CoordsResponse getLocationByIp (BigDecimal version, String ip) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling getLocationByIp",
        new ApiException(400, "Missing the required parameter 'version' when calling getLocationByIp"));
    }

    // create path and map variables
    String path = "/api/{version}/location/ip".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ip", ip));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (CoordsResponse) ApiInvoker.deserialize(localVarResponse, "", CoordsResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Location by IP
   * Get location information based on an IP address.
   * @param version    * @param ip the ip address of the client device
  */
  public void getLocationByIp (BigDecimal version, String ip, final Response.Listener<CoordsResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling getLocationByIp",
        new ApiException(400, "Missing the required parameter 'version' when calling getLocationByIp"));
    }

    // create path and map variables
    String path = "/api/{version}/location/ip".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "ip", ip));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((CoordsResponse) ApiInvoker.deserialize(localVarResponse,  "", CoordsResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Location by Trilateration
  * Send in device data and calculate a position based on signal strengths.
   * @param version 
   * @param accountId The account making the request, if provided the last know location will be updated
   * @param latitude The known GPS latitude to compare to the calculated version
   * @param longitude The known GPS longitude to compare to the calculated version
   * @param data The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60; 
   * @param responseFilters Optional response filters (not used currently)
   * @return GeoPointResponse
  */
  public GeoPointResponse getLocationByTrilateration (BigDecimal version, Long accountId, Double latitude, Double longitude, String data, String responseFilters) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling getLocationByTrilateration",
        new ApiException(400, "Missing the required parameter 'version' when calling getLocationByTrilateration"));
    }

    // create path and map variables
    String path = "/api/{version}/account/location/trilaterate".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "data", data));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "responseFilters", responseFilters));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (GeoPointResponse) ApiInvoker.deserialize(localVarResponse, "", GeoPointResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Location by Trilateration
   * Send in device data and calculate a position based on signal strengths.
   * @param version    * @param accountId The account making the request, if provided the last know location will be updated   * @param latitude The known GPS latitude to compare to the calculated version   * @param longitude The known GPS longitude to compare to the calculated version   * @param data The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60;    * @param responseFilters Optional response filters (not used currently)
  */
  public void getLocationByTrilateration (BigDecimal version, Long accountId, Double latitude, Double longitude, String data, String responseFilters, final Response.Listener<GeoPointResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling getLocationByTrilateration",
        new ApiException(400, "Missing the required parameter 'version' when calling getLocationByTrilateration"));
    }

    // create path and map variables
    String path = "/api/{version}/account/location/trilaterate".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "data", data));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "responseFilters", responseFilters));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((GeoPointResponse) ApiInvoker.deserialize(localVarResponse,  "", GeoPointResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search Regions or Postal Codes
  * Searches geographic locations by proximity via address or keyword.
   * @param version 
   * @param deviceId the device id
   * @param accountId the account id
   * @param currentlatitude This parameter is deprecated.
   * @param currentlongitude This parameter is deprecated.
   * @param currentLatitude the current latitude of the user
   * @param currentLongitude the current longitude of the user
   * @param query the query results by keyword or address
   * @param zipcode This parameter is deprecated.
   * @param zipCode the zip code to filter results
   * @param selectedMaplatitude This parameter is deprecated.
   * @param selectedMaplongitude This parameter is deprecated.
   * @param selectedMapLatitude the latitude of where the search should originate from
   * @param selectedMapLongitude the longitude of where the search should originate from
   * @param searchRange the search range of the search in miles
   * @param useGeocode determines whether to allow searches via address
   * @param i This parameter is deprecated.
   * @param start the start index for pagination
   * @param l This parameter is deprecated.
   * @param limit the limit for pagination
   * @return LocationSearchResponse
  */
  public LocationSearchResponse getLocations (BigDecimal version, String deviceId, Long accountId, Double currentlatitude, Double currentlongitude, Double currentLatitude, Double currentLongitude, String query, String zipcode, String zipCode, Double selectedMaplatitude, Double selectedMaplongitude, Double selectedMapLatitude, Double selectedMapLongitude, Double searchRange, Boolean useGeocode, Integer i, Integer start, Integer l, Integer limit) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling getLocations",
        new ApiException(400, "Missing the required parameter 'version' when calling getLocations"));
    }

    // create path and map variables
    String path = "/api/{version}/location/search".replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "currentlatitude", currentlatitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "currentlongitude", currentlongitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "currentLatitude", currentLatitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "currentLongitude", currentLongitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "query", query));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "zipcode", zipcode));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "zipCode", zipCode));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "selectedMaplatitude", selectedMaplatitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "selectedMaplongitude", selectedMaplongitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "selectedMapLatitude", selectedMapLatitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "selectedMapLongitude", selectedMapLongitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "searchRange", searchRange));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "useGeocode", useGeocode));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "_i", i));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "_l", l));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (LocationSearchResponse) ApiInvoker.deserialize(localVarResponse, "", LocationSearchResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search Regions or Postal Codes
   * Searches geographic locations by proximity via address or keyword.
   * @param version    * @param deviceId the device id   * @param accountId the account id   * @param currentlatitude This parameter is deprecated.   * @param currentlongitude This parameter is deprecated.   * @param currentLatitude the current latitude of the user   * @param currentLongitude the current longitude of the user   * @param query the query results by keyword or address   * @param zipcode This parameter is deprecated.   * @param zipCode the zip code to filter results   * @param selectedMaplatitude This parameter is deprecated.   * @param selectedMaplongitude This parameter is deprecated.   * @param selectedMapLatitude the latitude of where the search should originate from   * @param selectedMapLongitude the longitude of where the search should originate from   * @param searchRange the search range of the search in miles   * @param useGeocode determines whether to allow searches via address   * @param i This parameter is deprecated.   * @param start the start index for pagination   * @param l This parameter is deprecated.   * @param limit the limit for pagination
  */
  public void getLocations (BigDecimal version, String deviceId, Long accountId, Double currentlatitude, Double currentlongitude, Double currentLatitude, Double currentLongitude, String query, String zipcode, String zipCode, Double selectedMaplatitude, Double selectedMaplongitude, Double selectedMapLatitude, Double selectedMapLongitude, Double searchRange, Boolean useGeocode, Integer i, Integer start, Integer l, Integer limit, final Response.Listener<LocationSearchResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'version' is set
    if (version == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'version' when calling getLocations",
        new ApiException(400, "Missing the required parameter 'version' when calling getLocations"));
    }

    // create path and map variables
    String path = "/api/{version}/location/search".replaceAll("\\{format\\}","json").replaceAll("\\{" + "version" + "\\}", apiInvoker.escapeString(version.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "currentlatitude", currentlatitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "currentlongitude", currentlongitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "currentLatitude", currentLatitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "currentLongitude", currentLongitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "query", query));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "zipcode", zipcode));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "zipCode", zipCode));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "selectedMaplatitude", selectedMaplatitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "selectedMaplongitude", selectedMaplongitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "selectedMapLatitude", selectedMapLatitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "selectedMapLongitude", selectedMapLongitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "searchRange", searchRange));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "useGeocode", useGeocode));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "_i", i));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "_l", l));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((LocationSearchResponse) ApiInvoker.deserialize(localVarResponse,  "", LocationSearchResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
