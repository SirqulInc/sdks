/*
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client.api;

import org.openapitools.client.ApiInvoker;
import org.openapitools.client.ApiException;
import org.openapitools.client.Pair;

import org.openapitools.client.model.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import org.openapitools.client.model.QueueResponse;
import org.openapitools.client.model.SirqulResponse;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class AMQPApi {
  String basePath = "https://dev.sirqul.com/api/3.18";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * Create Consumer
  * Create a connection to an existing amqp queue and register as a consumer.
   * @param appKey The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
   * @param name The name of the queue to connect to
   * @param hostname The hostname of the server the queue is hosted on
   * @param username The username to access the server the queue is hosted on
   * @param password The password to access the queue to connect to
   * @param dataMapping The data mapping information in the format of AMQPRequest
   * @param deviceId The client deviceID
   * @param accountId The logged in user ID
   * @param port The port of the server the queue is hosted on
   * @param virtualHost The virtual host defined on the server the queue is associated on
   * @param exchanger The exchanger of the queue to connect to
   * @param exchangerType The exchanger type of the queue to connect to
   * @param workers The number of workers to generate 
   * @param useSSL Use SSL
   * @return QueueResponse
  */
  public QueueResponse consumerCreate (String appKey, String name, String hostname, String username, String password, String dataMapping, String deviceId, Long accountId, Integer port, String virtualHost, String exchanger, String exchangerType, Integer workers, Boolean useSSL) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling consumerCreate",
        new ApiException(400, "Missing the required parameter 'appKey' when calling consumerCreate"));
    }
    // verify the required parameter 'name' is set
    if (name == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'name' when calling consumerCreate",
        new ApiException(400, "Missing the required parameter 'name' when calling consumerCreate"));
    }
    // verify the required parameter 'hostname' is set
    if (hostname == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'hostname' when calling consumerCreate",
        new ApiException(400, "Missing the required parameter 'hostname' when calling consumerCreate"));
    }
    // verify the required parameter 'username' is set
    if (username == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'username' when calling consumerCreate",
        new ApiException(400, "Missing the required parameter 'username' when calling consumerCreate"));
    }
    // verify the required parameter 'password' is set
    if (password == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'password' when calling consumerCreate",
        new ApiException(400, "Missing the required parameter 'password' when calling consumerCreate"));
    }
    // verify the required parameter 'dataMapping' is set
    if (dataMapping == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'dataMapping' when calling consumerCreate",
        new ApiException(400, "Missing the required parameter 'dataMapping' when calling consumerCreate"));
    }

    // create path and map variables
    String path = "/queue/consumer/create";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "name", name));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "hostname", hostname));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "port", port));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "username", username));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "password", password));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "virtualHost", virtualHost));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "exchanger", exchanger));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "exchangerType", exchangerType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "workers", workers));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "dataMapping", dataMapping));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "useSSL", useSSL));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (QueueResponse) ApiInvoker.deserialize(localVarResponse, "", QueueResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Create Consumer
   * Create a connection to an existing amqp queue and register as a consumer.
   * @param appKey The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.   * @param name The name of the queue to connect to   * @param hostname The hostname of the server the queue is hosted on   * @param username The username to access the server the queue is hosted on   * @param password The password to access the queue to connect to   * @param dataMapping The data mapping information in the format of AMQPRequest   * @param deviceId The client deviceID   * @param accountId The logged in user ID   * @param port The port of the server the queue is hosted on   * @param virtualHost The virtual host defined on the server the queue is associated on   * @param exchanger The exchanger of the queue to connect to   * @param exchangerType The exchanger type of the queue to connect to   * @param workers The number of workers to generate    * @param useSSL Use SSL
  */
  public void consumerCreate (String appKey, String name, String hostname, String username, String password, String dataMapping, String deviceId, Long accountId, Integer port, String virtualHost, String exchanger, String exchangerType, Integer workers, Boolean useSSL, final Response.Listener<QueueResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling consumerCreate",
        new ApiException(400, "Missing the required parameter 'appKey' when calling consumerCreate"));
    }
    // verify the required parameter 'name' is set
    if (name == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'name' when calling consumerCreate",
        new ApiException(400, "Missing the required parameter 'name' when calling consumerCreate"));
    }
    // verify the required parameter 'hostname' is set
    if (hostname == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'hostname' when calling consumerCreate",
        new ApiException(400, "Missing the required parameter 'hostname' when calling consumerCreate"));
    }
    // verify the required parameter 'username' is set
    if (username == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'username' when calling consumerCreate",
        new ApiException(400, "Missing the required parameter 'username' when calling consumerCreate"));
    }
    // verify the required parameter 'password' is set
    if (password == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'password' when calling consumerCreate",
        new ApiException(400, "Missing the required parameter 'password' when calling consumerCreate"));
    }
    // verify the required parameter 'dataMapping' is set
    if (dataMapping == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'dataMapping' when calling consumerCreate",
        new ApiException(400, "Missing the required parameter 'dataMapping' when calling consumerCreate"));
    }

    // create path and map variables
    String path = "/queue/consumer/create".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "name", name));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "hostname", hostname));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "port", port));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "username", username));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "password", password));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "virtualHost", virtualHost));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "exchanger", exchanger));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "exchangerType", exchangerType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "workers", workers));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "dataMapping", dataMapping));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "useSSL", useSSL));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((QueueResponse) ApiInvoker.deserialize(localVarResponse,  "", QueueResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Update Consumer
  * Update an existing amqp queue&#39;s data mapping.
   * @param appKey The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
   * @param queueId The queue to update
   * @param dataMapping The data mapping information in the format of AMQPRequest
   * @param deviceId The client deviceID
   * @param accountId The logged in user ID
   * @param useSSL Use SSL
   * @return QueueResponse
  */
  public QueueResponse consumerUpdate (String appKey, Long queueId, String dataMapping, String deviceId, Long accountId, Boolean useSSL) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling consumerUpdate",
        new ApiException(400, "Missing the required parameter 'appKey' when calling consumerUpdate"));
    }
    // verify the required parameter 'queueId' is set
    if (queueId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'queueId' when calling consumerUpdate",
        new ApiException(400, "Missing the required parameter 'queueId' when calling consumerUpdate"));
    }
    // verify the required parameter 'dataMapping' is set
    if (dataMapping == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'dataMapping' when calling consumerUpdate",
        new ApiException(400, "Missing the required parameter 'dataMapping' when calling consumerUpdate"));
    }

    // create path and map variables
    String path = "/queue/consumer/update";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "queueId", queueId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "dataMapping", dataMapping));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "useSSL", useSSL));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (QueueResponse) ApiInvoker.deserialize(localVarResponse, "", QueueResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Update Consumer
   * Update an existing amqp queue&#39;s data mapping.
   * @param appKey The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.   * @param queueId The queue to update   * @param dataMapping The data mapping information in the format of AMQPRequest   * @param deviceId The client deviceID   * @param accountId The logged in user ID   * @param useSSL Use SSL
  */
  public void consumerUpdate (String appKey, Long queueId, String dataMapping, String deviceId, Long accountId, Boolean useSSL, final Response.Listener<QueueResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling consumerUpdate",
        new ApiException(400, "Missing the required parameter 'appKey' when calling consumerUpdate"));
    }
    // verify the required parameter 'queueId' is set
    if (queueId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'queueId' when calling consumerUpdate",
        new ApiException(400, "Missing the required parameter 'queueId' when calling consumerUpdate"));
    }
    // verify the required parameter 'dataMapping' is set
    if (dataMapping == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'dataMapping' when calling consumerUpdate",
        new ApiException(400, "Missing the required parameter 'dataMapping' when calling consumerUpdate"));
    }

    // create path and map variables
    String path = "/queue/consumer/update".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "queueId", queueId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "dataMapping", dataMapping));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "useSSL", useSSL));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((QueueResponse) ApiInvoker.deserialize(localVarResponse,  "", QueueResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Create Queue
  * Create a basic AMQP queue. If the username and password and virtual host is not sepcified, the queue will be created on the virtual host assigned to the application.
   * @param appKey The application key unique to each application.
   * @param name The name of the queue to create
   * @param deviceId The client deviceID
   * @param accountId The logged in user ID
   * @param workers The number of workers to generate 
   * @param analyticTags If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags
   * @param hostname The hostname of the server the queue is hosted on
   * @param port The port of the server the queue is hosted on
   * @param username The username to access the server that the queue is on
   * @param password The password to access the queue to connect to
   * @param virtualHost The virtual host defined on the server to queue
   * @param useSSL Use SSL
   * @return QueueResponse
  */
  public QueueResponse queueCreate (String appKey, String name, String deviceId, Long accountId, Integer workers, String analyticTags, String hostname, Integer port, String username, String password, String virtualHost, Boolean useSSL) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling queueCreate",
        new ApiException(400, "Missing the required parameter 'appKey' when calling queueCreate"));
    }
    // verify the required parameter 'name' is set
    if (name == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'name' when calling queueCreate",
        new ApiException(400, "Missing the required parameter 'name' when calling queueCreate"));
    }

    // create path and map variables
    String path = "/queue/create";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "name", name));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "workers", workers));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "analyticTags", analyticTags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "hostname", hostname));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "port", port));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "username", username));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "password", password));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "virtualHost", virtualHost));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "useSSL", useSSL));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (QueueResponse) ApiInvoker.deserialize(localVarResponse, "", QueueResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Create Queue
   * Create a basic AMQP queue. If the username and password and virtual host is not sepcified, the queue will be created on the virtual host assigned to the application.
   * @param appKey The application key unique to each application.   * @param name The name of the queue to create   * @param deviceId The client deviceID   * @param accountId The logged in user ID   * @param workers The number of workers to generate    * @param analyticTags If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags   * @param hostname The hostname of the server the queue is hosted on   * @param port The port of the server the queue is hosted on   * @param username The username to access the server that the queue is on   * @param password The password to access the queue to connect to   * @param virtualHost The virtual host defined on the server to queue   * @param useSSL Use SSL
  */
  public void queueCreate (String appKey, String name, String deviceId, Long accountId, Integer workers, String analyticTags, String hostname, Integer port, String username, String password, String virtualHost, Boolean useSSL, final Response.Listener<QueueResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling queueCreate",
        new ApiException(400, "Missing the required parameter 'appKey' when calling queueCreate"));
    }
    // verify the required parameter 'name' is set
    if (name == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'name' when calling queueCreate",
        new ApiException(400, "Missing the required parameter 'name' when calling queueCreate"));
    }

    // create path and map variables
    String path = "/queue/create".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "name", name));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "workers", workers));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "analyticTags", analyticTags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "hostname", hostname));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "port", port));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "username", username));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "password", password));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "virtualHost", virtualHost));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "useSSL", useSSL));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((QueueResponse) ApiInvoker.deserialize(localVarResponse,  "", QueueResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Delete Queue
  * Delete the stored queue record and close any active connections to the AMQP servers.
   * @param queueId The id of the queue to find
   * @param deviceId The client device ID
   * @param accountId The logged in user ID
   * @return SirqulResponse
  */
  public SirqulResponse queueDelete (Long queueId, String deviceId, Long accountId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'queueId' is set
    if (queueId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'queueId' when calling queueDelete",
        new ApiException(400, "Missing the required parameter 'queueId' when calling queueDelete"));
    }

    // create path and map variables
    String path = "/queue/delete";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "queueId", queueId));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SirqulResponse) ApiInvoker.deserialize(localVarResponse, "", SirqulResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Delete Queue
   * Delete the stored queue record and close any active connections to the AMQP servers.
   * @param queueId The id of the queue to find   * @param deviceId The client device ID   * @param accountId The logged in user ID
  */
  public void queueDelete (Long queueId, String deviceId, Long accountId, final Response.Listener<SirqulResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'queueId' is set
    if (queueId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'queueId' when calling queueDelete",
        new ApiException(400, "Missing the required parameter 'queueId' when calling queueDelete"));
    }

    // create path and map variables
    String path = "/queue/delete".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "queueId", queueId));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SirqulResponse) ApiInvoker.deserialize(localVarResponse,  "", SirqulResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Queue
  * Get the stored queue record. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
   * @param deviceId The client device ID
   * @param accountId The logged in user ID
   * @param queueId The id of the queue to find
   * @param appKey The application key the queue was assigned to
   * @param name The name of the queue to find
   * @param hostname The hostname of the queue to find
   * @param virtualHost The virtual host of the queue to find
   * @return QueueResponse
  */
  public QueueResponse queueGet (String deviceId, Long accountId, Long queueId, String appKey, String name, String hostname, String virtualHost) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/queue/get";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "queueId", queueId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "name", name));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "hostname", hostname));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "virtualHost", virtualHost));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (QueueResponse) ApiInvoker.deserialize(localVarResponse, "", QueueResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Queue
   * Get the stored queue record. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
   * @param deviceId The client device ID   * @param accountId The logged in user ID   * @param queueId The id of the queue to find   * @param appKey The application key the queue was assigned to   * @param name The name of the queue to find   * @param hostname The hostname of the queue to find   * @param virtualHost The virtual host of the queue to find
  */
  public void queueGet (String deviceId, Long accountId, Long queueId, String appKey, String name, String hostname, String virtualHost, final Response.Listener<QueueResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/queue/get".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "queueId", queueId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "name", name));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "hostname", hostname));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "virtualHost", virtualHost));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((QueueResponse) ApiInvoker.deserialize(localVarResponse,  "", QueueResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Publish Queue
  * Publish a message to a stored queue. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
   * @param message The payload to send to the queue
   * @param queueId The id of the queue to publish to
   * @param appKey The application key the queue was assigned to
   * @param name The name of the queue to publish to or the analytic tag to handle if the analytic param is true
   * @param hostname The hostname of the server the queue is hosted on
   * @param virtualHost The virtual host defined on the server to queue
   * @return SirqulResponse
  */
  public SirqulResponse queuePublish (String message, Long queueId, String appKey, String name, String hostname, String virtualHost) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'message' is set
    if (message == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'message' when calling queuePublish",
        new ApiException(400, "Missing the required parameter 'message' when calling queuePublish"));
    }

    // create path and map variables
    String path = "/queue/publish";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "queueId", queueId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "name", name));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "hostname", hostname));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "virtualHost", virtualHost));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "message", message));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SirqulResponse) ApiInvoker.deserialize(localVarResponse, "", SirqulResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Publish Queue
   * Publish a message to a stored queue. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
   * @param message The payload to send to the queue   * @param queueId The id of the queue to publish to   * @param appKey The application key the queue was assigned to   * @param name The name of the queue to publish to or the analytic tag to handle if the analytic param is true   * @param hostname The hostname of the server the queue is hosted on   * @param virtualHost The virtual host defined on the server to queue
  */
  public void queuePublish (String message, Long queueId, String appKey, String name, String hostname, String virtualHost, final Response.Listener<SirqulResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'message' is set
    if (message == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'message' when calling queuePublish",
        new ApiException(400, "Missing the required parameter 'message' when calling queuePublish"));
    }

    // create path and map variables
    String path = "/queue/publish".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "queueId", queueId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "name", name));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "hostname", hostname));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "virtualHost", virtualHost));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "message", message));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SirqulResponse) ApiInvoker.deserialize(localVarResponse,  "", SirqulResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search Queue
  * Get the queues setup for the BillableEntity&#39;s applications.
   * @param queueId The id of the queue to find
   * @param deviceId The client device ID
   * @param accountId The logged in user ID
   * @param name The name of the queue to find
   * @param start Start of the index
   * @param limit Limit of the index
   * @return QueueResponse
  */
  public QueueResponse queueSearch (Long queueId, String deviceId, Long accountId, String name, Integer start, Integer limit) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/queue/search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "queueId", queueId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "name", name));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (QueueResponse) ApiInvoker.deserialize(localVarResponse, "", QueueResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search Queue
   * Get the queues setup for the BillableEntity&#39;s applications.
   * @param queueId The id of the queue to find   * @param deviceId The client device ID   * @param accountId The logged in user ID   * @param name The name of the queue to find   * @param start Start of the index   * @param limit Limit of the index
  */
  public void queueSearch (Long queueId, String deviceId, Long accountId, String name, Integer start, Integer limit, final Response.Listener<QueueResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/queue/search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "queueId", queueId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "name", name));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((QueueResponse) ApiInvoker.deserialize(localVarResponse,  "", QueueResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Update Queue
  * Update the basic AMQP queue.
   * @param queueId The id of the queue to update
   * @param deviceId The client deviceID
   * @param accountId The logged in user ID
   * @param appKey The application key unique to each application.
   * @param workers The number of workers to generate
   * @param analyticTags If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags
   * @param hostname The hostname of the server the queue is hosted on
   * @param port The port of the server the queue is hosted on
   * @param username The username to access the server that the queue is on
   * @param password The password to access the queue to connect to
   * @param virtualHost The virtual host defined on the server to queue
   * @param useSSL the SSL to use
   * @return QueueResponse
  */
  public QueueResponse queueUpdate (Long queueId, String deviceId, Long accountId, String appKey, Integer workers, String analyticTags, String hostname, Integer port, String username, String password, String virtualHost, Boolean useSSL) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'queueId' is set
    if (queueId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'queueId' when calling queueUpdate",
        new ApiException(400, "Missing the required parameter 'queueId' when calling queueUpdate"));
    }

    // create path and map variables
    String path = "/queue/update";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "queueId", queueId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "workers", workers));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "analyticTags", analyticTags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "hostname", hostname));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "port", port));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "username", username));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "password", password));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "virtualHost", virtualHost));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "useSSL", useSSL));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (QueueResponse) ApiInvoker.deserialize(localVarResponse, "", QueueResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Update Queue
   * Update the basic AMQP queue.
   * @param queueId The id of the queue to update   * @param deviceId The client deviceID   * @param accountId The logged in user ID   * @param appKey The application key unique to each application.   * @param workers The number of workers to generate   * @param analyticTags If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags   * @param hostname The hostname of the server the queue is hosted on   * @param port The port of the server the queue is hosted on   * @param username The username to access the server that the queue is on   * @param password The password to access the queue to connect to   * @param virtualHost The virtual host defined on the server to queue   * @param useSSL the SSL to use
  */
  public void queueUpdate (Long queueId, String deviceId, Long accountId, String appKey, Integer workers, String analyticTags, String hostname, Integer port, String username, String password, String virtualHost, Boolean useSSL, final Response.Listener<QueueResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'queueId' is set
    if (queueId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'queueId' when calling queueUpdate",
        new ApiException(400, "Missing the required parameter 'queueId' when calling queueUpdate"));
    }

    // create path and map variables
    String path = "/queue/update".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "queueId", queueId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "workers", workers));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "analyticTags", analyticTags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "hostname", hostname));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "port", port));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "username", username));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "password", password));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "virtualHost", virtualHost));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "useSSL", useSSL));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((QueueResponse) ApiInvoker.deserialize(localVarResponse,  "", QueueResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
