/*
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client.api;

import org.openapitools.client.ApiInvoker;
import org.openapitools.client.ApiException;
import org.openapitools.client.Pair;

import org.openapitools.client.model.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import java.math.BigDecimal;
import java.io.File;
import java.util.*;
import org.openapitools.client.model.NoteResponse;
import org.openapitools.client.model.SirqulResponse;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class NoteApi {
  String basePath = "https://dev.sirqul.com/api/3.18";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * Batch Note Operation
  * Perform a batch operation on notes for a notable object (for example: DELETE_ALL_NOTES_IN_NOTABLE). 
   * @param notableId The id of the notable object the batch operation will affect
   * @param notableType The notable object type (for example ALBUM, ASSET, OFFER, etc.)
   * @param deviceId The device id (deviceId or accountId required)
   * @param accountId The account id of the user (deviceId or accountId required)
   * @param batchOperation The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional.
   * @return SirqulResponse
  */
  public SirqulResponse batchOperation (Long notableId, String notableType, String deviceId, Long accountId, String batchOperation) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'notableId' is set
    if (notableId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'notableId' when calling batchOperation",
        new ApiException(400, "Missing the required parameter 'notableId' when calling batchOperation"));
    }
    // verify the required parameter 'notableType' is set
    if (notableType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'notableType' when calling batchOperation",
        new ApiException(400, "Missing the required parameter 'notableType' when calling batchOperation"));
    }

    // create path and map variables
    String path = "/note/batch";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "notableId", notableId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "notableType", notableType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "batchOperation", batchOperation));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SirqulResponse) ApiInvoker.deserialize(localVarResponse, "", SirqulResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Batch Note Operation
   * Perform a batch operation on notes for a notable object (for example: DELETE_ALL_NOTES_IN_NOTABLE). 
   * @param notableId The id of the notable object the batch operation will affect   * @param notableType The notable object type (for example ALBUM, ASSET, OFFER, etc.)   * @param deviceId The device id (deviceId or accountId required)   * @param accountId The account id of the user (deviceId or accountId required)   * @param batchOperation The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional.
  */
  public void batchOperation (Long notableId, String notableType, String deviceId, Long accountId, String batchOperation, final Response.Listener<SirqulResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'notableId' is set
    if (notableId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'notableId' when calling batchOperation",
        new ApiException(400, "Missing the required parameter 'notableId' when calling batchOperation"));
    }
    // verify the required parameter 'notableType' is set
    if (notableType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'notableType' when calling batchOperation",
        new ApiException(400, "Missing the required parameter 'notableType' when calling batchOperation"));
    }

    // create path and map variables
    String path = "/note/batch".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "notableId", notableId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "notableType", notableType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "batchOperation", batchOperation));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SirqulResponse) ApiInvoker.deserialize(localVarResponse,  "", SirqulResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Create Note
  * This is used to leave a comment (note) on a notable object (i.e. albums, album contests, assets, game levels, offers, offer locations, retailers, retailer locations, and theme descriptors). Leaving a comment on a notable object will be visiable to everyone who has access to view the object.
   * @param comment The message the user wishes to leave a comment on
   * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used)
   * @param accountId The unique accountId that made the request (either deviceId or accountId must be used)
   * @param notableType The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}
   * @param notableId The id of the notable object
   * @param noteType The custom string defined by the client (used for differentiating various note types)
   * @param assetIds A comma separated list of asset IDs to add with the note
   * @param tags search tags
   * @param permissionableType This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
   * @param permissionableId The id of the permissionable object (for sending group notifications)
   * @param appKey The application key used to identify the application
   * @param locationDescription The description of the location
   * @param latitude The current location of the user
   * @param longitude The current location of the user
   * @param metaData External custom client defined data
   * @param receiverAccountIds Comma separated list of additional account IDs that will receive the note notifications
   * @param returnFullResponse whether to return the full response or not
   * @param initializeAsset Check true if need to initialize an asset and assign to current note
   * @param assetReturnNulls Return null fields for asset response when creating an asset
   * @param assetAlbumId the album the asset will be added to (optional)
   * @param assetCollectionId the collection ID that the asset is associated with
   * @param assetAddToDefaultAlbum the default album to add the asset to
   * @param assetAddToMediaLibrary the media library to add the asset to
   * @param assetVersionCode the version code of the asset
   * @param assetVersionName the version name of the asset
   * @param assetMetaData the meta data of the asset
   * @param assetCaption the caption of the asset
   * @param assetMedia the media of the asset
   * @param assetMediaUrl the media URL of the asset
   * @param assetMediaString the media string of the asset
   * @param assetMediaStringFileName the media string file name of the asset
   * @param assetMediaStringContentType the media string content type of the asset
   * @param assetAttachedMedia the attached media of the asset
   * @param assetAttachedMediaUrl the attached media URL of the asset
   * @param assetAttachedMediaString the attached media string of the asset
   * @param assetAttachedMediaStringFileName the attached media string file name of the asset
   * @param assetAttachedMediaStringContentType the attached media string content type of the asset
   * @param assetLocationDescription the location description for the asset
   * @param assetApp the application for the asset
   * @param assetSearchTags the search tags used for the asset
   * @param assetLatitude the latitude of the asset
   * @param assetLongitude the longitude of the asset
   * @return NoteResponse
  */
  public NoteResponse createNote (String comment, String deviceId, Long accountId, String notableType, Long notableId, String noteType, String assetIds, String tags, String permissionableType, Long permissionableId, String appKey, String locationDescription, Double latitude, Double longitude, String metaData, String receiverAccountIds, Boolean returnFullResponse, Boolean initializeAsset, Boolean assetReturnNulls, Long assetAlbumId, Long assetCollectionId, String assetAddToDefaultAlbum, Boolean assetAddToMediaLibrary, Integer assetVersionCode, String assetVersionName, String assetMetaData, String assetCaption, File assetMedia, String assetMediaUrl, String assetMediaString, String assetMediaStringFileName, String assetMediaStringContentType, File assetAttachedMedia, String assetAttachedMediaUrl, String assetAttachedMediaString, String assetAttachedMediaStringFileName, String assetAttachedMediaStringContentType, String assetLocationDescription, String assetApp, String assetSearchTags, Double assetLatitude, BigDecimal assetLongitude) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'comment' is set
    if (comment == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'comment' when calling createNote",
        new ApiException(400, "Missing the required parameter 'comment' when calling createNote"));
    }

    // create path and map variables
    String path = "/note/create";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "notableType", notableType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "notableId", notableId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "comment", comment));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "noteType", noteType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetIds", assetIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "tags", tags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "permissionableType", permissionableType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "permissionableId", permissionableId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locationDescription", locationDescription));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "metaData", metaData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "receiverAccountIds", receiverAccountIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnFullResponse", returnFullResponse));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "initializeAsset", initializeAsset));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetReturnNulls", assetReturnNulls));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAlbumId", assetAlbumId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetCollectionId", assetCollectionId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAddToDefaultAlbum", assetAddToDefaultAlbum));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAddToMediaLibrary", assetAddToMediaLibrary));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetVersionCode", assetVersionCode));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetVersionName", assetVersionName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMetaData", assetMetaData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetCaption", assetCaption));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMedia", assetMedia));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMediaUrl", assetMediaUrl));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMediaString", assetMediaString));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMediaStringFileName", assetMediaStringFileName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMediaStringContentType", assetMediaStringContentType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMedia", assetAttachedMedia));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMediaUrl", assetAttachedMediaUrl));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMediaString", assetAttachedMediaString));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMediaStringFileName", assetAttachedMediaStringFileName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMediaStringContentType", assetAttachedMediaStringContentType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetLocationDescription", assetLocationDescription));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetApp", assetApp));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetSearchTags", assetSearchTags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetLatitude", assetLatitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetLongitude", assetLongitude));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (NoteResponse) ApiInvoker.deserialize(localVarResponse, "", NoteResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Create Note
   * This is used to leave a comment (note) on a notable object (i.e. albums, album contests, assets, game levels, offers, offer locations, retailers, retailer locations, and theme descriptors). Leaving a comment on a notable object will be visiable to everyone who has access to view the object.
   * @param comment The message the user wishes to leave a comment on   * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used)   * @param accountId The unique accountId that made the request (either deviceId or accountId must be used)   * @param notableType The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}   * @param notableId The id of the notable object   * @param noteType The custom string defined by the client (used for differentiating various note types)   * @param assetIds A comma separated list of asset IDs to add with the note   * @param tags search tags   * @param permissionableType This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}   * @param permissionableId The id of the permissionable object (for sending group notifications)   * @param appKey The application key used to identify the application   * @param locationDescription The description of the location   * @param latitude The current location of the user   * @param longitude The current location of the user   * @param metaData External custom client defined data   * @param receiverAccountIds Comma separated list of additional account IDs that will receive the note notifications   * @param returnFullResponse whether to return the full response or not   * @param initializeAsset Check true if need to initialize an asset and assign to current note   * @param assetReturnNulls Return null fields for asset response when creating an asset   * @param assetAlbumId the album the asset will be added to (optional)   * @param assetCollectionId the collection ID that the asset is associated with   * @param assetAddToDefaultAlbum the default album to add the asset to   * @param assetAddToMediaLibrary the media library to add the asset to   * @param assetVersionCode the version code of the asset   * @param assetVersionName the version name of the asset   * @param assetMetaData the meta data of the asset   * @param assetCaption the caption of the asset   * @param assetMedia the media of the asset   * @param assetMediaUrl the media URL of the asset   * @param assetMediaString the media string of the asset   * @param assetMediaStringFileName the media string file name of the asset   * @param assetMediaStringContentType the media string content type of the asset   * @param assetAttachedMedia the attached media of the asset   * @param assetAttachedMediaUrl the attached media URL of the asset   * @param assetAttachedMediaString the attached media string of the asset   * @param assetAttachedMediaStringFileName the attached media string file name of the asset   * @param assetAttachedMediaStringContentType the attached media string content type of the asset   * @param assetLocationDescription the location description for the asset   * @param assetApp the application for the asset   * @param assetSearchTags the search tags used for the asset   * @param assetLatitude the latitude of the asset   * @param assetLongitude the longitude of the asset
  */
  public void createNote (String comment, String deviceId, Long accountId, String notableType, Long notableId, String noteType, String assetIds, String tags, String permissionableType, Long permissionableId, String appKey, String locationDescription, Double latitude, Double longitude, String metaData, String receiverAccountIds, Boolean returnFullResponse, Boolean initializeAsset, Boolean assetReturnNulls, Long assetAlbumId, Long assetCollectionId, String assetAddToDefaultAlbum, Boolean assetAddToMediaLibrary, Integer assetVersionCode, String assetVersionName, String assetMetaData, String assetCaption, File assetMedia, String assetMediaUrl, String assetMediaString, String assetMediaStringFileName, String assetMediaStringContentType, File assetAttachedMedia, String assetAttachedMediaUrl, String assetAttachedMediaString, String assetAttachedMediaStringFileName, String assetAttachedMediaStringContentType, String assetLocationDescription, String assetApp, String assetSearchTags, Double assetLatitude, BigDecimal assetLongitude, final Response.Listener<NoteResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'comment' is set
    if (comment == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'comment' when calling createNote",
        new ApiException(400, "Missing the required parameter 'comment' when calling createNote"));
    }

    // create path and map variables
    String path = "/note/create".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "notableType", notableType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "notableId", notableId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "comment", comment));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "noteType", noteType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetIds", assetIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "tags", tags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "permissionableType", permissionableType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "permissionableId", permissionableId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locationDescription", locationDescription));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "metaData", metaData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "receiverAccountIds", receiverAccountIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnFullResponse", returnFullResponse));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "initializeAsset", initializeAsset));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetReturnNulls", assetReturnNulls));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAlbumId", assetAlbumId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetCollectionId", assetCollectionId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAddToDefaultAlbum", assetAddToDefaultAlbum));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAddToMediaLibrary", assetAddToMediaLibrary));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetVersionCode", assetVersionCode));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetVersionName", assetVersionName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMetaData", assetMetaData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetCaption", assetCaption));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMedia", assetMedia));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMediaUrl", assetMediaUrl));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMediaString", assetMediaString));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMediaStringFileName", assetMediaStringFileName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMediaStringContentType", assetMediaStringContentType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMedia", assetAttachedMedia));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMediaUrl", assetAttachedMediaUrl));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMediaString", assetAttachedMediaString));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMediaStringFileName", assetAttachedMediaStringFileName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMediaStringContentType", assetAttachedMediaStringContentType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetLocationDescription", assetLocationDescription));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetApp", assetApp));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetSearchTags", assetSearchTags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetLatitude", assetLatitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetLongitude", assetLongitude));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((NoteResponse) ApiInvoker.deserialize(localVarResponse,  "", NoteResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Delete Note
  * Sets a comment (note) as deleted.
   * @param noteId The ID of the note to delete
   * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used)
   * @param accountId The unique accountId that made the request (either deviceId or accountId must be used)
   * @param latitude The current location of the user
   * @param longitude The current location of the user
   * @param appKey The application key used to identify the application
   * @return SirqulResponse
  */
  public SirqulResponse deleteNote (Long noteId, String deviceId, Long accountId, Double latitude, Double longitude, String appKey) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'noteId' is set
    if (noteId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'noteId' when calling deleteNote",
        new ApiException(400, "Missing the required parameter 'noteId' when calling deleteNote"));
    }

    // create path and map variables
    String path = "/note/delete";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "noteId", noteId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SirqulResponse) ApiInvoker.deserialize(localVarResponse, "", SirqulResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Delete Note
   * Sets a comment (note) as deleted.
   * @param noteId The ID of the note to delete   * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used)   * @param accountId The unique accountId that made the request (either deviceId or accountId must be used)   * @param latitude The current location of the user   * @param longitude The current location of the user   * @param appKey The application key used to identify the application
  */
  public void deleteNote (Long noteId, String deviceId, Long accountId, Double latitude, Double longitude, String appKey, final Response.Listener<SirqulResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'noteId' is set
    if (noteId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'noteId' when calling deleteNote",
        new ApiException(400, "Missing the required parameter 'noteId' when calling deleteNote"));
    }

    // create path and map variables
    String path = "/note/delete".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "noteId", noteId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SirqulResponse) ApiInvoker.deserialize(localVarResponse,  "", SirqulResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Note
  * Get for a note based on its Id.
   * @param noteId the id of the note to get
   * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used)
   * @param accountId The unique accountId that made the request (either deviceId or accountId must be used)
   * @param returnFullResponse Determines whether to return the NoteFullResponse for the item
   * @return SirqulResponse
  */
  public SirqulResponse getNote (Long noteId, String deviceId, Long accountId, Boolean returnFullResponse) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'noteId' is set
    if (noteId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'noteId' when calling getNote",
        new ApiException(400, "Missing the required parameter 'noteId' when calling getNote"));
    }

    // create path and map variables
    String path = "/note/get";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnFullResponse", returnFullResponse));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "noteId", noteId));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SirqulResponse) ApiInvoker.deserialize(localVarResponse, "", SirqulResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Note
   * Get for a note based on its Id.
   * @param noteId the id of the note to get   * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used)   * @param accountId The unique accountId that made the request (either deviceId or accountId must be used)   * @param returnFullResponse Determines whether to return the NoteFullResponse for the item
  */
  public void getNote (Long noteId, String deviceId, Long accountId, Boolean returnFullResponse, final Response.Listener<SirqulResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'noteId' is set
    if (noteId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'noteId' when calling getNote",
        new ApiException(400, "Missing the required parameter 'noteId' when calling getNote"));
    }

    // create path and map variables
    String path = "/note/get".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnFullResponse", returnFullResponse));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "noteId", noteId));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SirqulResponse) ApiInvoker.deserialize(localVarResponse,  "", SirqulResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search Notes
  * Search for notes on a notable object.
   * @param deviceId The device id (deviceId or accountId required)
   * @param accountId The account id of the user (deviceId or accountId required)
   * @param notableType The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}
   * @param notableId The id of the notable object
   * @param noteTypes Comma separated list of noteType strings to filter results with
   * @param appKey The application key used to identify the application
   * @param keyword The keyword used to search
   * @param flagCountMinimum return items that has flagCount &gt;&#x3D; flagCountMinimum if this is set, return all items, even ones with flagCount &gt;&#x3D; flagThreshold
   * @param flagsExceedThreshold return items that has flagCount &gt;&#x3D; flagThreshold, which are hidden by default
   * @param includeInactive include inactive in the result
   * @param sortField The column to sort the search on
   * @param descending The order to return the search results
   * @param returnFullResponse Determines whether to return the NoteFullResponse for each search item
   * @param updatedSince return items that have been updated since this date (time-stamp in milliseconds)
   * @param updatedBefore return items that have been updated before this date (time-stamp in milliseconds)
   * @param start The record to begin the return set on
   * @param limit The number of records to return
   * @return List<NoteResponse>
  */
  public List<NoteResponse> searchNotes (String deviceId, Long accountId, String notableType, Long notableId, String noteTypes, String appKey, String keyword, Long flagCountMinimum, Boolean flagsExceedThreshold, Boolean includeInactive, String sortField, Boolean descending, Boolean returnFullResponse, Long updatedSince, Long updatedBefore, Integer start, Integer limit) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/note/search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "notableType", notableType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "notableId", notableId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "noteTypes", noteTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "flagCountMinimum", flagCountMinimum));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "flagsExceedThreshold", flagsExceedThreshold));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "includeInactive", includeInactive));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnFullResponse", returnFullResponse));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "updatedSince", updatedSince));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "updatedBefore", updatedBefore));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<NoteResponse>) ApiInvoker.deserialize(localVarResponse, "array", NoteResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search Notes
   * Search for notes on a notable object.
   * @param deviceId The device id (deviceId or accountId required)   * @param accountId The account id of the user (deviceId or accountId required)   * @param notableType The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}   * @param notableId The id of the notable object   * @param noteTypes Comma separated list of noteType strings to filter results with   * @param appKey The application key used to identify the application   * @param keyword The keyword used to search   * @param flagCountMinimum return items that has flagCount &gt;&#x3D; flagCountMinimum if this is set, return all items, even ones with flagCount &gt;&#x3D; flagThreshold   * @param flagsExceedThreshold return items that has flagCount &gt;&#x3D; flagThreshold, which are hidden by default   * @param includeInactive include inactive in the result   * @param sortField The column to sort the search on   * @param descending The order to return the search results   * @param returnFullResponse Determines whether to return the NoteFullResponse for each search item   * @param updatedSince return items that have been updated since this date (time-stamp in milliseconds)   * @param updatedBefore return items that have been updated before this date (time-stamp in milliseconds)   * @param start The record to begin the return set on   * @param limit The number of records to return
  */
  public void searchNotes (String deviceId, Long accountId, String notableType, Long notableId, String noteTypes, String appKey, String keyword, Long flagCountMinimum, Boolean flagsExceedThreshold, Boolean includeInactive, String sortField, Boolean descending, Boolean returnFullResponse, Long updatedSince, Long updatedBefore, Integer start, Integer limit, final Response.Listener<List<NoteResponse>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/note/search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "notableType", notableType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "notableId", notableId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "noteTypes", noteTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "flagCountMinimum", flagCountMinimum));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "flagsExceedThreshold", flagsExceedThreshold));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "includeInactive", includeInactive));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnFullResponse", returnFullResponse));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "updatedSince", updatedSince));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "updatedBefore", updatedBefore));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<NoteResponse>) ApiInvoker.deserialize(localVarResponse,  "array", NoteResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Update Note
  * Update an existing comment (note). Only the creator of the note have permission to update.
   * @param noteId The id of the note, used when editing a comment
   * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used)
   * @param accountId The unique accountId that made the request (either deviceId or accountId must be used)
   * @param comment The message the user wishes to leave a comment on
   * @param noteType The custom string defined by the client (used for differentiating on various note types)
   * @param assetIds A comma separated list of asset IDs to add with the note
   * @param tags search tags
   * @param permissionableType This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
   * @param permissionableId The id of the permissionable object (for sending group notifications)
   * @param appKey The application key used to identify the application
   * @param locationDescription The description of the location
   * @param latitude The current location of the user
   * @param longitude The current location of the user
   * @param metaData meta data to update with the note
   * @param returnFullResponse whether to return the full response or not
   * @param active Sets the active flag for the note
   * @param updateAsset main flag for updating asset in note, must set to true if you want to update the note&#39;s asset
   * @param assetReturnNulls Return null fields for asset response when updating an asset
   * @param assetAlbumId the album the asset will be added to (optional)
   * @param assetCollectionId the collection ID that the asset is associated with
   * @param assetAddToDefaultAlbum the default album to add the asset to
   * @param assetAddToMediaLibrary the media library to add the asset to
   * @param assetVersionCode the version code of the asset
   * @param assetVersionName the version name of the asset
   * @param assetMetaData the meta data of the asset
   * @param assetCaption the caption of the asset
   * @param assetMedia the media of the asset
   * @param assetMediaUrl the media URL of the asset
   * @param assetMediaString the media string of the asset
   * @param assetMediaStringFileName the media string file name of the asset
   * @param assetMediaStringContentType the media string content type of the asset
   * @param assetAttachedMedia the attached media of the asset
   * @param assetAttachedMediaUrl the attached media URL of the asset
   * @param assetAttachedMediaString the attached media string of the asset
   * @param assetAttachedMediaStringFileName the attached media string file name of the asset
   * @param assetAttachedMediaStringContentType the attached media string content type of the asset
   * @param assetLocationDescription the location description for the asset
   * @param assetApp the application for the asset
   * @param assetSearchTags the search tags used for the asset
   * @param assetLatitude the latitude of the asset
   * @param assetLongitude the longitude of the asset
   * @return NoteResponse
  */
  public NoteResponse updateNote (Long noteId, String deviceId, Long accountId, String comment, String noteType, String assetIds, String tags, String permissionableType, Long permissionableId, String appKey, String locationDescription, Double latitude, Double longitude, String metaData, Boolean returnFullResponse, Boolean active, Boolean updateAsset, Boolean assetReturnNulls, Long assetAlbumId, Long assetCollectionId, String assetAddToDefaultAlbum, Boolean assetAddToMediaLibrary, Integer assetVersionCode, String assetVersionName, String assetMetaData, String assetCaption, File assetMedia, String assetMediaUrl, String assetMediaString, String assetMediaStringFileName, String assetMediaStringContentType, File assetAttachedMedia, String assetAttachedMediaUrl, String assetAttachedMediaString, String assetAttachedMediaStringFileName, String assetAttachedMediaStringContentType, String assetLocationDescription, String assetApp, String assetSearchTags, Double assetLatitude, Double assetLongitude) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'noteId' is set
    if (noteId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'noteId' when calling updateNote",
        new ApiException(400, "Missing the required parameter 'noteId' when calling updateNote"));
    }

    // create path and map variables
    String path = "/note/update";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "noteId", noteId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "comment", comment));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "noteType", noteType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetIds", assetIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "tags", tags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "permissionableType", permissionableType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "permissionableId", permissionableId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locationDescription", locationDescription));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "metaData", metaData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnFullResponse", returnFullResponse));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "active", active));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "updateAsset", updateAsset));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetReturnNulls", assetReturnNulls));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAlbumId", assetAlbumId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetCollectionId", assetCollectionId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAddToDefaultAlbum", assetAddToDefaultAlbum));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAddToMediaLibrary", assetAddToMediaLibrary));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetVersionCode", assetVersionCode));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetVersionName", assetVersionName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMetaData", assetMetaData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetCaption", assetCaption));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMedia", assetMedia));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMediaUrl", assetMediaUrl));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMediaString", assetMediaString));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMediaStringFileName", assetMediaStringFileName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMediaStringContentType", assetMediaStringContentType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMedia", assetAttachedMedia));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMediaUrl", assetAttachedMediaUrl));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMediaString", assetAttachedMediaString));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMediaStringFileName", assetAttachedMediaStringFileName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMediaStringContentType", assetAttachedMediaStringContentType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetLocationDescription", assetLocationDescription));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetApp", assetApp));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetSearchTags", assetSearchTags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetLatitude", assetLatitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetLongitude", assetLongitude));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (NoteResponse) ApiInvoker.deserialize(localVarResponse, "", NoteResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Update Note
   * Update an existing comment (note). Only the creator of the note have permission to update.
   * @param noteId The id of the note, used when editing a comment   * @param deviceId The unique device identifier that made the request (either deviceId or accountId must be used)   * @param accountId The unique accountId that made the request (either deviceId or accountId must be used)   * @param comment The message the user wishes to leave a comment on   * @param noteType The custom string defined by the client (used for differentiating on various note types)   * @param assetIds A comma separated list of asset IDs to add with the note   * @param tags search tags   * @param permissionableType This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}   * @param permissionableId The id of the permissionable object (for sending group notifications)   * @param appKey The application key used to identify the application   * @param locationDescription The description of the location   * @param latitude The current location of the user   * @param longitude The current location of the user   * @param metaData meta data to update with the note   * @param returnFullResponse whether to return the full response or not   * @param active Sets the active flag for the note   * @param updateAsset main flag for updating asset in note, must set to true if you want to update the note&#39;s asset   * @param assetReturnNulls Return null fields for asset response when updating an asset   * @param assetAlbumId the album the asset will be added to (optional)   * @param assetCollectionId the collection ID that the asset is associated with   * @param assetAddToDefaultAlbum the default album to add the asset to   * @param assetAddToMediaLibrary the media library to add the asset to   * @param assetVersionCode the version code of the asset   * @param assetVersionName the version name of the asset   * @param assetMetaData the meta data of the asset   * @param assetCaption the caption of the asset   * @param assetMedia the media of the asset   * @param assetMediaUrl the media URL of the asset   * @param assetMediaString the media string of the asset   * @param assetMediaStringFileName the media string file name of the asset   * @param assetMediaStringContentType the media string content type of the asset   * @param assetAttachedMedia the attached media of the asset   * @param assetAttachedMediaUrl the attached media URL of the asset   * @param assetAttachedMediaString the attached media string of the asset   * @param assetAttachedMediaStringFileName the attached media string file name of the asset   * @param assetAttachedMediaStringContentType the attached media string content type of the asset   * @param assetLocationDescription the location description for the asset   * @param assetApp the application for the asset   * @param assetSearchTags the search tags used for the asset   * @param assetLatitude the latitude of the asset   * @param assetLongitude the longitude of the asset
  */
  public void updateNote (Long noteId, String deviceId, Long accountId, String comment, String noteType, String assetIds, String tags, String permissionableType, Long permissionableId, String appKey, String locationDescription, Double latitude, Double longitude, String metaData, Boolean returnFullResponse, Boolean active, Boolean updateAsset, Boolean assetReturnNulls, Long assetAlbumId, Long assetCollectionId, String assetAddToDefaultAlbum, Boolean assetAddToMediaLibrary, Integer assetVersionCode, String assetVersionName, String assetMetaData, String assetCaption, File assetMedia, String assetMediaUrl, String assetMediaString, String assetMediaStringFileName, String assetMediaStringContentType, File assetAttachedMedia, String assetAttachedMediaUrl, String assetAttachedMediaString, String assetAttachedMediaStringFileName, String assetAttachedMediaStringContentType, String assetLocationDescription, String assetApp, String assetSearchTags, Double assetLatitude, Double assetLongitude, final Response.Listener<NoteResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'noteId' is set
    if (noteId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'noteId' when calling updateNote",
        new ApiException(400, "Missing the required parameter 'noteId' when calling updateNote"));
    }

    // create path and map variables
    String path = "/note/update".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "noteId", noteId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "comment", comment));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "noteType", noteType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetIds", assetIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "tags", tags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "permissionableType", permissionableType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "permissionableId", permissionableId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "locationDescription", locationDescription));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "metaData", metaData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnFullResponse", returnFullResponse));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "active", active));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "updateAsset", updateAsset));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetReturnNulls", assetReturnNulls));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAlbumId", assetAlbumId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetCollectionId", assetCollectionId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAddToDefaultAlbum", assetAddToDefaultAlbum));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAddToMediaLibrary", assetAddToMediaLibrary));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetVersionCode", assetVersionCode));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetVersionName", assetVersionName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMetaData", assetMetaData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetCaption", assetCaption));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMedia", assetMedia));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMediaUrl", assetMediaUrl));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMediaString", assetMediaString));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMediaStringFileName", assetMediaStringFileName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetMediaStringContentType", assetMediaStringContentType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMedia", assetAttachedMedia));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMediaUrl", assetAttachedMediaUrl));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMediaString", assetAttachedMediaString));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMediaStringFileName", assetAttachedMediaStringFileName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetAttachedMediaStringContentType", assetAttachedMediaStringContentType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetLocationDescription", assetLocationDescription));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetApp", assetApp));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetSearchTags", assetSearchTags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetLatitude", assetLatitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "assetLongitude", assetLongitude));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((NoteResponse) ApiInvoker.deserialize(localVarResponse,  "", NoteResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
