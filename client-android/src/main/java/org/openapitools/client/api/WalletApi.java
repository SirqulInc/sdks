/*
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client.api;

import org.openapitools.client.ApiInvoker;
import org.openapitools.client.ApiException;
import org.openapitools.client.Pair;

import org.openapitools.client.model.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import java.util.*;
import org.openapitools.client.model.OfferTransactionResponse;
import org.openapitools.client.model.SirqulResponse;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class WalletApi {
  String basePath = "https://dev.sirqul.com/api/3.18";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * Create Wallet Offers
  * Adds offers to the wallet
   * @param deviceId The device id (deviceId or accountId required)
   * @param accountId The account id of the user (deviceId or accountId required)
   * @param offerId The id of the offer being added (offerId or offeLocationId required)
   * @param offerLocationId The id of the offer location being added (offerId or offeLocationId required)
   * @param offerCart A JSON list of offers to purchase. &#x60;&#x60;&#x60;json [   {     \&quot;offerId\&quot;: 123,     \&quot;offerLocationId\&quot;: 234,     \&quot;quantity\&quot;: 2   },   {     \&quot;offerId\&quot;: 456,     \&quot;offerLocationId\&quot;: 567,     \&quot;quantity\&quot;: 1   } ] &#x60;&#x60;&#x60; 
   * @param promoCode The promoCode
   * @param currencyType Determines the method of purchasing offer. CASH &#x3D; use card on file, POINTS &#x3D; use points, TICKETS &#x3D; use tickets
   * @param usePoints Sets the currencyType to POINTS
   * @param metaData External custom client defined data
   * @param appKey The application requesting the purchase, required when currencyType is TICKETS
   * @param status Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)
   * @return List<OfferTransactionResponse>
  */
  public List<OfferTransactionResponse> createOfferTransaction (String deviceId, Long accountId, Long offerId, Long offerLocationId, String offerCart, String promoCode, String currencyType, Boolean usePoints, String metaData, String appKey, Integer status) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/wallet/create";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerId", offerId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerLocationId", offerLocationId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerCart", offerCart));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "promoCode", promoCode));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "currencyType", currencyType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "usePoints", usePoints));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "metaData", metaData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "status", status));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<OfferTransactionResponse>) ApiInvoker.deserialize(localVarResponse, "array", OfferTransactionResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Create Wallet Offers
   * Adds offers to the wallet
   * @param deviceId The device id (deviceId or accountId required)   * @param accountId The account id of the user (deviceId or accountId required)   * @param offerId The id of the offer being added (offerId or offeLocationId required)   * @param offerLocationId The id of the offer location being added (offerId or offeLocationId required)   * @param offerCart A JSON list of offers to purchase. &#x60;&#x60;&#x60;json [   {     \&quot;offerId\&quot;: 123,     \&quot;offerLocationId\&quot;: 234,     \&quot;quantity\&quot;: 2   },   {     \&quot;offerId\&quot;: 456,     \&quot;offerLocationId\&quot;: 567,     \&quot;quantity\&quot;: 1   } ] &#x60;&#x60;&#x60;    * @param promoCode The promoCode   * @param currencyType Determines the method of purchasing offer. CASH &#x3D; use card on file, POINTS &#x3D; use points, TICKETS &#x3D; use tickets   * @param usePoints Sets the currencyType to POINTS   * @param metaData External custom client defined data   * @param appKey The application requesting the purchase, required when currencyType is TICKETS   * @param status Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)
  */
  public void createOfferTransaction (String deviceId, Long accountId, Long offerId, Long offerLocationId, String offerCart, String promoCode, String currencyType, Boolean usePoints, String metaData, String appKey, Integer status, final Response.Listener<List<OfferTransactionResponse>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/wallet/create".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerId", offerId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerLocationId", offerLocationId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerCart", offerCart));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "promoCode", promoCode));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "currencyType", currencyType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "usePoints", usePoints));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "metaData", metaData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "status", status));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<OfferTransactionResponse>) ApiInvoker.deserialize(localVarResponse,  "array", OfferTransactionResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Delete Wallet Offer
  * Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.
   * @param transactionId The offer transaction id to remove
   * @param deviceId The device id (deviceId or accountId required)
   * @param accountId The account id of the user (deviceId or accountId required)
   * @return SirqulResponse
  */
  public SirqulResponse deleteOfferTransaction (Long transactionId, String deviceId, Long accountId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'transactionId' is set
    if (transactionId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'transactionId' when calling deleteOfferTransaction",
        new ApiException(400, "Missing the required parameter 'transactionId' when calling deleteOfferTransaction"));
    }

    // create path and map variables
    String path = "/wallet/delete";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "transactionId", transactionId));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SirqulResponse) ApiInvoker.deserialize(localVarResponse, "", SirqulResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Delete Wallet Offer
   * Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.
   * @param transactionId The offer transaction id to remove   * @param deviceId The device id (deviceId or accountId required)   * @param accountId The account id of the user (deviceId or accountId required)
  */
  public void deleteOfferTransaction (Long transactionId, String deviceId, Long accountId, final Response.Listener<SirqulResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'transactionId' is set
    if (transactionId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'transactionId' when calling deleteOfferTransaction",
        new ApiException(400, "Missing the required parameter 'transactionId' when calling deleteOfferTransaction"));
    }

    // create path and map variables
    String path = "/wallet/delete".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "transactionId", transactionId));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SirqulResponse) ApiInvoker.deserialize(localVarResponse,  "", SirqulResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Wallet Offer
  * 
   * @param transactionId The offer transaction id to get details of
   * @param deviceId The device id (deviceId or accountId required)
   * @param accountId The account id of the user (deviceId or accountId required)
   * @param includeMission If true then include mission data, false to not include
   * @param latitude The latitude location of the user
   * @param longitude The latitude location of the user
   * @param returnFullResponse Determines whether to return a detailed version of the response
   * @return OfferTransactionResponse
  */
  public OfferTransactionResponse getOfferTransaction (Long transactionId, String deviceId, Long accountId, Boolean includeMission, Double latitude, Double longitude, Boolean returnFullResponse) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'transactionId' is set
    if (transactionId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'transactionId' when calling getOfferTransaction",
        new ApiException(400, "Missing the required parameter 'transactionId' when calling getOfferTransaction"));
    }

    // create path and map variables
    String path = "/wallet/get";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "transactionId", transactionId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "includeMission", includeMission));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnFullResponse", returnFullResponse));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (OfferTransactionResponse) ApiInvoker.deserialize(localVarResponse, "", OfferTransactionResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Wallet Offer
   * 
   * @param transactionId The offer transaction id to get details of   * @param deviceId The device id (deviceId or accountId required)   * @param accountId The account id of the user (deviceId or accountId required)   * @param includeMission If true then include mission data, false to not include   * @param latitude The latitude location of the user   * @param longitude The latitude location of the user   * @param returnFullResponse Determines whether to return a detailed version of the response
  */
  public void getOfferTransaction (Long transactionId, String deviceId, Long accountId, Boolean includeMission, Double latitude, Double longitude, Boolean returnFullResponse, final Response.Listener<OfferTransactionResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'transactionId' is set
    if (transactionId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'transactionId' when calling getOfferTransaction",
        new ApiException(400, "Missing the required parameter 'transactionId' when calling getOfferTransaction"));
    }

    // create path and map variables
    String path = "/wallet/get".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "transactionId", transactionId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "includeMission", includeMission));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnFullResponse", returnFullResponse));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((OfferTransactionResponse) ApiInvoker.deserialize(localVarResponse,  "", OfferTransactionResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Preview Wallet Offers
  * Preview the final cost of a transaction without charging the user
   * @param deviceId The device id (deviceId or accountId required)
   * @param accountId The account id of the user (deviceId or accountId required)
   * @param offerId The id of the offer being added (offerId or offeLocationId required)
   * @param offerLocationId The id of the offer location being added (offerId or offeLocationId required)
   * @param offerCart A JSON list of offers to purchase.
   * @param promoCode The promoCode
   * @param currencyType Determines the method of purchasing offer. CASH &#x3D; use card on file, POINTS &#x3D; use points, TICKETS &#x3D; use tickets
   * @param usePoints Sets the currencyType to POINTS
   * @param metaData External custom client defined data
   * @param appKey The application requesting the purchase, required when currencyType is TICKETS
   * @return List<OfferTransactionResponse>
  */
  public List<OfferTransactionResponse> previewOfferTransaction (String deviceId, Long accountId, Long offerId, Long offerLocationId, String offerCart, String promoCode, String currencyType, Boolean usePoints, String metaData, String appKey) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/wallet/preview";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerId", offerId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerLocationId", offerLocationId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerCart", offerCart));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "promoCode", promoCode));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "currencyType", currencyType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "usePoints", usePoints));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "metaData", metaData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<OfferTransactionResponse>) ApiInvoker.deserialize(localVarResponse, "array", OfferTransactionResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Preview Wallet Offers
   * Preview the final cost of a transaction without charging the user
   * @param deviceId The device id (deviceId or accountId required)   * @param accountId The account id of the user (deviceId or accountId required)   * @param offerId The id of the offer being added (offerId or offeLocationId required)   * @param offerLocationId The id of the offer location being added (offerId or offeLocationId required)   * @param offerCart A JSON list of offers to purchase.   * @param promoCode The promoCode   * @param currencyType Determines the method of purchasing offer. CASH &#x3D; use card on file, POINTS &#x3D; use points, TICKETS &#x3D; use tickets   * @param usePoints Sets the currencyType to POINTS   * @param metaData External custom client defined data   * @param appKey The application requesting the purchase, required when currencyType is TICKETS
  */
  public void previewOfferTransaction (String deviceId, Long accountId, Long offerId, Long offerLocationId, String offerCart, String promoCode, String currencyType, Boolean usePoints, String metaData, String appKey, final Response.Listener<List<OfferTransactionResponse>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/wallet/preview".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerId", offerId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerLocationId", offerLocationId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerCart", offerCart));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "promoCode", promoCode));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "currencyType", currencyType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "usePoints", usePoints));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "metaData", metaData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<OfferTransactionResponse>) ApiInvoker.deserialize(localVarResponse,  "array", OfferTransactionResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search Wallet Offers
  * Search on active offers currently in the user&#39;s wallet, or past offers the user has already redeemed.
   * @param deviceId The device id (deviceId or accountId required)
   * @param accountId The account id of the user (deviceId or accountId required)
   * @param keyword The keyword to search for
   * @param retailerId Filter results for this retailer
   * @param retailerIds Filter results for a list of retailers
   * @param retailerLocationId Filter results for this retailer location
   * @param retailerLocationIds Filter results for a list of retailer locations
   * @param excludeRetailerLocationIds Filter results to exclude retailer locations
   * @param offerId Filter results for this offer
   * @param offerIds Filter results for a list of offer
   * @param offerLocationId Filter results for this offer location
   * @param offerLocationIds Filter results for a list of offer locations
   * @param offerType Filter results to return a specific offer type
   * @param offerTypes Filter results to return specific offer types
   * @param specialOfferType Filter results to return a specific special offer type
   * @param specialOfferTypes Filter results to return specific special offer types
   * @param categoryIds Category Ids
   * @param filterIds Filter Ids
   * @param offerAudienceIds Offer Audience Ids
   * @param sortField Determines what to sort the results by
   * @param descending Determines whether the results are in descending order
   * @param start The start index for pagination
   * @param limit The limit for pagination
   * @param latitude The latitude location of the user
   * @param longitude The latitude location of the user
   * @param redeemableStartDate Filter results by the offer redeemable date
   * @param redeemableEndDate Filter results by the offer redeemable date
   * @param filterByParentOffer Apply params to offer&#39;s parent
   * @param startedSince Filter results by the offer start date
   * @param startedBefore Filter results by the offer start date
   * @param endedSince Filter results by the offer end date
   * @param endedBefore Filter results by the offer end date
   * @param redeemed If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1)
   * @param statuses Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)
   * @param reservationsOnly Returns only reservation transactions if true
   * @param activeOnly Active Only
   * @param returnFullResponse Determines whether to return a detailed version of the response
   * @param recurringStartedSince Filter results by the recurring billing start date
   * @param recurringStartedBefore Filter results by the recurring billing start date
   * @param recurringExpirationSince Filter results by the recurring billing expiration date
   * @param recurringExpirationBefore Filter results by the recurring billing expiration date
   * @return List<OfferTransactionResponse>
  */
  public List<OfferTransactionResponse> searchOfferTransactions (String deviceId, Long accountId, String keyword, Long retailerId, String retailerIds, Long retailerLocationId, String retailerLocationIds, String excludeRetailerLocationIds, Long offerId, String offerIds, Long offerLocationId, String offerLocationIds, String offerType, String offerTypes, String specialOfferType, String specialOfferTypes, String categoryIds, String filterIds, String offerAudienceIds, String sortField, Boolean descending, Integer start, Integer limit, Double latitude, Double longitude, Long redeemableStartDate, Long redeemableEndDate, Boolean filterByParentOffer, Long startedSince, Long startedBefore, Long endedSince, Long endedBefore, Boolean redeemed, String statuses, Boolean reservationsOnly, Boolean activeOnly, Boolean returnFullResponse, Long recurringStartedSince, Long recurringStartedBefore, Long recurringExpirationSince, Long recurringExpirationBefore) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/wallet/search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "retailerId", retailerId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "retailerIds", retailerIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "retailerLocationId", retailerLocationId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "retailerLocationIds", retailerLocationIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "excludeRetailerLocationIds", excludeRetailerLocationIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerId", offerId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerIds", offerIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerLocationId", offerLocationId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerLocationIds", offerLocationIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerType", offerType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerTypes", offerTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "specialOfferType", specialOfferType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "specialOfferTypes", specialOfferTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "categoryIds", categoryIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "filterIds", filterIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerAudienceIds", offerAudienceIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "redeemableStartDate", redeemableStartDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "redeemableEndDate", redeemableEndDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "filterByParentOffer", filterByParentOffer));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startedSince", startedSince));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startedBefore", startedBefore));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endedSince", endedSince));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endedBefore", endedBefore));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "redeemed", redeemed));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "statuses", statuses));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "reservationsOnly", reservationsOnly));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "activeOnly", activeOnly));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnFullResponse", returnFullResponse));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "recurringStartedSince", recurringStartedSince));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "recurringStartedBefore", recurringStartedBefore));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "recurringExpirationSince", recurringExpirationSince));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "recurringExpirationBefore", recurringExpirationBefore));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<OfferTransactionResponse>) ApiInvoker.deserialize(localVarResponse, "array", OfferTransactionResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search Wallet Offers
   * Search on active offers currently in the user&#39;s wallet, or past offers the user has already redeemed.
   * @param deviceId The device id (deviceId or accountId required)   * @param accountId The account id of the user (deviceId or accountId required)   * @param keyword The keyword to search for   * @param retailerId Filter results for this retailer   * @param retailerIds Filter results for a list of retailers   * @param retailerLocationId Filter results for this retailer location   * @param retailerLocationIds Filter results for a list of retailer locations   * @param excludeRetailerLocationIds Filter results to exclude retailer locations   * @param offerId Filter results for this offer   * @param offerIds Filter results for a list of offer   * @param offerLocationId Filter results for this offer location   * @param offerLocationIds Filter results for a list of offer locations   * @param offerType Filter results to return a specific offer type   * @param offerTypes Filter results to return specific offer types   * @param specialOfferType Filter results to return a specific special offer type   * @param specialOfferTypes Filter results to return specific special offer types   * @param categoryIds Category Ids   * @param filterIds Filter Ids   * @param offerAudienceIds Offer Audience Ids   * @param sortField Determines what to sort the results by   * @param descending Determines whether the results are in descending order   * @param start The start index for pagination   * @param limit The limit for pagination   * @param latitude The latitude location of the user   * @param longitude The latitude location of the user   * @param redeemableStartDate Filter results by the offer redeemable date   * @param redeemableEndDate Filter results by the offer redeemable date   * @param filterByParentOffer Apply params to offer&#39;s parent   * @param startedSince Filter results by the offer start date   * @param startedBefore Filter results by the offer start date   * @param endedSince Filter results by the offer end date   * @param endedBefore Filter results by the offer end date   * @param redeemed If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1)   * @param statuses Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)   * @param reservationsOnly Returns only reservation transactions if true   * @param activeOnly Active Only   * @param returnFullResponse Determines whether to return a detailed version of the response   * @param recurringStartedSince Filter results by the recurring billing start date   * @param recurringStartedBefore Filter results by the recurring billing start date   * @param recurringExpirationSince Filter results by the recurring billing expiration date   * @param recurringExpirationBefore Filter results by the recurring billing expiration date
  */
  public void searchOfferTransactions (String deviceId, Long accountId, String keyword, Long retailerId, String retailerIds, Long retailerLocationId, String retailerLocationIds, String excludeRetailerLocationIds, Long offerId, String offerIds, Long offerLocationId, String offerLocationIds, String offerType, String offerTypes, String specialOfferType, String specialOfferTypes, String categoryIds, String filterIds, String offerAudienceIds, String sortField, Boolean descending, Integer start, Integer limit, Double latitude, Double longitude, Long redeemableStartDate, Long redeemableEndDate, Boolean filterByParentOffer, Long startedSince, Long startedBefore, Long endedSince, Long endedBefore, Boolean redeemed, String statuses, Boolean reservationsOnly, Boolean activeOnly, Boolean returnFullResponse, Long recurringStartedSince, Long recurringStartedBefore, Long recurringExpirationSince, Long recurringExpirationBefore, final Response.Listener<List<OfferTransactionResponse>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/wallet/search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "retailerId", retailerId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "retailerIds", retailerIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "retailerLocationId", retailerLocationId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "retailerLocationIds", retailerLocationIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "excludeRetailerLocationIds", excludeRetailerLocationIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerId", offerId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerIds", offerIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerLocationId", offerLocationId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerLocationIds", offerLocationIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerType", offerType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerTypes", offerTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "specialOfferType", specialOfferType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "specialOfferTypes", specialOfferTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "categoryIds", categoryIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "filterIds", filterIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerAudienceIds", offerAudienceIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "redeemableStartDate", redeemableStartDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "redeemableEndDate", redeemableEndDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "filterByParentOffer", filterByParentOffer));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startedSince", startedSince));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "startedBefore", startedBefore));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endedSince", endedSince));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "endedBefore", endedBefore));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "redeemed", redeemed));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "statuses", statuses));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "reservationsOnly", reservationsOnly));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "activeOnly", activeOnly));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnFullResponse", returnFullResponse));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "recurringStartedSince", recurringStartedSince));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "recurringStartedBefore", recurringStartedBefore));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "recurringExpirationSince", recurringExpirationSince));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "recurringExpirationBefore", recurringExpirationBefore));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<OfferTransactionResponse>) ApiInvoker.deserialize(localVarResponse,  "array", OfferTransactionResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Update Wallet Offer
  * Update offer status. The status values are: 0 - not redeemable, 1 - redeemable.  Not redeemable means the customer has received the offer but has not decided to use (or print) it yet.  Until they choose to do this the merchant cannot redeem the offer (has not been given permission yet).   Redeemable means the customer has chosen to use the offer and wishes to redeem it.  Redeemed means the merchant has accepted the offer and the given the customer its value, then marked it a used in the system.  This status change is handled by a merchant end point.
   * @param transactionId The offer transaction id to remove
   * @param status The status value to change to (0 or 1)
   * @param deviceId The device id (deviceId or accountId required)
   * @param accountId The account id of the user (deviceId or accountId required)
   * @param offerLocationId Offer Location Id
   * @param currencyType Currency Type
   * @param usePoints Use Points
   * @param appKey App Key
   * @param latitude The latitude location of the user
   * @param longitude The latitude location of the user
   * @param metaData External custom client defined data
   * @param returnFullResponse Determines whether to return a detailed version of the response
   * @param exceptionMembershipOfferIds Exception Offers, transaction audiences of these offers won&#39;t be removed out of the account when up
   * @return OfferTransactionResponse
  */
  public OfferTransactionResponse updateOfferTransaction (Long transactionId, Integer status, String deviceId, Long accountId, Long offerLocationId, String currencyType, Boolean usePoints, String appKey, Double latitude, Double longitude, String metaData, Boolean returnFullResponse, String exceptionMembershipOfferIds) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'transactionId' is set
    if (transactionId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'transactionId' when calling updateOfferTransaction",
        new ApiException(400, "Missing the required parameter 'transactionId' when calling updateOfferTransaction"));
    }
    // verify the required parameter 'status' is set
    if (status == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'status' when calling updateOfferTransaction",
        new ApiException(400, "Missing the required parameter 'status' when calling updateOfferTransaction"));
    }

    // create path and map variables
    String path = "/wallet/update";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "transactionId", transactionId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerLocationId", offerLocationId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "currencyType", currencyType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "usePoints", usePoints));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "status", status));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "metaData", metaData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnFullResponse", returnFullResponse));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "exceptionMembershipOfferIds", exceptionMembershipOfferIds));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (OfferTransactionResponse) ApiInvoker.deserialize(localVarResponse, "", OfferTransactionResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Update Wallet Offer
   * Update offer status. The status values are: 0 - not redeemable, 1 - redeemable.  Not redeemable means the customer has received the offer but has not decided to use (or print) it yet.  Until they choose to do this the merchant cannot redeem the offer (has not been given permission yet).   Redeemable means the customer has chosen to use the offer and wishes to redeem it.  Redeemed means the merchant has accepted the offer and the given the customer its value, then marked it a used in the system.  This status change is handled by a merchant end point.
   * @param transactionId The offer transaction id to remove   * @param status The status value to change to (0 or 1)   * @param deviceId The device id (deviceId or accountId required)   * @param accountId The account id of the user (deviceId or accountId required)   * @param offerLocationId Offer Location Id   * @param currencyType Currency Type   * @param usePoints Use Points   * @param appKey App Key   * @param latitude The latitude location of the user   * @param longitude The latitude location of the user   * @param metaData External custom client defined data   * @param returnFullResponse Determines whether to return a detailed version of the response   * @param exceptionMembershipOfferIds Exception Offers, transaction audiences of these offers won&#39;t be removed out of the account when up
  */
  public void updateOfferTransaction (Long transactionId, Integer status, String deviceId, Long accountId, Long offerLocationId, String currencyType, Boolean usePoints, String appKey, Double latitude, Double longitude, String metaData, Boolean returnFullResponse, String exceptionMembershipOfferIds, final Response.Listener<OfferTransactionResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'transactionId' is set
    if (transactionId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'transactionId' when calling updateOfferTransaction",
        new ApiException(400, "Missing the required parameter 'transactionId' when calling updateOfferTransaction"));
    }
    // verify the required parameter 'status' is set
    if (status == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'status' when calling updateOfferTransaction",
        new ApiException(400, "Missing the required parameter 'status' when calling updateOfferTransaction"));
    }

    // create path and map variables
    String path = "/wallet/update".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "transactionId", transactionId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "offerLocationId", offerLocationId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "currencyType", currencyType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "usePoints", usePoints));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "status", status));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "metaData", metaData));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnFullResponse", returnFullResponse));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "exceptionMembershipOfferIds", exceptionMembershipOfferIds));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((OfferTransactionResponse) ApiInvoker.deserialize(localVarResponse,  "", OfferTransactionResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
