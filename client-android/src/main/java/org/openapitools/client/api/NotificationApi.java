/*
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client.api;

import org.openapitools.client.ApiInvoker;
import org.openapitools.client.ApiException;
import org.openapitools.client.Pair;

import org.openapitools.client.model.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import org.openapitools.client.model.BlockedNotificationResponse;
import java.util.*;
import org.openapitools.client.model.NotificationMessageListResponse;
import org.openapitools.client.model.NotificationRecipientResponse;
import org.openapitools.client.model.NotificationRecipientResponseListResponse;
import org.openapitools.client.model.NotificationTemplateResponse;
import org.openapitools.client.model.SirqulResponse;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class NotificationApi {
  String basePath = "https://dev.sirqul.com/api/3.18";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * Create Notification Template
  * Create a notification template. Developers will only be able to create notification templates for their own applications.
   * @param accountId The account ID of the user.
   * @param conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
   * @param title title of the notification template
   * @param body body of the notification template
   * @param appKey Filter results by application.
   * @param event Filter results by event.
   * @param tags tags associated with the note template
   * @return NotificationTemplateResponse
  */
  public NotificationTemplateResponse createNotificationTemplate (Long accountId, String conduit, String title, String body, String appKey, String event, String tags) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling createNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'accountId' when calling createNotificationTemplate"));
    }
    // verify the required parameter 'conduit' is set
    if (conduit == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'conduit' when calling createNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'conduit' when calling createNotificationTemplate"));
    }
    // verify the required parameter 'title' is set
    if (title == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'title' when calling createNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'title' when calling createNotificationTemplate"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling createNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'body' when calling createNotificationTemplate"));
    }

    // create path and map variables
    String path = "/notification/template/create";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "event", event));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "conduit", conduit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "title", title));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "body", body));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "tags", tags));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (NotificationTemplateResponse) ApiInvoker.deserialize(localVarResponse, "", NotificationTemplateResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Create Notification Template
   * Create a notification template. Developers will only be able to create notification templates for their own applications.
   * @param accountId The account ID of the user.   * @param conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.   * @param title title of the notification template   * @param body body of the notification template   * @param appKey Filter results by application.   * @param event Filter results by event.   * @param tags tags associated with the note template
  */
  public void createNotificationTemplate (Long accountId, String conduit, String title, String body, String appKey, String event, String tags, final Response.Listener<NotificationTemplateResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling createNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'accountId' when calling createNotificationTemplate"));
    }
    // verify the required parameter 'conduit' is set
    if (conduit == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'conduit' when calling createNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'conduit' when calling createNotificationTemplate"));
    }
    // verify the required parameter 'title' is set
    if (title == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'title' when calling createNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'title' when calling createNotificationTemplate"));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'body' when calling createNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'body' when calling createNotificationTemplate"));
    }

    // create path and map variables
    String path = "/notification/template/create".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "event", event));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "conduit", conduit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "title", title));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "body", body));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "tags", tags));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((NotificationTemplateResponse) ApiInvoker.deserialize(localVarResponse,  "", NotificationTemplateResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Create or update blocked notification settings
  * Create or update blocked notification settings
   * @param appKey The application key
   * @param data batch data payload (application specific)
   * @param accountId the account id of the user
   * @return BlockedNotificationResponse
  */
  public BlockedNotificationResponse createOrUpdateBlockedNotifications (String appKey, String data, Long accountId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling createOrUpdateBlockedNotifications",
        new ApiException(400, "Missing the required parameter 'appKey' when calling createOrUpdateBlockedNotifications"));
    }
    // verify the required parameter 'data' is set
    if (data == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'data' when calling createOrUpdateBlockedNotifications",
        new ApiException(400, "Missing the required parameter 'data' when calling createOrUpdateBlockedNotifications"));
    }

    // create path and map variables
    String path = "/notification/blocked/batch";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "data", data));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (BlockedNotificationResponse) ApiInvoker.deserialize(localVarResponse, "", BlockedNotificationResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Create or update blocked notification settings
   * Create or update blocked notification settings
   * @param appKey The application key   * @param data batch data payload (application specific)   * @param accountId the account id of the user
  */
  public void createOrUpdateBlockedNotifications (String appKey, String data, Long accountId, final Response.Listener<BlockedNotificationResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling createOrUpdateBlockedNotifications",
        new ApiException(400, "Missing the required parameter 'appKey' when calling createOrUpdateBlockedNotifications"));
    }
    // verify the required parameter 'data' is set
    if (data == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'data' when calling createOrUpdateBlockedNotifications",
        new ApiException(400, "Missing the required parameter 'data' when calling createOrUpdateBlockedNotifications"));
    }

    // create path and map variables
    String path = "/notification/blocked/batch".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "data", data));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((BlockedNotificationResponse) ApiInvoker.deserialize(localVarResponse,  "", BlockedNotificationResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Delete Notification Template
  * Deletes a notification template. Developers will only be able to delete notification templates for their own applications.
   * @param accountId the account id of the user
   * @param notificationTemplateId the id of the notification template to delete
   * @return NotificationTemplateResponse
  */
  public NotificationTemplateResponse deleteNotificationTemplate (Long accountId, Long notificationTemplateId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling deleteNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'accountId' when calling deleteNotificationTemplate"));
    }
    // verify the required parameter 'notificationTemplateId' is set
    if (notificationTemplateId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'notificationTemplateId' when calling deleteNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'notificationTemplateId' when calling deleteNotificationTemplate"));
    }

    // create path and map variables
    String path = "/notification/template/delete";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "notificationTemplateId", notificationTemplateId));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (NotificationTemplateResponse) ApiInvoker.deserialize(localVarResponse, "", NotificationTemplateResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Delete Notification Template
   * Deletes a notification template. Developers will only be able to delete notification templates for their own applications.
   * @param accountId the account id of the user   * @param notificationTemplateId the id of the notification template to delete
  */
  public void deleteNotificationTemplate (Long accountId, Long notificationTemplateId, final Response.Listener<NotificationTemplateResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling deleteNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'accountId' when calling deleteNotificationTemplate"));
    }
    // verify the required parameter 'notificationTemplateId' is set
    if (notificationTemplateId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'notificationTemplateId' when calling deleteNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'notificationTemplateId' when calling deleteNotificationTemplate"));
    }

    // create path and map variables
    String path = "/notification/template/delete".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "notificationTemplateId", notificationTemplateId));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((NotificationTemplateResponse) ApiInvoker.deserialize(localVarResponse,  "", NotificationTemplateResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Notification Template
  * Get the details of a notification template. Developers will only be able to see notification templates for their own applications.
   * @param accountId the id of the account
   * @param notificationTemplateId the id of the notification template to get
   * @return NotificationTemplateResponse
  */
  public NotificationTemplateResponse getNotificationTemplate (Long accountId, Long notificationTemplateId) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling getNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'accountId' when calling getNotificationTemplate"));
    }
    // verify the required parameter 'notificationTemplateId' is set
    if (notificationTemplateId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'notificationTemplateId' when calling getNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'notificationTemplateId' when calling getNotificationTemplate"));
    }

    // create path and map variables
    String path = "/notification/template/get";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "notificationTemplateId", notificationTemplateId));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (NotificationTemplateResponse) ApiInvoker.deserialize(localVarResponse, "", NotificationTemplateResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Notification Template
   * Get the details of a notification template. Developers will only be able to see notification templates for their own applications.
   * @param accountId the id of the account   * @param notificationTemplateId the id of the notification template to get
  */
  public void getNotificationTemplate (Long accountId, Long notificationTemplateId, final Response.Listener<NotificationTemplateResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling getNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'accountId' when calling getNotificationTemplate"));
    }
    // verify the required parameter 'notificationTemplateId' is set
    if (notificationTemplateId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'notificationTemplateId' when calling getNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'notificationTemplateId' when calling getNotificationTemplate"));
    }

    // create path and map variables
    String path = "/notification/template/get".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "notificationTemplateId", notificationTemplateId));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((NotificationTemplateResponse) ApiInvoker.deserialize(localVarResponse,  "", NotificationTemplateResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get Notifications
  * Get a list of notifications for a user. If the \&quot;markAsRead\&quot; parameter is set to true, the returned notifications will be marked as \&quot;read\&quot; after the response has been sent. By default, read messages will not be returned, so to see read messages, set \&quot;returnReadMessages\&quot; to true.
   * @param deviceId the unique id of the device making the request (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param connectionAccountId the account id used to view another person&#39;s notifications
   * @param appKey the application key to filter messages by application
   * @param eventType comma separated list of EVENTS. Filters search results to only include these events. Don&#39;t include this parameter or pass in an empty string to return all event types.
   * @param contentIds comma separated list of content ids to search notifications on
   * @param contentTypes comma separated list of content types to search notifications on
   * @param parentIds comma separated list of parent ids to search notifications on
   * @param parentTypes comma separated list of parent types to search notifications on
   * @param actionCategory Action category used to filter notifications
   * @param conduits comma separated list of conduits to search notifications on
   * @param keyword search notifications via keyword
   * @param returnReadMessages if set to true, will return notifications that have been marked as read
   * @param markAsRead if set to true, the returned notifications will be marked as \\\&quot;read\\\&quot; after the response has been sent
   * @param fromDate filter notifications from this date
   * @param latitude latitude used to update the user&#39;s current location
   * @param longitude longitude used to update the user&#39;s current location
   * @param returnSent whether to include notifications sent by the requester in the response
   * @param ignoreFlagged whether to ignore flagged notifications
   * @param start start of the pagination
   * @param limit limit of the pagination
   * @return NotificationMessageListResponse
  */
  public NotificationMessageListResponse getNotifications (String deviceId, Long accountId, Long connectionAccountId, String appKey, String eventType, String contentIds, String contentTypes, String parentIds, String parentTypes, String actionCategory, String conduits, String keyword, Boolean returnReadMessages, Boolean markAsRead, Long fromDate, Double latitude, Double longitude, Boolean returnSent, Boolean ignoreFlagged, Integer start, Integer limit) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/notification/search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "connectionAccountId", connectionAccountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "eventType", eventType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentIds", contentIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentTypes", contentTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "parentIds", parentIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "parentTypes", parentTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "actionCategory", actionCategory));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "conduits", conduits));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnReadMessages", returnReadMessages));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "markAsRead", markAsRead));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "fromDate", fromDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnSent", returnSent));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ignoreFlagged", ignoreFlagged));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (NotificationMessageListResponse) ApiInvoker.deserialize(localVarResponse, "", NotificationMessageListResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get Notifications
   * Get a list of notifications for a user. If the \&quot;markAsRead\&quot; parameter is set to true, the returned notifications will be marked as \&quot;read\&quot; after the response has been sent. By default, read messages will not be returned, so to see read messages, set \&quot;returnReadMessages\&quot; to true.
   * @param deviceId the unique id of the device making the request (deviceId or accountId required)   * @param accountId the account id of the user (deviceId or accountId required)   * @param connectionAccountId the account id used to view another person&#39;s notifications   * @param appKey the application key to filter messages by application   * @param eventType comma separated list of EVENTS. Filters search results to only include these events. Don&#39;t include this parameter or pass in an empty string to return all event types.   * @param contentIds comma separated list of content ids to search notifications on   * @param contentTypes comma separated list of content types to search notifications on   * @param parentIds comma separated list of parent ids to search notifications on   * @param parentTypes comma separated list of parent types to search notifications on   * @param actionCategory Action category used to filter notifications   * @param conduits comma separated list of conduits to search notifications on   * @param keyword search notifications via keyword   * @param returnReadMessages if set to true, will return notifications that have been marked as read   * @param markAsRead if set to true, the returned notifications will be marked as \\\&quot;read\\\&quot; after the response has been sent   * @param fromDate filter notifications from this date   * @param latitude latitude used to update the user&#39;s current location   * @param longitude longitude used to update the user&#39;s current location   * @param returnSent whether to include notifications sent by the requester in the response   * @param ignoreFlagged whether to ignore flagged notifications   * @param start start of the pagination   * @param limit limit of the pagination
  */
  public void getNotifications (String deviceId, Long accountId, Long connectionAccountId, String appKey, String eventType, String contentIds, String contentTypes, String parentIds, String parentTypes, String actionCategory, String conduits, String keyword, Boolean returnReadMessages, Boolean markAsRead, Long fromDate, Double latitude, Double longitude, Boolean returnSent, Boolean ignoreFlagged, Integer start, Integer limit, final Response.Listener<NotificationMessageListResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/notification/search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "connectionAccountId", connectionAccountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "eventType", eventType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentIds", contentIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentTypes", contentTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "parentIds", parentIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "parentTypes", parentTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "actionCategory", actionCategory));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "conduits", conduits));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnReadMessages", returnReadMessages));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "markAsRead", markAsRead));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "fromDate", fromDate));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "returnSent", returnSent));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "ignoreFlagged", ignoreFlagged));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((NotificationMessageListResponse) ApiInvoker.deserialize(localVarResponse,  "", NotificationMessageListResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Register Notification Token
  * Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.
   * @param token A token that is generated by the device to sign requests for the notification service providers
   * @param pushType The type of push notification. Possible values include: APNS, GCM
   * @param deviceId The unique id of the device making the request (deviceId or accountId required)
   * @param accountId The account id of the user (deviceId or accountId required)
   * @param environment Determines if the token is a DEVELOPMENT or PRODUCTION token
   * @param appKey The application key
   * @param gameType This parameter is deprecated (use appKey instead)
   * @param active Sets whether the token is active or not (non-active tokens are not used)
   * @param latitude Latitude used to update the user&#39;s current location
   * @param longitude Longitude used to update the user&#39;s current location
   * @return SirqulResponse
  */
  public SirqulResponse registerNotificationToken (String token, String pushType, String deviceId, Long accountId, String environment, String appKey, String gameType, Boolean active, Double latitude, Double longitude) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'token' is set
    if (token == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'token' when calling registerNotificationToken",
        new ApiException(400, "Missing the required parameter 'token' when calling registerNotificationToken"));
    }
    // verify the required parameter 'pushType' is set
    if (pushType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'pushType' when calling registerNotificationToken",
        new ApiException(400, "Missing the required parameter 'pushType' when calling registerNotificationToken"));
    }

    // create path and map variables
    String path = "/notification/token";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "token", token));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pushType", pushType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "environment", environment));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "gameType", gameType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "active", active));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SirqulResponse) ApiInvoker.deserialize(localVarResponse, "", SirqulResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Register Notification Token
   * Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.
   * @param token A token that is generated by the device to sign requests for the notification service providers   * @param pushType The type of push notification. Possible values include: APNS, GCM   * @param deviceId The unique id of the device making the request (deviceId or accountId required)   * @param accountId The account id of the user (deviceId or accountId required)   * @param environment Determines if the token is a DEVELOPMENT or PRODUCTION token   * @param appKey The application key   * @param gameType This parameter is deprecated (use appKey instead)   * @param active Sets whether the token is active or not (non-active tokens are not used)   * @param latitude Latitude used to update the user&#39;s current location   * @param longitude Longitude used to update the user&#39;s current location
  */
  public void registerNotificationToken (String token, String pushType, String deviceId, Long accountId, String environment, String appKey, String gameType, Boolean active, Double latitude, Double longitude, final Response.Listener<SirqulResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'token' is set
    if (token == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'token' when calling registerNotificationToken",
        new ApiException(400, "Missing the required parameter 'token' when calling registerNotificationToken"));
    }
    // verify the required parameter 'pushType' is set
    if (pushType == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'pushType' when calling registerNotificationToken",
        new ApiException(400, "Missing the required parameter 'pushType' when calling registerNotificationToken"));
    }

    // create path and map variables
    String path = "/notification/token".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "token", token));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "pushType", pushType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "environment", environment));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "gameType", gameType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "active", active));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SirqulResponse) ApiInvoker.deserialize(localVarResponse,  "", SirqulResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search on the user&#39;s blocked notification settings
  * Search on the user&#39;s blocked notification settings
   * @param appKey The application key
   * @param accountId the account id of the user
   * @param searchTags search tags to filter results
   * @param events events to filter by (comma separated)
   * @param conduits conduits to filter by (comma separated)
   * @param customTypes custom types to filter by (comma separated)
   * @param contentTypes content types to filter by (comma separated)
   * @param contentIds content ids to filter by (comma separated)
   * @param sortField sort field for results
   * @param descending whether to sort descending
   * @param start start of the pagination
   * @param limit limit of the pagination
   * @return BlockedNotificationResponse
  */
  public BlockedNotificationResponse searchBlockedNotifications (String appKey, Long accountId, String searchTags, String events, String conduits, String customTypes, String contentTypes, String contentIds, String sortField, Boolean descending, Integer start, Integer limit) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling searchBlockedNotifications",
        new ApiException(400, "Missing the required parameter 'appKey' when calling searchBlockedNotifications"));
    }

    // create path and map variables
    String path = "/notification/blocked/search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "searchTags", searchTags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "events", events));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "conduits", conduits));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "customTypes", customTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentTypes", contentTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentIds", contentIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (BlockedNotificationResponse) ApiInvoker.deserialize(localVarResponse, "", BlockedNotificationResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search on the user&#39;s blocked notification settings
   * Search on the user&#39;s blocked notification settings
   * @param appKey The application key   * @param accountId the account id of the user   * @param searchTags search tags to filter results   * @param events events to filter by (comma separated)   * @param conduits conduits to filter by (comma separated)   * @param customTypes custom types to filter by (comma separated)   * @param contentTypes content types to filter by (comma separated)   * @param contentIds content ids to filter by (comma separated)   * @param sortField sort field for results   * @param descending whether to sort descending   * @param start start of the pagination   * @param limit limit of the pagination
  */
  public void searchBlockedNotifications (String appKey, Long accountId, String searchTags, String events, String conduits, String customTypes, String contentTypes, String contentIds, String sortField, Boolean descending, Integer start, Integer limit, final Response.Listener<BlockedNotificationResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling searchBlockedNotifications",
        new ApiException(400, "Missing the required parameter 'appKey' when calling searchBlockedNotifications"));
    }

    // create path and map variables
    String path = "/notification/blocked/search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "searchTags", searchTags));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "events", events));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "conduits", conduits));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "customTypes", customTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentTypes", contentTypes));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentIds", contentIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((BlockedNotificationResponse) ApiInvoker.deserialize(localVarResponse,  "", BlockedNotificationResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search Notification Templates
  * Search for notification templates on owned applications.
   * @param accountId The account ID of the user.
   * @param sortField Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name (&#39;global&#39; templates will not have an application and will be returned last if &#39;descending&#39; is set to false.
   * @param descending Specified whether the results are returned in descending or ascending order.
   * @param start The start of the pagination.
   * @param limit The limit of the pagination.
   * @param appKey Filter results by application.
   * @param event Filter results by event.
   * @param conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
   * @param globalOnly Returns only templates that have been reserved for system use on all applications (only for admin accounts).
   * @param reservedOnly Returns only templates that use reserved events.
   * @param keyword Filter results by keyword on the title, tags.
   * @return NotificationTemplateResponse
  */
  public NotificationTemplateResponse searchNotificationTemplate (Long accountId, String sortField, Boolean descending, Integer start, Integer limit, String appKey, String event, String conduit, Boolean globalOnly, Boolean reservedOnly, String keyword) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling searchNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'accountId' when calling searchNotificationTemplate"));
    }
    // verify the required parameter 'sortField' is set
    if (sortField == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'sortField' when calling searchNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'sortField' when calling searchNotificationTemplate"));
    }
    // verify the required parameter 'descending' is set
    if (descending == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'descending' when calling searchNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'descending' when calling searchNotificationTemplate"));
    }
    // verify the required parameter 'start' is set
    if (start == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'start' when calling searchNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'start' when calling searchNotificationTemplate"));
    }
    // verify the required parameter 'limit' is set
    if (limit == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'limit' when calling searchNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'limit' when calling searchNotificationTemplate"));
    }

    // create path and map variables
    String path = "/notification/template/search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "event", event));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "conduit", conduit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "globalOnly", globalOnly));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "reservedOnly", reservedOnly));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (NotificationTemplateResponse) ApiInvoker.deserialize(localVarResponse, "", NotificationTemplateResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search Notification Templates
   * Search for notification templates on owned applications.
   * @param accountId The account ID of the user.   * @param sortField Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name (&#39;global&#39; templates will not have an application and will be returned last if &#39;descending&#39; is set to false.   * @param descending Specified whether the results are returned in descending or ascending order.   * @param start The start of the pagination.   * @param limit The limit of the pagination.   * @param appKey Filter results by application.   * @param event Filter results by event.   * @param conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.   * @param globalOnly Returns only templates that have been reserved for system use on all applications (only for admin accounts).   * @param reservedOnly Returns only templates that use reserved events.   * @param keyword Filter results by keyword on the title, tags.
  */
  public void searchNotificationTemplate (Long accountId, String sortField, Boolean descending, Integer start, Integer limit, String appKey, String event, String conduit, Boolean globalOnly, Boolean reservedOnly, String keyword, final Response.Listener<NotificationTemplateResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling searchNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'accountId' when calling searchNotificationTemplate"));
    }
    // verify the required parameter 'sortField' is set
    if (sortField == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'sortField' when calling searchNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'sortField' when calling searchNotificationTemplate"));
    }
    // verify the required parameter 'descending' is set
    if (descending == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'descending' when calling searchNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'descending' when calling searchNotificationTemplate"));
    }
    // verify the required parameter 'start' is set
    if (start == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'start' when calling searchNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'start' when calling searchNotificationTemplate"));
    }
    // verify the required parameter 'limit' is set
    if (limit == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'limit' when calling searchNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'limit' when calling searchNotificationTemplate"));
    }

    // create path and map variables
    String path = "/notification/template/search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "event", event));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "conduit", conduit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "globalOnly", globalOnly));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "reservedOnly", reservedOnly));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((NotificationTemplateResponse) ApiInvoker.deserialize(localVarResponse,  "", NotificationTemplateResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search for Recipients
  * Search for application users to send notifications.
   * @param sortField The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}
   * @param deviceId the unique id of the device making the request (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param appKey filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
   * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
   * @param keyword search by keyword on user&#39;s display name and email
   * @param audienceId This parameter is deprecated. filter results by audience
   * @param audienceIds filter results by audiences (comma separated list of audience ids)
   * @param connectionGroupIds filter results by connection groups (comma separated list of connection group ids)
   * @param recipientAccountIds filter results by accounts (comma separated list of account ids)
   * @param descending Determines whether the sorted list is in descending or ascending order
   * @param start start of the pagination
   * @param limit limit of the pagination (hard limit of 1000)
   * @return List<NotificationRecipientResponse>
  */
  public List<NotificationRecipientResponse> searchRecipients (String sortField, String deviceId, Long accountId, String appKey, String conduit, String keyword, Long audienceId, String audienceIds, String connectionGroupIds, String recipientAccountIds, Boolean descending, Integer start, Integer limit) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'sortField' is set
    if (sortField == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'sortField' when calling searchRecipients",
        new ApiException(400, "Missing the required parameter 'sortField' when calling searchRecipients"));
    }

    // create path and map variables
    String path = "/notification/recipient/search";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "conduit", conduit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceId", audienceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceIds", audienceIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "connectionGroupIds", connectionGroupIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "recipientAccountIds", recipientAccountIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (List<NotificationRecipientResponse>) ApiInvoker.deserialize(localVarResponse, "array", NotificationRecipientResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search for Recipients
   * Search for application users to send notifications.
   * @param sortField The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}   * @param deviceId the unique id of the device making the request (deviceId or accountId required)   * @param accountId the account id of the user (deviceId or accountId required)   * @param appKey filters results by application. If this is empty, will return all recipients for all applications that the user has access to.   * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.   * @param keyword search by keyword on user&#39;s display name and email   * @param audienceId This parameter is deprecated. filter results by audience   * @param audienceIds filter results by audiences (comma separated list of audience ids)   * @param connectionGroupIds filter results by connection groups (comma separated list of connection group ids)   * @param recipientAccountIds filter results by accounts (comma separated list of account ids)   * @param descending Determines whether the sorted list is in descending or ascending order   * @param start start of the pagination   * @param limit limit of the pagination (hard limit of 1000)
  */
  public void searchRecipients (String sortField, String deviceId, Long accountId, String appKey, String conduit, String keyword, Long audienceId, String audienceIds, String connectionGroupIds, String recipientAccountIds, Boolean descending, Integer start, Integer limit, final Response.Listener<List<NotificationRecipientResponse>> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'sortField' is set
    if (sortField == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'sortField' when calling searchRecipients",
        new ApiException(400, "Missing the required parameter 'sortField' when calling searchRecipients"));
    }

    // create path and map variables
    String path = "/notification/recipient/search".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "conduit", conduit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceId", audienceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceIds", audienceIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "connectionGroupIds", connectionGroupIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "recipientAccountIds", recipientAccountIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((List<NotificationRecipientResponse>) ApiInvoker.deserialize(localVarResponse,  "array", NotificationRecipientResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Search for Recipients (Counts/Grouped)
  * Search for application users to send notifications (count/grouped variant).
   * @param deviceId the unique id of the device making the request (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param appKey filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
   * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
   * @param keyword search by keyword on user&#39;s display name and email
   * @param audienceId This parameter is deprecated. filter results by audience
   * @param audienceIds filter results by audiences (comma separated list of audience ids)
   * @param connectionGroupIds filter results by connection groups (comma separated list of connection group ids)
   * @param sortField The field to sort by (see API docs for allowed values).
   * @param descending Determines whether the sorted list is in descending or ascending order
   * @param start start of the pagination
   * @param limit limit of the pagination
   * @return NotificationRecipientResponseListResponse
  */
  public NotificationRecipientResponseListResponse searchRecipientsCount (String deviceId, Long accountId, String appKey, String conduit, String keyword, Long audienceId, String audienceIds, String connectionGroupIds, String sortField, Boolean descending, Integer start, Integer limit) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/notification/recipient/search/count";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "conduit", conduit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceId", audienceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceIds", audienceIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "connectionGroupIds", connectionGroupIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (NotificationRecipientResponseListResponse) ApiInvoker.deserialize(localVarResponse, "", NotificationRecipientResponseListResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Search for Recipients (Counts/Grouped)
   * Search for application users to send notifications (count/grouped variant).
   * @param deviceId the unique id of the device making the request (deviceId or accountId required)   * @param accountId the account id of the user (deviceId or accountId required)   * @param appKey filters results by application. If this is empty, will return all recipients for all applications that the user has access to.   * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.   * @param keyword search by keyword on user&#39;s display name and email   * @param audienceId This parameter is deprecated. filter results by audience   * @param audienceIds filter results by audiences (comma separated list of audience ids)   * @param connectionGroupIds filter results by connection groups (comma separated list of connection group ids)   * @param sortField The field to sort by (see API docs for allowed values).   * @param descending Determines whether the sorted list is in descending or ascending order   * @param start start of the pagination   * @param limit limit of the pagination
  */
  public void searchRecipientsCount (String deviceId, Long accountId, String appKey, String conduit, String keyword, Long audienceId, String audienceIds, String connectionGroupIds, String sortField, Boolean descending, Integer start, Integer limit, final Response.Listener<NotificationRecipientResponseListResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/notification/recipient/search/count".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "conduit", conduit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "keyword", keyword));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceId", audienceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "audienceIds", audienceIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "connectionGroupIds", connectionGroupIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sortField", sortField));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "descending", descending));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "start", start));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((NotificationRecipientResponseListResponse) ApiInvoker.deserialize(localVarResponse,  "", NotificationRecipientResponseListResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Send Batch Notifications
  * Send notifications to all users of an application. Only someone with permissions to the application can do this.
   * @param accountId The account id of the application owner/manager
   * @param appKey The application key for updating an existing application
   * @param customMessage Message string that will be displayed in on the notification
   * @param conduit The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
   * @param contentId Default notification pay-load field (usage is dependent on the app and the type of event)
   * @param contentName Default notification pay-load field (usage is dependent on the app and the type of event)
   * @param contentType Default notification pay-load field (usage is dependent on the app and the type of event)
   * @param parentId Default notification pay-load field (usage is dependent on the app and the type of event)
   * @param parentType Default notification pay-load field (usage is dependent on the app and the type of event)
   * @return SirqulResponse
  */
  public SirqulResponse sendBatchNotifications (Long accountId, String appKey, String customMessage, String conduit, Long contentId, String contentName, String contentType, Long parentId, String parentType) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling sendBatchNotifications",
        new ApiException(400, "Missing the required parameter 'accountId' when calling sendBatchNotifications"));
    }
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling sendBatchNotifications",
        new ApiException(400, "Missing the required parameter 'appKey' when calling sendBatchNotifications"));
    }
    // verify the required parameter 'customMessage' is set
    if (customMessage == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'customMessage' when calling sendBatchNotifications",
        new ApiException(400, "Missing the required parameter 'customMessage' when calling sendBatchNotifications"));
    }

    // create path and map variables
    String path = "/notification/batch";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "conduit", conduit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "customMessage", customMessage));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentId", contentId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentName", contentName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentType", contentType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "parentId", parentId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "parentType", parentType));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SirqulResponse) ApiInvoker.deserialize(localVarResponse, "", SirqulResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Send Batch Notifications
   * Send notifications to all users of an application. Only someone with permissions to the application can do this.
   * @param accountId The account id of the application owner/manager   * @param appKey The application key for updating an existing application   * @param customMessage Message string that will be displayed in on the notification   * @param conduit The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.   * @param contentId Default notification pay-load field (usage is dependent on the app and the type of event)   * @param contentName Default notification pay-load field (usage is dependent on the app and the type of event)   * @param contentType Default notification pay-load field (usage is dependent on the app and the type of event)   * @param parentId Default notification pay-load field (usage is dependent on the app and the type of event)   * @param parentType Default notification pay-load field (usage is dependent on the app and the type of event)
  */
  public void sendBatchNotifications (Long accountId, String appKey, String customMessage, String conduit, Long contentId, String contentName, String contentType, Long parentId, String parentType, final Response.Listener<SirqulResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling sendBatchNotifications",
        new ApiException(400, "Missing the required parameter 'accountId' when calling sendBatchNotifications"));
    }
    // verify the required parameter 'appKey' is set
    if (appKey == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'appKey' when calling sendBatchNotifications",
        new ApiException(400, "Missing the required parameter 'appKey' when calling sendBatchNotifications"));
    }
    // verify the required parameter 'customMessage' is set
    if (customMessage == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'customMessage' when calling sendBatchNotifications",
        new ApiException(400, "Missing the required parameter 'customMessage' when calling sendBatchNotifications"));
    }

    // create path and map variables
    String path = "/notification/batch".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "conduit", conduit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "customMessage", customMessage));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentId", contentId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentName", contentName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentType", contentType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "parentId", parentId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "parentType", parentType));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SirqulResponse) ApiInvoker.deserialize(localVarResponse,  "", SirqulResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Send Custom Notifications
  * Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.
   * @param deviceId the unique id of the device making the request (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param receiverAccountIds comma separated list of account IDs that will receive the notification
   * @param includeFriendGroup determines whether to send to all of the user&#39;s friends, this flag must be true or receiverAccountIds must not be empty
   * @param appKey the application key
   * @param gameType This parameter is deprecated.
   * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
   * @param contentId default notification pay-load field (usage is dependent on the app and the type of event)
   * @param contentName default notification pay-load field (usage is dependent on the app and the type of event)
   * @param contentType default notification pay-load field (usage is dependent on the app and the type of event)
   * @param parentId default notification pay-load field (usage is dependent on the app and the type of event)
   * @param parentType default notification pay-load field (usage is dependent on the app and the type of event)
   * @param actionCategory 
   * @param subject the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)
   * @param customMessage message string that will be displayed in on the notification
   * @param friendOnlyAPNS only sends APNS to people who are friends of the user (still saves the notification message for feed polling)
   * @param latitude latitude used to update the user&#39;s current location
   * @param longitude longitude used to update the user&#39;s current location
   * @return SirqulResponse
  */
  public SirqulResponse sendCustomNotifications (String deviceId, Long accountId, String receiverAccountIds, Boolean includeFriendGroup, String appKey, String gameType, String conduit, Long contentId, String contentName, String contentType, Long parentId, String parentType, String actionCategory, String subject, String customMessage, Boolean friendOnlyAPNS, Double latitude, Double longitude) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/notification/custom";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "receiverAccountIds", receiverAccountIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "includeFriendGroup", includeFriendGroup));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "gameType", gameType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "conduit", conduit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentId", contentId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentName", contentName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentType", contentType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "parentId", parentId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "parentType", parentType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "actionCategory", actionCategory));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "subject", subject));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "customMessage", customMessage));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "friendOnlyAPNS", friendOnlyAPNS));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (SirqulResponse) ApiInvoker.deserialize(localVarResponse, "", SirqulResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Send Custom Notifications
   * Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.
   * @param deviceId the unique id of the device making the request (deviceId or accountId required)   * @param accountId the account id of the user (deviceId or accountId required)   * @param receiverAccountIds comma separated list of account IDs that will receive the notification   * @param includeFriendGroup determines whether to send to all of the user&#39;s friends, this flag must be true or receiverAccountIds must not be empty   * @param appKey the application key   * @param gameType This parameter is deprecated.   * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.   * @param contentId default notification pay-load field (usage is dependent on the app and the type of event)   * @param contentName default notification pay-load field (usage is dependent on the app and the type of event)   * @param contentType default notification pay-load field (usage is dependent on the app and the type of event)   * @param parentId default notification pay-load field (usage is dependent on the app and the type of event)   * @param parentType default notification pay-load field (usage is dependent on the app and the type of event)   * @param actionCategory    * @param subject the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)   * @param customMessage message string that will be displayed in on the notification   * @param friendOnlyAPNS only sends APNS to people who are friends of the user (still saves the notification message for feed polling)   * @param latitude latitude used to update the user&#39;s current location   * @param longitude longitude used to update the user&#39;s current location
  */
  public void sendCustomNotifications (String deviceId, Long accountId, String receiverAccountIds, Boolean includeFriendGroup, String appKey, String gameType, String conduit, Long contentId, String contentName, String contentType, Long parentId, String parentType, String actionCategory, String subject, String customMessage, Boolean friendOnlyAPNS, Double latitude, Double longitude, final Response.Listener<SirqulResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/notification/custom".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "deviceId", deviceId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "receiverAccountIds", receiverAccountIds));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "includeFriendGroup", includeFriendGroup));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "appKey", appKey));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "gameType", gameType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "conduit", conduit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentId", contentId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentName", contentName));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "contentType", contentType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "parentId", parentId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "parentType", parentType));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "actionCategory", actionCategory));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "subject", subject));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "customMessage", customMessage));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "friendOnlyAPNS", friendOnlyAPNS));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "latitude", latitude));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "longitude", longitude));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((SirqulResponse) ApiInvoker.deserialize(localVarResponse,  "", SirqulResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Update Notification Template
  * Update a notification template. Developers will only be able to update notification templates for their own applications.
   * @param accountId The account ID of the user.
   * @param notificationTemplateId The notification template ID to update.
   * @param title The title of the message (this would become the subject title for emails). There is a 191 character limit.
   * @param body The body of the message.
   * @param tags The search tags on the template used during search queries.
   * @return NotificationTemplateResponse
  */
  public NotificationTemplateResponse updateNotificationTemplate (Long accountId, Long notificationTemplateId, String title, String body, String tags) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling updateNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'accountId' when calling updateNotificationTemplate"));
    }
    // verify the required parameter 'notificationTemplateId' is set
    if (notificationTemplateId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'notificationTemplateId' when calling updateNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'notificationTemplateId' when calling updateNotificationTemplate"));
    }

    // create path and map variables
    String path = "/notification/template/update";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "notificationTemplateId", notificationTemplateId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "title", title));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "body", body));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "tags", tags));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (NotificationTemplateResponse) ApiInvoker.deserialize(localVarResponse, "", NotificationTemplateResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Update Notification Template
   * Update a notification template. Developers will only be able to update notification templates for their own applications.
   * @param accountId The account ID of the user.   * @param notificationTemplateId The notification template ID to update.   * @param title The title of the message (this would become the subject title for emails). There is a 191 character limit.   * @param body The body of the message.   * @param tags The search tags on the template used during search queries.
  */
  public void updateNotificationTemplate (Long accountId, Long notificationTemplateId, String title, String body, String tags, final Response.Listener<NotificationTemplateResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'accountId' when calling updateNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'accountId' when calling updateNotificationTemplate"));
    }
    // verify the required parameter 'notificationTemplateId' is set
    if (notificationTemplateId == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'notificationTemplateId' when calling updateNotificationTemplate",
        new ApiException(400, "Missing the required parameter 'notificationTemplateId' when calling updateNotificationTemplate"));
    }

    // create path and map variables
    String path = "/notification/template/update".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "accountId", accountId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "notificationTemplateId", notificationTemplateId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "title", title));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "body", body));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "tags", tags));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "POST", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((NotificationTemplateResponse) ApiInvoker.deserialize(localVarResponse,  "", NotificationTemplateResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
