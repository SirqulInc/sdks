//
// NoteResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct NoteResponse: Sendable, Codable, Hashable {

    public var valid: Bool?
    public var message: String?
    public var version: Double?
    public var serializeNulls: Bool?
    public var startTimeLog: Int64?
    public var errorCode: String?
    public var request: [NameStringValueResponse]?
    public var noteId: Int64?
    public var comment: String?
    public var tags: String?
    public var likesCount: Int64?
    public var dislikesCount: Int64?
    public var dateCreated: Int64?
    public var createdDate: Int64?
    public var updatedDate: Int64?
    public var owner: AccountShortResponse?
    public var latitude: Double?
    public var longitude: Double?
    public var locationDescription: String?
    public var returning: String?

    public init(valid: Bool? = nil, message: String? = nil, version: Double? = nil, serializeNulls: Bool? = nil, startTimeLog: Int64? = nil, errorCode: String? = nil, request: [NameStringValueResponse]? = nil, noteId: Int64? = nil, comment: String? = nil, tags: String? = nil, likesCount: Int64? = nil, dislikesCount: Int64? = nil, dateCreated: Int64? = nil, createdDate: Int64? = nil, updatedDate: Int64? = nil, owner: AccountShortResponse? = nil, latitude: Double? = nil, longitude: Double? = nil, locationDescription: String? = nil, returning: String? = nil) {
        self.valid = valid
        self.message = message
        self.version = version
        self.serializeNulls = serializeNulls
        self.startTimeLog = startTimeLog
        self.errorCode = errorCode
        self.request = request
        self.noteId = noteId
        self.comment = comment
        self.tags = tags
        self.likesCount = likesCount
        self.dislikesCount = dislikesCount
        self.dateCreated = dateCreated
        self.createdDate = createdDate
        self.updatedDate = updatedDate
        self.owner = owner
        self.latitude = latitude
        self.longitude = longitude
        self.locationDescription = locationDescription
        self.returning = returning
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case valid
        case message
        case version
        case serializeNulls
        case startTimeLog
        case errorCode
        case request
        case noteId
        case comment
        case tags
        case likesCount
        case dislikesCount
        case dateCreated
        case createdDate
        case updatedDate
        case owner
        case latitude
        case longitude
        case locationDescription
        case returning
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(valid, forKey: .valid)
        try container.encodeIfPresent(message, forKey: .message)
        try container.encodeIfPresent(version, forKey: .version)
        try container.encodeIfPresent(serializeNulls, forKey: .serializeNulls)
        try container.encodeIfPresent(startTimeLog, forKey: .startTimeLog)
        try container.encodeIfPresent(errorCode, forKey: .errorCode)
        try container.encodeIfPresent(request, forKey: .request)
        try container.encodeIfPresent(noteId, forKey: .noteId)
        try container.encodeIfPresent(comment, forKey: .comment)
        try container.encodeIfPresent(tags, forKey: .tags)
        try container.encodeIfPresent(likesCount, forKey: .likesCount)
        try container.encodeIfPresent(dislikesCount, forKey: .dislikesCount)
        try container.encodeIfPresent(dateCreated, forKey: .dateCreated)
        try container.encodeIfPresent(createdDate, forKey: .createdDate)
        try container.encodeIfPresent(updatedDate, forKey: .updatedDate)
        try container.encodeIfPresent(owner, forKey: .owner)
        try container.encodeIfPresent(latitude, forKey: .latitude)
        try container.encodeIfPresent(longitude, forKey: .longitude)
        try container.encodeIfPresent(locationDescription, forKey: .locationDescription)
        try container.encodeIfPresent(returning, forKey: .returning)
    }
}

