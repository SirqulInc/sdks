//
// OrderResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct OrderResponse: Sendable, Codable, Hashable {

    public var valid: Bool?
    public var message: String?
    public var version: Double?
    public var serializeNulls: Bool?
    public var startTimeLog: Int64?
    public var errorCode: String?
    public var request: [NameStringValueResponse]?
    public var orderId: Int64?
    public var application: ApplicationMiniResponse?
    public var customer: AccountShortResponse?
    public var amount: Double?
    public var purchases: Double?
    public var credits: Double?
    public var payments: [PaymentTransactionResponse]?
    public var externalOrderId: String?
    public var created: Int64?
    public var updated: Int64?
    public var externalDate: Int64?
    public var description: String?
    public var returning: String?

    public init(valid: Bool? = nil, message: String? = nil, version: Double? = nil, serializeNulls: Bool? = nil, startTimeLog: Int64? = nil, errorCode: String? = nil, request: [NameStringValueResponse]? = nil, orderId: Int64? = nil, application: ApplicationMiniResponse? = nil, customer: AccountShortResponse? = nil, amount: Double? = nil, purchases: Double? = nil, credits: Double? = nil, payments: [PaymentTransactionResponse]? = nil, externalOrderId: String? = nil, created: Int64? = nil, updated: Int64? = nil, externalDate: Int64? = nil, description: String? = nil, returning: String? = nil) {
        self.valid = valid
        self.message = message
        self.version = version
        self.serializeNulls = serializeNulls
        self.startTimeLog = startTimeLog
        self.errorCode = errorCode
        self.request = request
        self.orderId = orderId
        self.application = application
        self.customer = customer
        self.amount = amount
        self.purchases = purchases
        self.credits = credits
        self.payments = payments
        self.externalOrderId = externalOrderId
        self.created = created
        self.updated = updated
        self.externalDate = externalDate
        self.description = description
        self.returning = returning
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case valid
        case message
        case version
        case serializeNulls
        case startTimeLog
        case errorCode
        case request
        case orderId
        case application
        case customer
        case amount
        case purchases
        case credits
        case payments
        case externalOrderId
        case created
        case updated
        case externalDate
        case description
        case returning
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(valid, forKey: .valid)
        try container.encodeIfPresent(message, forKey: .message)
        try container.encodeIfPresent(version, forKey: .version)
        try container.encodeIfPresent(serializeNulls, forKey: .serializeNulls)
        try container.encodeIfPresent(startTimeLog, forKey: .startTimeLog)
        try container.encodeIfPresent(errorCode, forKey: .errorCode)
        try container.encodeIfPresent(request, forKey: .request)
        try container.encodeIfPresent(orderId, forKey: .orderId)
        try container.encodeIfPresent(application, forKey: .application)
        try container.encodeIfPresent(customer, forKey: .customer)
        try container.encodeIfPresent(amount, forKey: .amount)
        try container.encodeIfPresent(purchases, forKey: .purchases)
        try container.encodeIfPresent(credits, forKey: .credits)
        try container.encodeIfPresent(payments, forKey: .payments)
        try container.encodeIfPresent(externalOrderId, forKey: .externalOrderId)
        try container.encodeIfPresent(created, forKey: .created)
        try container.encodeIfPresent(updated, forKey: .updated)
        try container.encodeIfPresent(externalDate, forKey: .externalDate)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encodeIfPresent(returning, forKey: .returning)
    }
}

