//
// QuestionResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct QuestionResponse: Sendable, Codable, Hashable {

    public var id: Int64?
    public var question: String?
    public var image: AssetShortResponse?
    public var videoURL: String?
    public var active: Bool?
    public var answers: [AnswerResponse]?
    public var scores: ScoreListResponse?
    public var tickets: TicketListResponse?
    public var owner: AccountShortResponse?
    public var icon: AssetShortResponse?
    public var authorOverride: String?
    public var updatedDate: Int64?
    public var startDate: Int64?
    public var endDate: Int64?
    public var createdDate: Int64?
    public var tags: String?
    public var allocateTickets: Bool?
    public var ticketType: String?
    public var ticketCount: Int64?
    public var points: Int64?

    public init(id: Int64? = nil, question: String? = nil, image: AssetShortResponse? = nil, videoURL: String? = nil, active: Bool? = nil, answers: [AnswerResponse]? = nil, scores: ScoreListResponse? = nil, tickets: TicketListResponse? = nil, owner: AccountShortResponse? = nil, icon: AssetShortResponse? = nil, authorOverride: String? = nil, updatedDate: Int64? = nil, startDate: Int64? = nil, endDate: Int64? = nil, createdDate: Int64? = nil, tags: String? = nil, allocateTickets: Bool? = nil, ticketType: String? = nil, ticketCount: Int64? = nil, points: Int64? = nil) {
        self.id = id
        self.question = question
        self.image = image
        self.videoURL = videoURL
        self.active = active
        self.answers = answers
        self.scores = scores
        self.tickets = tickets
        self.owner = owner
        self.icon = icon
        self.authorOverride = authorOverride
        self.updatedDate = updatedDate
        self.startDate = startDate
        self.endDate = endDate
        self.createdDate = createdDate
        self.tags = tags
        self.allocateTickets = allocateTickets
        self.ticketType = ticketType
        self.ticketCount = ticketCount
        self.points = points
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case question
        case image
        case videoURL
        case active
        case answers
        case scores
        case tickets
        case owner
        case icon
        case authorOverride
        case updatedDate
        case startDate
        case endDate
        case createdDate
        case tags
        case allocateTickets
        case ticketType
        case ticketCount
        case points
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(question, forKey: .question)
        try container.encodeIfPresent(image, forKey: .image)
        try container.encodeIfPresent(videoURL, forKey: .videoURL)
        try container.encodeIfPresent(active, forKey: .active)
        try container.encodeIfPresent(answers, forKey: .answers)
        try container.encodeIfPresent(scores, forKey: .scores)
        try container.encodeIfPresent(tickets, forKey: .tickets)
        try container.encodeIfPresent(owner, forKey: .owner)
        try container.encodeIfPresent(icon, forKey: .icon)
        try container.encodeIfPresent(authorOverride, forKey: .authorOverride)
        try container.encodeIfPresent(updatedDate, forKey: .updatedDate)
        try container.encodeIfPresent(startDate, forKey: .startDate)
        try container.encodeIfPresent(endDate, forKey: .endDate)
        try container.encodeIfPresent(createdDate, forKey: .createdDate)
        try container.encodeIfPresent(tags, forKey: .tags)
        try container.encodeIfPresent(allocateTickets, forKey: .allocateTickets)
        try container.encodeIfPresent(ticketType, forKey: .ticketType)
        try container.encodeIfPresent(ticketCount, forKey: .ticketCount)
        try container.encodeIfPresent(points, forKey: .points)
    }
}


extension QuestionResponse: Identifiable {}
