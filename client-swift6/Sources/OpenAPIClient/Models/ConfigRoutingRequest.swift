//
// ConfigRoutingRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct ConfigRoutingRequest: Sendable, Codable, Hashable {

    public enum OrderAlgorithm: String, Sendable, Codable, CaseIterable {
        case closestFirst = "CLOSEST_FIRST"
        case furthestFirst = "FURTHEST_FIRST"
        case pickupsFirst = "PICKUPS_FIRST"
    }
    public enum ScoreAlgorithm: String, Sendable, Codable, CaseIterable {
        case fewestVehicles = "FEWEST_VEHICLES"
        case shortestPassengerTime = "SHORTEST_PASSENGER_TIME"
    }
    public var debugMode: Bool?
    public var threaded: Bool?
    public var threadType: String?
    public var maxRuntime: Int64?
    public var numberOfMatches: Int?
    public var maxItineraryTime: Int?
    public var maxStopsPerVehicle: Int?
    public var averageCityTimePerMile: Int?
    public var averageFreewayTimePerMile: Int?
    public var freewayTravelDistance: Float?
    public var sameStopBuffer: Double?
    public var orderAlgorithm: OrderAlgorithm?
    public var scoreAlgorithm: ScoreAlgorithm?

    public init(debugMode: Bool? = nil, threaded: Bool? = nil, threadType: String? = nil, maxRuntime: Int64? = nil, numberOfMatches: Int? = nil, maxItineraryTime: Int? = nil, maxStopsPerVehicle: Int? = nil, averageCityTimePerMile: Int? = nil, averageFreewayTimePerMile: Int? = nil, freewayTravelDistance: Float? = nil, sameStopBuffer: Double? = nil, orderAlgorithm: OrderAlgorithm? = nil, scoreAlgorithm: ScoreAlgorithm? = nil) {
        self.debugMode = debugMode
        self.threaded = threaded
        self.threadType = threadType
        self.maxRuntime = maxRuntime
        self.numberOfMatches = numberOfMatches
        self.maxItineraryTime = maxItineraryTime
        self.maxStopsPerVehicle = maxStopsPerVehicle
        self.averageCityTimePerMile = averageCityTimePerMile
        self.averageFreewayTimePerMile = averageFreewayTimePerMile
        self.freewayTravelDistance = freewayTravelDistance
        self.sameStopBuffer = sameStopBuffer
        self.orderAlgorithm = orderAlgorithm
        self.scoreAlgorithm = scoreAlgorithm
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case debugMode
        case threaded
        case threadType
        case maxRuntime
        case numberOfMatches
        case maxItineraryTime
        case maxStopsPerVehicle
        case averageCityTimePerMile
        case averageFreewayTimePerMile
        case freewayTravelDistance
        case sameStopBuffer
        case orderAlgorithm
        case scoreAlgorithm
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(debugMode, forKey: .debugMode)
        try container.encodeIfPresent(threaded, forKey: .threaded)
        try container.encodeIfPresent(threadType, forKey: .threadType)
        try container.encodeIfPresent(maxRuntime, forKey: .maxRuntime)
        try container.encodeIfPresent(numberOfMatches, forKey: .numberOfMatches)
        try container.encodeIfPresent(maxItineraryTime, forKey: .maxItineraryTime)
        try container.encodeIfPresent(maxStopsPerVehicle, forKey: .maxStopsPerVehicle)
        try container.encodeIfPresent(averageCityTimePerMile, forKey: .averageCityTimePerMile)
        try container.encodeIfPresent(averageFreewayTimePerMile, forKey: .averageFreewayTimePerMile)
        try container.encodeIfPresent(freewayTravelDistance, forKey: .freewayTravelDistance)
        try container.encodeIfPresent(sameStopBuffer, forKey: .sameStopBuffer)
        try container.encodeIfPresent(orderAlgorithm, forKey: .orderAlgorithm)
        try container.encodeIfPresent(scoreAlgorithm, forKey: .scoreAlgorithm)
    }
}

