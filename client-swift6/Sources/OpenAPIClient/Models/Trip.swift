//
// Trip.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct Trip: Sendable, Codable, Hashable {

    public enum Preference: String, Sendable, Codable, CaseIterable {
        case drive = "DRIVE"
        case flexible = "FLEXIBLE"
        case ride = "RIDE"
    }
    public var id: Int64?
    public var active: Bool?
    public var valid: Bool?
    public var owner: Account?
    public var pickupLocation: Location?
    public var pickupTime: Date?
    public var dropOffLocation: Location?
    public var dropOffTime: Date?
    public var shipments: [Shipment]?
    public var recurrence: Recurrence?
    public var timeZone: String?
    public var route: Route?
    public var preference: Preference?
    public var notifications: String?
    public var matches: [Trip]?
    public var ownerConnection: Connection?
    public var originalId: Int64?

    public init(id: Int64? = nil, active: Bool? = nil, valid: Bool? = nil, owner: Account? = nil, pickupLocation: Location? = nil, pickupTime: Date? = nil, dropOffLocation: Location? = nil, dropOffTime: Date? = nil, shipments: [Shipment]? = nil, recurrence: Recurrence? = nil, timeZone: String? = nil, route: Route? = nil, preference: Preference? = nil, notifications: String? = nil, matches: [Trip]? = nil, ownerConnection: Connection? = nil, originalId: Int64? = nil) {
        self.id = id
        self.active = active
        self.valid = valid
        self.owner = owner
        self.pickupLocation = pickupLocation
        self.pickupTime = pickupTime
        self.dropOffLocation = dropOffLocation
        self.dropOffTime = dropOffTime
        self.shipments = shipments
        self.recurrence = recurrence
        self.timeZone = timeZone
        self.route = route
        self.preference = preference
        self.notifications = notifications
        self.matches = matches
        self.ownerConnection = ownerConnection
        self.originalId = originalId
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case active
        case valid
        case owner
        case pickupLocation
        case pickupTime
        case dropOffLocation
        case dropOffTime
        case shipments
        case recurrence
        case timeZone
        case route
        case preference
        case notifications
        case matches
        case ownerConnection
        case originalId
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(active, forKey: .active)
        try container.encodeIfPresent(valid, forKey: .valid)
        try container.encodeIfPresent(owner, forKey: .owner)
        try container.encodeIfPresent(pickupLocation, forKey: .pickupLocation)
        try container.encodeIfPresent(pickupTime, forKey: .pickupTime)
        try container.encodeIfPresent(dropOffLocation, forKey: .dropOffLocation)
        try container.encodeIfPresent(dropOffTime, forKey: .dropOffTime)
        try container.encodeIfPresent(shipments, forKey: .shipments)
        try container.encodeIfPresent(recurrence, forKey: .recurrence)
        try container.encodeIfPresent(timeZone, forKey: .timeZone)
        try container.encodeIfPresent(route, forKey: .route)
        try container.encodeIfPresent(preference, forKey: .preference)
        try container.encodeIfPresent(notifications, forKey: .notifications)
        try container.encodeIfPresent(matches, forKey: .matches)
        try container.encodeIfPresent(ownerConnection, forKey: .ownerConnection)
        try container.encodeIfPresent(originalId, forKey: .originalId)
    }
}


extension Trip: Identifiable {}
