//
// TicketResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct TicketResponse: Sendable, Codable, Hashable {

    public enum Action: String, Sendable, Codable, CaseIterable {
        case data = "DATA"
        case save = "SAVE"
        case delete = "DELETE"
        case _get = "GET"
    }
    public enum ModelType: String, Sendable, Codable, CaseIterable {
        case gameObject = "GAME_OBJECT"
        case gameLevel = "GAME_LEVEL"
        case pack = "PACK"
        case game = "GAME"
        case mission = "MISSION"
        case profile = "PROFILE"
        case application = "APPLICATION"
        case tickets = "TICKETS"
        case asset = "ASSET"
        case custom = "CUSTOM"
    }
    public enum ActionType: String, Sendable, Codable, CaseIterable {
        case completed = "COMPLETED"
        case redeemed = "REDEEMED"
        case usersPlayed = "USERS_PLAYED"
        case tournamentOwner = "TOURNAMENT_OWNER"
        case purchased = "PURCHASED"
        case sumation = "SUMATION"
        case gifted = "GIFTED"
        case refunded = "REFUNDED"
    }
    public var action: Action?
    public var id: Int64?
    public var accountId: Int64?
    public var objectId: Int64?
    public var type: ModelType?
    public var actionType: ActionType?
    public var used: Int64?
    public var count: Int64?
    public var purchaseItem: PurchaseItemShortResponse?
    public var customMessage: String?
    public var sender: AccountShortResponse?
    public var receiver: [AccountShortResponse]?
    public var customAsset: AssetShortResponse?
    public var receiptToken: String?
    public var ticketType: String?
    public var application: ApplicationShortResponse?

    public init(action: Action? = nil, id: Int64? = nil, accountId: Int64? = nil, objectId: Int64? = nil, type: ModelType? = nil, actionType: ActionType? = nil, used: Int64? = nil, count: Int64? = nil, purchaseItem: PurchaseItemShortResponse? = nil, customMessage: String? = nil, sender: AccountShortResponse? = nil, receiver: [AccountShortResponse]? = nil, customAsset: AssetShortResponse? = nil, receiptToken: String? = nil, ticketType: String? = nil, application: ApplicationShortResponse? = nil) {
        self.action = action
        self.id = id
        self.accountId = accountId
        self.objectId = objectId
        self.type = type
        self.actionType = actionType
        self.used = used
        self.count = count
        self.purchaseItem = purchaseItem
        self.customMessage = customMessage
        self.sender = sender
        self.receiver = receiver
        self.customAsset = customAsset
        self.receiptToken = receiptToken
        self.ticketType = ticketType
        self.application = application
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case action
        case id
        case accountId
        case objectId
        case type
        case actionType
        case used
        case count
        case purchaseItem
        case customMessage
        case sender
        case receiver
        case customAsset
        case receiptToken
        case ticketType
        case application
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(action, forKey: .action)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(accountId, forKey: .accountId)
        try container.encodeIfPresent(objectId, forKey: .objectId)
        try container.encodeIfPresent(type, forKey: .type)
        try container.encodeIfPresent(actionType, forKey: .actionType)
        try container.encodeIfPresent(used, forKey: .used)
        try container.encodeIfPresent(count, forKey: .count)
        try container.encodeIfPresent(purchaseItem, forKey: .purchaseItem)
        try container.encodeIfPresent(customMessage, forKey: .customMessage)
        try container.encodeIfPresent(sender, forKey: .sender)
        try container.encodeIfPresent(receiver, forKey: .receiver)
        try container.encodeIfPresent(customAsset, forKey: .customAsset)
        try container.encodeIfPresent(receiptToken, forKey: .receiptToken)
        try container.encodeIfPresent(ticketType, forKey: .ticketType)
        try container.encodeIfPresent(application, forKey: .application)
    }
}


extension TicketResponse: Identifiable {}
