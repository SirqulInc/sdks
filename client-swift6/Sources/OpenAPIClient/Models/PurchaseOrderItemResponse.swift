//
// PurchaseOrderItemResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct PurchaseOrderItemResponse: Sendable, Codable, Hashable {

    public var valid: Bool?
    public var message: String?
    public var version: Double?
    public var serializeNulls: Bool?
    public var startTimeLog: Int64?
    public var errorCode: String?
    public var request: [NameStringValueResponse]?
    public var purchaseOrderItemId: Int64?
    public var created: Int64?
    public var updated: Int64?
    public var customer: AccountShortResponse?
    public var orderItemType: String?
    public var orderItemId: Int64?
    public var orderCustomType: String?
    public var orderCustomId: String?
    public var retailerLocationId: Int64?
    public var amount: Double?
    public var tax: Double?
    public var comment: String?
    public var returning: String?

    public init(valid: Bool? = nil, message: String? = nil, version: Double? = nil, serializeNulls: Bool? = nil, startTimeLog: Int64? = nil, errorCode: String? = nil, request: [NameStringValueResponse]? = nil, purchaseOrderItemId: Int64? = nil, created: Int64? = nil, updated: Int64? = nil, customer: AccountShortResponse? = nil, orderItemType: String? = nil, orderItemId: Int64? = nil, orderCustomType: String? = nil, orderCustomId: String? = nil, retailerLocationId: Int64? = nil, amount: Double? = nil, tax: Double? = nil, comment: String? = nil, returning: String? = nil) {
        self.valid = valid
        self.message = message
        self.version = version
        self.serializeNulls = serializeNulls
        self.startTimeLog = startTimeLog
        self.errorCode = errorCode
        self.request = request
        self.purchaseOrderItemId = purchaseOrderItemId
        self.created = created
        self.updated = updated
        self.customer = customer
        self.orderItemType = orderItemType
        self.orderItemId = orderItemId
        self.orderCustomType = orderCustomType
        self.orderCustomId = orderCustomId
        self.retailerLocationId = retailerLocationId
        self.amount = amount
        self.tax = tax
        self.comment = comment
        self.returning = returning
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case valid
        case message
        case version
        case serializeNulls
        case startTimeLog
        case errorCode
        case request
        case purchaseOrderItemId
        case created
        case updated
        case customer
        case orderItemType
        case orderItemId
        case orderCustomType
        case orderCustomId
        case retailerLocationId
        case amount
        case tax
        case comment
        case returning
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(valid, forKey: .valid)
        try container.encodeIfPresent(message, forKey: .message)
        try container.encodeIfPresent(version, forKey: .version)
        try container.encodeIfPresent(serializeNulls, forKey: .serializeNulls)
        try container.encodeIfPresent(startTimeLog, forKey: .startTimeLog)
        try container.encodeIfPresent(errorCode, forKey: .errorCode)
        try container.encodeIfPresent(request, forKey: .request)
        try container.encodeIfPresent(purchaseOrderItemId, forKey: .purchaseOrderItemId)
        try container.encodeIfPresent(created, forKey: .created)
        try container.encodeIfPresent(updated, forKey: .updated)
        try container.encodeIfPresent(customer, forKey: .customer)
        try container.encodeIfPresent(orderItemType, forKey: .orderItemType)
        try container.encodeIfPresent(orderItemId, forKey: .orderItemId)
        try container.encodeIfPresent(orderCustomType, forKey: .orderCustomType)
        try container.encodeIfPresent(orderCustomId, forKey: .orderCustomId)
        try container.encodeIfPresent(retailerLocationId, forKey: .retailerLocationId)
        try container.encodeIfPresent(amount, forKey: .amount)
        try container.encodeIfPresent(tax, forKey: .tax)
        try container.encodeIfPresent(comment, forKey: .comment)
        try container.encodeIfPresent(returning, forKey: .returning)
    }
}

