//
// DisbursementResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct DisbursementResponse: Sendable, Codable, Hashable {

    public enum Status: String, Sendable, Codable, CaseIterable {
        case new = "NEW"
        case approved = "APPROVED"
        case validating = "VALIDATING"
        case error = "ERROR"
        case authorized = "AUTHORIZED"
        case captured = "CAPTURED"
        case settled = "SETTLED"
    }
    public enum Provider: String, Sendable, Codable, CaseIterable {
        case authorizeNet = "AUTHORIZE_NET"
        case amazonFps = "AMAZON_FPS"
        case billCom = "BILL_COM"
    }
    public var disbursementId: Int64?
    public var title: String?
    public var comment: String?
    public var externalId: String?
    public var introspectionParams: String?
    public var amount: Double?
    public var scheduledDate: Int64?
    public var captureDate: Int64?
    public var estimatedDate: Int64?
    public var settledDate: Int64?
    public var status: Status?
    public var provider: Provider?
    public var senderBillable: BillableEntityShortResponse?
    public var receiverBillable: BillableEntityShortResponse?
    public var errorCode: String?
    public var errorMessage: String?

    public init(disbursementId: Int64? = nil, title: String? = nil, comment: String? = nil, externalId: String? = nil, introspectionParams: String? = nil, amount: Double? = nil, scheduledDate: Int64? = nil, captureDate: Int64? = nil, estimatedDate: Int64? = nil, settledDate: Int64? = nil, status: Status? = nil, provider: Provider? = nil, senderBillable: BillableEntityShortResponse? = nil, receiverBillable: BillableEntityShortResponse? = nil, errorCode: String? = nil, errorMessage: String? = nil) {
        self.disbursementId = disbursementId
        self.title = title
        self.comment = comment
        self.externalId = externalId
        self.introspectionParams = introspectionParams
        self.amount = amount
        self.scheduledDate = scheduledDate
        self.captureDate = captureDate
        self.estimatedDate = estimatedDate
        self.settledDate = settledDate
        self.status = status
        self.provider = provider
        self.senderBillable = senderBillable
        self.receiverBillable = receiverBillable
        self.errorCode = errorCode
        self.errorMessage = errorMessage
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case disbursementId
        case title
        case comment
        case externalId
        case introspectionParams
        case amount
        case scheduledDate
        case captureDate
        case estimatedDate
        case settledDate
        case status
        case provider
        case senderBillable
        case receiverBillable
        case errorCode
        case errorMessage
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(disbursementId, forKey: .disbursementId)
        try container.encodeIfPresent(title, forKey: .title)
        try container.encodeIfPresent(comment, forKey: .comment)
        try container.encodeIfPresent(externalId, forKey: .externalId)
        try container.encodeIfPresent(introspectionParams, forKey: .introspectionParams)
        try container.encodeIfPresent(amount, forKey: .amount)
        try container.encodeIfPresent(scheduledDate, forKey: .scheduledDate)
        try container.encodeIfPresent(captureDate, forKey: .captureDate)
        try container.encodeIfPresent(estimatedDate, forKey: .estimatedDate)
        try container.encodeIfPresent(settledDate, forKey: .settledDate)
        try container.encodeIfPresent(status, forKey: .status)
        try container.encodeIfPresent(provider, forKey: .provider)
        try container.encodeIfPresent(senderBillable, forKey: .senderBillable)
        try container.encodeIfPresent(receiverBillable, forKey: .receiverBillable)
        try container.encodeIfPresent(errorCode, forKey: .errorCode)
        try container.encodeIfPresent(errorMessage, forKey: .errorMessage)
    }
}

