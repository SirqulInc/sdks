//
// ScheduledNotificationAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

open class ScheduledNotificationAPI {

    /**
     * enum for parameter visibility
     */
    public enum Visibility_createScheduledNotification: String, Sendable, CaseIterable {
        case _public = "PUBLIC"
        case _private = "PRIVATE"
        case friends = "FRIENDS"
    }

    /**
     Create Scheduled Notification
     
     - parameter version: (path)  
     - parameter accountId: (query) The logged in user. 
     - parameter name: (query) The name of the scheduled notification 
     - parameter type: (query) The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages 
     - parameter message: (query) The message to send 
     - parameter contentId: (query) The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter contentName: (query) The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter contentType: (query) The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter parentId: (query) The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter parentType: (query) The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter appKey: (query) The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     - parameter groupingId: (query) Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     - parameter connectionGroupIds: (query) The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     - parameter connectionAccountIds: (query) The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     - parameter audienceId: (query) This parameter is deprecated. The audience used to generate the list of recipients (optional)
     - parameter audienceIds: (query) The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     - parameter albumIds: (query) The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     - parameter reportId: (query) The report used to generate the the list of recipients (optional)
     - parameter reportParams: (query) The parameters to supply to the report used to generate the the list of recipients (optional)
     - parameter endpointURL: (query) The URL for making an HTTP call (optional)
     - parameter payload: (query) The parameters for making an HTTP call (optional)
     - parameter scheduledDate: (query) The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     - parameter startDate: (query) The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     - parameter endDate: (query) The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     - parameter cronExpression: (query) The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     - parameter cronType: (query) The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     - parameter metaData: (query) Additional metadata for the scheduled notification (optional)
     - parameter conditionalInput: (query) Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     - parameter templateType: (query) This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     - parameter visibility: (query) Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     - parameter active: (query) Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;. (optional)
     - parameter sendNow: (query)  (optional)
     - parameter eventType: (query) Sets the event type for the notification (optional, default to "CUSTOM")
     - parameter deepLinkURI: (query) The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     - parameter sendToAll: (query) Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: ScheduledNotificationFullResponse
     */
    open class func createScheduledNotification(version: Double, accountId: Int64, name: String, type: String, message: String, contentId: Int64? = nil, contentName: String? = nil, contentType: String? = nil, parentId: Int64? = nil, parentType: String? = nil, appKey: String? = nil, groupingId: String? = nil, connectionGroupIds: String? = nil, connectionAccountIds: String? = nil, audienceId: Int64? = nil, audienceIds: String? = nil, albumIds: String? = nil, reportId: Int64? = nil, reportParams: String? = nil, endpointURL: String? = nil, payload: String? = nil, scheduledDate: Int64? = nil, startDate: Int64? = nil, endDate: Int64? = nil, cronExpression: String? = nil, cronType: String? = nil, metaData: String? = nil, conditionalInput: String? = nil, templateType: String? = nil, visibility: Visibility_createScheduledNotification? = nil, active: Bool? = nil, sendNow: Bool? = nil, eventType: String? = nil, deepLinkURI: String? = nil, sendToAll: Bool? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> ScheduledNotificationFullResponse {
        return try await createScheduledNotificationWithRequestBuilder(version: version, accountId: accountId, name: name, type: type, message: message, contentId: contentId, contentName: contentName, contentType: contentType, parentId: parentId, parentType: parentType, appKey: appKey, groupingId: groupingId, connectionGroupIds: connectionGroupIds, connectionAccountIds: connectionAccountIds, audienceId: audienceId, audienceIds: audienceIds, albumIds: albumIds, reportId: reportId, reportParams: reportParams, endpointURL: endpointURL, payload: payload, scheduledDate: scheduledDate, startDate: startDate, endDate: endDate, cronExpression: cronExpression, cronType: cronType, metaData: metaData, conditionalInput: conditionalInput, templateType: templateType, visibility: visibility, active: active, sendNow: sendNow, eventType: eventType, deepLinkURI: deepLinkURI, sendToAll: sendToAll, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Create Scheduled Notification
     - POST /api/{version}/notification/schedule/create
     - This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods
     - parameter version: (path)  
     - parameter accountId: (query) The logged in user. 
     - parameter name: (query) The name of the scheduled notification 
     - parameter type: (query) The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages 
     - parameter message: (query) The message to send 
     - parameter contentId: (query) The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter contentName: (query) The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter contentType: (query) The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter parentId: (query) The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter parentType: (query) The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter appKey: (query) The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     - parameter groupingId: (query) Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     - parameter connectionGroupIds: (query) The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     - parameter connectionAccountIds: (query) The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     - parameter audienceId: (query) This parameter is deprecated. The audience used to generate the list of recipients (optional)
     - parameter audienceIds: (query) The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     - parameter albumIds: (query) The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     - parameter reportId: (query) The report used to generate the the list of recipients (optional)
     - parameter reportParams: (query) The parameters to supply to the report used to generate the the list of recipients (optional)
     - parameter endpointURL: (query) The URL for making an HTTP call (optional)
     - parameter payload: (query) The parameters for making an HTTP call (optional)
     - parameter scheduledDate: (query) The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     - parameter startDate: (query) The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     - parameter endDate: (query) The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     - parameter cronExpression: (query) The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     - parameter cronType: (query) The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     - parameter metaData: (query) Additional metadata for the scheduled notification (optional)
     - parameter conditionalInput: (query) Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     - parameter templateType: (query) This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     - parameter visibility: (query) Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     - parameter active: (query) Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;. (optional)
     - parameter sendNow: (query)  (optional)
     - parameter eventType: (query) Sets the event type for the notification (optional, default to "CUSTOM")
     - parameter deepLinkURI: (query) The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     - parameter sendToAll: (query) Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ScheduledNotificationFullResponse> 
     */
    open class func createScheduledNotificationWithRequestBuilder(version: Double, accountId: Int64, name: String, type: String, message: String, contentId: Int64? = nil, contentName: String? = nil, contentType: String? = nil, parentId: Int64? = nil, parentType: String? = nil, appKey: String? = nil, groupingId: String? = nil, connectionGroupIds: String? = nil, connectionAccountIds: String? = nil, audienceId: Int64? = nil, audienceIds: String? = nil, albumIds: String? = nil, reportId: Int64? = nil, reportParams: String? = nil, endpointURL: String? = nil, payload: String? = nil, scheduledDate: Int64? = nil, startDate: Int64? = nil, endDate: Int64? = nil, cronExpression: String? = nil, cronType: String? = nil, metaData: String? = nil, conditionalInput: String? = nil, templateType: String? = nil, visibility: Visibility_createScheduledNotification? = nil, active: Bool? = nil, sendNow: Bool? = nil, eventType: String? = nil, deepLinkURI: String? = nil, sendToAll: Bool? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<ScheduledNotificationFullResponse> {
        var localVariablePath = "/api/{version}/notification/schedule/create"
        let versionPreEscape = "\(APIHelper.mapValueToPathItem(version))"
        let versionPostEscape = versionPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{version}", with: versionPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "accountId": (wrappedValue: accountId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "name": (wrappedValue: name.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "type": (wrappedValue: type.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "message": (wrappedValue: message.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "contentId": (wrappedValue: contentId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "contentName": (wrappedValue: contentName?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "contentType": (wrappedValue: contentType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "parentId": (wrappedValue: parentId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "parentType": (wrappedValue: parentType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "appKey": (wrappedValue: appKey?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "groupingId": (wrappedValue: groupingId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "connectionGroupIds": (wrappedValue: connectionGroupIds?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "connectionAccountIds": (wrappedValue: connectionAccountIds?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "audienceId": (wrappedValue: audienceId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "audienceIds": (wrappedValue: audienceIds?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "albumIds": (wrappedValue: albumIds?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "reportId": (wrappedValue: reportId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "reportParams": (wrappedValue: reportParams?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "endpointURL": (wrappedValue: endpointURL?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "payload": (wrappedValue: payload?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "scheduledDate": (wrappedValue: scheduledDate?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "startDate": (wrappedValue: startDate?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "endDate": (wrappedValue: endDate?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "cronExpression": (wrappedValue: cronExpression?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "cronType": (wrappedValue: cronType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "metaData": (wrappedValue: metaData?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "conditionalInput": (wrappedValue: conditionalInput?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "templateType": (wrappedValue: templateType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "visibility": (wrappedValue: visibility?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "active": (wrappedValue: active?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sendNow": (wrappedValue: sendNow?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "eventType": (wrappedValue: eventType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "deepLinkURI": (wrappedValue: deepLinkURI?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sendToAll": (wrappedValue: sendToAll?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ScheduledNotificationFullResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     Delete Scheduled Notification
     
     - parameter version: (path)  
     - parameter accountId: (query) the id of the logged in user 
     - parameter scheduledNotificationId: (query) the id of the scheduled notification to delete 
     - parameter deleteByGroupingId: (query) If set to true, also deletes Scheduled Notifications under the same account with the same groupingId. (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: ScheduledNotificationFullResponse
     */
    open class func deleteScheduledNotification(version: Double, accountId: Int64, scheduledNotificationId: Int64, deleteByGroupingId: Bool? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> ScheduledNotificationFullResponse {
        return try await deleteScheduledNotificationWithRequestBuilder(version: version, accountId: accountId, scheduledNotificationId: scheduledNotificationId, deleteByGroupingId: deleteByGroupingId, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Delete Scheduled Notification
     - POST /api/{version}/notification/schedule/delete
     - This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.
     - parameter version: (path)  
     - parameter accountId: (query) the id of the logged in user 
     - parameter scheduledNotificationId: (query) the id of the scheduled notification to delete 
     - parameter deleteByGroupingId: (query) If set to true, also deletes Scheduled Notifications under the same account with the same groupingId. (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ScheduledNotificationFullResponse> 
     */
    open class func deleteScheduledNotificationWithRequestBuilder(version: Double, accountId: Int64, scheduledNotificationId: Int64, deleteByGroupingId: Bool? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<ScheduledNotificationFullResponse> {
        var localVariablePath = "/api/{version}/notification/schedule/delete"
        let versionPreEscape = "\(APIHelper.mapValueToPathItem(version))"
        let versionPostEscape = versionPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{version}", with: versionPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "accountId": (wrappedValue: accountId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "scheduledNotificationId": (wrappedValue: scheduledNotificationId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "deleteByGroupingId": (wrappedValue: deleteByGroupingId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ScheduledNotificationFullResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     Get Scheduled Notification
     
     - parameter version: (path)  
     - parameter accountId: (query) the id of the account logged in 
     - parameter scheduledNotificationId: (query) the id of the scheduled notification to get 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: ScheduledNotificationFullResponse
     */
    open class func getScheduledNotification(version: Double, accountId: Int64, scheduledNotificationId: Int64, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> ScheduledNotificationFullResponse {
        return try await getScheduledNotificationWithRequestBuilder(version: version, accountId: accountId, scheduledNotificationId: scheduledNotificationId, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Get Scheduled Notification
     - GET /api/{version}/notification/schedule/get
     - Get a ScheduledNotification
     - parameter version: (path)  
     - parameter accountId: (query) the id of the account logged in 
     - parameter scheduledNotificationId: (query) the id of the scheduled notification to get 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ScheduledNotificationFullResponse> 
     */
    open class func getScheduledNotificationWithRequestBuilder(version: Double, accountId: Int64, scheduledNotificationId: Int64, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<ScheduledNotificationFullResponse> {
        var localVariablePath = "/api/{version}/notification/schedule/get"
        let versionPreEscape = "\(APIHelper.mapValueToPathItem(version))"
        let versionPostEscape = versionPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{version}", with: versionPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "accountId": (wrappedValue: accountId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "scheduledNotificationId": (wrappedValue: scheduledNotificationId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ScheduledNotificationFullResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     Generate Schedule Notifications
     
     - parameter version: (path)  
     - parameter accountId: (query) The logged in user. 
     - parameter appKey: (query) The application to target 
     - parameter reportName: (query) The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail 
     - parameter message: (query) The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in 
     - parameter offset: (query) Time in munites before the event starts to notify recipients 
     - parameter recipientReportId: (query) The report id used to generate the recipient list 
     - parameter reportParams: (query) The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)
     - parameter type: (query) The type of scheduled notification; supported values are: MOBILE_NOTIFICATION (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: SirqulResponse
     */
    open class func scheduleNotificationListings(version: Double, accountId: Int64, appKey: String, reportName: String, message: String, offset: Int, recipientReportId: Int64, reportParams: String? = nil, type: String? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> SirqulResponse {
        return try await scheduleNotificationListingsWithRequestBuilder(version: version, accountId: accountId, appKey: appKey, reportName: reportName, message: message, offset: offset, recipientReportId: recipientReportId, reportParams: reportParams, type: type, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Generate Schedule Notifications
     - POST /api/{version}/notification/schedule/generate
     - Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.
     - parameter version: (path)  
     - parameter accountId: (query) The logged in user. 
     - parameter appKey: (query) The application to target 
     - parameter reportName: (query) The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail 
     - parameter message: (query) The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in 
     - parameter offset: (query) Time in munites before the event starts to notify recipients 
     - parameter recipientReportId: (query) The report id used to generate the recipient list 
     - parameter reportParams: (query) The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)
     - parameter type: (query) The type of scheduled notification; supported values are: MOBILE_NOTIFICATION (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<SirqulResponse> 
     */
    open class func scheduleNotificationListingsWithRequestBuilder(version: Double, accountId: Int64, appKey: String, reportName: String, message: String, offset: Int, recipientReportId: Int64, reportParams: String? = nil, type: String? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<SirqulResponse> {
        var localVariablePath = "/api/{version}/notification/schedule/generate"
        let versionPreEscape = "\(APIHelper.mapValueToPathItem(version))"
        let versionPostEscape = versionPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{version}", with: versionPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "accountId": (wrappedValue: accountId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "appKey": (wrappedValue: appKey.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "reportName": (wrappedValue: reportName.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "reportParams": (wrappedValue: reportParams?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "message": (wrappedValue: message.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "offset": (wrappedValue: offset.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "type": (wrappedValue: type?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "recipientReportId": (wrappedValue: recipientReportId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<SirqulResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     Search Scheduled Notifications
     
     - parameter version: (path)  
     - parameter accountId: (query) The logged in user. 
     - parameter groupingId: (query) Filter results by a grouping identifier defined by the client (optional)
     - parameter audienceId: (query) Filter results by audience (optional)
     - parameter filter: (query) a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications. (optional)
     - parameter types: (query) Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION (optional)
     - parameter contentIds: (query) search using content IDs (optional)
     - parameter contentTypes: (query) search using content types (optional)
     - parameter parentIds: (query) search using parent IDs (optional)
     - parameter parentTypes: (query) search using parent types (optional)
     - parameter statuses: (query) Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending (optional)
     - parameter templateTypes: (query)  (optional)
     - parameter appKey: (query) Filter the list by a specific application (optional)
     - parameter keyword: (query) Keyword search on the scheduled notification names. (optional)
     - parameter sortField: (query) The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date (optional)
     - parameter descending: (query) Determines whether the sorted list is in descending or ascending order (optional)
     - parameter start: (query) Start the result set at some index. (optional)
     - parameter limit: (query) Limit the result to some number. (optional)
     - parameter activeOnly: (query) Determines whether to return only active results (optional)
     - parameter groupByGroupingId: (query) Determines whether to group results with the same groupingId together. (optional)
     - parameter returnAudienceAccountCount: (query) If true, include audience account counts in the response (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: ScheduledNotificationFullResponse
     */
    open class func searchScheduledNotifications(version: Double, accountId: Int64, groupingId: String? = nil, audienceId: Int64? = nil, filter: String? = nil, types: String? = nil, contentIds: String? = nil, contentTypes: String? = nil, parentIds: String? = nil, parentTypes: String? = nil, statuses: String? = nil, templateTypes: String? = nil, appKey: String? = nil, keyword: String? = nil, sortField: String? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil, activeOnly: Bool? = nil, groupByGroupingId: Bool? = nil, returnAudienceAccountCount: Bool? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> ScheduledNotificationFullResponse {
        return try await searchScheduledNotificationsWithRequestBuilder(version: version, accountId: accountId, groupingId: groupingId, audienceId: audienceId, filter: filter, types: types, contentIds: contentIds, contentTypes: contentTypes, parentIds: parentIds, parentTypes: parentTypes, statuses: statuses, templateTypes: templateTypes, appKey: appKey, keyword: keyword, sortField: sortField, descending: descending, start: start, limit: limit, activeOnly: activeOnly, groupByGroupingId: groupByGroupingId, returnAudienceAccountCount: returnAudienceAccountCount, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Search Scheduled Notifications
     - GET /api/{version}/notification/schedule/search
     - This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.
     - parameter version: (path)  
     - parameter accountId: (query) The logged in user. 
     - parameter groupingId: (query) Filter results by a grouping identifier defined by the client (optional)
     - parameter audienceId: (query) Filter results by audience (optional)
     - parameter filter: (query) a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications. (optional)
     - parameter types: (query) Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION (optional)
     - parameter contentIds: (query) search using content IDs (optional)
     - parameter contentTypes: (query) search using content types (optional)
     - parameter parentIds: (query) search using parent IDs (optional)
     - parameter parentTypes: (query) search using parent types (optional)
     - parameter statuses: (query) Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending (optional)
     - parameter templateTypes: (query)  (optional)
     - parameter appKey: (query) Filter the list by a specific application (optional)
     - parameter keyword: (query) Keyword search on the scheduled notification names. (optional)
     - parameter sortField: (query) The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date (optional)
     - parameter descending: (query) Determines whether the sorted list is in descending or ascending order (optional)
     - parameter start: (query) Start the result set at some index. (optional)
     - parameter limit: (query) Limit the result to some number. (optional)
     - parameter activeOnly: (query) Determines whether to return only active results (optional)
     - parameter groupByGroupingId: (query) Determines whether to group results with the same groupingId together. (optional)
     - parameter returnAudienceAccountCount: (query) If true, include audience account counts in the response (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ScheduledNotificationFullResponse> 
     */
    open class func searchScheduledNotificationsWithRequestBuilder(version: Double, accountId: Int64, groupingId: String? = nil, audienceId: Int64? = nil, filter: String? = nil, types: String? = nil, contentIds: String? = nil, contentTypes: String? = nil, parentIds: String? = nil, parentTypes: String? = nil, statuses: String? = nil, templateTypes: String? = nil, appKey: String? = nil, keyword: String? = nil, sortField: String? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil, activeOnly: Bool? = nil, groupByGroupingId: Bool? = nil, returnAudienceAccountCount: Bool? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<ScheduledNotificationFullResponse> {
        var localVariablePath = "/api/{version}/notification/schedule/search"
        let versionPreEscape = "\(APIHelper.mapValueToPathItem(version))"
        let versionPostEscape = versionPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{version}", with: versionPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "accountId": (wrappedValue: accountId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "groupingId": (wrappedValue: groupingId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "audienceId": (wrappedValue: audienceId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "filter": (wrappedValue: filter?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "types": (wrappedValue: types?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "contentIds": (wrappedValue: contentIds?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "contentTypes": (wrappedValue: contentTypes?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "parentIds": (wrappedValue: parentIds?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "parentTypes": (wrappedValue: parentTypes?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "statuses": (wrappedValue: statuses?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "templateTypes": (wrappedValue: templateTypes?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "appKey": (wrappedValue: appKey?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "keyword": (wrappedValue: keyword?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sortField": (wrappedValue: sortField?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "descending": (wrappedValue: descending?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "start": (wrappedValue: start?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "limit": (wrappedValue: limit?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "activeOnly": (wrappedValue: activeOnly?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "groupByGroupingId": (wrappedValue: groupByGroupingId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "returnAudienceAccountCount": (wrappedValue: returnAudienceAccountCount?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ScheduledNotificationFullResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter visibility
     */
    public enum Visibility_updateScheduledNotification: String, Sendable, CaseIterable {
        case _public = "PUBLIC"
        case _private = "PRIVATE"
        case friends = "FRIENDS"
    }

    /**
     Update Scheduled Notification
     
     - parameter version: (path)  
     - parameter scheduledNotificationId: (query) The id of scheduled notification to update 
     - parameter accountId: (query) The logged in user. 
     - parameter name: (query) The name of the scheduled notification (optional)
     - parameter type: (query) The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (optional)
     - parameter message: (query) The message to send (optional)
     - parameter payload: (query) The parameters for making an HTTP call (optional)
     - parameter contentId: (query) The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter contentName: (query) The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter contentType: (query) The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter parentId: (query) The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter parentType: (query) The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter appKey: (query) The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     - parameter groupingId: (query) Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     - parameter connectionGroupIds: (query) The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     - parameter connectionAccountIds: (query) The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     - parameter audienceId: (query) This parameter is deprecated. The audience used to generate the list of recipients (optional)
     - parameter audienceIds: (query) The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     - parameter albumIds: (query) The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     - parameter reportId: (query) The report used to generate the the list of recipients (optional)
     - parameter reportParams: (query) The parameters to supply to the report used to generate the the list of recipients (optional)
     - parameter endpointURL: (query) The URL for making an HTTP call (optional)
     - parameter scheduledDate: (query) The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     - parameter startDate: (query) The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     - parameter endDate: (query) The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     - parameter cronExpression: (query) The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     - parameter cronType: (query) The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     - parameter metaData: (query) Additional metadata for the scheduled notification (optional)
     - parameter conditionalInput: (query) Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     - parameter templateType: (query) This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     - parameter visibility: (query) Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     - parameter active: (query) Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. (optional)
     - parameter errorMessage: (query) the error message associated with the scheduled notification (optional)
     - parameter status: (query) the status of the scheduled notification (optional)
     - parameter updateByGroupingId: (query) also updates ScheduledNotifications with the same groupingId and account (optional)
     - parameter sendNow: (query) whether to send the scheduled notification now or not (optional)
     - parameter eventType: (query) Sets the event type for the notification (optional, default to "CUSTOM")
     - parameter deepLinkURI: (query) The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     - parameter sendToAll: (query) Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: ScheduledNotificationFullResponse
     */
    open class func updateScheduledNotification(version: Double, scheduledNotificationId: Int64, accountId: Int64, name: String? = nil, type: String? = nil, message: String? = nil, payload: String? = nil, contentId: Int64? = nil, contentName: String? = nil, contentType: String? = nil, parentId: Int64? = nil, parentType: String? = nil, appKey: String? = nil, groupingId: String? = nil, connectionGroupIds: String? = nil, connectionAccountIds: String? = nil, audienceId: Int64? = nil, audienceIds: String? = nil, albumIds: String? = nil, reportId: Int64? = nil, reportParams: String? = nil, endpointURL: String? = nil, scheduledDate: Int64? = nil, startDate: Int64? = nil, endDate: Int64? = nil, cronExpression: String? = nil, cronType: String? = nil, metaData: String? = nil, conditionalInput: String? = nil, templateType: String? = nil, visibility: Visibility_updateScheduledNotification? = nil, active: Bool? = nil, errorMessage: String? = nil, status: String? = nil, updateByGroupingId: Bool? = nil, sendNow: Bool? = nil, eventType: String? = nil, deepLinkURI: String? = nil, sendToAll: Bool? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> ScheduledNotificationFullResponse {
        return try await updateScheduledNotificationWithRequestBuilder(version: version, scheduledNotificationId: scheduledNotificationId, accountId: accountId, name: name, type: type, message: message, payload: payload, contentId: contentId, contentName: contentName, contentType: contentType, parentId: parentId, parentType: parentType, appKey: appKey, groupingId: groupingId, connectionGroupIds: connectionGroupIds, connectionAccountIds: connectionAccountIds, audienceId: audienceId, audienceIds: audienceIds, albumIds: albumIds, reportId: reportId, reportParams: reportParams, endpointURL: endpointURL, scheduledDate: scheduledDate, startDate: startDate, endDate: endDate, cronExpression: cronExpression, cronType: cronType, metaData: metaData, conditionalInput: conditionalInput, templateType: templateType, visibility: visibility, active: active, errorMessage: errorMessage, status: status, updateByGroupingId: updateByGroupingId, sendNow: sendNow, eventType: eventType, deepLinkURI: deepLinkURI, sendToAll: sendToAll, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Update Scheduled Notification
     - POST /api/{version}/notification/schedule/update
     - This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.
     - parameter version: (path)  
     - parameter scheduledNotificationId: (query) The id of scheduled notification to update 
     - parameter accountId: (query) The logged in user. 
     - parameter name: (query) The name of the scheduled notification (optional)
     - parameter type: (query) The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (optional)
     - parameter message: (query) The message to send (optional)
     - parameter payload: (query) The parameters for making an HTTP call (optional)
     - parameter contentId: (query) The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter contentName: (query) The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter contentType: (query) The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter parentId: (query) The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter parentType: (query) The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     - parameter appKey: (query) The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     - parameter groupingId: (query) Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     - parameter connectionGroupIds: (query) The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     - parameter connectionAccountIds: (query) The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     - parameter audienceId: (query) This parameter is deprecated. The audience used to generate the list of recipients (optional)
     - parameter audienceIds: (query) The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     - parameter albumIds: (query) The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     - parameter reportId: (query) The report used to generate the the list of recipients (optional)
     - parameter reportParams: (query) The parameters to supply to the report used to generate the the list of recipients (optional)
     - parameter endpointURL: (query) The URL for making an HTTP call (optional)
     - parameter scheduledDate: (query) The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     - parameter startDate: (query) The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     - parameter endDate: (query) The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     - parameter cronExpression: (query) The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     - parameter cronType: (query) The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     - parameter metaData: (query) Additional metadata for the scheduled notification (optional)
     - parameter conditionalInput: (query) Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     - parameter templateType: (query) This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     - parameter visibility: (query) Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     - parameter active: (query) Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. (optional)
     - parameter errorMessage: (query) the error message associated with the scheduled notification (optional)
     - parameter status: (query) the status of the scheduled notification (optional)
     - parameter updateByGroupingId: (query) also updates ScheduledNotifications with the same groupingId and account (optional)
     - parameter sendNow: (query) whether to send the scheduled notification now or not (optional)
     - parameter eventType: (query) Sets the event type for the notification (optional, default to "CUSTOM")
     - parameter deepLinkURI: (query) The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     - parameter sendToAll: (query) Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ScheduledNotificationFullResponse> 
     */
    open class func updateScheduledNotificationWithRequestBuilder(version: Double, scheduledNotificationId: Int64, accountId: Int64, name: String? = nil, type: String? = nil, message: String? = nil, payload: String? = nil, contentId: Int64? = nil, contentName: String? = nil, contentType: String? = nil, parentId: Int64? = nil, parentType: String? = nil, appKey: String? = nil, groupingId: String? = nil, connectionGroupIds: String? = nil, connectionAccountIds: String? = nil, audienceId: Int64? = nil, audienceIds: String? = nil, albumIds: String? = nil, reportId: Int64? = nil, reportParams: String? = nil, endpointURL: String? = nil, scheduledDate: Int64? = nil, startDate: Int64? = nil, endDate: Int64? = nil, cronExpression: String? = nil, cronType: String? = nil, metaData: String? = nil, conditionalInput: String? = nil, templateType: String? = nil, visibility: Visibility_updateScheduledNotification? = nil, active: Bool? = nil, errorMessage: String? = nil, status: String? = nil, updateByGroupingId: Bool? = nil, sendNow: Bool? = nil, eventType: String? = nil, deepLinkURI: String? = nil, sendToAll: Bool? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<ScheduledNotificationFullResponse> {
        var localVariablePath = "/api/{version}/notification/schedule/update"
        let versionPreEscape = "\(APIHelper.mapValueToPathItem(version))"
        let versionPostEscape = versionPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{version}", with: versionPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "scheduledNotificationId": (wrappedValue: scheduledNotificationId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "accountId": (wrappedValue: accountId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "name": (wrappedValue: name?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "type": (wrappedValue: type?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "message": (wrappedValue: message?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "payload": (wrappedValue: payload?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "contentId": (wrappedValue: contentId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "contentName": (wrappedValue: contentName?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "contentType": (wrappedValue: contentType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "parentId": (wrappedValue: parentId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "parentType": (wrappedValue: parentType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "appKey": (wrappedValue: appKey?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "groupingId": (wrappedValue: groupingId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "connectionGroupIds": (wrappedValue: connectionGroupIds?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "connectionAccountIds": (wrappedValue: connectionAccountIds?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "audienceId": (wrappedValue: audienceId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "audienceIds": (wrappedValue: audienceIds?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "albumIds": (wrappedValue: albumIds?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "reportId": (wrappedValue: reportId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "reportParams": (wrappedValue: reportParams?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "endpointURL": (wrappedValue: endpointURL?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "scheduledDate": (wrappedValue: scheduledDate?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "startDate": (wrappedValue: startDate?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "endDate": (wrappedValue: endDate?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "cronExpression": (wrappedValue: cronExpression?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "cronType": (wrappedValue: cronType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "metaData": (wrappedValue: metaData?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "conditionalInput": (wrappedValue: conditionalInput?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "templateType": (wrappedValue: templateType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "visibility": (wrappedValue: visibility?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "active": (wrappedValue: active?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "errorMessage": (wrappedValue: errorMessage?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "status": (wrappedValue: status?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "updateByGroupingId": (wrappedValue: updateByGroupingId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sendNow": (wrappedValue: sendNow?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "eventType": (wrappedValue: eventType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "deepLinkURI": (wrappedValue: deepLinkURI?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sendToAll": (wrappedValue: sendToAll?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ScheduledNotificationFullResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }
}
