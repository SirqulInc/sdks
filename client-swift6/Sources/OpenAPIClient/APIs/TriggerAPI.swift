//
// TriggerAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

open class TriggerAPI {

    /**
     * enum for parameter visibility
     */
    public enum Visibility_createTrigger: String, Sendable, CaseIterable {
        case _public = "PUBLIC"
        case _private = "PRIVATE"
        case friends = "FRIENDS"
    }

    /**
     Create Trigger
     
     - parameter accountId: (query) The logged in user 
     - parameter name: (query) The name of the trigger 
     - parameter appKey: (query) The application to target (optional)
     - parameter groupingId: (query) Client defined identifier for grouping triggers (optional)
     - parameter endpointURL: (query) The URL for making an HTTP call (optional)
     - parameter payload: (query) The parameters for making an HTTP call (optional)
     - parameter scheduledDate: (query) The date and time of the next trigger (optional)
     - parameter startDate: (query) The starting date of the trigger (optional)
     - parameter endDate: (query) The ending date of the trigger (optional)
     - parameter cronExpression: (query) The cron expression that represents the trigger&#39;s schedule (optional)
     - parameter conditionalInput: (query) Json input representing conditional logic that has to be met before running the trigger (optional)
     - parameter visibility: (query) The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     - parameter active: (query) Sets whether the Trigger is active or not (inactive Triggers are not processed) (optional, default to true)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: TriggerResponse
     */
    open class func createTrigger(accountId: Int64, name: String, appKey: String? = nil, groupingId: String? = nil, endpointURL: String? = nil, payload: String? = nil, scheduledDate: Int64? = nil, startDate: Int64? = nil, endDate: Int64? = nil, cronExpression: String? = nil, conditionalInput: String? = nil, visibility: Visibility_createTrigger? = nil, active: Bool? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> TriggerResponse {
        return try await createTriggerWithRequestBuilder(accountId: accountId, name: name, appKey: appKey, groupingId: groupingId, endpointURL: endpointURL, payload: payload, scheduledDate: scheduledDate, startDate: startDate, endDate: endDate, cronExpression: cronExpression, conditionalInput: conditionalInput, visibility: visibility, active: active, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Create Trigger
     - POST /trigger/create
     - Create a trigger
     - parameter accountId: (query) The logged in user 
     - parameter name: (query) The name of the trigger 
     - parameter appKey: (query) The application to target (optional)
     - parameter groupingId: (query) Client defined identifier for grouping triggers (optional)
     - parameter endpointURL: (query) The URL for making an HTTP call (optional)
     - parameter payload: (query) The parameters for making an HTTP call (optional)
     - parameter scheduledDate: (query) The date and time of the next trigger (optional)
     - parameter startDate: (query) The starting date of the trigger (optional)
     - parameter endDate: (query) The ending date of the trigger (optional)
     - parameter cronExpression: (query) The cron expression that represents the trigger&#39;s schedule (optional)
     - parameter conditionalInput: (query) Json input representing conditional logic that has to be met before running the trigger (optional)
     - parameter visibility: (query) The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     - parameter active: (query) Sets whether the Trigger is active or not (inactive Triggers are not processed) (optional, default to true)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<TriggerResponse> 
     */
    open class func createTriggerWithRequestBuilder(accountId: Int64, name: String, appKey: String? = nil, groupingId: String? = nil, endpointURL: String? = nil, payload: String? = nil, scheduledDate: Int64? = nil, startDate: Int64? = nil, endDate: Int64? = nil, cronExpression: String? = nil, conditionalInput: String? = nil, visibility: Visibility_createTrigger? = nil, active: Bool? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<TriggerResponse> {
        let localVariablePath = "/trigger/create"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "accountId": (wrappedValue: accountId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "name": (wrappedValue: name.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "appKey": (wrappedValue: appKey?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "groupingId": (wrappedValue: groupingId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "endpointURL": (wrappedValue: endpointURL?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "payload": (wrappedValue: payload?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "scheduledDate": (wrappedValue: scheduledDate?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "startDate": (wrappedValue: startDate?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "endDate": (wrappedValue: endDate?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "cronExpression": (wrappedValue: cronExpression?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "conditionalInput": (wrappedValue: conditionalInput?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "visibility": (wrappedValue: visibility?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "active": (wrappedValue: active?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<TriggerResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     Delete Trigger
     
     - parameter accountId: (query) The logged in user. 
     - parameter triggerId: (query) The id of the trigger to delete. 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: SirqulResponse
     */
    open class func deleteTrigger(accountId: Int64, triggerId: Int64, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> SirqulResponse {
        return try await deleteTriggerWithRequestBuilder(accountId: accountId, triggerId: triggerId, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Delete Trigger
     - POST /trigger/delete
     - Mark a trigger as deleted.
     - parameter accountId: (query) The logged in user. 
     - parameter triggerId: (query) The id of the trigger to delete. 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<SirqulResponse> 
     */
    open class func deleteTriggerWithRequestBuilder(accountId: Int64, triggerId: Int64, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<SirqulResponse> {
        let localVariablePath = "/trigger/delete"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "accountId": (wrappedValue: accountId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "triggerId": (wrappedValue: triggerId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<SirqulResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     Get Trigger
     
     - parameter accountId: (query) The logged in user. 
     - parameter triggerId: (query) The id of the Trigger to return. 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: TriggerResponse
     */
    open class func getTrigger(accountId: Int64, triggerId: Int64, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> TriggerResponse {
        return try await getTriggerWithRequestBuilder(accountId: accountId, triggerId: triggerId, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Get Trigger
     - GET /trigger/get
     - Get a trigger
     - parameter accountId: (query) The logged in user. 
     - parameter triggerId: (query) The id of the Trigger to return. 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<TriggerResponse> 
     */
    open class func getTriggerWithRequestBuilder(accountId: Int64, triggerId: Int64, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<TriggerResponse> {
        let localVariablePath = "/trigger/get"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "accountId": (wrappedValue: accountId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "triggerId": (wrappedValue: triggerId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<TriggerResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     Search Triggers
     
     - parameter accountId: (query) The logged in user. 
     - parameter groupingId: (query) Filter results by a grouping identifier defined by the client (optional)
     - parameter filter: (query) A comma separated list of filters. * MINE - Return triggers that the user has created * SHARED - Return triggers that have been shared to the user * FOLLOWER - Return triggers that have been created by the user&#39;&#39;s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return triggers that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC triggers that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC triggers regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all triggers that the user has liked * FEATURED - Return all triggers that have been featured * PENDING - Return all pending triggers  (optional, default to "MINE")
     - parameter statuses: (query) Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE (optional, default to "NEW,ERROR,COMPLETE,PROCESSING")
     - parameter templateTypes: (query) Template Types (optional)
     - parameter appKey: (query) Filter the list by a specific application (optional)
     - parameter keyword: (query) Keyword search on the trigger names. (optional)
     - parameter sortField: (query) The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE (optional, default to "CREATED")
     - parameter descending: (query) Determines whether the sorted list is in descending or ascending order (optional, default to true)
     - parameter start: (query) Start the result set at some index. (optional, default to 0)
     - parameter limit: (query) Limit the result to some number. (optional, default to 20)
     - parameter activeOnly: (query) Determines whether to return only active results (optional, default to true)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: [TriggerResponse]
     */
    open class func searchTriggers(accountId: Int64, groupingId: String? = nil, filter: String? = nil, statuses: String? = nil, templateTypes: String? = nil, appKey: String? = nil, keyword: String? = nil, sortField: String? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil, activeOnly: Bool? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> [TriggerResponse] {
        return try await searchTriggersWithRequestBuilder(accountId: accountId, groupingId: groupingId, filter: filter, statuses: statuses, templateTypes: templateTypes, appKey: appKey, keyword: keyword, sortField: sortField, descending: descending, start: start, limit: limit, activeOnly: activeOnly, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Search Triggers
     - GET /trigger/search
     - Search for triggers
     - parameter accountId: (query) The logged in user. 
     - parameter groupingId: (query) Filter results by a grouping identifier defined by the client (optional)
     - parameter filter: (query) A comma separated list of filters. * MINE - Return triggers that the user has created * SHARED - Return triggers that have been shared to the user * FOLLOWER - Return triggers that have been created by the user&#39;&#39;s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return triggers that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC triggers that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC triggers regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all triggers that the user has liked * FEATURED - Return all triggers that have been featured * PENDING - Return all pending triggers  (optional, default to "MINE")
     - parameter statuses: (query) Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE (optional, default to "NEW,ERROR,COMPLETE,PROCESSING")
     - parameter templateTypes: (query) Template Types (optional)
     - parameter appKey: (query) Filter the list by a specific application (optional)
     - parameter keyword: (query) Keyword search on the trigger names. (optional)
     - parameter sortField: (query) The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE (optional, default to "CREATED")
     - parameter descending: (query) Determines whether the sorted list is in descending or ascending order (optional, default to true)
     - parameter start: (query) Start the result set at some index. (optional, default to 0)
     - parameter limit: (query) Limit the result to some number. (optional, default to 20)
     - parameter activeOnly: (query) Determines whether to return only active results (optional, default to true)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<[TriggerResponse]> 
     */
    open class func searchTriggersWithRequestBuilder(accountId: Int64, groupingId: String? = nil, filter: String? = nil, statuses: String? = nil, templateTypes: String? = nil, appKey: String? = nil, keyword: String? = nil, sortField: String? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil, activeOnly: Bool? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<[TriggerResponse]> {
        let localVariablePath = "/trigger/search"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "accountId": (wrappedValue: accountId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "groupingId": (wrappedValue: groupingId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "filter": (wrappedValue: filter?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "statuses": (wrappedValue: statuses?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "templateTypes": (wrappedValue: templateTypes?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "appKey": (wrappedValue: appKey?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "keyword": (wrappedValue: keyword?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sortField": (wrappedValue: sortField?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "descending": (wrappedValue: descending?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "start": (wrappedValue: start?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "limit": (wrappedValue: limit?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "activeOnly": (wrappedValue: activeOnly?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[TriggerResponse]>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter visibility
     */
    public enum Visibility_updateTrigger: String, Sendable, CaseIterable {
        case _public = "PUBLIC"
        case _private = "PRIVATE"
        case friends = "FRIENDS"
    }

    /**
     Update Trigger
     
     - parameter triggerId: (query) The trigger to update 
     - parameter accountId: (query) The logged in user 
     - parameter name: (query) The name of the trigger (optional)
     - parameter appKey: (query) The application to target (optional)
     - parameter groupingId: (query) Client defined identifier for grouping triggers (optional)
     - parameter endpointURL: (query) The URL for making an HTTP call (optional)
     - parameter payload: (query) The parameters for making an HTTP call (optional)
     - parameter scheduledDate: (query) The date and time of the next trigger (optional)
     - parameter startDate: (query) The starting date of the trigger (optional)
     - parameter endDate: (query) The ending date of the trigger (optional)
     - parameter cronExpression: (query) The cron expression that represents the trigger&#39;s schedule (optional)
     - parameter conditionalInput: (query) Json input representing conditional logic that has to be met before running the trigger (optional)
     - parameter visibility: (query) The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     - parameter active: (query) Sets whether the Trigger is active or not (inactive Triggers are not processed) (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: TriggerResponse
     */
    open class func updateTrigger(triggerId: Int64, accountId: Int64, name: String? = nil, appKey: String? = nil, groupingId: String? = nil, endpointURL: String? = nil, payload: String? = nil, scheduledDate: Int64? = nil, startDate: Int64? = nil, endDate: Int64? = nil, cronExpression: String? = nil, conditionalInput: String? = nil, visibility: Visibility_updateTrigger? = nil, active: Bool? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) async throws(ErrorResponse) -> TriggerResponse {
        return try await updateTriggerWithRequestBuilder(triggerId: triggerId, accountId: accountId, name: name, appKey: appKey, groupingId: groupingId, endpointURL: endpointURL, payload: payload, scheduledDate: scheduledDate, startDate: startDate, endDate: endDate, cronExpression: cronExpression, conditionalInput: conditionalInput, visibility: visibility, active: active, apiConfiguration: apiConfiguration).execute().body
    }

    /**
     Update Trigger
     - POST /trigger/update
     - Update a trigger
     - parameter triggerId: (query) The trigger to update 
     - parameter accountId: (query) The logged in user 
     - parameter name: (query) The name of the trigger (optional)
     - parameter appKey: (query) The application to target (optional)
     - parameter groupingId: (query) Client defined identifier for grouping triggers (optional)
     - parameter endpointURL: (query) The URL for making an HTTP call (optional)
     - parameter payload: (query) The parameters for making an HTTP call (optional)
     - parameter scheduledDate: (query) The date and time of the next trigger (optional)
     - parameter startDate: (query) The starting date of the trigger (optional)
     - parameter endDate: (query) The ending date of the trigger (optional)
     - parameter cronExpression: (query) The cron expression that represents the trigger&#39;s schedule (optional)
     - parameter conditionalInput: (query) Json input representing conditional logic that has to be met before running the trigger (optional)
     - parameter visibility: (query) The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     - parameter active: (query) Sets whether the Trigger is active or not (inactive Triggers are not processed) (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<TriggerResponse> 
     */
    open class func updateTriggerWithRequestBuilder(triggerId: Int64, accountId: Int64, name: String? = nil, appKey: String? = nil, groupingId: String? = nil, endpointURL: String? = nil, payload: String? = nil, scheduledDate: Int64? = nil, startDate: Int64? = nil, endDate: Int64? = nil, cronExpression: String? = nil, conditionalInput: String? = nil, visibility: Visibility_updateTrigger? = nil, active: Bool? = nil, apiConfiguration: OpenAPIClientAPIConfiguration = OpenAPIClientAPIConfiguration.shared) -> RequestBuilder<TriggerResponse> {
        let localVariablePath = "/trigger/update"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "triggerId": (wrappedValue: triggerId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "accountId": (wrappedValue: accountId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "name": (wrappedValue: name?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "appKey": (wrappedValue: appKey?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "groupingId": (wrappedValue: groupingId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "endpointURL": (wrappedValue: endpointURL?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "payload": (wrappedValue: payload?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "scheduledDate": (wrappedValue: scheduledDate?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "startDate": (wrappedValue: startDate?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "endDate": (wrappedValue: endDate?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "cronExpression": (wrappedValue: cronExpression?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "conditionalInput": (wrappedValue: conditionalInput?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "visibility": (wrappedValue: visibility?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "active": (wrappedValue: active?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<TriggerResponse>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false, apiConfiguration: apiConfiguration)
    }
}
