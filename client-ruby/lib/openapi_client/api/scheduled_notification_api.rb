=begin
#Sirqul IoT Platform

#Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

The version of the OpenAPI document: 3.16
Contact: info@sirqul.com
Generated by: https://openapi-generator.tech
Generator version: 7.20.0-SNAPSHOT

=end

require 'cgi'

module OpenapiClient
  class ScheduledNotificationApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Create Scheduled Notification
    # This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods
    # @param account_id [Integer] The logged in user.
    # @param name [String] The name of the scheduled notification
    # @param type [String] The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
    # @param message [String] The message to send
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :content_id The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [String] :content_name The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [String] :content_type The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [Integer] :parent_id The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [String] :parent_type The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [String] :app_key The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
    # @option opts [String] :grouping_id Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
    # @option opts [String] :connection_group_ids The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
    # @option opts [String] :connection_account_ids The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
    # @option opts [Integer] :audience_id This parameter is deprecated. The audience used to generate the list of recipients
    # @option opts [String] :audience_ids The audiences used to generate the list of recipients (comma separated list of audience IDs)
    # @option opts [String] :album_ids The album ids to associate with the scheduled notification (comma separated list of album IDs)
    # @option opts [Integer] :report_id The report used to generate the the list of recipients
    # @option opts [String] :report_params The parameters to supply to the report used to generate the the list of recipients
    # @option opts [String] :endpoint_url The URL for making an HTTP call
    # @option opts [String] :payload The parameters for making an HTTP call
    # @option opts [Integer] :scheduled_date The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
    # @option opts [Integer] :start_date The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
    # @option opts [Integer] :end_date The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
    # @option opts [String] :cron_expression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
    # @option opts [String] :cron_type The cron expression type: UNIX, CRON4J, QUARTZ
    # @option opts [String] :meta_data Additional metadata for the scheduled notification
    # @option opts [String] :conditional_input Json input representing conditional logic that has to be met before running the scheduled notification
    # @option opts [String] :template_type This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
    # @option opts [String] :visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
    # @option opts [Boolean] :active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;.
    # @option opts [Boolean] :send_now 
    # @option opts [String] :event_type Sets the event type for the notification (default to 'CUSTOM')
    # @option opts [String] :deep_link_uri The payload deep link URI that can be used by the client app to direct users to a screen in the app
    # @option opts [Boolean] :send_to_all Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
    # @return [ScheduledNotificationFullResponse]
    def create_scheduled_notification(account_id, name, type, message, opts = {})
      data, _status_code, _headers = create_scheduled_notification_with_http_info(account_id, name, type, message, opts)
      data
    end

    # Create Scheduled Notification
    # This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods
    # @param account_id [Integer] The logged in user.
    # @param name [String] The name of the scheduled notification
    # @param type [String] The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
    # @param message [String] The message to send
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :content_id The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [String] :content_name The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [String] :content_type The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [Integer] :parent_id The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [String] :parent_type The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [String] :app_key The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
    # @option opts [String] :grouping_id Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
    # @option opts [String] :connection_group_ids The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
    # @option opts [String] :connection_account_ids The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
    # @option opts [Integer] :audience_id This parameter is deprecated. The audience used to generate the list of recipients
    # @option opts [String] :audience_ids The audiences used to generate the list of recipients (comma separated list of audience IDs)
    # @option opts [String] :album_ids The album ids to associate with the scheduled notification (comma separated list of album IDs)
    # @option opts [Integer] :report_id The report used to generate the the list of recipients
    # @option opts [String] :report_params The parameters to supply to the report used to generate the the list of recipients
    # @option opts [String] :endpoint_url The URL for making an HTTP call
    # @option opts [String] :payload The parameters for making an HTTP call
    # @option opts [Integer] :scheduled_date The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
    # @option opts [Integer] :start_date The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
    # @option opts [Integer] :end_date The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
    # @option opts [String] :cron_expression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
    # @option opts [String] :cron_type The cron expression type: UNIX, CRON4J, QUARTZ
    # @option opts [String] :meta_data Additional metadata for the scheduled notification
    # @option opts [String] :conditional_input Json input representing conditional logic that has to be met before running the scheduled notification
    # @option opts [String] :template_type This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
    # @option opts [String] :visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
    # @option opts [Boolean] :active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;.
    # @option opts [Boolean] :send_now 
    # @option opts [String] :event_type Sets the event type for the notification (default to 'CUSTOM')
    # @option opts [String] :deep_link_uri The payload deep link URI that can be used by the client app to direct users to a screen in the app
    # @option opts [Boolean] :send_to_all Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
    # @return [Array<(ScheduledNotificationFullResponse, Integer, Hash)>] ScheduledNotificationFullResponse data, response status code and response headers
    def create_scheduled_notification_with_http_info(account_id, name, type, message, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ScheduledNotificationApi.create_scheduled_notification ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling ScheduledNotificationApi.create_scheduled_notification"
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling ScheduledNotificationApi.create_scheduled_notification"
      end
      # verify the required parameter 'type' is set
      if @api_client.config.client_side_validation && type.nil?
        fail ArgumentError, "Missing the required parameter 'type' when calling ScheduledNotificationApi.create_scheduled_notification"
      end
      # verify the required parameter 'message' is set
      if @api_client.config.client_side_validation && message.nil?
        fail ArgumentError, "Missing the required parameter 'message' when calling ScheduledNotificationApi.create_scheduled_notification"
      end
      allowable_values = ["PUBLIC", "PRIVATE", "FRIENDS"]
      if @api_client.config.client_side_validation && opts[:'visibility'] && !allowable_values.include?(opts[:'visibility'])
        fail ArgumentError, "invalid value for \"visibility\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/notification/schedule/create'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'name'] = name
      query_params[:'type'] = type
      query_params[:'message'] = message
      query_params[:'contentId'] = opts[:'content_id'] if !opts[:'content_id'].nil?
      query_params[:'contentName'] = opts[:'content_name'] if !opts[:'content_name'].nil?
      query_params[:'contentType'] = opts[:'content_type'] if !opts[:'content_type'].nil?
      query_params[:'parentId'] = opts[:'parent_id'] if !opts[:'parent_id'].nil?
      query_params[:'parentType'] = opts[:'parent_type'] if !opts[:'parent_type'].nil?
      query_params[:'appKey'] = opts[:'app_key'] if !opts[:'app_key'].nil?
      query_params[:'groupingId'] = opts[:'grouping_id'] if !opts[:'grouping_id'].nil?
      query_params[:'connectionGroupIds'] = opts[:'connection_group_ids'] if !opts[:'connection_group_ids'].nil?
      query_params[:'connectionAccountIds'] = opts[:'connection_account_ids'] if !opts[:'connection_account_ids'].nil?
      query_params[:'audienceId'] = opts[:'audience_id'] if !opts[:'audience_id'].nil?
      query_params[:'audienceIds'] = opts[:'audience_ids'] if !opts[:'audience_ids'].nil?
      query_params[:'albumIds'] = opts[:'album_ids'] if !opts[:'album_ids'].nil?
      query_params[:'reportId'] = opts[:'report_id'] if !opts[:'report_id'].nil?
      query_params[:'reportParams'] = opts[:'report_params'] if !opts[:'report_params'].nil?
      query_params[:'endpointURL'] = opts[:'endpoint_url'] if !opts[:'endpoint_url'].nil?
      query_params[:'payload'] = opts[:'payload'] if !opts[:'payload'].nil?
      query_params[:'scheduledDate'] = opts[:'scheduled_date'] if !opts[:'scheduled_date'].nil?
      query_params[:'startDate'] = opts[:'start_date'] if !opts[:'start_date'].nil?
      query_params[:'endDate'] = opts[:'end_date'] if !opts[:'end_date'].nil?
      query_params[:'cronExpression'] = opts[:'cron_expression'] if !opts[:'cron_expression'].nil?
      query_params[:'cronType'] = opts[:'cron_type'] if !opts[:'cron_type'].nil?
      query_params[:'metaData'] = opts[:'meta_data'] if !opts[:'meta_data'].nil?
      query_params[:'conditionalInput'] = opts[:'conditional_input'] if !opts[:'conditional_input'].nil?
      query_params[:'templateType'] = opts[:'template_type'] if !opts[:'template_type'].nil?
      query_params[:'visibility'] = opts[:'visibility'] if !opts[:'visibility'].nil?
      query_params[:'active'] = opts[:'active'] if !opts[:'active'].nil?
      query_params[:'sendNow'] = opts[:'send_now'] if !opts[:'send_now'].nil?
      query_params[:'eventType'] = opts[:'event_type'] if !opts[:'event_type'].nil?
      query_params[:'deepLinkURI'] = opts[:'deep_link_uri'] if !opts[:'deep_link_uri'].nil?
      query_params[:'sendToAll'] = opts[:'send_to_all'] if !opts[:'send_to_all'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ScheduledNotificationFullResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"ScheduledNotificationApi.create_scheduled_notification",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ScheduledNotificationApi#create_scheduled_notification\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Scheduled Notification
    # This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.
    # @param account_id [Integer] the id of the logged in user
    # @param scheduled_notification_id [Integer] the id of the scheduled notification to delete
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :delete_by_grouping_id If set to true, also deletes Scheduled Notifications under the same account with the same groupingId.
    # @return [ScheduledNotificationFullResponse]
    def delete_scheduled_notification(account_id, scheduled_notification_id, opts = {})
      data, _status_code, _headers = delete_scheduled_notification_with_http_info(account_id, scheduled_notification_id, opts)
      data
    end

    # Delete Scheduled Notification
    # This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.
    # @param account_id [Integer] the id of the logged in user
    # @param scheduled_notification_id [Integer] the id of the scheduled notification to delete
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :delete_by_grouping_id If set to true, also deletes Scheduled Notifications under the same account with the same groupingId.
    # @return [Array<(ScheduledNotificationFullResponse, Integer, Hash)>] ScheduledNotificationFullResponse data, response status code and response headers
    def delete_scheduled_notification_with_http_info(account_id, scheduled_notification_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ScheduledNotificationApi.delete_scheduled_notification ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling ScheduledNotificationApi.delete_scheduled_notification"
      end
      # verify the required parameter 'scheduled_notification_id' is set
      if @api_client.config.client_side_validation && scheduled_notification_id.nil?
        fail ArgumentError, "Missing the required parameter 'scheduled_notification_id' when calling ScheduledNotificationApi.delete_scheduled_notification"
      end
      # resource path
      local_var_path = '/notification/schedule/delete'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'scheduledNotificationId'] = scheduled_notification_id
      query_params[:'deleteByGroupingId'] = opts[:'delete_by_grouping_id'] if !opts[:'delete_by_grouping_id'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ScheduledNotificationFullResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"ScheduledNotificationApi.delete_scheduled_notification",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ScheduledNotificationApi#delete_scheduled_notification\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Scheduled Notification
    # Get a ScheduledNotification
    # @param account_id [Integer] the id of the account logged in
    # @param scheduled_notification_id [Integer] the id of the scheduled notification to get
    # @param [Hash] opts the optional parameters
    # @return [ScheduledNotificationFullResponse]
    def get_scheduled_notification(account_id, scheduled_notification_id, opts = {})
      data, _status_code, _headers = get_scheduled_notification_with_http_info(account_id, scheduled_notification_id, opts)
      data
    end

    # Get Scheduled Notification
    # Get a ScheduledNotification
    # @param account_id [Integer] the id of the account logged in
    # @param scheduled_notification_id [Integer] the id of the scheduled notification to get
    # @param [Hash] opts the optional parameters
    # @return [Array<(ScheduledNotificationFullResponse, Integer, Hash)>] ScheduledNotificationFullResponse data, response status code and response headers
    def get_scheduled_notification_with_http_info(account_id, scheduled_notification_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ScheduledNotificationApi.get_scheduled_notification ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling ScheduledNotificationApi.get_scheduled_notification"
      end
      # verify the required parameter 'scheduled_notification_id' is set
      if @api_client.config.client_side_validation && scheduled_notification_id.nil?
        fail ArgumentError, "Missing the required parameter 'scheduled_notification_id' when calling ScheduledNotificationApi.get_scheduled_notification"
      end
      # resource path
      local_var_path = '/notification/schedule/get'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'scheduledNotificationId'] = scheduled_notification_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ScheduledNotificationFullResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"ScheduledNotificationApi.get_scheduled_notification",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ScheduledNotificationApi#get_scheduled_notification\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Generate Schedule Notifications
    # Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.
    # @param account_id [Integer] The logged in user.
    # @param app_key [String] The application to target
    # @param report_name [String] The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail
    # @param message [String] The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in
    # @param offset [Integer] Time in munites before the event starts to notify recipients
    # @param recipient_report_id [Integer] The report id used to generate the recipient list
    # @param [Hash] opts the optional parameters
    # @option opts [String] :report_params The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60; 
    # @option opts [String] :type The type of scheduled notification; supported values are: MOBILE_NOTIFICATION
    # @return [SirqulResponse]
    def schedule_notification_listings(account_id, app_key, report_name, message, offset, recipient_report_id, opts = {})
      data, _status_code, _headers = schedule_notification_listings_with_http_info(account_id, app_key, report_name, message, offset, recipient_report_id, opts)
      data
    end

    # Generate Schedule Notifications
    # Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.
    # @param account_id [Integer] The logged in user.
    # @param app_key [String] The application to target
    # @param report_name [String] The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail
    # @param message [String] The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in
    # @param offset [Integer] Time in munites before the event starts to notify recipients
    # @param recipient_report_id [Integer] The report id used to generate the recipient list
    # @param [Hash] opts the optional parameters
    # @option opts [String] :report_params The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60; 
    # @option opts [String] :type The type of scheduled notification; supported values are: MOBILE_NOTIFICATION
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def schedule_notification_listings_with_http_info(account_id, app_key, report_name, message, offset, recipient_report_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ScheduledNotificationApi.schedule_notification_listings ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling ScheduledNotificationApi.schedule_notification_listings"
      end
      # verify the required parameter 'app_key' is set
      if @api_client.config.client_side_validation && app_key.nil?
        fail ArgumentError, "Missing the required parameter 'app_key' when calling ScheduledNotificationApi.schedule_notification_listings"
      end
      # verify the required parameter 'report_name' is set
      if @api_client.config.client_side_validation && report_name.nil?
        fail ArgumentError, "Missing the required parameter 'report_name' when calling ScheduledNotificationApi.schedule_notification_listings"
      end
      # verify the required parameter 'message' is set
      if @api_client.config.client_side_validation && message.nil?
        fail ArgumentError, "Missing the required parameter 'message' when calling ScheduledNotificationApi.schedule_notification_listings"
      end
      # verify the required parameter 'offset' is set
      if @api_client.config.client_side_validation && offset.nil?
        fail ArgumentError, "Missing the required parameter 'offset' when calling ScheduledNotificationApi.schedule_notification_listings"
      end
      # verify the required parameter 'recipient_report_id' is set
      if @api_client.config.client_side_validation && recipient_report_id.nil?
        fail ArgumentError, "Missing the required parameter 'recipient_report_id' when calling ScheduledNotificationApi.schedule_notification_listings"
      end
      # resource path
      local_var_path = '/notification/schedule/generate'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'appKey'] = app_key
      query_params[:'reportName'] = report_name
      query_params[:'message'] = message
      query_params[:'offset'] = offset
      query_params[:'recipientReportId'] = recipient_report_id
      query_params[:'reportParams'] = opts[:'report_params'] if !opts[:'report_params'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"ScheduledNotificationApi.schedule_notification_listings",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ScheduledNotificationApi#schedule_notification_listings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Search Scheduled Notifications
    # This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.
    # @param account_id [Integer] The logged in user.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :grouping_id Filter results by a grouping identifier defined by the client
    # @option opts [Integer] :audience_id Filter results by audience
    # @option opts [String] :filter a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications.
    # @option opts [String] :types Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION
    # @option opts [String] :content_ids search using content IDs
    # @option opts [String] :content_types search using content types
    # @option opts [String] :parent_ids search using parent IDs
    # @option opts [String] :parent_types search using parent types
    # @option opts [String] :statuses Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending
    # @option opts [String] :template_types 
    # @option opts [String] :app_key Filter the list by a specific application
    # @option opts [String] :keyword Keyword search on the scheduled notification names.
    # @option opts [String] :sort_field The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date
    # @option opts [Boolean] :descending Determines whether the sorted list is in descending or ascending order
    # @option opts [Integer] :start Start the result set at some index.
    # @option opts [Integer] :limit Limit the result to some number.
    # @option opts [Boolean] :active_only Determines whether to return only active results
    # @option opts [Boolean] :group_by_grouping_id Determines whether to group results with the same groupingId together.
    # @option opts [Boolean] :return_audience_account_count If true, include audience account counts in the response
    # @return [ScheduledNotificationFullResponse]
    def search_scheduled_notifications(account_id, opts = {})
      data, _status_code, _headers = search_scheduled_notifications_with_http_info(account_id, opts)
      data
    end

    # Search Scheduled Notifications
    # This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.
    # @param account_id [Integer] The logged in user.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :grouping_id Filter results by a grouping identifier defined by the client
    # @option opts [Integer] :audience_id Filter results by audience
    # @option opts [String] :filter a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications.
    # @option opts [String] :types Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION
    # @option opts [String] :content_ids search using content IDs
    # @option opts [String] :content_types search using content types
    # @option opts [String] :parent_ids search using parent IDs
    # @option opts [String] :parent_types search using parent types
    # @option opts [String] :statuses Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending
    # @option opts [String] :template_types 
    # @option opts [String] :app_key Filter the list by a specific application
    # @option opts [String] :keyword Keyword search on the scheduled notification names.
    # @option opts [String] :sort_field The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date
    # @option opts [Boolean] :descending Determines whether the sorted list is in descending or ascending order
    # @option opts [Integer] :start Start the result set at some index.
    # @option opts [Integer] :limit Limit the result to some number.
    # @option opts [Boolean] :active_only Determines whether to return only active results
    # @option opts [Boolean] :group_by_grouping_id Determines whether to group results with the same groupingId together.
    # @option opts [Boolean] :return_audience_account_count If true, include audience account counts in the response
    # @return [Array<(ScheduledNotificationFullResponse, Integer, Hash)>] ScheduledNotificationFullResponse data, response status code and response headers
    def search_scheduled_notifications_with_http_info(account_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ScheduledNotificationApi.search_scheduled_notifications ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling ScheduledNotificationApi.search_scheduled_notifications"
      end
      # resource path
      local_var_path = '/notification/schedule/search'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'groupingId'] = opts[:'grouping_id'] if !opts[:'grouping_id'].nil?
      query_params[:'audienceId'] = opts[:'audience_id'] if !opts[:'audience_id'].nil?
      query_params[:'filter'] = opts[:'filter'] if !opts[:'filter'].nil?
      query_params[:'types'] = opts[:'types'] if !opts[:'types'].nil?
      query_params[:'contentIds'] = opts[:'content_ids'] if !opts[:'content_ids'].nil?
      query_params[:'contentTypes'] = opts[:'content_types'] if !opts[:'content_types'].nil?
      query_params[:'parentIds'] = opts[:'parent_ids'] if !opts[:'parent_ids'].nil?
      query_params[:'parentTypes'] = opts[:'parent_types'] if !opts[:'parent_types'].nil?
      query_params[:'statuses'] = opts[:'statuses'] if !opts[:'statuses'].nil?
      query_params[:'templateTypes'] = opts[:'template_types'] if !opts[:'template_types'].nil?
      query_params[:'appKey'] = opts[:'app_key'] if !opts[:'app_key'].nil?
      query_params[:'keyword'] = opts[:'keyword'] if !opts[:'keyword'].nil?
      query_params[:'sortField'] = opts[:'sort_field'] if !opts[:'sort_field'].nil?
      query_params[:'descending'] = opts[:'descending'] if !opts[:'descending'].nil?
      query_params[:'start'] = opts[:'start'] if !opts[:'start'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'activeOnly'] = opts[:'active_only'] if !opts[:'active_only'].nil?
      query_params[:'groupByGroupingId'] = opts[:'group_by_grouping_id'] if !opts[:'group_by_grouping_id'].nil?
      query_params[:'returnAudienceAccountCount'] = opts[:'return_audience_account_count'] if !opts[:'return_audience_account_count'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ScheduledNotificationFullResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"ScheduledNotificationApi.search_scheduled_notifications",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ScheduledNotificationApi#search_scheduled_notifications\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Scheduled Notification
    # This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.
    # @param scheduled_notification_id [Integer] The id of scheduled notification to update
    # @param account_id [Integer] The logged in user.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :name The name of the scheduled notification
    # @option opts [String] :type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
    # @option opts [String] :message The message to send
    # @option opts [String] :payload The parameters for making an HTTP call
    # @option opts [Integer] :content_id The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [String] :content_name The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [String] :content_type The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [Integer] :parent_id The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [String] :parent_type The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [String] :app_key The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
    # @option opts [String] :grouping_id Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
    # @option opts [String] :connection_group_ids The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
    # @option opts [String] :connection_account_ids The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
    # @option opts [Integer] :audience_id This parameter is deprecated. The audience used to generate the list of recipients
    # @option opts [String] :audience_ids The audiences used to generate the list of recipients (comma separated list of audience IDs)
    # @option opts [String] :album_ids The album ids to associate with the scheduled notification (comma separated list of album IDs)
    # @option opts [Integer] :report_id The report used to generate the the list of recipients
    # @option opts [String] :report_params The parameters to supply to the report used to generate the the list of recipients
    # @option opts [String] :endpoint_url The URL for making an HTTP call
    # @option opts [Integer] :scheduled_date The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
    # @option opts [Integer] :start_date The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
    # @option opts [Integer] :end_date The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
    # @option opts [String] :cron_expression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
    # @option opts [String] :cron_type The cron expression type: UNIX, CRON4J, QUARTZ
    # @option opts [String] :meta_data Additional metadata for the scheduled notification
    # @option opts [String] :conditional_input Json input representing conditional logic that has to be met before running the scheduled notification
    # @option opts [String] :template_type This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
    # @option opts [String] :visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
    # @option opts [Boolean] :active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule.
    # @option opts [String] :error_message the error message associated with the scheduled notification
    # @option opts [String] :status the status of the scheduled notification
    # @option opts [Boolean] :update_by_grouping_id also updates ScheduledNotifications with the same groupingId and account
    # @option opts [Boolean] :send_now whether to send the scheduled notification now or not
    # @option opts [String] :event_type Sets the event type for the notification (default to 'CUSTOM')
    # @option opts [String] :deep_link_uri The payload deep link URI that can be used by the client app to direct users to a screen in the app
    # @option opts [Boolean] :send_to_all Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
    # @return [ScheduledNotificationFullResponse]
    def update_scheduled_notification(scheduled_notification_id, account_id, opts = {})
      data, _status_code, _headers = update_scheduled_notification_with_http_info(scheduled_notification_id, account_id, opts)
      data
    end

    # Update Scheduled Notification
    # This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.
    # @param scheduled_notification_id [Integer] The id of scheduled notification to update
    # @param account_id [Integer] The logged in user.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :name The name of the scheduled notification
    # @option opts [String] :type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
    # @option opts [String] :message The message to send
    # @option opts [String] :payload The parameters for making an HTTP call
    # @option opts [Integer] :content_id The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [String] :content_name The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [String] :content_type The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [Integer] :parent_id The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [String] :parent_type The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    # @option opts [String] :app_key The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
    # @option opts [String] :grouping_id Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
    # @option opts [String] :connection_group_ids The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
    # @option opts [String] :connection_account_ids The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
    # @option opts [Integer] :audience_id This parameter is deprecated. The audience used to generate the list of recipients
    # @option opts [String] :audience_ids The audiences used to generate the list of recipients (comma separated list of audience IDs)
    # @option opts [String] :album_ids The album ids to associate with the scheduled notification (comma separated list of album IDs)
    # @option opts [Integer] :report_id The report used to generate the the list of recipients
    # @option opts [String] :report_params The parameters to supply to the report used to generate the the list of recipients
    # @option opts [String] :endpoint_url The URL for making an HTTP call
    # @option opts [Integer] :scheduled_date The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
    # @option opts [Integer] :start_date The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
    # @option opts [Integer] :end_date The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
    # @option opts [String] :cron_expression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
    # @option opts [String] :cron_type The cron expression type: UNIX, CRON4J, QUARTZ
    # @option opts [String] :meta_data Additional metadata for the scheduled notification
    # @option opts [String] :conditional_input Json input representing conditional logic that has to be met before running the scheduled notification
    # @option opts [String] :template_type This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
    # @option opts [String] :visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
    # @option opts [Boolean] :active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule.
    # @option opts [String] :error_message the error message associated with the scheduled notification
    # @option opts [String] :status the status of the scheduled notification
    # @option opts [Boolean] :update_by_grouping_id also updates ScheduledNotifications with the same groupingId and account
    # @option opts [Boolean] :send_now whether to send the scheduled notification now or not
    # @option opts [String] :event_type Sets the event type for the notification (default to 'CUSTOM')
    # @option opts [String] :deep_link_uri The payload deep link URI that can be used by the client app to direct users to a screen in the app
    # @option opts [Boolean] :send_to_all Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
    # @return [Array<(ScheduledNotificationFullResponse, Integer, Hash)>] ScheduledNotificationFullResponse data, response status code and response headers
    def update_scheduled_notification_with_http_info(scheduled_notification_id, account_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ScheduledNotificationApi.update_scheduled_notification ...'
      end
      # verify the required parameter 'scheduled_notification_id' is set
      if @api_client.config.client_side_validation && scheduled_notification_id.nil?
        fail ArgumentError, "Missing the required parameter 'scheduled_notification_id' when calling ScheduledNotificationApi.update_scheduled_notification"
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling ScheduledNotificationApi.update_scheduled_notification"
      end
      allowable_values = ["PUBLIC", "PRIVATE", "FRIENDS"]
      if @api_client.config.client_side_validation && opts[:'visibility'] && !allowable_values.include?(opts[:'visibility'])
        fail ArgumentError, "invalid value for \"visibility\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/notification/schedule/update'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'scheduledNotificationId'] = scheduled_notification_id
      query_params[:'accountId'] = account_id
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'type'] = opts[:'type'] if !opts[:'type'].nil?
      query_params[:'message'] = opts[:'message'] if !opts[:'message'].nil?
      query_params[:'payload'] = opts[:'payload'] if !opts[:'payload'].nil?
      query_params[:'contentId'] = opts[:'content_id'] if !opts[:'content_id'].nil?
      query_params[:'contentName'] = opts[:'content_name'] if !opts[:'content_name'].nil?
      query_params[:'contentType'] = opts[:'content_type'] if !opts[:'content_type'].nil?
      query_params[:'parentId'] = opts[:'parent_id'] if !opts[:'parent_id'].nil?
      query_params[:'parentType'] = opts[:'parent_type'] if !opts[:'parent_type'].nil?
      query_params[:'appKey'] = opts[:'app_key'] if !opts[:'app_key'].nil?
      query_params[:'groupingId'] = opts[:'grouping_id'] if !opts[:'grouping_id'].nil?
      query_params[:'connectionGroupIds'] = opts[:'connection_group_ids'] if !opts[:'connection_group_ids'].nil?
      query_params[:'connectionAccountIds'] = opts[:'connection_account_ids'] if !opts[:'connection_account_ids'].nil?
      query_params[:'audienceId'] = opts[:'audience_id'] if !opts[:'audience_id'].nil?
      query_params[:'audienceIds'] = opts[:'audience_ids'] if !opts[:'audience_ids'].nil?
      query_params[:'albumIds'] = opts[:'album_ids'] if !opts[:'album_ids'].nil?
      query_params[:'reportId'] = opts[:'report_id'] if !opts[:'report_id'].nil?
      query_params[:'reportParams'] = opts[:'report_params'] if !opts[:'report_params'].nil?
      query_params[:'endpointURL'] = opts[:'endpoint_url'] if !opts[:'endpoint_url'].nil?
      query_params[:'scheduledDate'] = opts[:'scheduled_date'] if !opts[:'scheduled_date'].nil?
      query_params[:'startDate'] = opts[:'start_date'] if !opts[:'start_date'].nil?
      query_params[:'endDate'] = opts[:'end_date'] if !opts[:'end_date'].nil?
      query_params[:'cronExpression'] = opts[:'cron_expression'] if !opts[:'cron_expression'].nil?
      query_params[:'cronType'] = opts[:'cron_type'] if !opts[:'cron_type'].nil?
      query_params[:'metaData'] = opts[:'meta_data'] if !opts[:'meta_data'].nil?
      query_params[:'conditionalInput'] = opts[:'conditional_input'] if !opts[:'conditional_input'].nil?
      query_params[:'templateType'] = opts[:'template_type'] if !opts[:'template_type'].nil?
      query_params[:'visibility'] = opts[:'visibility'] if !opts[:'visibility'].nil?
      query_params[:'active'] = opts[:'active'] if !opts[:'active'].nil?
      query_params[:'errorMessage'] = opts[:'error_message'] if !opts[:'error_message'].nil?
      query_params[:'status'] = opts[:'status'] if !opts[:'status'].nil?
      query_params[:'updateByGroupingId'] = opts[:'update_by_grouping_id'] if !opts[:'update_by_grouping_id'].nil?
      query_params[:'sendNow'] = opts[:'send_now'] if !opts[:'send_now'].nil?
      query_params[:'eventType'] = opts[:'event_type'] if !opts[:'event_type'].nil?
      query_params[:'deepLinkURI'] = opts[:'deep_link_uri'] if !opts[:'deep_link_uri'].nil?
      query_params[:'sendToAll'] = opts[:'send_to_all'] if !opts[:'send_to_all'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ScheduledNotificationFullResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"ScheduledNotificationApi.update_scheduled_notification",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ScheduledNotificationApi#update_scheduled_notification\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
