=begin
#Sirqul IoT Platform

#Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

The version of the OpenAPI document: 3.16
Contact: info@sirqul.com
Generated by: https://openapi-generator.tech
Generator version: 7.20.0-SNAPSHOT

=end

require 'cgi'

module OpenapiClient
  class TrackingApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Create Batch Tracking
    # Batch create tracking legs
    # @param data [String] JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60; 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id the device id (deviceId or accountId required)
    # @option opts [Integer] :account_id the account id of the user (deviceId or accountId required)
    # @option opts [Boolean] :generate_accounts Whether to generate accounts for tracking entries when the owner does not exist
    # @option opts [Boolean] :update_account_locations Whether to update the account&#39;s current location from the incoming tracking data
    # @option opts [String] :default_tag The default tag to apply to incoming legs when no tag is provided (default to 'PASSIVE')
    # @option opts [String] :slave_uid 
    # @return [Array<Leg>]
    def batch_save_tracking(data, opts = {})
      data, _status_code, _headers = batch_save_tracking_with_http_info(data, opts)
      data
    end

    # Create Batch Tracking
    # Batch create tracking legs
    # @param data [String] JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60; 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id the device id (deviceId or accountId required)
    # @option opts [Integer] :account_id the account id of the user (deviceId or accountId required)
    # @option opts [Boolean] :generate_accounts Whether to generate accounts for tracking entries when the owner does not exist
    # @option opts [Boolean] :update_account_locations Whether to update the account&#39;s current location from the incoming tracking data
    # @option opts [String] :default_tag The default tag to apply to incoming legs when no tag is provided (default to 'PASSIVE')
    # @option opts [String] :slave_uid 
    # @return [Array<(Array<Leg>, Integer, Hash)>] Array<Leg> data, response status code and response headers
    def batch_save_tracking_with_http_info(data, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TrackingApi.batch_save_tracking ...'
      end
      # verify the required parameter 'data' is set
      if @api_client.config.client_side_validation && data.nil?
        fail ArgumentError, "Missing the required parameter 'data' when calling TrackingApi.batch_save_tracking"
      end
      # resource path
      local_var_path = '/tracking/batch/create'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'data'] = data
      query_params[:'deviceId'] = opts[:'device_id'] if !opts[:'device_id'].nil?
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'generateAccounts'] = opts[:'generate_accounts'] if !opts[:'generate_accounts'].nil?
      query_params[:'updateAccountLocations'] = opts[:'update_account_locations'] if !opts[:'update_account_locations'].nil?
      query_params[:'defaultTag'] = opts[:'default_tag'] if !opts[:'default_tag'].nil?
      query_params[:'slaveUID'] = opts[:'slave_uid'] if !opts[:'slave_uid'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<Leg>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TrackingApi.batch_save_tracking",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TrackingApi#batch_save_tracking\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Predicted Locations
    # Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.
    # @param account_id [Integer] The account id of the customer
    # @param [Hash] opts the optional parameters
    # @option opts [Float] :latitude latitude to return a more likely result set based on the user&#39;s current location
    # @option opts [Float] :longitude longitude to return a more likely result set based on the user&#39;s current location
    # @option opts [Integer] :date_check Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used.
    # @option opts [String] :hour_check Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;.
    # @option opts [Integer] :threshold The minimum number matches in 1 hour to be considered a likely location. (default to 1)
    # @option opts [String] :distance_unit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (default to 'MILES')
    # @option opts [Float] :search_range Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (default to 0)
    # @option opts [String] :sort_order The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (default to 'MATCHES')
    # @return [PredictedLocationResponse]
    def get_predicted_locations(account_id, opts = {})
      data, _status_code, _headers = get_predicted_locations_with_http_info(account_id, opts)
      data
    end

    # Get Predicted Locations
    # Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.
    # @param account_id [Integer] The account id of the customer
    # @param [Hash] opts the optional parameters
    # @option opts [Float] :latitude latitude to return a more likely result set based on the user&#39;s current location
    # @option opts [Float] :longitude longitude to return a more likely result set based on the user&#39;s current location
    # @option opts [Integer] :date_check Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used.
    # @option opts [String] :hour_check Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;.
    # @option opts [Integer] :threshold The minimum number matches in 1 hour to be considered a likely location. (default to 1)
    # @option opts [String] :distance_unit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (default to 'MILES')
    # @option opts [Float] :search_range Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (default to 0)
    # @option opts [String] :sort_order The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (default to 'MATCHES')
    # @return [Array<(PredictedLocationResponse, Integer, Hash)>] PredictedLocationResponse data, response status code and response headers
    def get_predicted_locations_with_http_info(account_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TrackingApi.get_predicted_locations ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling TrackingApi.get_predicted_locations"
      end
      allowable_values = ["MILES", "KILOMETERS"]
      if @api_client.config.client_side_validation && opts[:'distance_unit'] && !allowable_values.include?(opts[:'distance_unit'])
        fail ArgumentError, "invalid value for \"distance_unit\", must be one of #{allowable_values}"
      end
      allowable_values = ["MATCHES", "DISTANCE", "WEIGHTED"]
      if @api_client.config.client_side_validation && opts[:'sort_order'] && !allowable_values.include?(opts[:'sort_order'])
        fail ArgumentError, "invalid value for \"sort_order\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/tracking/predicted/get'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'latitude'] = opts[:'latitude'] if !opts[:'latitude'].nil?
      query_params[:'longitude'] = opts[:'longitude'] if !opts[:'longitude'].nil?
      query_params[:'dateCheck'] = opts[:'date_check'] if !opts[:'date_check'].nil?
      query_params[:'hourCheck'] = opts[:'hour_check'] if !opts[:'hour_check'].nil?
      query_params[:'threshold'] = opts[:'threshold'] if !opts[:'threshold'].nil?
      query_params[:'distanceUnit'] = opts[:'distance_unit'] if !opts[:'distance_unit'].nil?
      query_params[:'searchRange'] = opts[:'search_range'] if !opts[:'search_range'].nil?
      query_params[:'sortOrder'] = opts[:'sort_order'] if !opts[:'sort_order'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'PredictedLocationResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TrackingApi.get_predicted_locations",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TrackingApi#get_predicted_locations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Tracking Path
    # Get the path (lat/long coordinates) between 2 steps previously logged for a customer.
    # @param account_id [Integer] The account id of the customer
    # @param start_step_id [Integer] The stepId to begin from
    # @param end_step_id [Integer] The stepId to end with
    # @param [Hash] opts the optional parameters
    # @return [Array<StepResponse>]
    def get_predicted_path(account_id, start_step_id, end_step_id, opts = {})
      data, _status_code, _headers = get_predicted_path_with_http_info(account_id, start_step_id, end_step_id, opts)
      data
    end

    # Get Tracking Path
    # Get the path (lat/long coordinates) between 2 steps previously logged for a customer.
    # @param account_id [Integer] The account id of the customer
    # @param start_step_id [Integer] The stepId to begin from
    # @param end_step_id [Integer] The stepId to end with
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<StepResponse>, Integer, Hash)>] Array<StepResponse> data, response status code and response headers
    def get_predicted_path_with_http_info(account_id, start_step_id, end_step_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TrackingApi.get_predicted_path ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling TrackingApi.get_predicted_path"
      end
      # verify the required parameter 'start_step_id' is set
      if @api_client.config.client_side_validation && start_step_id.nil?
        fail ArgumentError, "Missing the required parameter 'start_step_id' when calling TrackingApi.get_predicted_path"
      end
      # verify the required parameter 'end_step_id' is set
      if @api_client.config.client_side_validation && end_step_id.nil?
        fail ArgumentError, "Missing the required parameter 'end_step_id' when calling TrackingApi.get_predicted_path"
      end
      # resource path
      local_var_path = '/tracking/path/get'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'startStepId'] = start_step_id
      query_params[:'endStepId'] = end_step_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<StepResponse>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TrackingApi.get_predicted_path",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TrackingApi#get_predicted_path\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Search Preferred Locations
    # Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.
    # @param account_id [Integer] The account id of the customer
    # @param [Hash] opts the optional parameters
    # @option opts [Float] :latitude latitude to return a more likely result set based on the user&#39;s current location
    # @option opts [Float] :longitude longitude to return a more likely result set based on the user&#39;s current location
    # @option opts [Integer] :date_check Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.
    # @option opts [String] :hour_check Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;.
    # @option opts [String] :sort_field Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (default to 'PREFERRED_DATE')
    # @option opts [Boolean] :descending Determines whether the sorted list is in descending or ascending order (default to true)
    # @option opts [Integer] :start The start index for pagination (default to 0)
    # @option opts [Integer] :limit The limit for pagination (default to 20)
    # @option opts [Float] :search_range Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (default to 0)
    # @option opts [String] :distance_unit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (default to 'MILES')
    # @return [Array<PreferredLocationResponse>]
    def get_preferred_locations(account_id, opts = {})
      data, _status_code, _headers = get_preferred_locations_with_http_info(account_id, opts)
      data
    end

    # Search Preferred Locations
    # Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.
    # @param account_id [Integer] The account id of the customer
    # @param [Hash] opts the optional parameters
    # @option opts [Float] :latitude latitude to return a more likely result set based on the user&#39;s current location
    # @option opts [Float] :longitude longitude to return a more likely result set based on the user&#39;s current location
    # @option opts [Integer] :date_check Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.
    # @option opts [String] :hour_check Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;.
    # @option opts [String] :sort_field Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (default to 'PREFERRED_DATE')
    # @option opts [Boolean] :descending Determines whether the sorted list is in descending or ascending order (default to true)
    # @option opts [Integer] :start The start index for pagination (default to 0)
    # @option opts [Integer] :limit The limit for pagination (default to 20)
    # @option opts [Float] :search_range Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (default to 0)
    # @option opts [String] :distance_unit Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (default to 'MILES')
    # @return [Array<(Array<PreferredLocationResponse>, Integer, Hash)>] Array<PreferredLocationResponse> data, response status code and response headers
    def get_preferred_locations_with_http_info(account_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TrackingApi.get_preferred_locations ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling TrackingApi.get_preferred_locations"
      end
      allowable_values = ["MILES", "KILOMETERS"]
      if @api_client.config.client_side_validation && opts[:'distance_unit'] && !allowable_values.include?(opts[:'distance_unit'])
        fail ArgumentError, "invalid value for \"distance_unit\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/tracking/preferred/search'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'latitude'] = opts[:'latitude'] if !opts[:'latitude'].nil?
      query_params[:'longitude'] = opts[:'longitude'] if !opts[:'longitude'].nil?
      query_params[:'dateCheck'] = opts[:'date_check'] if !opts[:'date_check'].nil?
      query_params[:'hourCheck'] = opts[:'hour_check'] if !opts[:'hour_check'].nil?
      query_params[:'sortField'] = opts[:'sort_field'] if !opts[:'sort_field'].nil?
      query_params[:'descending'] = opts[:'descending'] if !opts[:'descending'].nil?
      query_params[:'start'] = opts[:'start'] if !opts[:'start'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'searchRange'] = opts[:'search_range'] if !opts[:'search_range'].nil?
      query_params[:'distanceUnit'] = opts[:'distance_unit'] if !opts[:'distance_unit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<PreferredLocationResponse>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TrackingApi.get_preferred_locations",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TrackingApi#get_preferred_locations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Search Tracking
    # Retrieve tracking data to be able to show where a user has been.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id the device id (deviceId or accountId required)
    # @option opts [Integer] :account_id the account id of the user (deviceId or accountId required)
    # @option opts [Integer] :owner_id the account id of the person the user wants to tracking data for
    # @option opts [String] :tracking_device_id the id of the tracking device
    # @option opts [Integer] :start_date the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.
    # @option opts [Integer] :end_date the end date in (UTC milliseconds) to filter the tracking results
    # @option opts [String] :tags filter results by tag
    # @option opts [Boolean] :get_last_point gets the last known location of the user (default to false)
    # @return [Array<LegResponse>]
    def get_tracking_legs(opts = {})
      data, _status_code, _headers = get_tracking_legs_with_http_info(opts)
      data
    end

    # Search Tracking
    # Retrieve tracking data to be able to show where a user has been.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id the device id (deviceId or accountId required)
    # @option opts [Integer] :account_id the account id of the user (deviceId or accountId required)
    # @option opts [Integer] :owner_id the account id of the person the user wants to tracking data for
    # @option opts [String] :tracking_device_id the id of the tracking device
    # @option opts [Integer] :start_date the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.
    # @option opts [Integer] :end_date the end date in (UTC milliseconds) to filter the tracking results
    # @option opts [String] :tags filter results by tag
    # @option opts [Boolean] :get_last_point gets the last known location of the user (default to false)
    # @return [Array<(Array<LegResponse>, Integer, Hash)>] Array<LegResponse> data, response status code and response headers
    def get_tracking_legs_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TrackingApi.get_tracking_legs ...'
      end
      # resource path
      local_var_path = '/tracking/search'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'deviceId'] = opts[:'device_id'] if !opts[:'device_id'].nil?
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'ownerId'] = opts[:'owner_id'] if !opts[:'owner_id'].nil?
      query_params[:'trackingDeviceId'] = opts[:'tracking_device_id'] if !opts[:'tracking_device_id'].nil?
      query_params[:'startDate'] = opts[:'start_date'] if !opts[:'start_date'].nil?
      query_params[:'endDate'] = opts[:'end_date'] if !opts[:'end_date'].nil?
      query_params[:'tags'] = opts[:'tags'] if !opts[:'tags'].nil?
      query_params[:'getLastPoint'] = opts[:'get_last_point'] if !opts[:'get_last_point'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<LegResponse>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TrackingApi.get_tracking_legs",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TrackingApi#get_tracking_legs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Tracking Leg
    # Send tracking points to be able to generate pathing data
    # @param start_lat [Float] the latitude of the first point
    # @param start_lng [Float] the longitude of the first point
    # @param start_date [Integer] the start date (in UTC milliseconds) of the first point
    # @param end_lat [Float] the latitude of the last point
    # @param end_lng [Float] the longitude of the last point
    # @param end_date [Integer] the end date (in UTC milliseconds) of the last point
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id the device id (deviceId or accountId required)
    # @option opts [Integer] :account_id the account id of the user (deviceId or accountId required)
    # @option opts [Float] :distance the total distance
    # @option opts [Integer] :duration the total duration
    # @option opts [String] :steps JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60; 
    # @option opts [String] :tags name the leg for searching
    # @return [SirqulResponse]
    def save_tracking_leg(start_lat, start_lng, start_date, end_lat, end_lng, end_date, opts = {})
      data, _status_code, _headers = save_tracking_leg_with_http_info(start_lat, start_lng, start_date, end_lat, end_lng, end_date, opts)
      data
    end

    # Create Tracking Leg
    # Send tracking points to be able to generate pathing data
    # @param start_lat [Float] the latitude of the first point
    # @param start_lng [Float] the longitude of the first point
    # @param start_date [Integer] the start date (in UTC milliseconds) of the first point
    # @param end_lat [Float] the latitude of the last point
    # @param end_lng [Float] the longitude of the last point
    # @param end_date [Integer] the end date (in UTC milliseconds) of the last point
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id the device id (deviceId or accountId required)
    # @option opts [Integer] :account_id the account id of the user (deviceId or accountId required)
    # @option opts [Float] :distance the total distance
    # @option opts [Integer] :duration the total duration
    # @option opts [String] :steps JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60; 
    # @option opts [String] :tags name the leg for searching
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def save_tracking_leg_with_http_info(start_lat, start_lng, start_date, end_lat, end_lng, end_date, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TrackingApi.save_tracking_leg ...'
      end
      # verify the required parameter 'start_lat' is set
      if @api_client.config.client_side_validation && start_lat.nil?
        fail ArgumentError, "Missing the required parameter 'start_lat' when calling TrackingApi.save_tracking_leg"
      end
      # verify the required parameter 'start_lng' is set
      if @api_client.config.client_side_validation && start_lng.nil?
        fail ArgumentError, "Missing the required parameter 'start_lng' when calling TrackingApi.save_tracking_leg"
      end
      # verify the required parameter 'start_date' is set
      if @api_client.config.client_side_validation && start_date.nil?
        fail ArgumentError, "Missing the required parameter 'start_date' when calling TrackingApi.save_tracking_leg"
      end
      # verify the required parameter 'end_lat' is set
      if @api_client.config.client_side_validation && end_lat.nil?
        fail ArgumentError, "Missing the required parameter 'end_lat' when calling TrackingApi.save_tracking_leg"
      end
      # verify the required parameter 'end_lng' is set
      if @api_client.config.client_side_validation && end_lng.nil?
        fail ArgumentError, "Missing the required parameter 'end_lng' when calling TrackingApi.save_tracking_leg"
      end
      # verify the required parameter 'end_date' is set
      if @api_client.config.client_side_validation && end_date.nil?
        fail ArgumentError, "Missing the required parameter 'end_date' when calling TrackingApi.save_tracking_leg"
      end
      # resource path
      local_var_path = '/tracking/leg/create'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'startLat'] = start_lat
      query_params[:'startLng'] = start_lng
      query_params[:'startDate'] = start_date
      query_params[:'endLat'] = end_lat
      query_params[:'endLng'] = end_lng
      query_params[:'endDate'] = end_date
      query_params[:'deviceId'] = opts[:'device_id'] if !opts[:'device_id'].nil?
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'distance'] = opts[:'distance'] if !opts[:'distance'].nil?
      query_params[:'duration'] = opts[:'duration'] if !opts[:'duration'].nil?
      query_params[:'steps'] = opts[:'steps'] if !opts[:'steps'].nil?
      query_params[:'tags'] = opts[:'tags'] if !opts[:'tags'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TrackingApi.save_tracking_leg",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TrackingApi#save_tracking_leg\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Tracking Step
    # Send tracking points to be able to generate pathing data
    # @param leg_id [Integer] the leg to add the step to
    # @param start_lat [Float] the latitude of the first point
    # @param start_lng [Float] the longitude of the first point
    # @param start_date [Integer] the start date (in UTC milliseconds) of the first point
    # @param end_lat [Float] the latitude of the last point
    # @param end_lng [Float] the longitude of the last point
    # @param end_date [Integer] the end date (in UTC milliseconds) of the last point
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id the device id (deviceId or accountId required)
    # @option opts [Integer] :account_id the account id of the user (deviceId or accountId required)
    # @option opts [Float] :distance the total distance
    # @option opts [Integer] :duration the total duration
    # @return [SirqulResponse]
    def save_tracking_step(leg_id, start_lat, start_lng, start_date, end_lat, end_lng, end_date, opts = {})
      data, _status_code, _headers = save_tracking_step_with_http_info(leg_id, start_lat, start_lng, start_date, end_lat, end_lng, end_date, opts)
      data
    end

    # Create Tracking Step
    # Send tracking points to be able to generate pathing data
    # @param leg_id [Integer] the leg to add the step to
    # @param start_lat [Float] the latitude of the first point
    # @param start_lng [Float] the longitude of the first point
    # @param start_date [Integer] the start date (in UTC milliseconds) of the first point
    # @param end_lat [Float] the latitude of the last point
    # @param end_lng [Float] the longitude of the last point
    # @param end_date [Integer] the end date (in UTC milliseconds) of the last point
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id the device id (deviceId or accountId required)
    # @option opts [Integer] :account_id the account id of the user (deviceId or accountId required)
    # @option opts [Float] :distance the total distance
    # @option opts [Integer] :duration the total duration
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def save_tracking_step_with_http_info(leg_id, start_lat, start_lng, start_date, end_lat, end_lng, end_date, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TrackingApi.save_tracking_step ...'
      end
      # verify the required parameter 'leg_id' is set
      if @api_client.config.client_side_validation && leg_id.nil?
        fail ArgumentError, "Missing the required parameter 'leg_id' when calling TrackingApi.save_tracking_step"
      end
      # verify the required parameter 'start_lat' is set
      if @api_client.config.client_side_validation && start_lat.nil?
        fail ArgumentError, "Missing the required parameter 'start_lat' when calling TrackingApi.save_tracking_step"
      end
      # verify the required parameter 'start_lng' is set
      if @api_client.config.client_side_validation && start_lng.nil?
        fail ArgumentError, "Missing the required parameter 'start_lng' when calling TrackingApi.save_tracking_step"
      end
      # verify the required parameter 'start_date' is set
      if @api_client.config.client_side_validation && start_date.nil?
        fail ArgumentError, "Missing the required parameter 'start_date' when calling TrackingApi.save_tracking_step"
      end
      # verify the required parameter 'end_lat' is set
      if @api_client.config.client_side_validation && end_lat.nil?
        fail ArgumentError, "Missing the required parameter 'end_lat' when calling TrackingApi.save_tracking_step"
      end
      # verify the required parameter 'end_lng' is set
      if @api_client.config.client_side_validation && end_lng.nil?
        fail ArgumentError, "Missing the required parameter 'end_lng' when calling TrackingApi.save_tracking_step"
      end
      # verify the required parameter 'end_date' is set
      if @api_client.config.client_side_validation && end_date.nil?
        fail ArgumentError, "Missing the required parameter 'end_date' when calling TrackingApi.save_tracking_step"
      end
      # resource path
      local_var_path = '/tracking/step/create'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'legId'] = leg_id
      query_params[:'startLat'] = start_lat
      query_params[:'startLng'] = start_lng
      query_params[:'startDate'] = start_date
      query_params[:'endLat'] = end_lat
      query_params[:'endLng'] = end_lng
      query_params[:'endDate'] = end_date
      query_params[:'deviceId'] = opts[:'device_id'] if !opts[:'device_id'].nil?
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'distance'] = opts[:'distance'] if !opts[:'distance'].nil?
      query_params[:'duration'] = opts[:'duration'] if !opts[:'duration'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TrackingApi.save_tracking_step",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TrackingApi#save_tracking_step\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Tracking
    # Search for all accounts that have tracking legs data by the given constraints.
    # @param account_id [Integer] The account id of the user
    # @param [Hash] opts the optional parameters
    # @option opts [String] :keyword Used for LIKE search of first or last name on the acocunt
    # @option opts [Integer] :start_date Range to begin in UTC milliseconds
    # @option opts [Integer] :end_date Range to end in UTC milliseconds
    # @option opts [String] :tags Exact match on tag field of Legs&#39;s searchTag
    # @option opts [String] :audience_ids 
    # @option opts [Float] :latitude Origin latitude to perform searching constraints with given range
    # @option opts [Float] :longitude Origin longitude to perform searching constraints with given range
    # @option opts [Float] :range The radius, in miles, to perform the search for (default to 5)
    # @option opts [String] :sort_field The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (default to 'LEG_START_DATE')
    # @option opts [Boolean] :descending The order to return the results. Default is false, which will return the results in ascending order. (default to true)
    # @option opts [Integer] :start The index into the record set to start with. Default is 0. (default to 0)
    # @option opts [Integer] :limit The total number of records to return. Default is 20. (default to 20)
    # @option opts [Boolean] :active_only Determines whether to return only active results. Default is false. (default to false)
    # @return [Array<AccountMiniResponse>]
    def search_accounts_with_tracking_legs(account_id, opts = {})
      data, _status_code, _headers = search_accounts_with_tracking_legs_with_http_info(account_id, opts)
      data
    end

    # List Tracking
    # Search for all accounts that have tracking legs data by the given constraints.
    # @param account_id [Integer] The account id of the user
    # @param [Hash] opts the optional parameters
    # @option opts [String] :keyword Used for LIKE search of first or last name on the acocunt
    # @option opts [Integer] :start_date Range to begin in UTC milliseconds
    # @option opts [Integer] :end_date Range to end in UTC milliseconds
    # @option opts [String] :tags Exact match on tag field of Legs&#39;s searchTag
    # @option opts [String] :audience_ids 
    # @option opts [Float] :latitude Origin latitude to perform searching constraints with given range
    # @option opts [Float] :longitude Origin longitude to perform searching constraints with given range
    # @option opts [Float] :range The radius, in miles, to perform the search for (default to 5)
    # @option opts [String] :sort_field The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (default to 'LEG_START_DATE')
    # @option opts [Boolean] :descending The order to return the results. Default is false, which will return the results in ascending order. (default to true)
    # @option opts [Integer] :start The index into the record set to start with. Default is 0. (default to 0)
    # @option opts [Integer] :limit The total number of records to return. Default is 20. (default to 20)
    # @option opts [Boolean] :active_only Determines whether to return only active results. Default is false. (default to false)
    # @return [Array<(Array<AccountMiniResponse>, Integer, Hash)>] Array<AccountMiniResponse> data, response status code and response headers
    def search_accounts_with_tracking_legs_with_http_info(account_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TrackingApi.search_accounts_with_tracking_legs ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling TrackingApi.search_accounts_with_tracking_legs"
      end
      # resource path
      local_var_path = '/tracking/list'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'keyword'] = opts[:'keyword'] if !opts[:'keyword'].nil?
      query_params[:'startDate'] = opts[:'start_date'] if !opts[:'start_date'].nil?
      query_params[:'endDate'] = opts[:'end_date'] if !opts[:'end_date'].nil?
      query_params[:'tags'] = opts[:'tags'] if !opts[:'tags'].nil?
      query_params[:'audienceIds'] = opts[:'audience_ids'] if !opts[:'audience_ids'].nil?
      query_params[:'latitude'] = opts[:'latitude'] if !opts[:'latitude'].nil?
      query_params[:'longitude'] = opts[:'longitude'] if !opts[:'longitude'].nil?
      query_params[:'range'] = opts[:'range'] if !opts[:'range'].nil?
      query_params[:'sortField'] = opts[:'sort_field'] if !opts[:'sort_field'].nil?
      query_params[:'descending'] = opts[:'descending'] if !opts[:'descending'].nil?
      query_params[:'start'] = opts[:'start'] if !opts[:'start'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'activeOnly'] = opts[:'active_only'] if !opts[:'active_only'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<AccountMiniResponse>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TrackingApi.search_accounts_with_tracking_legs",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TrackingApi#search_accounts_with_tracking_legs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Search Tracking (Billable)
    # Retrieve tracking data for billable/account scoped queries.
    # @param account_id [Integer] The account id to search tracking for
    # @param app_key [String] The application key
    # @param [Hash] opts the optional parameters
    # @option opts [String] :tracking_device_id The id of the tracking device
    # @option opts [Integer] :start_date The start date in (UTC milliseconds) to filter the tracking results
    # @option opts [Integer] :end_date The end date in (UTC milliseconds) to filter the tracking results
    # @option opts [String] :tags Filter results by tag
    # @option opts [Integer] :start The start index for pagination (default to 0)
    # @option opts [Integer] :limit The limit for pagination (default to 100)
    # @return [Array<LegResponse>]
    def search_tracking_legs(account_id, app_key, opts = {})
      data, _status_code, _headers = search_tracking_legs_with_http_info(account_id, app_key, opts)
      data
    end

    # Search Tracking (Billable)
    # Retrieve tracking data for billable/account scoped queries.
    # @param account_id [Integer] The account id to search tracking for
    # @param app_key [String] The application key
    # @param [Hash] opts the optional parameters
    # @option opts [String] :tracking_device_id The id of the tracking device
    # @option opts [Integer] :start_date The start date in (UTC milliseconds) to filter the tracking results
    # @option opts [Integer] :end_date The end date in (UTC milliseconds) to filter the tracking results
    # @option opts [String] :tags Filter results by tag
    # @option opts [Integer] :start The start index for pagination (default to 0)
    # @option opts [Integer] :limit The limit for pagination (default to 100)
    # @return [Array<(Array<LegResponse>, Integer, Hash)>] Array<LegResponse> data, response status code and response headers
    def search_tracking_legs_with_http_info(account_id, app_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TrackingApi.search_tracking_legs ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling TrackingApi.search_tracking_legs"
      end
      # verify the required parameter 'app_key' is set
      if @api_client.config.client_side_validation && app_key.nil?
        fail ArgumentError, "Missing the required parameter 'app_key' when calling TrackingApi.search_tracking_legs"
      end
      # resource path
      local_var_path = '/tracking/searchByBillable'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'appKey'] = app_key
      query_params[:'trackingDeviceId'] = opts[:'tracking_device_id'] if !opts[:'tracking_device_id'].nil?
      query_params[:'startDate'] = opts[:'start_date'] if !opts[:'start_date'].nil?
      query_params[:'endDate'] = opts[:'end_date'] if !opts[:'end_date'].nil?
      query_params[:'tags'] = opts[:'tags'] if !opts[:'tags'].nil?
      query_params[:'start'] = opts[:'start'] if !opts[:'start'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<LegResponse>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TrackingApi.search_tracking_legs",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TrackingApi#search_tracking_legs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
