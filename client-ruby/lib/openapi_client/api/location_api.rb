=begin
#Sirqul IoT Platform

#Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

The version of the OpenAPI document: 3.16
Contact: info@sirqul.com
Generated by: https://openapi-generator.tech
Generator version: 7.20.0-SNAPSHOT

=end

require 'cgi'

module OpenapiClient
  class LocationApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Create Trilateration Data with File
    # Creates trilateration samples for a source device (i.e. a router).
    # @param udid [String] The unique identifier of the source device
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :source_time The current timestamp of the source device
    # @option opts [Integer] :minimum_sample_size the minimum number of Edysen devices that must be used to be able to trilaterate a device
    # @option opts [String] :data The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;:\&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;: \&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60; 
    # @option opts [File] :data_file Binary file containing data (multipart upload)
    # @return [SirqulResponse]
    def cache_trilateration_data(udid, opts = {})
      data, _status_code, _headers = cache_trilateration_data_with_http_info(udid, opts)
      data
    end

    # Create Trilateration Data with File
    # Creates trilateration samples for a source device (i.e. a router).
    # @param udid [String] The unique identifier of the source device
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :source_time The current timestamp of the source device
    # @option opts [Integer] :minimum_sample_size the minimum number of Edysen devices that must be used to be able to trilaterate a device
    # @option opts [String] :data The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;:\&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;randomizedId\&quot;: true,        \&quot;deviceSignature\&quot;: \&quot;probe:xyz...\&quot;,        \&quot;alternativeId\&quot;: \&quot;adc123\&quot;,        \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60; 
    # @option opts [File] :data_file Binary file containing data (multipart upload)
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def cache_trilateration_data_with_http_info(udid, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: LocationApi.cache_trilateration_data ...'
      end
      # verify the required parameter 'udid' is set
      if @api_client.config.client_side_validation && udid.nil?
        fail ArgumentError, "Missing the required parameter 'udid' when calling LocationApi.cache_trilateration_data"
      end
      # resource path
      local_var_path = '/location/trilaterate/cache'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'udid'] = udid
      query_params[:'sourceTime'] = opts[:'source_time'] if !opts[:'source_time'].nil?
      query_params[:'minimumSampleSize'] = opts[:'minimum_sample_size'] if !opts[:'minimum_sample_size'].nil?
      query_params[:'data'] = opts[:'data'] if !opts[:'data'].nil?
      query_params[:'dataFile'] = opts[:'data_file'] if !opts[:'data_file'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"LocationApi.cache_trilateration_data",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: LocationApi#cache_trilateration_data\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Trilateration Data with Rest
    # Creates trilateration samples for a source device (i.e. a router).
    # @param [Hash] opts the optional parameters
    # @option opts [TrilatCacheRequest] :body 
    # @return [SirqulResponse]
    def cache_trilateration_data_gzip(opts = {})
      data, _status_code, _headers = cache_trilateration_data_gzip_with_http_info(opts)
      data
    end

    # Create Trilateration Data with Rest
    # Creates trilateration samples for a source device (i.e. a router).
    # @param [Hash] opts the optional parameters
    # @option opts [TrilatCacheRequest] :body 
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def cache_trilateration_data_gzip_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: LocationApi.cache_trilateration_data_gzip ...'
      end
      # resource path
      local_var_path = '/location/trilaterate/cache/submit'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'body'])

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"LocationApi.cache_trilateration_data_gzip",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: LocationApi#cache_trilateration_data_gzip\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Location by IP
    # Get location information based on an IP address.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :ip the ip address of the client device
    # @return [CoordsResponse]
    def get_location_by_ip(opts = {})
      data, _status_code, _headers = get_location_by_ip_with_http_info(opts)
      data
    end

    # Get Location by IP
    # Get location information based on an IP address.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :ip the ip address of the client device
    # @return [Array<(CoordsResponse, Integer, Hash)>] CoordsResponse data, response status code and response headers
    def get_location_by_ip_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: LocationApi.get_location_by_ip ...'
      end
      # resource path
      local_var_path = '/location/ip'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'ip'] = opts[:'ip'] if !opts[:'ip'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CoordsResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"LocationApi.get_location_by_ip",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: LocationApi#get_location_by_ip\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Location by Trilateration
    # Send in device data and calculate a position based on signal strengths.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :account_id The account making the request, if provided the last know location will be updated
    # @option opts [Float] :latitude The known GPS latitude to compare to the calculated version
    # @option opts [Float] :longitude The known GPS longitude to compare to the calculated version
    # @option opts [String] :data The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60; 
    # @option opts [String] :response_filters Optional response filters (not used currently)
    # @return [GeoPointResponse]
    def get_location_by_trilateration(opts = {})
      data, _status_code, _headers = get_location_by_trilateration_with_http_info(opts)
      data
    end

    # Get Location by Trilateration
    # Send in device data and calculate a position based on signal strengths.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :account_id The account making the request, if provided the last know location will be updated
    # @option opts [Float] :latitude The known GPS latitude to compare to the calculated version
    # @option opts [Float] :longitude The known GPS longitude to compare to the calculated version
    # @option opts [String] :data The json formated sample data:  &#x60;&#x60;&#x60;json {    \&quot;count\&quot;: 2,   \&quot;timespan\&quot;: 10,    \&quot;samples\&quot;: [     {       \&quot;deviceId\&quot;: \&quot;device1\&quot;,       \&quot;rssi\&quot;: [-63, -75]     },      {       \&quot;deviceId\&quot;: \&quot;device2\&quot;,       \&quot;rssi\&quot;: [-83, -79]     }   ] } &#x60;&#x60;&#x60; 
    # @option opts [String] :response_filters Optional response filters (not used currently)
    # @return [Array<(GeoPointResponse, Integer, Hash)>] GeoPointResponse data, response status code and response headers
    def get_location_by_trilateration_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: LocationApi.get_location_by_trilateration ...'
      end
      # resource path
      local_var_path = '/account/location/trilaterate'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'latitude'] = opts[:'latitude'] if !opts[:'latitude'].nil?
      query_params[:'longitude'] = opts[:'longitude'] if !opts[:'longitude'].nil?
      query_params[:'data'] = opts[:'data'] if !opts[:'data'].nil?
      query_params[:'responseFilters'] = opts[:'response_filters'] if !opts[:'response_filters'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GeoPointResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"LocationApi.get_location_by_trilateration",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: LocationApi#get_location_by_trilateration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Search Regions or Postal Codes
    # Searches geographic locations by proximity via address or keyword.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id the device id
    # @option opts [Integer] :account_id the account id
    # @option opts [Float] :currentlatitude This parameter is deprecated.
    # @option opts [Float] :currentlongitude This parameter is deprecated.
    # @option opts [Float] :current_latitude the current latitude of the user
    # @option opts [Float] :current_longitude the current longitude of the user
    # @option opts [String] :query the query results by keyword or address
    # @option opts [String] :zipcode This parameter is deprecated.
    # @option opts [String] :zip_code the zip code to filter results
    # @option opts [Float] :selected_maplatitude This parameter is deprecated.
    # @option opts [Float] :selected_maplongitude This parameter is deprecated.
    # @option opts [Float] :selected_map_latitude the latitude of where the search should originate from
    # @option opts [Float] :selected_map_longitude the longitude of where the search should originate from
    # @option opts [Float] :search_range the search range of the search in miles (default to 5)
    # @option opts [Boolean] :use_geocode determines whether to allow searches via address (default to false)
    # @option opts [Integer] :_i This parameter is deprecated.
    # @option opts [Integer] :start the start index for pagination (default to 0)
    # @option opts [Integer] :_l This parameter is deprecated.
    # @option opts [Integer] :limit the limit for pagination (default to 20)
    # @return [LocationSearchResponse]
    def get_locations(opts = {})
      data, _status_code, _headers = get_locations_with_http_info(opts)
      data
    end

    # Search Regions or Postal Codes
    # Searches geographic locations by proximity via address or keyword.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id the device id
    # @option opts [Integer] :account_id the account id
    # @option opts [Float] :currentlatitude This parameter is deprecated.
    # @option opts [Float] :currentlongitude This parameter is deprecated.
    # @option opts [Float] :current_latitude the current latitude of the user
    # @option opts [Float] :current_longitude the current longitude of the user
    # @option opts [String] :query the query results by keyword or address
    # @option opts [String] :zipcode This parameter is deprecated.
    # @option opts [String] :zip_code the zip code to filter results
    # @option opts [Float] :selected_maplatitude This parameter is deprecated.
    # @option opts [Float] :selected_maplongitude This parameter is deprecated.
    # @option opts [Float] :selected_map_latitude the latitude of where the search should originate from
    # @option opts [Float] :selected_map_longitude the longitude of where the search should originate from
    # @option opts [Float] :search_range the search range of the search in miles (default to 5)
    # @option opts [Boolean] :use_geocode determines whether to allow searches via address (default to false)
    # @option opts [Integer] :_i This parameter is deprecated.
    # @option opts [Integer] :start the start index for pagination (default to 0)
    # @option opts [Integer] :_l This parameter is deprecated.
    # @option opts [Integer] :limit the limit for pagination (default to 20)
    # @return [Array<(LocationSearchResponse, Integer, Hash)>] LocationSearchResponse data, response status code and response headers
    def get_locations_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: LocationApi.get_locations ...'
      end
      # resource path
      local_var_path = '/location/search'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'deviceId'] = opts[:'device_id'] if !opts[:'device_id'].nil?
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'currentlatitude'] = opts[:'currentlatitude'] if !opts[:'currentlatitude'].nil?
      query_params[:'currentlongitude'] = opts[:'currentlongitude'] if !opts[:'currentlongitude'].nil?
      query_params[:'currentLatitude'] = opts[:'current_latitude'] if !opts[:'current_latitude'].nil?
      query_params[:'currentLongitude'] = opts[:'current_longitude'] if !opts[:'current_longitude'].nil?
      query_params[:'query'] = opts[:'query'] if !opts[:'query'].nil?
      query_params[:'zipcode'] = opts[:'zipcode'] if !opts[:'zipcode'].nil?
      query_params[:'zipCode'] = opts[:'zip_code'] if !opts[:'zip_code'].nil?
      query_params[:'selectedMaplatitude'] = opts[:'selected_maplatitude'] if !opts[:'selected_maplatitude'].nil?
      query_params[:'selectedMaplongitude'] = opts[:'selected_maplongitude'] if !opts[:'selected_maplongitude'].nil?
      query_params[:'selectedMapLatitude'] = opts[:'selected_map_latitude'] if !opts[:'selected_map_latitude'].nil?
      query_params[:'selectedMapLongitude'] = opts[:'selected_map_longitude'] if !opts[:'selected_map_longitude'].nil?
      query_params[:'searchRange'] = opts[:'search_range'] if !opts[:'search_range'].nil?
      query_params[:'useGeocode'] = opts[:'use_geocode'] if !opts[:'use_geocode'].nil?
      query_params[:'_i'] = opts[:'_i'] if !opts[:'_i'].nil?
      query_params[:'start'] = opts[:'start'] if !opts[:'start'].nil?
      query_params[:'_l'] = opts[:'_l'] if !opts[:'_l'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'LocationSearchResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"LocationApi.get_locations",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: LocationApi#get_locations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
