=begin
#Sirqul IoT Platform

#Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

The version of the OpenAPI document: 3.16
Contact: info@sirqul.com
Generated by: https://openapi-generator.tech
Generator version: 7.20.0-SNAPSHOT

=end

require 'cgi'

module OpenapiClient
  class AudienceApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Create Audience
    # Create a user defined audience.
    # @param account_id [Integer] The logged in user.
    # @param name [String] The name of the audience
    # @param [Hash] opts the optional parameters
    # @option opts [String] :description The description of the audience
    # @option opts [String] :search_tags The search tags
    # @option opts [String] :gender The gender; possible values are: MALE, FEMALE, ANY
    # @option opts [String] :age_groups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
    # @option opts [String] :category_ids The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
    # @option opts [String] :application_ids The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
    # @option opts [String] :game_experience_level The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
    # @option opts [String] :devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
    # @option opts [String] :device_ids The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
    # @option opts [String] :device_versions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
    # @option opts [String] :locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
    # @option opts [String] :radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
    # @option opts [Integer] :start_time_offset Seconds from the start time of an event
    # @option opts [Integer] :end_time_offset Seconds from the end time of an event
    # @option opts [Boolean] :send_suggestion If true, then notify matching users when they are inside the radius (default to true)
    # @option opts [String] :associate_description The description of the associated object
    # @option opts [String] :associate_type The type of the object to center the audience geofence
    # @option opts [Integer] :associate_id The ID of the object to center the audience geofence
    # @option opts [String] :grouping_id Optional grouping id for the audience
    # @option opts [String] :meta_data External custom client defined data
    # @option opts [String] :visibility Visibility of the audience
    # @option opts [String] :audience_type Type of audience
    # @option opts [Boolean] :use_order Use order for cohort
    # @option opts [String] :cohort_regions_data Cohort data for \&quot;cohort\&quot; audience type
    # @option opts [String] :app_key Filter results by application key
    # @option opts [String] :trilateration_types Trilateration types
    # @option opts [Boolean] :unique_name If true, makes sure the audience name is unique
    # @return [AudienceResponse]
    def create_audience(account_id, name, opts = {})
      data, _status_code, _headers = create_audience_with_http_info(account_id, name, opts)
      data
    end

    # Create Audience
    # Create a user defined audience.
    # @param account_id [Integer] The logged in user.
    # @param name [String] The name of the audience
    # @param [Hash] opts the optional parameters
    # @option opts [String] :description The description of the audience
    # @option opts [String] :search_tags The search tags
    # @option opts [String] :gender The gender; possible values are: MALE, FEMALE, ANY
    # @option opts [String] :age_groups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
    # @option opts [String] :category_ids The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
    # @option opts [String] :application_ids The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
    # @option opts [String] :game_experience_level The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
    # @option opts [String] :devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
    # @option opts [String] :device_ids The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
    # @option opts [String] :device_versions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
    # @option opts [String] :locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
    # @option opts [String] :radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
    # @option opts [Integer] :start_time_offset Seconds from the start time of an event
    # @option opts [Integer] :end_time_offset Seconds from the end time of an event
    # @option opts [Boolean] :send_suggestion If true, then notify matching users when they are inside the radius (default to true)
    # @option opts [String] :associate_description The description of the associated object
    # @option opts [String] :associate_type The type of the object to center the audience geofence
    # @option opts [Integer] :associate_id The ID of the object to center the audience geofence
    # @option opts [String] :grouping_id Optional grouping id for the audience
    # @option opts [String] :meta_data External custom client defined data
    # @option opts [String] :visibility Visibility of the audience
    # @option opts [String] :audience_type Type of audience
    # @option opts [Boolean] :use_order Use order for cohort
    # @option opts [String] :cohort_regions_data Cohort data for \&quot;cohort\&quot; audience type
    # @option opts [String] :app_key Filter results by application key
    # @option opts [String] :trilateration_types Trilateration types
    # @option opts [Boolean] :unique_name If true, makes sure the audience name is unique
    # @return [Array<(AudienceResponse, Integer, Hash)>] AudienceResponse data, response status code and response headers
    def create_audience_with_http_info(account_id, name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AudienceApi.create_audience ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling AudienceApi.create_audience"
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling AudienceApi.create_audience"
      end
      # resource path
      local_var_path = '/audience/create'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'name'] = name
      query_params[:'description'] = opts[:'description'] if !opts[:'description'].nil?
      query_params[:'searchTags'] = opts[:'search_tags'] if !opts[:'search_tags'].nil?
      query_params[:'gender'] = opts[:'gender'] if !opts[:'gender'].nil?
      query_params[:'ageGroups'] = opts[:'age_groups'] if !opts[:'age_groups'].nil?
      query_params[:'categoryIds'] = opts[:'category_ids'] if !opts[:'category_ids'].nil?
      query_params[:'applicationIds'] = opts[:'application_ids'] if !opts[:'application_ids'].nil?
      query_params[:'gameExperienceLevel'] = opts[:'game_experience_level'] if !opts[:'game_experience_level'].nil?
      query_params[:'devices'] = opts[:'devices'] if !opts[:'devices'].nil?
      query_params[:'deviceIds'] = opts[:'device_ids'] if !opts[:'device_ids'].nil?
      query_params[:'deviceVersions'] = opts[:'device_versions'] if !opts[:'device_versions'].nil?
      query_params[:'locations'] = opts[:'locations'] if !opts[:'locations'].nil?
      query_params[:'radius'] = opts[:'radius'] if !opts[:'radius'].nil?
      query_params[:'startTimeOffset'] = opts[:'start_time_offset'] if !opts[:'start_time_offset'].nil?
      query_params[:'endTimeOffset'] = opts[:'end_time_offset'] if !opts[:'end_time_offset'].nil?
      query_params[:'sendSuggestion'] = opts[:'send_suggestion'] if !opts[:'send_suggestion'].nil?
      query_params[:'associateDescription'] = opts[:'associate_description'] if !opts[:'associate_description'].nil?
      query_params[:'associateType'] = opts[:'associate_type'] if !opts[:'associate_type'].nil?
      query_params[:'associateId'] = opts[:'associate_id'] if !opts[:'associate_id'].nil?
      query_params[:'groupingId'] = opts[:'grouping_id'] if !opts[:'grouping_id'].nil?
      query_params[:'metaData'] = opts[:'meta_data'] if !opts[:'meta_data'].nil?
      query_params[:'visibility'] = opts[:'visibility'] if !opts[:'visibility'].nil?
      query_params[:'audienceType'] = opts[:'audience_type'] if !opts[:'audience_type'].nil?
      query_params[:'useOrder'] = opts[:'use_order'] if !opts[:'use_order'].nil?
      query_params[:'cohortRegionsData'] = opts[:'cohort_regions_data'] if !opts[:'cohort_regions_data'].nil?
      query_params[:'appKey'] = opts[:'app_key'] if !opts[:'app_key'].nil?
      query_params[:'trilaterationTypes'] = opts[:'trilateration_types'] if !opts[:'trilateration_types'].nil?
      query_params[:'uniqueName'] = opts[:'unique_name'] if !opts[:'unique_name'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'AudienceResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AudienceApi.create_audience",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AudienceApi#create_audience\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Audience
    # Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.
    # @param account_id [Integer] The logged in user.
    # @param audience_id [Integer] The id of the audience to delete.
    # @param [Hash] opts the optional parameters
    # @return [SirqulResponse]
    def delete_audience(account_id, audience_id, opts = {})
      data, _status_code, _headers = delete_audience_with_http_info(account_id, audience_id, opts)
      data
    end

    # Delete Audience
    # Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.
    # @param account_id [Integer] The logged in user.
    # @param audience_id [Integer] The id of the audience to delete.
    # @param [Hash] opts the optional parameters
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def delete_audience_with_http_info(account_id, audience_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AudienceApi.delete_audience ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling AudienceApi.delete_audience"
      end
      # verify the required parameter 'audience_id' is set
      if @api_client.config.client_side_validation && audience_id.nil?
        fail ArgumentError, "Missing the required parameter 'audience_id' when calling AudienceApi.delete_audience"
      end
      # resource path
      local_var_path = '/audience/delete'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'audienceId'] = audience_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AudienceApi.delete_audience",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AudienceApi#delete_audience\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Age Groups
    # Gets the list of available age groups that can be selected by consumers and retailers targeting offers.
    # @param [Hash] opts the optional parameters
    # @return [Array<AgeGroupResponse>]
    def get_age_groups(opts = {})
      data, _status_code, _headers = get_age_groups_with_http_info(opts)
      data
    end

    # Get Age Groups
    # Gets the list of available age groups that can be selected by consumers and retailers targeting offers.
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<AgeGroupResponse>, Integer, Hash)>] Array<AgeGroupResponse> data, response status code and response headers
    def get_age_groups_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AudienceApi.get_age_groups ...'
      end
      # resource path
      local_var_path = '/audience/ageGroups'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<AgeGroupResponse>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AudienceApi.get_age_groups",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AudienceApi#get_age_groups\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Audience
    # Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.
    # @param account_id [Integer] The logged in user.
    # @param audience_id [Integer] The id of the audience to return.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :app_key The application key (optional). If provided, results may be scoped to this application.
    # @option opts [Boolean] :return_account_count (boolean) set to true to include the accountCount associated with current audience of the current app (default to false)
    # @option opts [Boolean] :return_album_count (boolean) set to true to include the albumCount associated with current audience of the current app (default to false)
    # @option opts [String] :album_types_for_count (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned.
    # @return [AudienceResponse]
    def get_audience(account_id, audience_id, opts = {})
      data, _status_code, _headers = get_audience_with_http_info(account_id, audience_id, opts)
      data
    end

    # Get Audience
    # Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.
    # @param account_id [Integer] The logged in user.
    # @param audience_id [Integer] The id of the audience to return.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :app_key The application key (optional). If provided, results may be scoped to this application.
    # @option opts [Boolean] :return_account_count (boolean) set to true to include the accountCount associated with current audience of the current app (default to false)
    # @option opts [Boolean] :return_album_count (boolean) set to true to include the albumCount associated with current audience of the current app (default to false)
    # @option opts [String] :album_types_for_count (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned.
    # @return [Array<(AudienceResponse, Integer, Hash)>] AudienceResponse data, response status code and response headers
    def get_audience_with_http_info(account_id, audience_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AudienceApi.get_audience ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling AudienceApi.get_audience"
      end
      # verify the required parameter 'audience_id' is set
      if @api_client.config.client_side_validation && audience_id.nil?
        fail ArgumentError, "Missing the required parameter 'audience_id' when calling AudienceApi.get_audience"
      end
      # resource path
      local_var_path = '/audience/get'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'audienceId'] = audience_id
      query_params[:'appKey'] = opts[:'app_key'] if !opts[:'app_key'].nil?
      query_params[:'returnAccountCount'] = opts[:'return_account_count'] if !opts[:'return_account_count'].nil?
      query_params[:'returnAlbumCount'] = opts[:'return_album_count'] if !opts[:'return_album_count'].nil?
      query_params[:'albumTypesForCount'] = opts[:'album_types_for_count'] if !opts[:'album_types_for_count'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'AudienceResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AudienceApi.get_audience",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AudienceApi#get_audience\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Search Audiences
    # Get the list audiences owned by the account
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :account_id The logged in user.
    # @option opts [String] :album_ids Comma separated list of album IDs to filter results with
    # @option opts [String] :keyword The keyword used to search
    # @option opts [String] :keyword_fields Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY (default to 'SEARCH_TAGS,NAME,DESCRIPTION')
    # @option opts [String] :sort_field The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER} (default to 'NAME')
    # @option opts [Boolean] :descending The order to return the results. Default is false, which will return the results in ascending order. (default to false)
    # @option opts [Integer] :start The index into the record set to start with. (default to 0)
    # @option opts [Integer] :limit The total number of record to return (there is a hard limit of 100). (default to 20)
    # @option opts [Boolean] :send_suggestion Filter results based on whether or not the audience is set to send suggestions
    # @option opts [Boolean] :active_only Determines whether to return only active results. Default is false.
    # @option opts [Boolean] :group_by_grouping_id Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)
    # @option opts [String] :app_key Filter results by application key
    # @option opts [Boolean] :return_global If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well
    # @option opts [Boolean] :exact_keyword If true, match keyword exactly
    # @option opts [String] :audience_type (Deprecated) Filter results by audience type
    # @option opts [String] :audience_types comma separated string with the different audience types you want to filter for
    # @option opts [Boolean] :return_account_count (boolean) set to true to include the accountCount associated with current audience of the current app (default to false)
    # @option opts [Boolean] :return_album_count (boolean) set to true to include the albumCount associated with current audience of the current app (default to false)
    # @option opts [String] :album_types_for_count (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned.
    # @return [Array<SearchResponse>]
    def get_audience_list(opts = {})
      data, _status_code, _headers = get_audience_list_with_http_info(opts)
      data
    end

    # Search Audiences
    # Get the list audiences owned by the account
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :account_id The logged in user.
    # @option opts [String] :album_ids Comma separated list of album IDs to filter results with
    # @option opts [String] :keyword The keyword used to search
    # @option opts [String] :keyword_fields Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY (default to 'SEARCH_TAGS,NAME,DESCRIPTION')
    # @option opts [String] :sort_field The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER} (default to 'NAME')
    # @option opts [Boolean] :descending The order to return the results. Default is false, which will return the results in ascending order. (default to false)
    # @option opts [Integer] :start The index into the record set to start with. (default to 0)
    # @option opts [Integer] :limit The total number of record to return (there is a hard limit of 100). (default to 20)
    # @option opts [Boolean] :send_suggestion Filter results based on whether or not the audience is set to send suggestions
    # @option opts [Boolean] :active_only Determines whether to return only active results. Default is false.
    # @option opts [Boolean] :group_by_grouping_id Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)
    # @option opts [String] :app_key Filter results by application key
    # @option opts [Boolean] :return_global If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well
    # @option opts [Boolean] :exact_keyword If true, match keyword exactly
    # @option opts [String] :audience_type (Deprecated) Filter results by audience type
    # @option opts [String] :audience_types comma separated string with the different audience types you want to filter for
    # @option opts [Boolean] :return_account_count (boolean) set to true to include the accountCount associated with current audience of the current app (default to false)
    # @option opts [Boolean] :return_album_count (boolean) set to true to include the albumCount associated with current audience of the current app (default to false)
    # @option opts [String] :album_types_for_count (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned.
    # @return [Array<(Array<SearchResponse>, Integer, Hash)>] Array<SearchResponse> data, response status code and response headers
    def get_audience_list_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AudienceApi.get_audience_list ...'
      end
      allowable_values = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "NAME", "DESCRIPTION", "SEND_SUGGESTION", "OWNER_ID", "OWNER_DISPLAY", "GENDER"]
      if @api_client.config.client_side_validation && opts[:'sort_field'] && !allowable_values.include?(opts[:'sort_field'])
        fail ArgumentError, "invalid value for \"sort_field\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/audience/search'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'albumIds'] = opts[:'album_ids'] if !opts[:'album_ids'].nil?
      query_params[:'keyword'] = opts[:'keyword'] if !opts[:'keyword'].nil?
      query_params[:'keywordFields'] = opts[:'keyword_fields'] if !opts[:'keyword_fields'].nil?
      query_params[:'sortField'] = opts[:'sort_field'] if !opts[:'sort_field'].nil?
      query_params[:'descending'] = opts[:'descending'] if !opts[:'descending'].nil?
      query_params[:'start'] = opts[:'start'] if !opts[:'start'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'sendSuggestion'] = opts[:'send_suggestion'] if !opts[:'send_suggestion'].nil?
      query_params[:'activeOnly'] = opts[:'active_only'] if !opts[:'active_only'].nil?
      query_params[:'groupByGroupingId'] = opts[:'group_by_grouping_id'] if !opts[:'group_by_grouping_id'].nil?
      query_params[:'appKey'] = opts[:'app_key'] if !opts[:'app_key'].nil?
      query_params[:'returnGlobal'] = opts[:'return_global'] if !opts[:'return_global'].nil?
      query_params[:'exactKeyword'] = opts[:'exact_keyword'] if !opts[:'exact_keyword'].nil?
      query_params[:'audienceType'] = opts[:'audience_type'] if !opts[:'audience_type'].nil?
      query_params[:'audienceTypes'] = opts[:'audience_types'] if !opts[:'audience_types'].nil?
      query_params[:'returnAccountCount'] = opts[:'return_account_count'] if !opts[:'return_account_count'].nil?
      query_params[:'returnAlbumCount'] = opts[:'return_album_count'] if !opts[:'return_album_count'].nil?
      query_params[:'albumTypesForCount'] = opts[:'album_types_for_count'] if !opts[:'album_types_for_count'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<SearchResponse>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AudienceApi.get_audience_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AudienceApi#get_audience_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Devices
    # Gets the list of available devices that can be selected by consumers and retailers.
    # @param include_inactive [Boolean] If true return inactive record as well. default is false.
    # @param [Hash] opts the optional parameters
    # @return [Array<AudienceDeviceResponse>]
    def get_devices(include_inactive, opts = {})
      data, _status_code, _headers = get_devices_with_http_info(include_inactive, opts)
      data
    end

    # Get Devices
    # Gets the list of available devices that can be selected by consumers and retailers.
    # @param include_inactive [Boolean] If true return inactive record as well. default is false.
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<AudienceDeviceResponse>, Integer, Hash)>] Array<AudienceDeviceResponse> data, response status code and response headers
    def get_devices_with_http_info(include_inactive, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AudienceApi.get_devices ...'
      end
      # verify the required parameter 'include_inactive' is set
      if @api_client.config.client_side_validation && include_inactive.nil?
        fail ArgumentError, "Missing the required parameter 'include_inactive' when calling AudienceApi.get_devices"
      end
      # resource path
      local_var_path = '/audience/devices'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'includeInactive'] = include_inactive

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<AudienceDeviceResponse>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AudienceApi.get_devices",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AudienceApi#get_devices\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Experiences
    # Gets the list of available experiences that can be selected by consumers and retailers.
    # @param [Hash] opts the optional parameters
    # @return [SirqulResponse]
    def get_experiences(opts = {})
      data, _status_code, _headers = get_experiences_with_http_info(opts)
      data
    end

    # Get Experiences
    # Gets the list of available experiences that can be selected by consumers and retailers.
    # @param [Hash] opts the optional parameters
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def get_experiences_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AudienceApi.get_experiences ...'
      end
      # resource path
      local_var_path = '/audience/experiences'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AudienceApi.get_experiences",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AudienceApi#get_experiences\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get GroupedAudiences
    # Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.
    # @param account_id [Integer] The logged in user.
    # @param audience_grouping_id [String] The audience grouping id to return.
    # @param [Hash] opts the optional parameters
    # @return [AudienceResponse]
    def get_grouped_audiences(account_id, audience_grouping_id, opts = {})
      data, _status_code, _headers = get_grouped_audiences_with_http_info(account_id, audience_grouping_id, opts)
      data
    end

    # Get GroupedAudiences
    # Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.
    # @param account_id [Integer] The logged in user.
    # @param audience_grouping_id [String] The audience grouping id to return.
    # @param [Hash] opts the optional parameters
    # @return [Array<(AudienceResponse, Integer, Hash)>] AudienceResponse data, response status code and response headers
    def get_grouped_audiences_with_http_info(account_id, audience_grouping_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AudienceApi.get_grouped_audiences ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling AudienceApi.get_grouped_audiences"
      end
      # verify the required parameter 'audience_grouping_id' is set
      if @api_client.config.client_side_validation && audience_grouping_id.nil?
        fail ArgumentError, "Missing the required parameter 'audience_grouping_id' when calling AudienceApi.get_grouped_audiences"
      end
      # resource path
      local_var_path = '/audience/grouped/get'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'audienceGroupingId'] = audience_grouping_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'AudienceResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AudienceApi.get_grouped_audiences",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AudienceApi#get_grouped_audiences\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Suggestions by Audience
    # List either Missions or Offers that the user matches the assigned audience.
    # @param account_id [Integer] The account to match offers for.
    # @param limit [Integer] the limit of the index
    # @param suggestion_type [String] the type of suggestion
    # @param [Hash] opts the optional parameters
    # @return [OfferListResponse]
    def list_by_account(account_id, limit, suggestion_type, opts = {})
      data, _status_code, _headers = list_by_account_with_http_info(account_id, limit, suggestion_type, opts)
      data
    end

    # List Suggestions by Audience
    # List either Missions or Offers that the user matches the assigned audience.
    # @param account_id [Integer] The account to match offers for.
    # @param limit [Integer] the limit of the index
    # @param suggestion_type [String] the type of suggestion
    # @param [Hash] opts the optional parameters
    # @return [Array<(OfferListResponse, Integer, Hash)>] OfferListResponse data, response status code and response headers
    def list_by_account_with_http_info(account_id, limit, suggestion_type, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AudienceApi.list_by_account ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling AudienceApi.list_by_account"
      end
      # verify the required parameter 'limit' is set
      if @api_client.config.client_side_validation && limit.nil?
        fail ArgumentError, "Missing the required parameter 'limit' when calling AudienceApi.list_by_account"
      end
      # verify the required parameter 'suggestion_type' is set
      if @api_client.config.client_side_validation && suggestion_type.nil?
        fail ArgumentError, "Missing the required parameter 'suggestion_type' when calling AudienceApi.list_by_account"
      end
      # resource path
      local_var_path = '/audience/suggestion/list'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'limit'] = limit
      query_params[:'suggestionType'] = suggestion_type

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'OfferListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AudienceApi.list_by_account",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AudienceApi#list_by_account\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Offers by Audience
    # Get a list of offer locations based on audience information provided.
    # @param limit [Integer] this is the limit of the index
    # @param [Hash] opts the optional parameters
    # @option opts [String] :gender this is the gender to list offers by
    # @option opts [Integer] :age this is the age to list offers by
    # @option opts [String] :category_ids this is the category IDs to list offers by
    # @option opts [Float] :latitude this is the latitude to list offers by
    # @option opts [Float] :longitude this is the longitude to list offers by
    # @return [OfferListResponse]
    def list_by_audience(limit, opts = {})
      data, _status_code, _headers = list_by_audience_with_http_info(limit, opts)
      data
    end

    # List Offers by Audience
    # Get a list of offer locations based on audience information provided.
    # @param limit [Integer] this is the limit of the index
    # @param [Hash] opts the optional parameters
    # @option opts [String] :gender this is the gender to list offers by
    # @option opts [Integer] :age this is the age to list offers by
    # @option opts [String] :category_ids this is the category IDs to list offers by
    # @option opts [Float] :latitude this is the latitude to list offers by
    # @option opts [Float] :longitude this is the longitude to list offers by
    # @return [Array<(OfferListResponse, Integer, Hash)>] OfferListResponse data, response status code and response headers
    def list_by_audience_with_http_info(limit, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AudienceApi.list_by_audience ...'
      end
      # verify the required parameter 'limit' is set
      if @api_client.config.client_side_validation && limit.nil?
        fail ArgumentError, "Missing the required parameter 'limit' when calling AudienceApi.list_by_audience"
      end
      # resource path
      local_var_path = '/audience/suggestion/offersByAudience'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'limit'] = limit
      query_params[:'gender'] = opts[:'gender'] if !opts[:'gender'].nil?
      query_params[:'age'] = opts[:'age'] if !opts[:'age'].nil?
      query_params[:'categoryIds'] = opts[:'category_ids'] if !opts[:'category_ids'].nil?
      query_params[:'latitude'] = opts[:'latitude'] if !opts[:'latitude'].nil?
      query_params[:'longitude'] = opts[:'longitude'] if !opts[:'longitude'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'OfferListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AudienceApi.list_by_audience",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AudienceApi#list_by_audience\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Sent Suggestions 
    # Return list of recent trigger suggestions that have been sent to the user.
    # @param account_id [Integer] The account to match offers for.
    # @param timeframe [Integer] The timeframe in seconds of the latest suggestions
    # @param suggestion_type [String] The type of trigger suggestions to return
    # @param [Hash] opts the optional parameters
    # @return [OfferListResponse]
    def list_lastest_by_account(account_id, timeframe, suggestion_type, opts = {})
      data, _status_code, _headers = list_lastest_by_account_with_http_info(account_id, timeframe, suggestion_type, opts)
      data
    end

    # List Sent Suggestions 
    # Return list of recent trigger suggestions that have been sent to the user.
    # @param account_id [Integer] The account to match offers for.
    # @param timeframe [Integer] The timeframe in seconds of the latest suggestions
    # @param suggestion_type [String] The type of trigger suggestions to return
    # @param [Hash] opts the optional parameters
    # @return [Array<(OfferListResponse, Integer, Hash)>] OfferListResponse data, response status code and response headers
    def list_lastest_by_account_with_http_info(account_id, timeframe, suggestion_type, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AudienceApi.list_lastest_by_account ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling AudienceApi.list_lastest_by_account"
      end
      # verify the required parameter 'timeframe' is set
      if @api_client.config.client_side_validation && timeframe.nil?
        fail ArgumentError, "Missing the required parameter 'timeframe' when calling AudienceApi.list_lastest_by_account"
      end
      # verify the required parameter 'suggestion_type' is set
      if @api_client.config.client_side_validation && suggestion_type.nil?
        fail ArgumentError, "Missing the required parameter 'suggestion_type' when calling AudienceApi.list_lastest_by_account"
      end
      # resource path
      local_var_path = '/audience/suggestion/latest'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'timeframe'] = timeframe
      query_params[:'suggestionType'] = suggestion_type

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'OfferListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AudienceApi.list_lastest_by_account",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AudienceApi#list_lastest_by_account\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Send Suggestions
    # Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.
    # @param account_id [Integer] The account to match offers for.
    # @param latitude [Float] the latitude
    # @param longitude [Float] the longitude
    # @param [Hash] opts the optional parameters
    # @return [SirqulResponse]
    def send_by_account(account_id, latitude, longitude, opts = {})
      data, _status_code, _headers = send_by_account_with_http_info(account_id, latitude, longitude, opts)
      data
    end

    # Send Suggestions
    # Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.
    # @param account_id [Integer] The account to match offers for.
    # @param latitude [Float] the latitude
    # @param longitude [Float] the longitude
    # @param [Hash] opts the optional parameters
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def send_by_account_with_http_info(account_id, latitude, longitude, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AudienceApi.send_by_account ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling AudienceApi.send_by_account"
      end
      # verify the required parameter 'latitude' is set
      if @api_client.config.client_side_validation && latitude.nil?
        fail ArgumentError, "Missing the required parameter 'latitude' when calling AudienceApi.send_by_account"
      end
      # verify the required parameter 'longitude' is set
      if @api_client.config.client_side_validation && longitude.nil?
        fail ArgumentError, "Missing the required parameter 'longitude' when calling AudienceApi.send_by_account"
      end
      # resource path
      local_var_path = '/audience/suggestion/send'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'latitude'] = latitude
      query_params[:'longitude'] = longitude

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AudienceApi.send_by_account",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AudienceApi#send_by_account\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Audience
    # Update a user defined audience.
    # @param account_id [Integer] The logged in user.
    # @param audience_id [Integer] The id of the audience to update.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :name The name of the audience
    # @option opts [String] :description The description of the audience
    # @option opts [String] :search_tags The search tags
    # @option opts [String] :gender The gender; possible values are: MALE, FEMALE, ANY
    # @option opts [String] :age_groups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
    # @option opts [String] :category_ids The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
    # @option opts [String] :application_ids The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
    # @option opts [String] :game_experience_level The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
    # @option opts [String] :devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
    # @option opts [String] :device_ids The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
    # @option opts [String] :device_versions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
    # @option opts [String] :locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
    # @option opts [String] :radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
    # @option opts [Boolean] :active if audience is active
    # @option opts [Boolean] :send_suggestion If true, then notify matching users when they are inside the radius
    # @option opts [Integer] :start_time_offset Seconds from the start time of an event
    # @option opts [Integer] :end_time_offset Seconds from the end time of an event
    # @option opts [String] :associate_description the associate description
    # @option opts [String] :associate_type The type of the object to center the audience geofence
    # @option opts [Integer] :associate_id The ID of the object to center the audience geofence
    # @option opts [String] :grouping_id Optional grouping id for the audience
    # @option opts [String] :meta_data External custom client defined data
    # @option opts [String] :visibility Visibility of the audience
    # @option opts [String] :audience_type Type of audience
    # @option opts [Boolean] :use_order Use order for cohort
    # @option opts [String] :cohort_regions_data Cohort data for \&quot;cohort\&quot; audience type
    # @option opts [String] :app_key Filter results by application key
    # @option opts [String] :trilateration_types Trilateration types
    # @option opts [Boolean] :unique_name If true, makes sure the audience name is unique
    # @return [AudienceResponse]
    def update_audience(account_id, audience_id, opts = {})
      data, _status_code, _headers = update_audience_with_http_info(account_id, audience_id, opts)
      data
    end

    # Update Audience
    # Update a user defined audience.
    # @param account_id [Integer] The logged in user.
    # @param audience_id [Integer] The id of the audience to update.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :name The name of the audience
    # @option opts [String] :description The description of the audience
    # @option opts [String] :search_tags The search tags
    # @option opts [String] :gender The gender; possible values are: MALE, FEMALE, ANY
    # @option opts [String] :age_groups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
    # @option opts [String] :category_ids The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
    # @option opts [String] :application_ids The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
    # @option opts [String] :game_experience_level The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
    # @option opts [String] :devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
    # @option opts [String] :device_ids The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
    # @option opts [String] :device_versions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
    # @option opts [String] :locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
    # @option opts [String] :radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
    # @option opts [Boolean] :active if audience is active
    # @option opts [Boolean] :send_suggestion If true, then notify matching users when they are inside the radius
    # @option opts [Integer] :start_time_offset Seconds from the start time of an event
    # @option opts [Integer] :end_time_offset Seconds from the end time of an event
    # @option opts [String] :associate_description the associate description
    # @option opts [String] :associate_type The type of the object to center the audience geofence
    # @option opts [Integer] :associate_id The ID of the object to center the audience geofence
    # @option opts [String] :grouping_id Optional grouping id for the audience
    # @option opts [String] :meta_data External custom client defined data
    # @option opts [String] :visibility Visibility of the audience
    # @option opts [String] :audience_type Type of audience
    # @option opts [Boolean] :use_order Use order for cohort
    # @option opts [String] :cohort_regions_data Cohort data for \&quot;cohort\&quot; audience type
    # @option opts [String] :app_key Filter results by application key
    # @option opts [String] :trilateration_types Trilateration types
    # @option opts [Boolean] :unique_name If true, makes sure the audience name is unique
    # @return [Array<(AudienceResponse, Integer, Hash)>] AudienceResponse data, response status code and response headers
    def update_audience_with_http_info(account_id, audience_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AudienceApi.update_audience ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling AudienceApi.update_audience"
      end
      # verify the required parameter 'audience_id' is set
      if @api_client.config.client_side_validation && audience_id.nil?
        fail ArgumentError, "Missing the required parameter 'audience_id' when calling AudienceApi.update_audience"
      end
      # resource path
      local_var_path = '/audience/update'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'audienceId'] = audience_id
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'description'] = opts[:'description'] if !opts[:'description'].nil?
      query_params[:'searchTags'] = opts[:'search_tags'] if !opts[:'search_tags'].nil?
      query_params[:'gender'] = opts[:'gender'] if !opts[:'gender'].nil?
      query_params[:'ageGroups'] = opts[:'age_groups'] if !opts[:'age_groups'].nil?
      query_params[:'categoryIds'] = opts[:'category_ids'] if !opts[:'category_ids'].nil?
      query_params[:'applicationIds'] = opts[:'application_ids'] if !opts[:'application_ids'].nil?
      query_params[:'gameExperienceLevel'] = opts[:'game_experience_level'] if !opts[:'game_experience_level'].nil?
      query_params[:'devices'] = opts[:'devices'] if !opts[:'devices'].nil?
      query_params[:'deviceIds'] = opts[:'device_ids'] if !opts[:'device_ids'].nil?
      query_params[:'deviceVersions'] = opts[:'device_versions'] if !opts[:'device_versions'].nil?
      query_params[:'locations'] = opts[:'locations'] if !opts[:'locations'].nil?
      query_params[:'radius'] = opts[:'radius'] if !opts[:'radius'].nil?
      query_params[:'active'] = opts[:'active'] if !opts[:'active'].nil?
      query_params[:'sendSuggestion'] = opts[:'send_suggestion'] if !opts[:'send_suggestion'].nil?
      query_params[:'startTimeOffset'] = opts[:'start_time_offset'] if !opts[:'start_time_offset'].nil?
      query_params[:'endTimeOffset'] = opts[:'end_time_offset'] if !opts[:'end_time_offset'].nil?
      query_params[:'associateDescription'] = opts[:'associate_description'] if !opts[:'associate_description'].nil?
      query_params[:'associateType'] = opts[:'associate_type'] if !opts[:'associate_type'].nil?
      query_params[:'associateId'] = opts[:'associate_id'] if !opts[:'associate_id'].nil?
      query_params[:'groupingId'] = opts[:'grouping_id'] if !opts[:'grouping_id'].nil?
      query_params[:'metaData'] = opts[:'meta_data'] if !opts[:'meta_data'].nil?
      query_params[:'visibility'] = opts[:'visibility'] if !opts[:'visibility'].nil?
      query_params[:'audienceType'] = opts[:'audience_type'] if !opts[:'audience_type'].nil?
      query_params[:'useOrder'] = opts[:'use_order'] if !opts[:'use_order'].nil?
      query_params[:'cohortRegionsData'] = opts[:'cohort_regions_data'] if !opts[:'cohort_regions_data'].nil?
      query_params[:'appKey'] = opts[:'app_key'] if !opts[:'app_key'].nil?
      query_params[:'trilaterationTypes'] = opts[:'trilateration_types'] if !opts[:'trilateration_types'].nil?
      query_params[:'uniqueName'] = opts[:'unique_name'] if !opts[:'unique_name'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'AudienceResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AudienceApi.update_audience",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AudienceApi#update_audience\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
