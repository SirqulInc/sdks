=begin
#Sirqul IoT Platform

#Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

The version of the OpenAPI document: 3.16
Contact: info@sirqul.com
Generated by: https://openapi-generator.tech
Generator version: 7.20.0-SNAPSHOT

=end

require 'cgi'

module OpenapiClient
  class NotificationApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Create Notification Template
    # Create a notification template. Developers will only be able to create notification templates for their own applications.
    # @param account_id [Integer] The account ID of the user.
    # @param conduit [String] Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
    # @param title [String] title of the notification template
    # @param body [String] body of the notification template
    # @param [Hash] opts the optional parameters
    # @option opts [String] :app_key Filter results by application.
    # @option opts [String] :event Filter results by event.
    # @option opts [String] :tags tags associated with the note template
    # @return [NotificationTemplateResponse]
    def create_notification_template(account_id, conduit, title, body, opts = {})
      data, _status_code, _headers = create_notification_template_with_http_info(account_id, conduit, title, body, opts)
      data
    end

    # Create Notification Template
    # Create a notification template. Developers will only be able to create notification templates for their own applications.
    # @param account_id [Integer] The account ID of the user.
    # @param conduit [String] Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
    # @param title [String] title of the notification template
    # @param body [String] body of the notification template
    # @param [Hash] opts the optional parameters
    # @option opts [String] :app_key Filter results by application.
    # @option opts [String] :event Filter results by event.
    # @option opts [String] :tags tags associated with the note template
    # @return [Array<(NotificationTemplateResponse, Integer, Hash)>] NotificationTemplateResponse data, response status code and response headers
    def create_notification_template_with_http_info(account_id, conduit, title, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: NotificationApi.create_notification_template ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling NotificationApi.create_notification_template"
      end
      # verify the required parameter 'conduit' is set
      if @api_client.config.client_side_validation && conduit.nil?
        fail ArgumentError, "Missing the required parameter 'conduit' when calling NotificationApi.create_notification_template"
      end
      # verify the required parameter 'title' is set
      if @api_client.config.client_side_validation && title.nil?
        fail ArgumentError, "Missing the required parameter 'title' when calling NotificationApi.create_notification_template"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling NotificationApi.create_notification_template"
      end
      # resource path
      local_var_path = '/notification/template/create'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'conduit'] = conduit
      query_params[:'title'] = title
      query_params[:'body'] = body
      query_params[:'appKey'] = opts[:'app_key'] if !opts[:'app_key'].nil?
      query_params[:'event'] = opts[:'event'] if !opts[:'event'].nil?
      query_params[:'tags'] = opts[:'tags'] if !opts[:'tags'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'NotificationTemplateResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"NotificationApi.create_notification_template",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NotificationApi#create_notification_template\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create or update blocked notification settings
    # Create or update blocked notification settings
    # @param app_key [String] The application key
    # @param data [String] batch data payload (application specific)
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :account_id the account id of the user
    # @return [BlockedNotificationResponse]
    def create_or_update_blocked_notifications(app_key, data, opts = {})
      data, _status_code, _headers = create_or_update_blocked_notifications_with_http_info(app_key, data, opts)
      data
    end

    # Create or update blocked notification settings
    # Create or update blocked notification settings
    # @param app_key [String] The application key
    # @param data [String] batch data payload (application specific)
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :account_id the account id of the user
    # @return [Array<(BlockedNotificationResponse, Integer, Hash)>] BlockedNotificationResponse data, response status code and response headers
    def create_or_update_blocked_notifications_with_http_info(app_key, data, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: NotificationApi.create_or_update_blocked_notifications ...'
      end
      # verify the required parameter 'app_key' is set
      if @api_client.config.client_side_validation && app_key.nil?
        fail ArgumentError, "Missing the required parameter 'app_key' when calling NotificationApi.create_or_update_blocked_notifications"
      end
      # verify the required parameter 'data' is set
      if @api_client.config.client_side_validation && data.nil?
        fail ArgumentError, "Missing the required parameter 'data' when calling NotificationApi.create_or_update_blocked_notifications"
      end
      # resource path
      local_var_path = '/notification/blocked/batch'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'appKey'] = app_key
      query_params[:'data'] = data
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'BlockedNotificationResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"NotificationApi.create_or_update_blocked_notifications",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NotificationApi#create_or_update_blocked_notifications\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Notification Template
    # Deletes a notification template. Developers will only be able to delete notification templates for their own applications.
    # @param account_id [Integer] the account id of the user
    # @param notification_template_id [Integer] the id of the notification template to delete
    # @param [Hash] opts the optional parameters
    # @return [NotificationTemplateResponse]
    def delete_notification_template(account_id, notification_template_id, opts = {})
      data, _status_code, _headers = delete_notification_template_with_http_info(account_id, notification_template_id, opts)
      data
    end

    # Delete Notification Template
    # Deletes a notification template. Developers will only be able to delete notification templates for their own applications.
    # @param account_id [Integer] the account id of the user
    # @param notification_template_id [Integer] the id of the notification template to delete
    # @param [Hash] opts the optional parameters
    # @return [Array<(NotificationTemplateResponse, Integer, Hash)>] NotificationTemplateResponse data, response status code and response headers
    def delete_notification_template_with_http_info(account_id, notification_template_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: NotificationApi.delete_notification_template ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling NotificationApi.delete_notification_template"
      end
      # verify the required parameter 'notification_template_id' is set
      if @api_client.config.client_side_validation && notification_template_id.nil?
        fail ArgumentError, "Missing the required parameter 'notification_template_id' when calling NotificationApi.delete_notification_template"
      end
      # resource path
      local_var_path = '/notification/template/delete'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'notificationTemplateId'] = notification_template_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'NotificationTemplateResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"NotificationApi.delete_notification_template",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NotificationApi#delete_notification_template\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Notification Template
    # Get the details of a notification template. Developers will only be able to see notification templates for their own applications.
    # @param account_id [Integer] the id of the account
    # @param notification_template_id [Integer] the id of the notification template to get
    # @param [Hash] opts the optional parameters
    # @return [NotificationTemplateResponse]
    def get_notification_template(account_id, notification_template_id, opts = {})
      data, _status_code, _headers = get_notification_template_with_http_info(account_id, notification_template_id, opts)
      data
    end

    # Get Notification Template
    # Get the details of a notification template. Developers will only be able to see notification templates for their own applications.
    # @param account_id [Integer] the id of the account
    # @param notification_template_id [Integer] the id of the notification template to get
    # @param [Hash] opts the optional parameters
    # @return [Array<(NotificationTemplateResponse, Integer, Hash)>] NotificationTemplateResponse data, response status code and response headers
    def get_notification_template_with_http_info(account_id, notification_template_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: NotificationApi.get_notification_template ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling NotificationApi.get_notification_template"
      end
      # verify the required parameter 'notification_template_id' is set
      if @api_client.config.client_side_validation && notification_template_id.nil?
        fail ArgumentError, "Missing the required parameter 'notification_template_id' when calling NotificationApi.get_notification_template"
      end
      # resource path
      local_var_path = '/notification/template/get'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'notificationTemplateId'] = notification_template_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'NotificationTemplateResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"NotificationApi.get_notification_template",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NotificationApi#get_notification_template\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Notifications
    # Get a list of notifications for a user. If the \"markAsRead\" parameter is set to true, the returned notifications will be marked as \"read\" after the response has been sent. By default, read messages will not be returned, so to see read messages, set \"returnReadMessages\" to true.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id the unique id of the device making the request (deviceId or accountId required)
    # @option opts [Integer] :account_id the account id of the user (deviceId or accountId required)
    # @option opts [Integer] :connection_account_id the account id used to view another person&#39;s notifications
    # @option opts [String] :app_key the application key to filter messages by application
    # @option opts [String] :event_type comma separated list of EVENTS. Filters search results to only include these events. Don&#39;t include this parameter or pass in an empty string to return all event types.
    # @option opts [String] :content_ids comma separated list of content ids to search notifications on
    # @option opts [String] :content_types comma separated list of content types to search notifications on
    # @option opts [String] :parent_ids comma separated list of parent ids to search notifications on
    # @option opts [String] :parent_types comma separated list of parent types to search notifications on
    # @option opts [String] :action_category Action category used to filter notifications
    # @option opts [String] :conduits comma separated list of conduits to search notifications on
    # @option opts [String] :keyword search notifications via keyword
    # @option opts [Boolean] :return_read_messages if set to true, will return notifications that have been marked as read
    # @option opts [Boolean] :mark_as_read if set to true, the returned notifications will be marked as \\\&quot;read\\\&quot; after the response has been sent
    # @option opts [Integer] :from_date filter notifications from this date
    # @option opts [Float] :latitude latitude used to update the user&#39;s current location
    # @option opts [Float] :longitude longitude used to update the user&#39;s current location
    # @option opts [Boolean] :return_sent whether to include notifications sent by the requester in the response
    # @option opts [Boolean] :ignore_flagged whether to ignore flagged notifications
    # @option opts [Integer] :start start of the pagination
    # @option opts [Integer] :limit limit of the pagination
    # @return [NotificationMessageListResponse]
    def get_notifications(opts = {})
      data, _status_code, _headers = get_notifications_with_http_info(opts)
      data
    end

    # Get Notifications
    # Get a list of notifications for a user. If the \&quot;markAsRead\&quot; parameter is set to true, the returned notifications will be marked as \&quot;read\&quot; after the response has been sent. By default, read messages will not be returned, so to see read messages, set \&quot;returnReadMessages\&quot; to true.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id the unique id of the device making the request (deviceId or accountId required)
    # @option opts [Integer] :account_id the account id of the user (deviceId or accountId required)
    # @option opts [Integer] :connection_account_id the account id used to view another person&#39;s notifications
    # @option opts [String] :app_key the application key to filter messages by application
    # @option opts [String] :event_type comma separated list of EVENTS. Filters search results to only include these events. Don&#39;t include this parameter or pass in an empty string to return all event types.
    # @option opts [String] :content_ids comma separated list of content ids to search notifications on
    # @option opts [String] :content_types comma separated list of content types to search notifications on
    # @option opts [String] :parent_ids comma separated list of parent ids to search notifications on
    # @option opts [String] :parent_types comma separated list of parent types to search notifications on
    # @option opts [String] :action_category Action category used to filter notifications
    # @option opts [String] :conduits comma separated list of conduits to search notifications on
    # @option opts [String] :keyword search notifications via keyword
    # @option opts [Boolean] :return_read_messages if set to true, will return notifications that have been marked as read
    # @option opts [Boolean] :mark_as_read if set to true, the returned notifications will be marked as \\\&quot;read\\\&quot; after the response has been sent
    # @option opts [Integer] :from_date filter notifications from this date
    # @option opts [Float] :latitude latitude used to update the user&#39;s current location
    # @option opts [Float] :longitude longitude used to update the user&#39;s current location
    # @option opts [Boolean] :return_sent whether to include notifications sent by the requester in the response
    # @option opts [Boolean] :ignore_flagged whether to ignore flagged notifications
    # @option opts [Integer] :start start of the pagination
    # @option opts [Integer] :limit limit of the pagination
    # @return [Array<(NotificationMessageListResponse, Integer, Hash)>] NotificationMessageListResponse data, response status code and response headers
    def get_notifications_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: NotificationApi.get_notifications ...'
      end
      # resource path
      local_var_path = '/notification/search'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'deviceId'] = opts[:'device_id'] if !opts[:'device_id'].nil?
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'connectionAccountId'] = opts[:'connection_account_id'] if !opts[:'connection_account_id'].nil?
      query_params[:'appKey'] = opts[:'app_key'] if !opts[:'app_key'].nil?
      query_params[:'eventType'] = opts[:'event_type'] if !opts[:'event_type'].nil?
      query_params[:'contentIds'] = opts[:'content_ids'] if !opts[:'content_ids'].nil?
      query_params[:'contentTypes'] = opts[:'content_types'] if !opts[:'content_types'].nil?
      query_params[:'parentIds'] = opts[:'parent_ids'] if !opts[:'parent_ids'].nil?
      query_params[:'parentTypes'] = opts[:'parent_types'] if !opts[:'parent_types'].nil?
      query_params[:'actionCategory'] = opts[:'action_category'] if !opts[:'action_category'].nil?
      query_params[:'conduits'] = opts[:'conduits'] if !opts[:'conduits'].nil?
      query_params[:'keyword'] = opts[:'keyword'] if !opts[:'keyword'].nil?
      query_params[:'returnReadMessages'] = opts[:'return_read_messages'] if !opts[:'return_read_messages'].nil?
      query_params[:'markAsRead'] = opts[:'mark_as_read'] if !opts[:'mark_as_read'].nil?
      query_params[:'fromDate'] = opts[:'from_date'] if !opts[:'from_date'].nil?
      query_params[:'latitude'] = opts[:'latitude'] if !opts[:'latitude'].nil?
      query_params[:'longitude'] = opts[:'longitude'] if !opts[:'longitude'].nil?
      query_params[:'returnSent'] = opts[:'return_sent'] if !opts[:'return_sent'].nil?
      query_params[:'ignoreFlagged'] = opts[:'ignore_flagged'] if !opts[:'ignore_flagged'].nil?
      query_params[:'start'] = opts[:'start'] if !opts[:'start'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'NotificationMessageListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"NotificationApi.get_notifications",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NotificationApi#get_notifications\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Register Notification Token
    # Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.
    # @param token [String] A token that is generated by the device to sign requests for the notification service providers
    # @param push_type [String] The type of push notification. Possible values include: APNS, GCM
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id The unique id of the device making the request (deviceId or accountId required)
    # @option opts [Integer] :account_id The account id of the user (deviceId or accountId required)
    # @option opts [String] :environment Determines if the token is a DEVELOPMENT or PRODUCTION token
    # @option opts [String] :app_key The application key
    # @option opts [String] :game_type This parameter is deprecated (use appKey instead)
    # @option opts [Boolean] :active Sets whether the token is active or not (non-active tokens are not used)
    # @option opts [Float] :latitude Latitude used to update the user&#39;s current location
    # @option opts [Float] :longitude Longitude used to update the user&#39;s current location
    # @return [SirqulResponse]
    def register_notification_token(token, push_type, opts = {})
      data, _status_code, _headers = register_notification_token_with_http_info(token, push_type, opts)
      data
    end

    # Register Notification Token
    # Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.
    # @param token [String] A token that is generated by the device to sign requests for the notification service providers
    # @param push_type [String] The type of push notification. Possible values include: APNS, GCM
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id The unique id of the device making the request (deviceId or accountId required)
    # @option opts [Integer] :account_id The account id of the user (deviceId or accountId required)
    # @option opts [String] :environment Determines if the token is a DEVELOPMENT or PRODUCTION token
    # @option opts [String] :app_key The application key
    # @option opts [String] :game_type This parameter is deprecated (use appKey instead)
    # @option opts [Boolean] :active Sets whether the token is active or not (non-active tokens are not used)
    # @option opts [Float] :latitude Latitude used to update the user&#39;s current location
    # @option opts [Float] :longitude Longitude used to update the user&#39;s current location
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def register_notification_token_with_http_info(token, push_type, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: NotificationApi.register_notification_token ...'
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling NotificationApi.register_notification_token"
      end
      # verify the required parameter 'push_type' is set
      if @api_client.config.client_side_validation && push_type.nil?
        fail ArgumentError, "Missing the required parameter 'push_type' when calling NotificationApi.register_notification_token"
      end
      # verify enum value
      allowable_values = ["APNS", "GCM", "BAIDU", "XGPUSH", "JPUSH"]
      if @api_client.config.client_side_validation && !allowable_values.include?(push_type)
        fail ArgumentError, "invalid value for \"push_type\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/notification/token'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'token'] = token
      query_params[:'pushType'] = push_type
      query_params[:'deviceId'] = opts[:'device_id'] if !opts[:'device_id'].nil?
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'environment'] = opts[:'environment'] if !opts[:'environment'].nil?
      query_params[:'appKey'] = opts[:'app_key'] if !opts[:'app_key'].nil?
      query_params[:'gameType'] = opts[:'game_type'] if !opts[:'game_type'].nil?
      query_params[:'active'] = opts[:'active'] if !opts[:'active'].nil?
      query_params[:'latitude'] = opts[:'latitude'] if !opts[:'latitude'].nil?
      query_params[:'longitude'] = opts[:'longitude'] if !opts[:'longitude'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"NotificationApi.register_notification_token",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NotificationApi#register_notification_token\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Search on the user's blocked notification settings
    # Search on the user's blocked notification settings
    # @param app_key [String] The application key
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :account_id the account id of the user
    # @option opts [String] :search_tags search tags to filter results
    # @option opts [String] :events events to filter by (comma separated)
    # @option opts [String] :conduits conduits to filter by (comma separated)
    # @option opts [String] :custom_types custom types to filter by (comma separated)
    # @option opts [String] :content_types content types to filter by (comma separated)
    # @option opts [String] :content_ids content ids to filter by (comma separated)
    # @option opts [String] :sort_field sort field for results
    # @option opts [Boolean] :descending whether to sort descending
    # @option opts [Integer] :start start of the pagination
    # @option opts [Integer] :limit limit of the pagination
    # @return [BlockedNotificationResponse]
    def search_blocked_notifications(app_key, opts = {})
      data, _status_code, _headers = search_blocked_notifications_with_http_info(app_key, opts)
      data
    end

    # Search on the user&#39;s blocked notification settings
    # Search on the user&#39;s blocked notification settings
    # @param app_key [String] The application key
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :account_id the account id of the user
    # @option opts [String] :search_tags search tags to filter results
    # @option opts [String] :events events to filter by (comma separated)
    # @option opts [String] :conduits conduits to filter by (comma separated)
    # @option opts [String] :custom_types custom types to filter by (comma separated)
    # @option opts [String] :content_types content types to filter by (comma separated)
    # @option opts [String] :content_ids content ids to filter by (comma separated)
    # @option opts [String] :sort_field sort field for results
    # @option opts [Boolean] :descending whether to sort descending
    # @option opts [Integer] :start start of the pagination
    # @option opts [Integer] :limit limit of the pagination
    # @return [Array<(BlockedNotificationResponse, Integer, Hash)>] BlockedNotificationResponse data, response status code and response headers
    def search_blocked_notifications_with_http_info(app_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: NotificationApi.search_blocked_notifications ...'
      end
      # verify the required parameter 'app_key' is set
      if @api_client.config.client_side_validation && app_key.nil?
        fail ArgumentError, "Missing the required parameter 'app_key' when calling NotificationApi.search_blocked_notifications"
      end
      # resource path
      local_var_path = '/notification/blocked/search'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'appKey'] = app_key
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'searchTags'] = opts[:'search_tags'] if !opts[:'search_tags'].nil?
      query_params[:'events'] = opts[:'events'] if !opts[:'events'].nil?
      query_params[:'conduits'] = opts[:'conduits'] if !opts[:'conduits'].nil?
      query_params[:'customTypes'] = opts[:'custom_types'] if !opts[:'custom_types'].nil?
      query_params[:'contentTypes'] = opts[:'content_types'] if !opts[:'content_types'].nil?
      query_params[:'contentIds'] = opts[:'content_ids'] if !opts[:'content_ids'].nil?
      query_params[:'sortField'] = opts[:'sort_field'] if !opts[:'sort_field'].nil?
      query_params[:'descending'] = opts[:'descending'] if !opts[:'descending'].nil?
      query_params[:'start'] = opts[:'start'] if !opts[:'start'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'BlockedNotificationResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"NotificationApi.search_blocked_notifications",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NotificationApi#search_blocked_notifications\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Search Notification Templates
    # Search for notification templates on owned applications.
    # @param account_id [Integer] The account ID of the user.
    # @param sort_field [String] Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name (&#39;global&#39; templates will not have an application and will be returned last if &#39;descending&#39; is set to false.
    # @param descending [Boolean] Specified whether the results are returned in descending or ascending order.
    # @param start [Integer] The start of the pagination.
    # @param limit [Integer] The limit of the pagination.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :app_key Filter results by application.
    # @option opts [String] :event Filter results by event.
    # @option opts [String] :conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
    # @option opts [Boolean] :global_only Returns only templates that have been reserved for system use on all applications (only for admin accounts).
    # @option opts [Boolean] :reserved_only Returns only templates that use reserved events.
    # @option opts [String] :keyword Filter results by keyword on the title, tags.
    # @return [NotificationTemplateResponse]
    def search_notification_template(account_id, sort_field, descending, start, limit, opts = {})
      data, _status_code, _headers = search_notification_template_with_http_info(account_id, sort_field, descending, start, limit, opts)
      data
    end

    # Search Notification Templates
    # Search for notification templates on owned applications.
    # @param account_id [Integer] The account ID of the user.
    # @param sort_field [String] Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name (&#39;global&#39; templates will not have an application and will be returned last if &#39;descending&#39; is set to false.
    # @param descending [Boolean] Specified whether the results are returned in descending or ascending order.
    # @param start [Integer] The start of the pagination.
    # @param limit [Integer] The limit of the pagination.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :app_key Filter results by application.
    # @option opts [String] :event Filter results by event.
    # @option opts [String] :conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
    # @option opts [Boolean] :global_only Returns only templates that have been reserved for system use on all applications (only for admin accounts).
    # @option opts [Boolean] :reserved_only Returns only templates that use reserved events.
    # @option opts [String] :keyword Filter results by keyword on the title, tags.
    # @return [Array<(NotificationTemplateResponse, Integer, Hash)>] NotificationTemplateResponse data, response status code and response headers
    def search_notification_template_with_http_info(account_id, sort_field, descending, start, limit, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: NotificationApi.search_notification_template ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling NotificationApi.search_notification_template"
      end
      # verify the required parameter 'sort_field' is set
      if @api_client.config.client_side_validation && sort_field.nil?
        fail ArgumentError, "Missing the required parameter 'sort_field' when calling NotificationApi.search_notification_template"
      end
      # verify the required parameter 'descending' is set
      if @api_client.config.client_side_validation && descending.nil?
        fail ArgumentError, "Missing the required parameter 'descending' when calling NotificationApi.search_notification_template"
      end
      # verify the required parameter 'start' is set
      if @api_client.config.client_side_validation && start.nil?
        fail ArgumentError, "Missing the required parameter 'start' when calling NotificationApi.search_notification_template"
      end
      # verify the required parameter 'limit' is set
      if @api_client.config.client_side_validation && limit.nil?
        fail ArgumentError, "Missing the required parameter 'limit' when calling NotificationApi.search_notification_template"
      end
      # resource path
      local_var_path = '/notification/template/search'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'sortField'] = sort_field
      query_params[:'descending'] = descending
      query_params[:'start'] = start
      query_params[:'limit'] = limit
      query_params[:'appKey'] = opts[:'app_key'] if !opts[:'app_key'].nil?
      query_params[:'event'] = opts[:'event'] if !opts[:'event'].nil?
      query_params[:'conduit'] = opts[:'conduit'] if !opts[:'conduit'].nil?
      query_params[:'globalOnly'] = opts[:'global_only'] if !opts[:'global_only'].nil?
      query_params[:'reservedOnly'] = opts[:'reserved_only'] if !opts[:'reserved_only'].nil?
      query_params[:'keyword'] = opts[:'keyword'] if !opts[:'keyword'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'NotificationTemplateResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"NotificationApi.search_notification_template",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NotificationApi#search_notification_template\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Search for Recipients
    # Search for application users to send notifications.
    # @param sort_field [String] The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id the unique id of the device making the request (deviceId or accountId required)
    # @option opts [Integer] :account_id the account id of the user (deviceId or accountId required)
    # @option opts [String] :app_key filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
    # @option opts [String] :conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
    # @option opts [String] :keyword search by keyword on user&#39;s display name and email
    # @option opts [Integer] :audience_id This parameter is deprecated. filter results by audience
    # @option opts [String] :audience_ids filter results by audiences (comma separated list of audience ids)
    # @option opts [String] :connection_group_ids filter results by connection groups (comma separated list of connection group ids)
    # @option opts [String] :recipient_account_ids filter results by accounts (comma separated list of account ids)
    # @option opts [Boolean] :descending Determines whether the sorted list is in descending or ascending order
    # @option opts [Integer] :start start of the pagination
    # @option opts [Integer] :limit limit of the pagination (hard limit of 1000)
    # @return [Array<NotificationRecipientResponse>]
    def search_recipients(sort_field, opts = {})
      data, _status_code, _headers = search_recipients_with_http_info(sort_field, opts)
      data
    end

    # Search for Recipients
    # Search for application users to send notifications.
    # @param sort_field [String] The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id the unique id of the device making the request (deviceId or accountId required)
    # @option opts [Integer] :account_id the account id of the user (deviceId or accountId required)
    # @option opts [String] :app_key filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
    # @option opts [String] :conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
    # @option opts [String] :keyword search by keyword on user&#39;s display name and email
    # @option opts [Integer] :audience_id This parameter is deprecated. filter results by audience
    # @option opts [String] :audience_ids filter results by audiences (comma separated list of audience ids)
    # @option opts [String] :connection_group_ids filter results by connection groups (comma separated list of connection group ids)
    # @option opts [String] :recipient_account_ids filter results by accounts (comma separated list of account ids)
    # @option opts [Boolean] :descending Determines whether the sorted list is in descending or ascending order
    # @option opts [Integer] :start start of the pagination
    # @option opts [Integer] :limit limit of the pagination (hard limit of 1000)
    # @return [Array<(Array<NotificationRecipientResponse>, Integer, Hash)>] Array<NotificationRecipientResponse> data, response status code and response headers
    def search_recipients_with_http_info(sort_field, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: NotificationApi.search_recipients ...'
      end
      # verify the required parameter 'sort_field' is set
      if @api_client.config.client_side_validation && sort_field.nil?
        fail ArgumentError, "Missing the required parameter 'sort_field' when calling NotificationApi.search_recipients"
      end
      # verify enum value
      allowable_values = ["ID", "HAS_SMS", "HAS_EMAIL", "HAS_APNS", "HAS_GCM", "APPLICATION_ID", "APPLICATION_NAME", "ACCOUNT_ID", "ACCOUNT_USERNAME", "ACCOUNT_DISPLAY", "ACCOUNT_TYPE"]
      if @api_client.config.client_side_validation && !allowable_values.include?(sort_field)
        fail ArgumentError, "invalid value for \"sort_field\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/notification/recipient/search'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'sortField'] = sort_field
      query_params[:'deviceId'] = opts[:'device_id'] if !opts[:'device_id'].nil?
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'appKey'] = opts[:'app_key'] if !opts[:'app_key'].nil?
      query_params[:'conduit'] = opts[:'conduit'] if !opts[:'conduit'].nil?
      query_params[:'keyword'] = opts[:'keyword'] if !opts[:'keyword'].nil?
      query_params[:'audienceId'] = opts[:'audience_id'] if !opts[:'audience_id'].nil?
      query_params[:'audienceIds'] = opts[:'audience_ids'] if !opts[:'audience_ids'].nil?
      query_params[:'connectionGroupIds'] = opts[:'connection_group_ids'] if !opts[:'connection_group_ids'].nil?
      query_params[:'recipientAccountIds'] = opts[:'recipient_account_ids'] if !opts[:'recipient_account_ids'].nil?
      query_params[:'descending'] = opts[:'descending'] if !opts[:'descending'].nil?
      query_params[:'start'] = opts[:'start'] if !opts[:'start'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<NotificationRecipientResponse>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"NotificationApi.search_recipients",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NotificationApi#search_recipients\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Search for Recipients (Counts/Grouped)
    # Search for application users to send notifications (count/grouped variant).
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id the unique id of the device making the request (deviceId or accountId required)
    # @option opts [Integer] :account_id the account id of the user (deviceId or accountId required)
    # @option opts [String] :app_key filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
    # @option opts [String] :conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
    # @option opts [String] :keyword search by keyword on user&#39;s display name and email
    # @option opts [Integer] :audience_id This parameter is deprecated. filter results by audience
    # @option opts [String] :audience_ids filter results by audiences (comma separated list of audience ids)
    # @option opts [String] :connection_group_ids filter results by connection groups (comma separated list of connection group ids)
    # @option opts [String] :sort_field The field to sort by (see API docs for allowed values).
    # @option opts [Boolean] :descending Determines whether the sorted list is in descending or ascending order
    # @option opts [Integer] :start start of the pagination
    # @option opts [Integer] :limit limit of the pagination
    # @return [NotificationRecipientResponseListResponse]
    def search_recipients_count(opts = {})
      data, _status_code, _headers = search_recipients_count_with_http_info(opts)
      data
    end

    # Search for Recipients (Counts/Grouped)
    # Search for application users to send notifications (count/grouped variant).
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id the unique id of the device making the request (deviceId or accountId required)
    # @option opts [Integer] :account_id the account id of the user (deviceId or accountId required)
    # @option opts [String] :app_key filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
    # @option opts [String] :conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
    # @option opts [String] :keyword search by keyword on user&#39;s display name and email
    # @option opts [Integer] :audience_id This parameter is deprecated. filter results by audience
    # @option opts [String] :audience_ids filter results by audiences (comma separated list of audience ids)
    # @option opts [String] :connection_group_ids filter results by connection groups (comma separated list of connection group ids)
    # @option opts [String] :sort_field The field to sort by (see API docs for allowed values).
    # @option opts [Boolean] :descending Determines whether the sorted list is in descending or ascending order
    # @option opts [Integer] :start start of the pagination
    # @option opts [Integer] :limit limit of the pagination
    # @return [Array<(NotificationRecipientResponseListResponse, Integer, Hash)>] NotificationRecipientResponseListResponse data, response status code and response headers
    def search_recipients_count_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: NotificationApi.search_recipients_count ...'
      end
      # resource path
      local_var_path = '/notification/recipient/search/count'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'deviceId'] = opts[:'device_id'] if !opts[:'device_id'].nil?
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'appKey'] = opts[:'app_key'] if !opts[:'app_key'].nil?
      query_params[:'conduit'] = opts[:'conduit'] if !opts[:'conduit'].nil?
      query_params[:'keyword'] = opts[:'keyword'] if !opts[:'keyword'].nil?
      query_params[:'audienceId'] = opts[:'audience_id'] if !opts[:'audience_id'].nil?
      query_params[:'audienceIds'] = opts[:'audience_ids'] if !opts[:'audience_ids'].nil?
      query_params[:'connectionGroupIds'] = opts[:'connection_group_ids'] if !opts[:'connection_group_ids'].nil?
      query_params[:'sortField'] = opts[:'sort_field'] if !opts[:'sort_field'].nil?
      query_params[:'descending'] = opts[:'descending'] if !opts[:'descending'].nil?
      query_params[:'start'] = opts[:'start'] if !opts[:'start'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'NotificationRecipientResponseListResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"NotificationApi.search_recipients_count",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NotificationApi#search_recipients_count\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Send Batch Notifications
    # Send notifications to all users of an application. Only someone with permissions to the application can do this.
    # @param account_id [Integer] The account id of the application owner/manager
    # @param app_key [String] The application key for updating an existing application
    # @param custom_message [String] Message string that will be displayed in on the notification
    # @param [Hash] opts the optional parameters
    # @option opts [String] :conduit The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
    # @option opts [Integer] :content_id Default notification pay-load field (usage is dependent on the app and the type of event)
    # @option opts [String] :content_name Default notification pay-load field (usage is dependent on the app and the type of event)
    # @option opts [String] :content_type Default notification pay-load field (usage is dependent on the app and the type of event)
    # @option opts [Integer] :parent_id Default notification pay-load field (usage is dependent on the app and the type of event)
    # @option opts [String] :parent_type Default notification pay-load field (usage is dependent on the app and the type of event)
    # @return [SirqulResponse]
    def send_batch_notifications(account_id, app_key, custom_message, opts = {})
      data, _status_code, _headers = send_batch_notifications_with_http_info(account_id, app_key, custom_message, opts)
      data
    end

    # Send Batch Notifications
    # Send notifications to all users of an application. Only someone with permissions to the application can do this.
    # @param account_id [Integer] The account id of the application owner/manager
    # @param app_key [String] The application key for updating an existing application
    # @param custom_message [String] Message string that will be displayed in on the notification
    # @param [Hash] opts the optional parameters
    # @option opts [String] :conduit The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
    # @option opts [Integer] :content_id Default notification pay-load field (usage is dependent on the app and the type of event)
    # @option opts [String] :content_name Default notification pay-load field (usage is dependent on the app and the type of event)
    # @option opts [String] :content_type Default notification pay-load field (usage is dependent on the app and the type of event)
    # @option opts [Integer] :parent_id Default notification pay-load field (usage is dependent on the app and the type of event)
    # @option opts [String] :parent_type Default notification pay-load field (usage is dependent on the app and the type of event)
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def send_batch_notifications_with_http_info(account_id, app_key, custom_message, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: NotificationApi.send_batch_notifications ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling NotificationApi.send_batch_notifications"
      end
      # verify the required parameter 'app_key' is set
      if @api_client.config.client_side_validation && app_key.nil?
        fail ArgumentError, "Missing the required parameter 'app_key' when calling NotificationApi.send_batch_notifications"
      end
      # verify the required parameter 'custom_message' is set
      if @api_client.config.client_side_validation && custom_message.nil?
        fail ArgumentError, "Missing the required parameter 'custom_message' when calling NotificationApi.send_batch_notifications"
      end
      # resource path
      local_var_path = '/notification/batch'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'appKey'] = app_key
      query_params[:'customMessage'] = custom_message
      query_params[:'conduit'] = opts[:'conduit'] if !opts[:'conduit'].nil?
      query_params[:'contentId'] = opts[:'content_id'] if !opts[:'content_id'].nil?
      query_params[:'contentName'] = opts[:'content_name'] if !opts[:'content_name'].nil?
      query_params[:'contentType'] = opts[:'content_type'] if !opts[:'content_type'].nil?
      query_params[:'parentId'] = opts[:'parent_id'] if !opts[:'parent_id'].nil?
      query_params[:'parentType'] = opts[:'parent_type'] if !opts[:'parent_type'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"NotificationApi.send_batch_notifications",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NotificationApi#send_batch_notifications\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Send Custom Notifications
    # Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id the unique id of the device making the request (deviceId or accountId required)
    # @option opts [Integer] :account_id the account id of the user (deviceId or accountId required)
    # @option opts [String] :receiver_account_ids comma separated list of account IDs that will receive the notification
    # @option opts [Boolean] :include_friend_group determines whether to send to all of the user&#39;s friends, this flag must be true or receiverAccountIds must not be empty
    # @option opts [String] :app_key the application key
    # @option opts [String] :game_type This parameter is deprecated.
    # @option opts [String] :conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
    # @option opts [Integer] :content_id default notification pay-load field (usage is dependent on the app and the type of event)
    # @option opts [String] :content_name default notification pay-load field (usage is dependent on the app and the type of event)
    # @option opts [String] :content_type default notification pay-load field (usage is dependent on the app and the type of event)
    # @option opts [Integer] :parent_id default notification pay-load field (usage is dependent on the app and the type of event)
    # @option opts [String] :parent_type default notification pay-load field (usage is dependent on the app and the type of event)
    # @option opts [String] :action_category 
    # @option opts [String] :subject the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)
    # @option opts [String] :custom_message message string that will be displayed in on the notification
    # @option opts [Boolean] :friend_only_apns only sends APNS to people who are friends of the user (still saves the notification message for feed polling)
    # @option opts [Float] :latitude latitude used to update the user&#39;s current location
    # @option opts [Float] :longitude longitude used to update the user&#39;s current location
    # @return [SirqulResponse]
    def send_custom_notifications(opts = {})
      data, _status_code, _headers = send_custom_notifications_with_http_info(opts)
      data
    end

    # Send Custom Notifications
    # Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id the unique id of the device making the request (deviceId or accountId required)
    # @option opts [Integer] :account_id the account id of the user (deviceId or accountId required)
    # @option opts [String] :receiver_account_ids comma separated list of account IDs that will receive the notification
    # @option opts [Boolean] :include_friend_group determines whether to send to all of the user&#39;s friends, this flag must be true or receiverAccountIds must not be empty
    # @option opts [String] :app_key the application key
    # @option opts [String] :game_type This parameter is deprecated.
    # @option opts [String] :conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
    # @option opts [Integer] :content_id default notification pay-load field (usage is dependent on the app and the type of event)
    # @option opts [String] :content_name default notification pay-load field (usage is dependent on the app and the type of event)
    # @option opts [String] :content_type default notification pay-load field (usage is dependent on the app and the type of event)
    # @option opts [Integer] :parent_id default notification pay-load field (usage is dependent on the app and the type of event)
    # @option opts [String] :parent_type default notification pay-load field (usage is dependent on the app and the type of event)
    # @option opts [String] :action_category 
    # @option opts [String] :subject the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)
    # @option opts [String] :custom_message message string that will be displayed in on the notification
    # @option opts [Boolean] :friend_only_apns only sends APNS to people who are friends of the user (still saves the notification message for feed polling)
    # @option opts [Float] :latitude latitude used to update the user&#39;s current location
    # @option opts [Float] :longitude longitude used to update the user&#39;s current location
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def send_custom_notifications_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: NotificationApi.send_custom_notifications ...'
      end
      # resource path
      local_var_path = '/notification/custom'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'deviceId'] = opts[:'device_id'] if !opts[:'device_id'].nil?
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'receiverAccountIds'] = opts[:'receiver_account_ids'] if !opts[:'receiver_account_ids'].nil?
      query_params[:'includeFriendGroup'] = opts[:'include_friend_group'] if !opts[:'include_friend_group'].nil?
      query_params[:'appKey'] = opts[:'app_key'] if !opts[:'app_key'].nil?
      query_params[:'gameType'] = opts[:'game_type'] if !opts[:'game_type'].nil?
      query_params[:'conduit'] = opts[:'conduit'] if !opts[:'conduit'].nil?
      query_params[:'contentId'] = opts[:'content_id'] if !opts[:'content_id'].nil?
      query_params[:'contentName'] = opts[:'content_name'] if !opts[:'content_name'].nil?
      query_params[:'contentType'] = opts[:'content_type'] if !opts[:'content_type'].nil?
      query_params[:'parentId'] = opts[:'parent_id'] if !opts[:'parent_id'].nil?
      query_params[:'parentType'] = opts[:'parent_type'] if !opts[:'parent_type'].nil?
      query_params[:'actionCategory'] = opts[:'action_category'] if !opts[:'action_category'].nil?
      query_params[:'subject'] = opts[:'subject'] if !opts[:'subject'].nil?
      query_params[:'customMessage'] = opts[:'custom_message'] if !opts[:'custom_message'].nil?
      query_params[:'friendOnlyAPNS'] = opts[:'friend_only_apns'] if !opts[:'friend_only_apns'].nil?
      query_params[:'latitude'] = opts[:'latitude'] if !opts[:'latitude'].nil?
      query_params[:'longitude'] = opts[:'longitude'] if !opts[:'longitude'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"NotificationApi.send_custom_notifications",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NotificationApi#send_custom_notifications\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Notification Template
    # Update a notification template. Developers will only be able to update notification templates for their own applications.
    # @param account_id [Integer] The account ID of the user.
    # @param notification_template_id [Integer] The notification template ID to update.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :title The title of the message (this would become the subject title for emails). There is a 191 character limit.
    # @option opts [String] :body The body of the message.
    # @option opts [String] :tags The search tags on the template used during search queries.
    # @return [NotificationTemplateResponse]
    def update_notification_template(account_id, notification_template_id, opts = {})
      data, _status_code, _headers = update_notification_template_with_http_info(account_id, notification_template_id, opts)
      data
    end

    # Update Notification Template
    # Update a notification template. Developers will only be able to update notification templates for their own applications.
    # @param account_id [Integer] The account ID of the user.
    # @param notification_template_id [Integer] The notification template ID to update.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :title The title of the message (this would become the subject title for emails). There is a 191 character limit.
    # @option opts [String] :body The body of the message.
    # @option opts [String] :tags The search tags on the template used during search queries.
    # @return [Array<(NotificationTemplateResponse, Integer, Hash)>] NotificationTemplateResponse data, response status code and response headers
    def update_notification_template_with_http_info(account_id, notification_template_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: NotificationApi.update_notification_template ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling NotificationApi.update_notification_template"
      end
      # verify the required parameter 'notification_template_id' is set
      if @api_client.config.client_side_validation && notification_template_id.nil?
        fail ArgumentError, "Missing the required parameter 'notification_template_id' when calling NotificationApi.update_notification_template"
      end
      # resource path
      local_var_path = '/notification/template/update'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'notificationTemplateId'] = notification_template_id
      query_params[:'title'] = opts[:'title'] if !opts[:'title'].nil?
      query_params[:'body'] = opts[:'body'] if !opts[:'body'].nil?
      query_params[:'tags'] = opts[:'tags'] if !opts[:'tags'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'NotificationTemplateResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"NotificationApi.update_notification_template",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: NotificationApi#update_notification_template\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
