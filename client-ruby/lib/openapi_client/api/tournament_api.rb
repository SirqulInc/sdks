=begin
#Sirqul IoT Platform

#Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

The version of the OpenAPI document: 3.16
Contact: info@sirqul.com
Generated by: https://openapi-generator.tech
Generator version: 7.20.0-SNAPSHOT

=end

require 'cgi'

module OpenapiClient
  class TournamentApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Create Tournament
    # Create a tournament.
    # @param account_id [Integer] The logged in user.
    # @param app_key [String] The appKey the tournament is created for.
    # @param title [String] The title of the tournament
    # @param cost_to_play [Integer] The number of tickets required to pay to enter the tournament
    # @param start_date [Integer] The date/time to start the tournament
    # @param [Hash] opts the optional parameters
    # @option opts [String] :sub_type Custom string client apps can use for searching/filtering tournaments
    # @option opts [Integer] :image_asset_id The asset ID to attach to the tournament
    # @option opts [Integer] :seconds_between_levels The number of seconds in between the start of each tournament game/group (default to 600)
    # @option opts [Integer] :seconds_for_tie_breaker The number of seconds to extend the round end time in the case of a tie breaker (default to 600)
    # @option opts [Integer] :seconds_between_packs The number of seconds in between the start of each tournament round (default to 86400)
    # @option opts [Integer] :maximum_level_length The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (default to 1800)
    # @option opts [String] :cost_to_play_type The type of ticket required to pay
    # @option opts [Integer] :minimum_to_play The minimum number of players required to sign up for the tournament to be played (default to 1)
    # @option opts [Integer] :starting_limit The starting number of players for a tournament (filled with AI&#39;s)
    # @option opts [Integer] :available_limit The maximum number of players for a tournament (currently 128 but not enforced)
    # @option opts [String] :description The description of the tournament
    # @option opts [String] :meta_data External custom client defined data
    # @option opts [String] :audience_ids The audiences associated with the tournament
    # @option opts [Boolean] :active Activate/deactivate the tournament
    # @option opts [Boolean] :enable_buy_back Determines whether to allow players to buy back into a tournament (default to false)
    # @option opts [String] :offer_ids The list of offers to give as a reward beyond the tickets
    # @option opts [Integer] :offer_asset_id The artwork ID to attach to the reward tickets offers
    # @option opts [Boolean] :fixed_reward If set then do not update the ticket reward, auto set to true if offerIds provided (default to false)
    # @option opts [String] :split_reward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (default to 'ALL')
    # @option opts [Boolean] :allocate_tickets Flag to indicate owner should receive tickets for completed missions
    # @option opts [String] :tournament_data A text based string that will be passed into each tournament setup to populate the content
    # @option opts [String] :mission_type The style of tournament to build, options are: TOURNAMENT, POOLPLAY (default to 'MULTISTAGE')
    # @option opts [String] :visibility Sets the visibility flag for the tournament (default to 'PUBLIC')
    # @option opts [Integer] :preliminary_groups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (default to 1)
    # @option opts [String] :preliminary_group_advancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (default to '1')
    # @option opts [Boolean] :enable_multiple_entries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (default to false)
    # @option opts [Boolean] :enable_multiple_votes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (default to false)
    # @option opts [Boolean] :featured This determines whether the tournament is \&quot;featured\&quot; or not (default to false)
    # @option opts [String] :winner_tag This sets what analytic tag is used when a winner is determined
    # @option opts [String] :tie_tag This sets what analytic tag is used when a tie has occurred
    # @return [TournamentResponse]
    def create_tournament(account_id, app_key, title, cost_to_play, start_date, opts = {})
      data, _status_code, _headers = create_tournament_with_http_info(account_id, app_key, title, cost_to_play, start_date, opts)
      data
    end

    # Create Tournament
    # Create a tournament.
    # @param account_id [Integer] The logged in user.
    # @param app_key [String] The appKey the tournament is created for.
    # @param title [String] The title of the tournament
    # @param cost_to_play [Integer] The number of tickets required to pay to enter the tournament
    # @param start_date [Integer] The date/time to start the tournament
    # @param [Hash] opts the optional parameters
    # @option opts [String] :sub_type Custom string client apps can use for searching/filtering tournaments
    # @option opts [Integer] :image_asset_id The asset ID to attach to the tournament
    # @option opts [Integer] :seconds_between_levels The number of seconds in between the start of each tournament game/group (default to 600)
    # @option opts [Integer] :seconds_for_tie_breaker The number of seconds to extend the round end time in the case of a tie breaker (default to 600)
    # @option opts [Integer] :seconds_between_packs The number of seconds in between the start of each tournament round (default to 86400)
    # @option opts [Integer] :maximum_level_length The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (default to 1800)
    # @option opts [String] :cost_to_play_type The type of ticket required to pay
    # @option opts [Integer] :minimum_to_play The minimum number of players required to sign up for the tournament to be played (default to 1)
    # @option opts [Integer] :starting_limit The starting number of players for a tournament (filled with AI&#39;s)
    # @option opts [Integer] :available_limit The maximum number of players for a tournament (currently 128 but not enforced)
    # @option opts [String] :description The description of the tournament
    # @option opts [String] :meta_data External custom client defined data
    # @option opts [String] :audience_ids The audiences associated with the tournament
    # @option opts [Boolean] :active Activate/deactivate the tournament
    # @option opts [Boolean] :enable_buy_back Determines whether to allow players to buy back into a tournament (default to false)
    # @option opts [String] :offer_ids The list of offers to give as a reward beyond the tickets
    # @option opts [Integer] :offer_asset_id The artwork ID to attach to the reward tickets offers
    # @option opts [Boolean] :fixed_reward If set then do not update the ticket reward, auto set to true if offerIds provided (default to false)
    # @option opts [String] :split_reward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (default to 'ALL')
    # @option opts [Boolean] :allocate_tickets Flag to indicate owner should receive tickets for completed missions
    # @option opts [String] :tournament_data A text based string that will be passed into each tournament setup to populate the content
    # @option opts [String] :mission_type The style of tournament to build, options are: TOURNAMENT, POOLPLAY (default to 'MULTISTAGE')
    # @option opts [String] :visibility Sets the visibility flag for the tournament (default to 'PUBLIC')
    # @option opts [Integer] :preliminary_groups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (default to 1)
    # @option opts [String] :preliminary_group_advancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (default to '1')
    # @option opts [Boolean] :enable_multiple_entries This determines if multiple submissions/entries are allowed in a multi-stage album tournament (default to false)
    # @option opts [Boolean] :enable_multiple_votes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (default to false)
    # @option opts [Boolean] :featured This determines whether the tournament is \&quot;featured\&quot; or not (default to false)
    # @option opts [String] :winner_tag This sets what analytic tag is used when a winner is determined
    # @option opts [String] :tie_tag This sets what analytic tag is used when a tie has occurred
    # @return [Array<(TournamentResponse, Integer, Hash)>] TournamentResponse data, response status code and response headers
    def create_tournament_with_http_info(account_id, app_key, title, cost_to_play, start_date, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TournamentApi.create_tournament ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling TournamentApi.create_tournament"
      end
      # verify the required parameter 'app_key' is set
      if @api_client.config.client_side_validation && app_key.nil?
        fail ArgumentError, "Missing the required parameter 'app_key' when calling TournamentApi.create_tournament"
      end
      # verify the required parameter 'title' is set
      if @api_client.config.client_side_validation && title.nil?
        fail ArgumentError, "Missing the required parameter 'title' when calling TournamentApi.create_tournament"
      end
      # verify the required parameter 'cost_to_play' is set
      if @api_client.config.client_side_validation && cost_to_play.nil?
        fail ArgumentError, "Missing the required parameter 'cost_to_play' when calling TournamentApi.create_tournament"
      end
      # verify the required parameter 'start_date' is set
      if @api_client.config.client_side_validation && start_date.nil?
        fail ArgumentError, "Missing the required parameter 'start_date' when calling TournamentApi.create_tournament"
      end
      allowable_values = ["EVEN", "ALL", "FIRST", "RANDOM"]
      if @api_client.config.client_side_validation && opts[:'split_reward'] && !allowable_values.include?(opts[:'split_reward'])
        fail ArgumentError, "invalid value for \"split_reward\", must be one of #{allowable_values}"
      end
      allowable_values = ["TOURNAMENT", "POOLPLAY", "MULTISTAGE"]
      if @api_client.config.client_side_validation && opts[:'mission_type'] && !allowable_values.include?(opts[:'mission_type'])
        fail ArgumentError, "invalid value for \"mission_type\", must be one of #{allowable_values}"
      end
      allowable_values = ["PUBLIC", "LISTABLE", "REWARDABLE", "TRIGGERABLE", "PRIVATE"]
      if @api_client.config.client_side_validation && opts[:'visibility'] && !allowable_values.include?(opts[:'visibility'])
        fail ArgumentError, "invalid value for \"visibility\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/tournament/create'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'appKey'] = app_key
      query_params[:'title'] = title
      query_params[:'costToPlay'] = cost_to_play
      query_params[:'startDate'] = start_date
      query_params[:'subType'] = opts[:'sub_type'] if !opts[:'sub_type'].nil?
      query_params[:'imageAssetId'] = opts[:'image_asset_id'] if !opts[:'image_asset_id'].nil?
      query_params[:'secondsBetweenLevels'] = opts[:'seconds_between_levels'] if !opts[:'seconds_between_levels'].nil?
      query_params[:'secondsForTieBreaker'] = opts[:'seconds_for_tie_breaker'] if !opts[:'seconds_for_tie_breaker'].nil?
      query_params[:'secondsBetweenPacks'] = opts[:'seconds_between_packs'] if !opts[:'seconds_between_packs'].nil?
      query_params[:'maximumLevelLength'] = opts[:'maximum_level_length'] if !opts[:'maximum_level_length'].nil?
      query_params[:'costToPlayType'] = opts[:'cost_to_play_type'] if !opts[:'cost_to_play_type'].nil?
      query_params[:'minimumToPlay'] = opts[:'minimum_to_play'] if !opts[:'minimum_to_play'].nil?
      query_params[:'startingLimit'] = opts[:'starting_limit'] if !opts[:'starting_limit'].nil?
      query_params[:'availableLimit'] = opts[:'available_limit'] if !opts[:'available_limit'].nil?
      query_params[:'description'] = opts[:'description'] if !opts[:'description'].nil?
      query_params[:'metaData'] = opts[:'meta_data'] if !opts[:'meta_data'].nil?
      query_params[:'audienceIds'] = opts[:'audience_ids'] if !opts[:'audience_ids'].nil?
      query_params[:'active'] = opts[:'active'] if !opts[:'active'].nil?
      query_params[:'enableBuyBack'] = opts[:'enable_buy_back'] if !opts[:'enable_buy_back'].nil?
      query_params[:'offerIds'] = opts[:'offer_ids'] if !opts[:'offer_ids'].nil?
      query_params[:'offerAssetId'] = opts[:'offer_asset_id'] if !opts[:'offer_asset_id'].nil?
      query_params[:'fixedReward'] = opts[:'fixed_reward'] if !opts[:'fixed_reward'].nil?
      query_params[:'splitReward'] = opts[:'split_reward'] if !opts[:'split_reward'].nil?
      query_params[:'allocateTickets'] = opts[:'allocate_tickets'] if !opts[:'allocate_tickets'].nil?
      query_params[:'tournamentData'] = opts[:'tournament_data'] if !opts[:'tournament_data'].nil?
      query_params[:'missionType'] = opts[:'mission_type'] if !opts[:'mission_type'].nil?
      query_params[:'visibility'] = opts[:'visibility'] if !opts[:'visibility'].nil?
      query_params[:'preliminaryGroups'] = opts[:'preliminary_groups'] if !opts[:'preliminary_groups'].nil?
      query_params[:'preliminaryGroupAdvancements'] = opts[:'preliminary_group_advancements'] if !opts[:'preliminary_group_advancements'].nil?
      query_params[:'enableMultipleEntries'] = opts[:'enable_multiple_entries'] if !opts[:'enable_multiple_entries'].nil?
      query_params[:'enableMultipleVotes'] = opts[:'enable_multiple_votes'] if !opts[:'enable_multiple_votes'].nil?
      query_params[:'featured'] = opts[:'featured'] if !opts[:'featured'].nil?
      query_params[:'winnerTag'] = opts[:'winner_tag'] if !opts[:'winner_tag'].nil?
      query_params[:'tieTag'] = opts[:'tie_tag'] if !opts[:'tie_tag'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'TournamentResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TournamentApi.create_tournament",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TournamentApi#create_tournament\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Tournament
    # Delete a tournament.
    # @param account_id [Integer] the id of the logged in user
    # @param mission_id [Integer] the id of the mission to delete
    # @param [Hash] opts the optional parameters
    # @return [SirqulResponse]
    def delete_tournament(account_id, mission_id, opts = {})
      data, _status_code, _headers = delete_tournament_with_http_info(account_id, mission_id, opts)
      data
    end

    # Delete Tournament
    # Delete a tournament.
    # @param account_id [Integer] the id of the logged in user
    # @param mission_id [Integer] the id of the mission to delete
    # @param [Hash] opts the optional parameters
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def delete_tournament_with_http_info(account_id, mission_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TournamentApi.delete_tournament ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling TournamentApi.delete_tournament"
      end
      # verify the required parameter 'mission_id' is set
      if @api_client.config.client_side_validation && mission_id.nil?
        fail ArgumentError, "Missing the required parameter 'mission_id' when calling TournamentApi.delete_tournament"
      end
      # resource path
      local_var_path = '/tournament/delete'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'missionId'] = mission_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TournamentApi.delete_tournament",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TournamentApi#delete_tournament\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Tournament
    # Get a tournament.
    # @param account_id [Integer] The id of the logged in user
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :mission_id The id of the mission to return (either missionId or joinCode is required)
    # @option opts [String] :join_code Optional identifier for getting the tournament (either missionId or joinCode is required)
    # @option opts [String] :include_scores Determines which type of scores are returned. Possible values include: ALL, MINE
    # @option opts [Integer] :object_preview_size Determines the max number of game objects that will get returned for each game level response (default to 50)
    # @return [TournamentResponse]
    def get_tournament(account_id, opts = {})
      data, _status_code, _headers = get_tournament_with_http_info(account_id, opts)
      data
    end

    # Get Tournament
    # Get a tournament.
    # @param account_id [Integer] The id of the logged in user
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :mission_id The id of the mission to return (either missionId or joinCode is required)
    # @option opts [String] :join_code Optional identifier for getting the tournament (either missionId or joinCode is required)
    # @option opts [String] :include_scores Determines which type of scores are returned. Possible values include: ALL, MINE
    # @option opts [Integer] :object_preview_size Determines the max number of game objects that will get returned for each game level response (default to 50)
    # @return [Array<(TournamentResponse, Integer, Hash)>] TournamentResponse data, response status code and response headers
    def get_tournament_with_http_info(account_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TournamentApi.get_tournament ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling TournamentApi.get_tournament"
      end
      allowable_values = ["ALL", "MINE"]
      if @api_client.config.client_side_validation && opts[:'include_scores'] && !allowable_values.include?(opts[:'include_scores'])
        fail ArgumentError, "invalid value for \"include_scores\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/tournament/get'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'missionId'] = opts[:'mission_id'] if !opts[:'mission_id'].nil?
      query_params[:'joinCode'] = opts[:'join_code'] if !opts[:'join_code'].nil?
      query_params[:'includeScores'] = opts[:'include_scores'] if !opts[:'include_scores'].nil?
      query_params[:'objectPreviewSize'] = opts[:'object_preview_size'] if !opts[:'object_preview_size'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'TournamentResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TournamentApi.get_tournament",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TournamentApi#get_tournament\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Search Tournament Objects
    # Search on game objects of tournaments
    # @param account_id [Integer] the account ID
    # @param game_level_id [Integer] the game level id to filter results by
    # @param [Hash] opts the optional parameters
    # @option opts [String] :sort_field the field to sort by (default to 'PLAYER_SCORE_COUNT')
    # @option opts [Boolean] :descending determines whether the sorted list is in descending or ascending order (default to true)
    # @option opts [Integer] :start the start index for pagination (default to 0)
    # @option opts [Integer] :limit the limit for pagination (default to 20)
    # @return [SirqulResponse]
    def search_objects(account_id, game_level_id, opts = {})
      data, _status_code, _headers = search_objects_with_http_info(account_id, game_level_id, opts)
      data
    end

    # Search Tournament Objects
    # Search on game objects of tournaments
    # @param account_id [Integer] the account ID
    # @param game_level_id [Integer] the game level id to filter results by
    # @param [Hash] opts the optional parameters
    # @option opts [String] :sort_field the field to sort by (default to 'PLAYER_SCORE_COUNT')
    # @option opts [Boolean] :descending determines whether the sorted list is in descending or ascending order (default to true)
    # @option opts [Integer] :start the start index for pagination (default to 0)
    # @option opts [Integer] :limit the limit for pagination (default to 20)
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def search_objects_with_http_info(account_id, game_level_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TournamentApi.search_objects ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling TournamentApi.search_objects"
      end
      # verify the required parameter 'game_level_id' is set
      if @api_client.config.client_side_validation && game_level_id.nil?
        fail ArgumentError, "Missing the required parameter 'game_level_id' when calling TournamentApi.search_objects"
      end
      allowable_values = ["ID", "PLAYER_SCORE_COUNT"]
      if @api_client.config.client_side_validation && opts[:'sort_field'] && !allowable_values.include?(opts[:'sort_field'])
        fail ArgumentError, "invalid value for \"sort_field\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/tournament/object/search'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'gameLevelId'] = game_level_id
      query_params[:'sortField'] = opts[:'sort_field'] if !opts[:'sort_field'].nil?
      query_params[:'descending'] = opts[:'descending'] if !opts[:'descending'].nil?
      query_params[:'start'] = opts[:'start'] if !opts[:'start'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TournamentApi.search_objects",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TournamentApi#search_objects\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Search Tournament Rounds
    # Search for the user's tournament games.
    # @param account_id [Integer] the account ID
    # @param app_key [String] the application key
    # @param [Hash] opts the optional parameters
    # @option opts [String] :status comma separated list of statuses to filter results by (default to 'ACCEPTED,ACTIVE')
    # @option opts [String] :mission_type The style of tournament to search for, options are: TOURNAMENT, POOLPLAY
    # @option opts [Boolean] :current_only search for games that are flagged current only (default to true)
    # @option opts [String] :visibilities Filter tournament rounds by the mission visibility flag (default to 'PUBLIC')
    # @option opts [Integer] :start the start index for pagination (default to 0)
    # @option opts [Integer] :limit the limit for pagination (default to 20)
    # @return [SirqulResponse]
    def search_rounds(account_id, app_key, opts = {})
      data, _status_code, _headers = search_rounds_with_http_info(account_id, app_key, opts)
      data
    end

    # Search Tournament Rounds
    # Search for the user&#39;s tournament games.
    # @param account_id [Integer] the account ID
    # @param app_key [String] the application key
    # @param [Hash] opts the optional parameters
    # @option opts [String] :status comma separated list of statuses to filter results by (default to 'ACCEPTED,ACTIVE')
    # @option opts [String] :mission_type The style of tournament to search for, options are: TOURNAMENT, POOLPLAY
    # @option opts [Boolean] :current_only search for games that are flagged current only (default to true)
    # @option opts [String] :visibilities Filter tournament rounds by the mission visibility flag (default to 'PUBLIC')
    # @option opts [Integer] :start the start index for pagination (default to 0)
    # @option opts [Integer] :limit the limit for pagination (default to 20)
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def search_rounds_with_http_info(account_id, app_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TournamentApi.search_rounds ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling TournamentApi.search_rounds"
      end
      # verify the required parameter 'app_key' is set
      if @api_client.config.client_side_validation && app_key.nil?
        fail ArgumentError, "Missing the required parameter 'app_key' when calling TournamentApi.search_rounds"
      end
      allowable_values = ["TOURNAMENT", "POOLPLAY"]
      if @api_client.config.client_side_validation && opts[:'mission_type'] && !allowable_values.include?(opts[:'mission_type'])
        fail ArgumentError, "invalid value for \"mission_type\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/tournament/round/search'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'appKey'] = app_key
      query_params[:'status'] = opts[:'status'] if !opts[:'status'].nil?
      query_params[:'missionType'] = opts[:'mission_type'] if !opts[:'mission_type'].nil?
      query_params[:'currentOnly'] = opts[:'current_only'] if !opts[:'current_only'].nil?
      query_params[:'visibilities'] = opts[:'visibilities'] if !opts[:'visibilities'].nil?
      query_params[:'start'] = opts[:'start'] if !opts[:'start'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TournamentApi.search_rounds",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TournamentApi#search_rounds\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Search Tournaments
    # Search for tournaments
    # @param account_id [Integer] The logged in user.
    # @param app_key [String] The application key
    # @param [Hash] opts the optional parameters
    # @option opts [String] :keyword the keyword to search tournament on
    # @option opts [String] :sub_type filter results by subType
    # @option opts [Boolean] :include_inactive whether to include inactives in the search or not (default to false)
    # @option opts [String] :mission_types comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (default to 'MULTISTAGE,TOURNAMENT,POOLPLAY')
    # @option opts [String] :filter filter tournaments by the tournament&#39;s current state (default to 'UPCOMING')
    # @option opts [String] :sort_field which field to sort on (default to 'START_DATE')
    # @option opts [Boolean] :descending Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false.
    # @option opts [String] :visibility Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (default to 'PUBLIC')
    # @option opts [Integer] :start Start the result set at some index. (default to 0)
    # @option opts [Integer] :limit Limit the result to some number (default to 20)
    # @return [MissionShortResponse]
    def search_tournaments(account_id, app_key, opts = {})
      data, _status_code, _headers = search_tournaments_with_http_info(account_id, app_key, opts)
      data
    end

    # Search Tournaments
    # Search for tournaments
    # @param account_id [Integer] The logged in user.
    # @param app_key [String] The application key
    # @param [Hash] opts the optional parameters
    # @option opts [String] :keyword the keyword to search tournament on
    # @option opts [String] :sub_type filter results by subType
    # @option opts [Boolean] :include_inactive whether to include inactives in the search or not (default to false)
    # @option opts [String] :mission_types comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (default to 'MULTISTAGE,TOURNAMENT,POOLPLAY')
    # @option opts [String] :filter filter tournaments by the tournament&#39;s current state (default to 'UPCOMING')
    # @option opts [String] :sort_field which field to sort on (default to 'START_DATE')
    # @option opts [Boolean] :descending Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false.
    # @option opts [String] :visibility Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (default to 'PUBLIC')
    # @option opts [Integer] :start Start the result set at some index. (default to 0)
    # @option opts [Integer] :limit Limit the result to some number (default to 20)
    # @return [Array<(MissionShortResponse, Integer, Hash)>] MissionShortResponse data, response status code and response headers
    def search_tournaments_with_http_info(account_id, app_key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TournamentApi.search_tournaments ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling TournamentApi.search_tournaments"
      end
      # verify the required parameter 'app_key' is set
      if @api_client.config.client_side_validation && app_key.nil?
        fail ArgumentError, "Missing the required parameter 'app_key' when calling TournamentApi.search_tournaments"
      end
      allowable_values = ["ALL", "UPCOMING", "PAST", "PRESENT", "ACTIVE"]
      if @api_client.config.client_side_validation && opts[:'filter'] && !allowable_values.include?(opts[:'filter'])
        fail ArgumentError, "invalid value for \"filter\", must be one of #{allowable_values}"
      end
      allowable_values = ["ACTIVE", "TITLE", "DESCRIPTION", "CREATED", "UPDATED", "MISSION_TYPE", "OWNER_DISPLAY", "START_DATE", "END_DATE", "STARTING_LIMIT", "AVAILABLE_LIMIT", "INVITE_COUNT", "ACCEPTED_COUNT"]
      if @api_client.config.client_side_validation && opts[:'sort_field'] && !allowable_values.include?(opts[:'sort_field'])
        fail ArgumentError, "invalid value for \"sort_field\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/tournament/search'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'appKey'] = app_key
      query_params[:'keyword'] = opts[:'keyword'] if !opts[:'keyword'].nil?
      query_params[:'subType'] = opts[:'sub_type'] if !opts[:'sub_type'].nil?
      query_params[:'includeInactive'] = opts[:'include_inactive'] if !opts[:'include_inactive'].nil?
      query_params[:'missionTypes'] = opts[:'mission_types'] if !opts[:'mission_types'].nil?
      query_params[:'filter'] = opts[:'filter'] if !opts[:'filter'].nil?
      query_params[:'sortField'] = opts[:'sort_field'] if !opts[:'sort_field'].nil?
      query_params[:'descending'] = opts[:'descending'] if !opts[:'descending'].nil?
      query_params[:'visibility'] = opts[:'visibility'] if !opts[:'visibility'].nil?
      query_params[:'start'] = opts[:'start'] if !opts[:'start'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MissionShortResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TournamentApi.search_tournaments",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TournamentApi#search_tournaments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Submit Tournament Score
    # Submit an array of scores for a tournament match. 
    # @param account_id [Integer] The logged in user account ID.
    # @param app_key [String] The application key.
    # @param mission_id [Integer] The missionId to score for
    # @param game_id [Integer] The gameId to score for
    # @param pack_id [Integer] The packId to score for
    # @param scores [String] a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60; 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :game_level_id The gameLevelId to score for
    # @return [SirqulResponse]
    def submit_tournament_score(account_id, app_key, mission_id, game_id, pack_id, scores, opts = {})
      data, _status_code, _headers = submit_tournament_score_with_http_info(account_id, app_key, mission_id, game_id, pack_id, scores, opts)
      data
    end

    # Submit Tournament Score
    # Submit an array of scores for a tournament match. 
    # @param account_id [Integer] The logged in user account ID.
    # @param app_key [String] The application key.
    # @param mission_id [Integer] The missionId to score for
    # @param game_id [Integer] The gameId to score for
    # @param pack_id [Integer] The packId to score for
    # @param scores [String] a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60; 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :game_level_id The gameLevelId to score for
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def submit_tournament_score_with_http_info(account_id, app_key, mission_id, game_id, pack_id, scores, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TournamentApi.submit_tournament_score ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling TournamentApi.submit_tournament_score"
      end
      # verify the required parameter 'app_key' is set
      if @api_client.config.client_side_validation && app_key.nil?
        fail ArgumentError, "Missing the required parameter 'app_key' when calling TournamentApi.submit_tournament_score"
      end
      # verify the required parameter 'mission_id' is set
      if @api_client.config.client_side_validation && mission_id.nil?
        fail ArgumentError, "Missing the required parameter 'mission_id' when calling TournamentApi.submit_tournament_score"
      end
      # verify the required parameter 'game_id' is set
      if @api_client.config.client_side_validation && game_id.nil?
        fail ArgumentError, "Missing the required parameter 'game_id' when calling TournamentApi.submit_tournament_score"
      end
      # verify the required parameter 'pack_id' is set
      if @api_client.config.client_side_validation && pack_id.nil?
        fail ArgumentError, "Missing the required parameter 'pack_id' when calling TournamentApi.submit_tournament_score"
      end
      # verify the required parameter 'scores' is set
      if @api_client.config.client_side_validation && scores.nil?
        fail ArgumentError, "Missing the required parameter 'scores' when calling TournamentApi.submit_tournament_score"
      end
      # resource path
      local_var_path = '/tournament/score'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'appKey'] = app_key
      query_params[:'missionId'] = mission_id
      query_params[:'gameId'] = game_id
      query_params[:'packId'] = pack_id
      query_params[:'scores'] = scores
      query_params[:'gameLevelId'] = opts[:'game_level_id'] if !opts[:'game_level_id'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TournamentApi.submit_tournament_score",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TournamentApi#submit_tournament_score\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Submit a vote for a multi-stage album tournament.
    # Submit a vote for a multi-stage album tournament.
    # @param account_id [Integer] The logged in user.
    # @param app_key [String] The application to target
    # @param mission_id [Integer] The tournament&#39;s primary id
    # @param game_object_id [Integer] The tournament game object the user wants to vote on
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id The unique id of the device making the request (optional)
    # @option opts [Boolean] :check_if_device_already_voted When true, check if the device already voted to prevent duplicate votes from the same device (default to false)
    # @return [SirqulResponse]
    def submit_tournament_vote(account_id, app_key, mission_id, game_object_id, opts = {})
      data, _status_code, _headers = submit_tournament_vote_with_http_info(account_id, app_key, mission_id, game_object_id, opts)
      data
    end

    # Submit a vote for a multi-stage album tournament.
    # Submit a vote for a multi-stage album tournament.
    # @param account_id [Integer] The logged in user.
    # @param app_key [String] The application to target
    # @param mission_id [Integer] The tournament&#39;s primary id
    # @param game_object_id [Integer] The tournament game object the user wants to vote on
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id The unique id of the device making the request (optional)
    # @option opts [Boolean] :check_if_device_already_voted When true, check if the device already voted to prevent duplicate votes from the same device (default to false)
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def submit_tournament_vote_with_http_info(account_id, app_key, mission_id, game_object_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TournamentApi.submit_tournament_vote ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling TournamentApi.submit_tournament_vote"
      end
      # verify the required parameter 'app_key' is set
      if @api_client.config.client_side_validation && app_key.nil?
        fail ArgumentError, "Missing the required parameter 'app_key' when calling TournamentApi.submit_tournament_vote"
      end
      # verify the required parameter 'mission_id' is set
      if @api_client.config.client_side_validation && mission_id.nil?
        fail ArgumentError, "Missing the required parameter 'mission_id' when calling TournamentApi.submit_tournament_vote"
      end
      # verify the required parameter 'game_object_id' is set
      if @api_client.config.client_side_validation && game_object_id.nil?
        fail ArgumentError, "Missing the required parameter 'game_object_id' when calling TournamentApi.submit_tournament_vote"
      end
      # resource path
      local_var_path = '/tournament/vote'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'appKey'] = app_key
      query_params[:'missionId'] = mission_id
      query_params[:'gameObjectId'] = game_object_id
      query_params[:'deviceId'] = opts[:'device_id'] if !opts[:'device_id'].nil?
      query_params[:'checkIfDeviceAlreadyVoted'] = opts[:'check_if_device_already_voted'] if !opts[:'check_if_device_already_voted'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TournamentApi.submit_tournament_vote",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TournamentApi#submit_tournament_vote\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Substitute Tournament Player
    # Service to replace the user's opponent in the current level - pack - mission with an AI account.
    # @param account_id [Integer] the id of the logged in user
    # @param mission_id [Integer] the id of the mission
    # @param pack_id [Integer] the id of the pack
    # @param game_level_id [Integer] the id of the game level
    # @param [Hash] opts the optional parameters
    # @return [SirqulResponse]
    def substitute_tournament_player(account_id, mission_id, pack_id, game_level_id, opts = {})
      data, _status_code, _headers = substitute_tournament_player_with_http_info(account_id, mission_id, pack_id, game_level_id, opts)
      data
    end

    # Substitute Tournament Player
    # Service to replace the user&#39;s opponent in the current level - pack - mission with an AI account.
    # @param account_id [Integer] the id of the logged in user
    # @param mission_id [Integer] the id of the mission
    # @param pack_id [Integer] the id of the pack
    # @param game_level_id [Integer] the id of the game level
    # @param [Hash] opts the optional parameters
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def substitute_tournament_player_with_http_info(account_id, mission_id, pack_id, game_level_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TournamentApi.substitute_tournament_player ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling TournamentApi.substitute_tournament_player"
      end
      # verify the required parameter 'mission_id' is set
      if @api_client.config.client_side_validation && mission_id.nil?
        fail ArgumentError, "Missing the required parameter 'mission_id' when calling TournamentApi.substitute_tournament_player"
      end
      # verify the required parameter 'pack_id' is set
      if @api_client.config.client_side_validation && pack_id.nil?
        fail ArgumentError, "Missing the required parameter 'pack_id' when calling TournamentApi.substitute_tournament_player"
      end
      # verify the required parameter 'game_level_id' is set
      if @api_client.config.client_side_validation && game_level_id.nil?
        fail ArgumentError, "Missing the required parameter 'game_level_id' when calling TournamentApi.substitute_tournament_player"
      end
      # resource path
      local_var_path = '/tournament/substitute'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'missionId'] = mission_id
      query_params[:'packId'] = pack_id
      query_params[:'gameLevelId'] = game_level_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TournamentApi.substitute_tournament_player",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TournamentApi#substitute_tournament_player\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Tournament
    # Update a tournament.
    # @param account_id [Integer] The logged in user.
    # @param mission_id [Integer] The mission/tournament to update
    # @param [Hash] opts the optional parameters
    # @option opts [String] :title The title of the tournament
    # @option opts [String] :sub_type Custom string client apps can use for searching/filtering missions
    # @option opts [Integer] :image_asset_id The asset ID to attach to the tournament
    # @option opts [Integer] :seconds_between_levels The number of seconds in between the start of each tournament game
    # @option opts [Integer] :seconds_for_tie_breaker The number of seconds to extend the round end time in the case of a tie breaker
    # @option opts [Integer] :seconds_between_packs The number of seconds in between the start of each tournament round
    # @option opts [Integer] :maximum_level_length The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
    # @option opts [Integer] :cost_to_play The number of tickets required to pay to enter the tournament
    # @option opts [String] :cost_to_play_type The type of ticket required to pay
    # @option opts [Integer] :minimum_to_play The minimum number of players required to sign up for the tournament to be played
    # @option opts [Integer] :starting_limit The starting number of players for a tournament (filled with AI&#39;s)
    # @option opts [Integer] :available_limit The maximum number of players for a tournament (currently 128 but not enforced)
    # @option opts [String] :description The description of the tournament
    # @option opts [String] :meta_data External custom client defined data
    # @option opts [Integer] :start_date The date/time to start the tournament
    # @option opts [String] :audience_ids The audiences associated with the tournament
    # @option opts [Boolean] :active Activate/deactivate the mission
    # @option opts [Boolean] :enable_buy_back Determines whether to allow players to buy back into a tournament
    # @option opts [String] :offer_ids The list of offers to give as a reward beyond the tickets
    # @option opts [Integer] :offer_asset_id The artwork ID to attach to the reward offer
    # @option opts [Boolean] :fixed_reward If set then do not update the ticket reward, auto set to true if offerIds provided
    # @option opts [String] :split_reward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
    # @option opts [Boolean] :allocate_tickets Flag to indicate owner should receive tickets for completed missions
    # @option opts [String] :tournament_data A text based string that will be passed into each tournament setup to populate the content
    # @option opts [String] :visibility Sets the visibility flag for the tournament
    # @option opts [Integer] :preliminary_groups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
    # @option opts [String] :preliminary_group_advancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
    # @option opts [Boolean] :enable_multiple_entries This determines if multiple submissions/entries are allowed in a multi-stage album tournament
    # @option opts [Boolean] :enable_multiple_votes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
    # @option opts [Boolean] :featured This determines whether the tournament is \&quot;featured\&quot; or not
    # @option opts [String] :winner_tag This sets what analytic tag is used when a winner is determined
    # @option opts [String] :tie_tag This sets what analytic tag is used when a winner is determined
    # @return [TournamentResponse]
    def update_tournament(account_id, mission_id, opts = {})
      data, _status_code, _headers = update_tournament_with_http_info(account_id, mission_id, opts)
      data
    end

    # Update Tournament
    # Update a tournament.
    # @param account_id [Integer] The logged in user.
    # @param mission_id [Integer] The mission/tournament to update
    # @param [Hash] opts the optional parameters
    # @option opts [String] :title The title of the tournament
    # @option opts [String] :sub_type Custom string client apps can use for searching/filtering missions
    # @option opts [Integer] :image_asset_id The asset ID to attach to the tournament
    # @option opts [Integer] :seconds_between_levels The number of seconds in between the start of each tournament game
    # @option opts [Integer] :seconds_for_tie_breaker The number of seconds to extend the round end time in the case of a tie breaker
    # @option opts [Integer] :seconds_between_packs The number of seconds in between the start of each tournament round
    # @option opts [Integer] :maximum_level_length The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
    # @option opts [Integer] :cost_to_play The number of tickets required to pay to enter the tournament
    # @option opts [String] :cost_to_play_type The type of ticket required to pay
    # @option opts [Integer] :minimum_to_play The minimum number of players required to sign up for the tournament to be played
    # @option opts [Integer] :starting_limit The starting number of players for a tournament (filled with AI&#39;s)
    # @option opts [Integer] :available_limit The maximum number of players for a tournament (currently 128 but not enforced)
    # @option opts [String] :description The description of the tournament
    # @option opts [String] :meta_data External custom client defined data
    # @option opts [Integer] :start_date The date/time to start the tournament
    # @option opts [String] :audience_ids The audiences associated with the tournament
    # @option opts [Boolean] :active Activate/deactivate the mission
    # @option opts [Boolean] :enable_buy_back Determines whether to allow players to buy back into a tournament
    # @option opts [String] :offer_ids The list of offers to give as a reward beyond the tickets
    # @option opts [Integer] :offer_asset_id The artwork ID to attach to the reward offer
    # @option opts [Boolean] :fixed_reward If set then do not update the ticket reward, auto set to true if offerIds provided
    # @option opts [String] :split_reward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
    # @option opts [Boolean] :allocate_tickets Flag to indicate owner should receive tickets for completed missions
    # @option opts [String] :tournament_data A text based string that will be passed into each tournament setup to populate the content
    # @option opts [String] :visibility Sets the visibility flag for the tournament
    # @option opts [Integer] :preliminary_groups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
    # @option opts [String] :preliminary_group_advancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
    # @option opts [Boolean] :enable_multiple_entries This determines if multiple submissions/entries are allowed in a multi-stage album tournament
    # @option opts [Boolean] :enable_multiple_votes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
    # @option opts [Boolean] :featured This determines whether the tournament is \&quot;featured\&quot; or not
    # @option opts [String] :winner_tag This sets what analytic tag is used when a winner is determined
    # @option opts [String] :tie_tag This sets what analytic tag is used when a winner is determined
    # @return [Array<(TournamentResponse, Integer, Hash)>] TournamentResponse data, response status code and response headers
    def update_tournament_with_http_info(account_id, mission_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TournamentApi.update_tournament ...'
      end
      # verify the required parameter 'account_id' is set
      if @api_client.config.client_side_validation && account_id.nil?
        fail ArgumentError, "Missing the required parameter 'account_id' when calling TournamentApi.update_tournament"
      end
      # verify the required parameter 'mission_id' is set
      if @api_client.config.client_side_validation && mission_id.nil?
        fail ArgumentError, "Missing the required parameter 'mission_id' when calling TournamentApi.update_tournament"
      end
      allowable_values = ["EVEN", "ALL", "FIRST", "RANDOM"]
      if @api_client.config.client_side_validation && opts[:'split_reward'] && !allowable_values.include?(opts[:'split_reward'])
        fail ArgumentError, "invalid value for \"split_reward\", must be one of #{allowable_values}"
      end
      allowable_values = ["PUBLIC", "LISTABLE", "REWARDABLE", "TRIGGERABLE", "PRIVATE"]
      if @api_client.config.client_side_validation && opts[:'visibility'] && !allowable_values.include?(opts[:'visibility'])
        fail ArgumentError, "invalid value for \"visibility\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/tournament/update'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'accountId'] = account_id
      query_params[:'missionId'] = mission_id
      query_params[:'title'] = opts[:'title'] if !opts[:'title'].nil?
      query_params[:'subType'] = opts[:'sub_type'] if !opts[:'sub_type'].nil?
      query_params[:'imageAssetId'] = opts[:'image_asset_id'] if !opts[:'image_asset_id'].nil?
      query_params[:'secondsBetweenLevels'] = opts[:'seconds_between_levels'] if !opts[:'seconds_between_levels'].nil?
      query_params[:'secondsForTieBreaker'] = opts[:'seconds_for_tie_breaker'] if !opts[:'seconds_for_tie_breaker'].nil?
      query_params[:'secondsBetweenPacks'] = opts[:'seconds_between_packs'] if !opts[:'seconds_between_packs'].nil?
      query_params[:'maximumLevelLength'] = opts[:'maximum_level_length'] if !opts[:'maximum_level_length'].nil?
      query_params[:'costToPlay'] = opts[:'cost_to_play'] if !opts[:'cost_to_play'].nil?
      query_params[:'costToPlayType'] = opts[:'cost_to_play_type'] if !opts[:'cost_to_play_type'].nil?
      query_params[:'minimumToPlay'] = opts[:'minimum_to_play'] if !opts[:'minimum_to_play'].nil?
      query_params[:'startingLimit'] = opts[:'starting_limit'] if !opts[:'starting_limit'].nil?
      query_params[:'availableLimit'] = opts[:'available_limit'] if !opts[:'available_limit'].nil?
      query_params[:'description'] = opts[:'description'] if !opts[:'description'].nil?
      query_params[:'metaData'] = opts[:'meta_data'] if !opts[:'meta_data'].nil?
      query_params[:'startDate'] = opts[:'start_date'] if !opts[:'start_date'].nil?
      query_params[:'audienceIds'] = opts[:'audience_ids'] if !opts[:'audience_ids'].nil?
      query_params[:'active'] = opts[:'active'] if !opts[:'active'].nil?
      query_params[:'enableBuyBack'] = opts[:'enable_buy_back'] if !opts[:'enable_buy_back'].nil?
      query_params[:'offerIds'] = opts[:'offer_ids'] if !opts[:'offer_ids'].nil?
      query_params[:'offerAssetId'] = opts[:'offer_asset_id'] if !opts[:'offer_asset_id'].nil?
      query_params[:'fixedReward'] = opts[:'fixed_reward'] if !opts[:'fixed_reward'].nil?
      query_params[:'splitReward'] = opts[:'split_reward'] if !opts[:'split_reward'].nil?
      query_params[:'allocateTickets'] = opts[:'allocate_tickets'] if !opts[:'allocate_tickets'].nil?
      query_params[:'tournamentData'] = opts[:'tournament_data'] if !opts[:'tournament_data'].nil?
      query_params[:'visibility'] = opts[:'visibility'] if !opts[:'visibility'].nil?
      query_params[:'preliminaryGroups'] = opts[:'preliminary_groups'] if !opts[:'preliminary_groups'].nil?
      query_params[:'preliminaryGroupAdvancements'] = opts[:'preliminary_group_advancements'] if !opts[:'preliminary_group_advancements'].nil?
      query_params[:'enableMultipleEntries'] = opts[:'enable_multiple_entries'] if !opts[:'enable_multiple_entries'].nil?
      query_params[:'enableMultipleVotes'] = opts[:'enable_multiple_votes'] if !opts[:'enable_multiple_votes'].nil?
      query_params[:'featured'] = opts[:'featured'] if !opts[:'featured'].nil?
      query_params[:'winnerTag'] = opts[:'winner_tag'] if !opts[:'winner_tag'].nil?
      query_params[:'tieTag'] = opts[:'tie_tag'] if !opts[:'tie_tag'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'TournamentResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"TournamentApi.update_tournament",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TournamentApi#update_tournament\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
