=begin
#Sirqul IoT Platform

#Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

The version of the OpenAPI document: 3.16
Contact: info@sirqul.com
Generated by: https://openapi-generator.tech
Generator version: 7.20.0-SNAPSHOT

=end

require 'cgi'

module OpenapiClient
  class AMQPApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Create Consumer
    # Create a connection to an existing amqp queue and register as a consumer.
    # @param app_key [String] The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
    # @param name [String] The name of the queue to connect to
    # @param hostname [String] The hostname of the server the queue is hosted on
    # @param username [String] The username to access the server the queue is hosted on
    # @param password [String] The password to access the queue to connect to
    # @param data_mapping [String] The data mapping information in the format of AMQPRequest
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id The client deviceID
    # @option opts [Integer] :account_id The logged in user ID
    # @option opts [Integer] :port The port of the server the queue is hosted on (default to 5672)
    # @option opts [String] :virtual_host The virtual host defined on the server the queue is associated on
    # @option opts [String] :exchanger The exchanger of the queue to connect to
    # @option opts [String] :exchanger_type The exchanger type of the queue to connect to
    # @option opts [Integer] :workers The number of workers to generate  (default to 1)
    # @option opts [Boolean] :use_ssl Use SSL
    # @return [QueueResponse]
    def consumer_create(app_key, name, hostname, username, password, data_mapping, opts = {})
      data, _status_code, _headers = consumer_create_with_http_info(app_key, name, hostname, username, password, data_mapping, opts)
      data
    end

    # Create Consumer
    # Create a connection to an existing amqp queue and register as a consumer.
    # @param app_key [String] The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
    # @param name [String] The name of the queue to connect to
    # @param hostname [String] The hostname of the server the queue is hosted on
    # @param username [String] The username to access the server the queue is hosted on
    # @param password [String] The password to access the queue to connect to
    # @param data_mapping [String] The data mapping information in the format of AMQPRequest
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id The client deviceID
    # @option opts [Integer] :account_id The logged in user ID
    # @option opts [Integer] :port The port of the server the queue is hosted on (default to 5672)
    # @option opts [String] :virtual_host The virtual host defined on the server the queue is associated on
    # @option opts [String] :exchanger The exchanger of the queue to connect to
    # @option opts [String] :exchanger_type The exchanger type of the queue to connect to
    # @option opts [Integer] :workers The number of workers to generate  (default to 1)
    # @option opts [Boolean] :use_ssl Use SSL
    # @return [Array<(QueueResponse, Integer, Hash)>] QueueResponse data, response status code and response headers
    def consumer_create_with_http_info(app_key, name, hostname, username, password, data_mapping, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AMQPApi.consumer_create ...'
      end
      # verify the required parameter 'app_key' is set
      if @api_client.config.client_side_validation && app_key.nil?
        fail ArgumentError, "Missing the required parameter 'app_key' when calling AMQPApi.consumer_create"
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling AMQPApi.consumer_create"
      end
      # verify the required parameter 'hostname' is set
      if @api_client.config.client_side_validation && hostname.nil?
        fail ArgumentError, "Missing the required parameter 'hostname' when calling AMQPApi.consumer_create"
      end
      # verify the required parameter 'username' is set
      if @api_client.config.client_side_validation && username.nil?
        fail ArgumentError, "Missing the required parameter 'username' when calling AMQPApi.consumer_create"
      end
      # verify the required parameter 'password' is set
      if @api_client.config.client_side_validation && password.nil?
        fail ArgumentError, "Missing the required parameter 'password' when calling AMQPApi.consumer_create"
      end
      # verify the required parameter 'data_mapping' is set
      if @api_client.config.client_side_validation && data_mapping.nil?
        fail ArgumentError, "Missing the required parameter 'data_mapping' when calling AMQPApi.consumer_create"
      end
      # resource path
      local_var_path = '/queue/consumer/create'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'appKey'] = app_key
      query_params[:'name'] = name
      query_params[:'hostname'] = hostname
      query_params[:'username'] = username
      query_params[:'password'] = password
      query_params[:'dataMapping'] = data_mapping
      query_params[:'deviceId'] = opts[:'device_id'] if !opts[:'device_id'].nil?
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'port'] = opts[:'port'] if !opts[:'port'].nil?
      query_params[:'virtualHost'] = opts[:'virtual_host'] if !opts[:'virtual_host'].nil?
      query_params[:'exchanger'] = opts[:'exchanger'] if !opts[:'exchanger'].nil?
      query_params[:'exchangerType'] = opts[:'exchanger_type'] if !opts[:'exchanger_type'].nil?
      query_params[:'workers'] = opts[:'workers'] if !opts[:'workers'].nil?
      query_params[:'useSSL'] = opts[:'use_ssl'] if !opts[:'use_ssl'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'QueueResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AMQPApi.consumer_create",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AMQPApi#consumer_create\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Consumer
    # Update an existing amqp queue's data mapping.
    # @param app_key [String] The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
    # @param queue_id [Integer] The queue to update
    # @param data_mapping [String] The data mapping information in the format of AMQPRequest
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id The client deviceID
    # @option opts [Integer] :account_id The logged in user ID
    # @option opts [Boolean] :use_ssl Use SSL
    # @return [QueueResponse]
    def consumer_update(app_key, queue_id, data_mapping, opts = {})
      data, _status_code, _headers = consumer_update_with_http_info(app_key, queue_id, data_mapping, opts)
      data
    end

    # Update Consumer
    # Update an existing amqp queue&#39;s data mapping.
    # @param app_key [String] The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
    # @param queue_id [Integer] The queue to update
    # @param data_mapping [String] The data mapping information in the format of AMQPRequest
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id The client deviceID
    # @option opts [Integer] :account_id The logged in user ID
    # @option opts [Boolean] :use_ssl Use SSL
    # @return [Array<(QueueResponse, Integer, Hash)>] QueueResponse data, response status code and response headers
    def consumer_update_with_http_info(app_key, queue_id, data_mapping, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AMQPApi.consumer_update ...'
      end
      # verify the required parameter 'app_key' is set
      if @api_client.config.client_side_validation && app_key.nil?
        fail ArgumentError, "Missing the required parameter 'app_key' when calling AMQPApi.consumer_update"
      end
      # verify the required parameter 'queue_id' is set
      if @api_client.config.client_side_validation && queue_id.nil?
        fail ArgumentError, "Missing the required parameter 'queue_id' when calling AMQPApi.consumer_update"
      end
      # verify the required parameter 'data_mapping' is set
      if @api_client.config.client_side_validation && data_mapping.nil?
        fail ArgumentError, "Missing the required parameter 'data_mapping' when calling AMQPApi.consumer_update"
      end
      # resource path
      local_var_path = '/queue/consumer/update'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'appKey'] = app_key
      query_params[:'queueId'] = queue_id
      query_params[:'dataMapping'] = data_mapping
      query_params[:'deviceId'] = opts[:'device_id'] if !opts[:'device_id'].nil?
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'useSSL'] = opts[:'use_ssl'] if !opts[:'use_ssl'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'QueueResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AMQPApi.consumer_update",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AMQPApi#consumer_update\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Queue
    # Create a basic AMQP queue. If the username and password and virtual host is not sepcified, the queue will be created on the virtual host assigned to the application.
    # @param app_key [String] The application key unique to each application.
    # @param name [String] The name of the queue to create
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id The client deviceID
    # @option opts [Integer] :account_id The logged in user ID
    # @option opts [Integer] :workers The number of workers to generate  (default to 1)
    # @option opts [String] :analytic_tags If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags
    # @option opts [String] :hostname The hostname of the server the queue is hosted on
    # @option opts [Integer] :port The port of the server the queue is hosted on
    # @option opts [String] :username The username to access the server that the queue is on
    # @option opts [String] :password The password to access the queue to connect to
    # @option opts [String] :virtual_host The virtual host defined on the server to queue
    # @option opts [Boolean] :use_ssl Use SSL
    # @return [QueueResponse]
    def queue_create(app_key, name, opts = {})
      data, _status_code, _headers = queue_create_with_http_info(app_key, name, opts)
      data
    end

    # Create Queue
    # Create a basic AMQP queue. If the username and password and virtual host is not sepcified, the queue will be created on the virtual host assigned to the application.
    # @param app_key [String] The application key unique to each application.
    # @param name [String] The name of the queue to create
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id The client deviceID
    # @option opts [Integer] :account_id The logged in user ID
    # @option opts [Integer] :workers The number of workers to generate  (default to 1)
    # @option opts [String] :analytic_tags If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags
    # @option opts [String] :hostname The hostname of the server the queue is hosted on
    # @option opts [Integer] :port The port of the server the queue is hosted on
    # @option opts [String] :username The username to access the server that the queue is on
    # @option opts [String] :password The password to access the queue to connect to
    # @option opts [String] :virtual_host The virtual host defined on the server to queue
    # @option opts [Boolean] :use_ssl Use SSL
    # @return [Array<(QueueResponse, Integer, Hash)>] QueueResponse data, response status code and response headers
    def queue_create_with_http_info(app_key, name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AMQPApi.queue_create ...'
      end
      # verify the required parameter 'app_key' is set
      if @api_client.config.client_side_validation && app_key.nil?
        fail ArgumentError, "Missing the required parameter 'app_key' when calling AMQPApi.queue_create"
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling AMQPApi.queue_create"
      end
      # resource path
      local_var_path = '/queue/create'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'appKey'] = app_key
      query_params[:'name'] = name
      query_params[:'deviceId'] = opts[:'device_id'] if !opts[:'device_id'].nil?
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'workers'] = opts[:'workers'] if !opts[:'workers'].nil?
      query_params[:'analyticTags'] = opts[:'analytic_tags'] if !opts[:'analytic_tags'].nil?
      query_params[:'hostname'] = opts[:'hostname'] if !opts[:'hostname'].nil?
      query_params[:'port'] = opts[:'port'] if !opts[:'port'].nil?
      query_params[:'username'] = opts[:'username'] if !opts[:'username'].nil?
      query_params[:'password'] = opts[:'password'] if !opts[:'password'].nil?
      query_params[:'virtualHost'] = opts[:'virtual_host'] if !opts[:'virtual_host'].nil?
      query_params[:'useSSL'] = opts[:'use_ssl'] if !opts[:'use_ssl'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'QueueResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AMQPApi.queue_create",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AMQPApi#queue_create\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Queue
    # Delete the stored queue record and close any active connections to the AMQP servers.
    # @param queue_id [Integer] The id of the queue to find
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id The client device ID
    # @option opts [Integer] :account_id The logged in user ID
    # @return [SirqulResponse]
    def queue_delete(queue_id, opts = {})
      data, _status_code, _headers = queue_delete_with_http_info(queue_id, opts)
      data
    end

    # Delete Queue
    # Delete the stored queue record and close any active connections to the AMQP servers.
    # @param queue_id [Integer] The id of the queue to find
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id The client device ID
    # @option opts [Integer] :account_id The logged in user ID
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def queue_delete_with_http_info(queue_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AMQPApi.queue_delete ...'
      end
      # verify the required parameter 'queue_id' is set
      if @api_client.config.client_side_validation && queue_id.nil?
        fail ArgumentError, "Missing the required parameter 'queue_id' when calling AMQPApi.queue_delete"
      end
      # resource path
      local_var_path = '/queue/delete'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'queueId'] = queue_id
      query_params[:'deviceId'] = opts[:'device_id'] if !opts[:'device_id'].nil?
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AMQPApi.queue_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AMQPApi#queue_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Queue
    # Get the stored queue record. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id The client device ID
    # @option opts [Integer] :account_id The logged in user ID
    # @option opts [Integer] :queue_id The id of the queue to find
    # @option opts [String] :app_key The application key the queue was assigned to
    # @option opts [String] :name The name of the queue to find
    # @option opts [String] :hostname The hostname of the queue to find
    # @option opts [String] :virtual_host The virtual host of the queue to find
    # @return [QueueResponse]
    def queue_get(opts = {})
      data, _status_code, _headers = queue_get_with_http_info(opts)
      data
    end

    # Get Queue
    # Get the stored queue record. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id The client device ID
    # @option opts [Integer] :account_id The logged in user ID
    # @option opts [Integer] :queue_id The id of the queue to find
    # @option opts [String] :app_key The application key the queue was assigned to
    # @option opts [String] :name The name of the queue to find
    # @option opts [String] :hostname The hostname of the queue to find
    # @option opts [String] :virtual_host The virtual host of the queue to find
    # @return [Array<(QueueResponse, Integer, Hash)>] QueueResponse data, response status code and response headers
    def queue_get_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AMQPApi.queue_get ...'
      end
      # resource path
      local_var_path = '/queue/get'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'deviceId'] = opts[:'device_id'] if !opts[:'device_id'].nil?
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'queueId'] = opts[:'queue_id'] if !opts[:'queue_id'].nil?
      query_params[:'appKey'] = opts[:'app_key'] if !opts[:'app_key'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'hostname'] = opts[:'hostname'] if !opts[:'hostname'].nil?
      query_params[:'virtualHost'] = opts[:'virtual_host'] if !opts[:'virtual_host'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'QueueResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AMQPApi.queue_get",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AMQPApi#queue_get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Publish Queue
    # Publish a message to a stored queue. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
    # @param message [String] The payload to send to the queue
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :queue_id The id of the queue to publish to
    # @option opts [String] :app_key The application key the queue was assigned to
    # @option opts [String] :name The name of the queue to publish to or the analytic tag to handle if the analytic param is true
    # @option opts [String] :hostname The hostname of the server the queue is hosted on
    # @option opts [String] :virtual_host The virtual host defined on the server to queue
    # @return [SirqulResponse]
    def queue_publish(message, opts = {})
      data, _status_code, _headers = queue_publish_with_http_info(message, opts)
      data
    end

    # Publish Queue
    # Publish a message to a stored queue. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
    # @param message [String] The payload to send to the queue
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :queue_id The id of the queue to publish to
    # @option opts [String] :app_key The application key the queue was assigned to
    # @option opts [String] :name The name of the queue to publish to or the analytic tag to handle if the analytic param is true
    # @option opts [String] :hostname The hostname of the server the queue is hosted on
    # @option opts [String] :virtual_host The virtual host defined on the server to queue
    # @return [Array<(SirqulResponse, Integer, Hash)>] SirqulResponse data, response status code and response headers
    def queue_publish_with_http_info(message, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AMQPApi.queue_publish ...'
      end
      # verify the required parameter 'message' is set
      if @api_client.config.client_side_validation && message.nil?
        fail ArgumentError, "Missing the required parameter 'message' when calling AMQPApi.queue_publish"
      end
      # resource path
      local_var_path = '/queue/publish'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'message'] = message
      query_params[:'queueId'] = opts[:'queue_id'] if !opts[:'queue_id'].nil?
      query_params[:'appKey'] = opts[:'app_key'] if !opts[:'app_key'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'hostname'] = opts[:'hostname'] if !opts[:'hostname'].nil?
      query_params[:'virtualHost'] = opts[:'virtual_host'] if !opts[:'virtual_host'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SirqulResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AMQPApi.queue_publish",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AMQPApi#queue_publish\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Search Queue
    # Get the queues setup for the BillableEntity's applications.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :queue_id The id of the queue to find
    # @option opts [String] :device_id The client device ID
    # @option opts [Integer] :account_id The logged in user ID
    # @option opts [String] :name The name of the queue to find
    # @option opts [Integer] :start Start of the index (default to 0)
    # @option opts [Integer] :limit Limit of the index (default to 10)
    # @return [QueueResponse]
    def queue_search(opts = {})
      data, _status_code, _headers = queue_search_with_http_info(opts)
      data
    end

    # Search Queue
    # Get the queues setup for the BillableEntity&#39;s applications.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :queue_id The id of the queue to find
    # @option opts [String] :device_id The client device ID
    # @option opts [Integer] :account_id The logged in user ID
    # @option opts [String] :name The name of the queue to find
    # @option opts [Integer] :start Start of the index (default to 0)
    # @option opts [Integer] :limit Limit of the index (default to 10)
    # @return [Array<(QueueResponse, Integer, Hash)>] QueueResponse data, response status code and response headers
    def queue_search_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AMQPApi.queue_search ...'
      end
      # resource path
      local_var_path = '/queue/search'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'queueId'] = opts[:'queue_id'] if !opts[:'queue_id'].nil?
      query_params[:'deviceId'] = opts[:'device_id'] if !opts[:'device_id'].nil?
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'start'] = opts[:'start'] if !opts[:'start'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'QueueResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AMQPApi.queue_search",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AMQPApi#queue_search\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Queue
    # Update the basic AMQP queue.
    # @param queue_id [Integer] The id of the queue to update
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id The client deviceID
    # @option opts [Integer] :account_id The logged in user ID
    # @option opts [String] :app_key The application key unique to each application.
    # @option opts [Integer] :workers The number of workers to generate
    # @option opts [String] :analytic_tags If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags
    # @option opts [String] :hostname The hostname of the server the queue is hosted on
    # @option opts [Integer] :port The port of the server the queue is hosted on
    # @option opts [String] :username The username to access the server that the queue is on
    # @option opts [String] :password The password to access the queue to connect to
    # @option opts [String] :virtual_host The virtual host defined on the server to queue
    # @option opts [Boolean] :use_ssl the SSL to use
    # @return [QueueResponse]
    def queue_update(queue_id, opts = {})
      data, _status_code, _headers = queue_update_with_http_info(queue_id, opts)
      data
    end

    # Update Queue
    # Update the basic AMQP queue.
    # @param queue_id [Integer] The id of the queue to update
    # @param [Hash] opts the optional parameters
    # @option opts [String] :device_id The client deviceID
    # @option opts [Integer] :account_id The logged in user ID
    # @option opts [String] :app_key The application key unique to each application.
    # @option opts [Integer] :workers The number of workers to generate
    # @option opts [String] :analytic_tags If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags
    # @option opts [String] :hostname The hostname of the server the queue is hosted on
    # @option opts [Integer] :port The port of the server the queue is hosted on
    # @option opts [String] :username The username to access the server that the queue is on
    # @option opts [String] :password The password to access the queue to connect to
    # @option opts [String] :virtual_host The virtual host defined on the server to queue
    # @option opts [Boolean] :use_ssl the SSL to use
    # @return [Array<(QueueResponse, Integer, Hash)>] QueueResponse data, response status code and response headers
    def queue_update_with_http_info(queue_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: AMQPApi.queue_update ...'
      end
      # verify the required parameter 'queue_id' is set
      if @api_client.config.client_side_validation && queue_id.nil?
        fail ArgumentError, "Missing the required parameter 'queue_id' when calling AMQPApi.queue_update"
      end
      # resource path
      local_var_path = '/queue/update'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'queueId'] = queue_id
      query_params[:'deviceId'] = opts[:'device_id'] if !opts[:'device_id'].nil?
      query_params[:'accountId'] = opts[:'account_id'] if !opts[:'account_id'].nil?
      query_params[:'appKey'] = opts[:'app_key'] if !opts[:'app_key'].nil?
      query_params[:'workers'] = opts[:'workers'] if !opts[:'workers'].nil?
      query_params[:'analyticTags'] = opts[:'analytic_tags'] if !opts[:'analytic_tags'].nil?
      query_params[:'hostname'] = opts[:'hostname'] if !opts[:'hostname'].nil?
      query_params[:'port'] = opts[:'port'] if !opts[:'port'].nil?
      query_params[:'username'] = opts[:'username'] if !opts[:'username'].nil?
      query_params[:'password'] = opts[:'password'] if !opts[:'password'].nil?
      query_params[:'virtualHost'] = opts[:'virtual_host'] if !opts[:'virtual_host'].nil?
      query_params[:'useSSL'] = opts[:'use_ssl'] if !opts[:'use_ssl'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'QueueResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"AMQPApi.queue_update",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: AMQPApi#queue_update\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
